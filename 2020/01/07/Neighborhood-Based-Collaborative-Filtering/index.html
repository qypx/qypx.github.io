<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Recommender System,">










<meta name="description" content="This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean f">
<meta name="keywords" content="Recommender System">
<meta property="og:type" content="article">
<meta property="og:title" content="Neighborhood-Based Collaborative Filtering 协同过滤">
<meta property="og:url" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/index.html">
<meta property="og:site_name" content="qypx の blog">
<meta property="og:description" content="This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean f">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372382962.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372454415.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578373973291.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578374644148.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376440604.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376851254.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578377776225.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385168727.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385386398.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386125836.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386158223.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012706765.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012763141.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455133171.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455288882.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578456962753.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457107702.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457502291.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457620591.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457759908.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457999015.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458842316.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463648320.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463881122.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578464579773.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011528508.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011935928.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012034088.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png">
<meta property="og:image" content="https://camo.githubusercontent.com/c056188f3498f28ff6bfe618b81642ba7711a797/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d32342d34382e706e67">
<meta property="og:image" content="https://camo.githubusercontent.com/77fdc47c74a72f3b3c1b57ab29ec08452697eb42/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d33362d35312e6a7067">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468263883.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468513742.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468541742.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469111053.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469413099.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469688733.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578470341309.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578471356190.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578478326957.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479201990.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479315924.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479574982.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479972763.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480409983.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480533805.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480727372.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480843642.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491595381.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491659157.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491938065.png">
<meta property="og:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578492119528.png">
<meta property="og:updated_time" content="2020-07-29T09:09:38.567Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Neighborhood-Based Collaborative Filtering 协同过滤">
<meta name="twitter:description" content="This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean f">
<meta name="twitter:image" content="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372382962.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/">





<!-- 网页加载条 -->
<script src="https://neveryu.github.io/js/src/pace.min.js"></script>

  <title>Neighborhood-Based Collaborative Filtering 协同过滤 | qypx の blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">qypx の blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">机会是留给有准备的人的.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://qypx.github.io/2020/01/07/Neighborhood-Based-Collaborative-Filtering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="qypx">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="qypx の blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Neighborhood-Based Collaborative Filtering 协同过滤</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-07T12:37:30+08:00">
                2020-01-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-07-29T17:09:38+08:00">
                2020-07-29
              </time>
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Recommender-System/" itemprop="url" rel="index">
                    <span itemprop="name">Recommender System</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> 阅读量
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean finding other things similar to the thing that you like. </p>
<p>That’s why we call it collaborative filtering. It’s recommending stuff based on other people’s collaborative behavior. </p>
<p>The heart of neighborhood-based collaborative filtering is the ability to find people similar to you, or items similar to items you’ve liked.</p>
<h3 id="1-Measuring-Similarity-and-Sparsity"><a href="#1-Measuring-Similarity-and-Sparsity" class="headerlink" title="1. Measuring Similarity, and Sparsity"></a>1. Measuring Similarity, and Sparsity</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372382962.png" alt="1578372382962"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372454415.png" alt="1578372454415"></p>
<p>这里的余弦相似度和前面content-based中的余弦相似度的区别在于：Our dimensions would be things like his: Did this user like this thing? Or was this thing liked by this user? So every user or every thing might constitute its own dimension, and the dimensions are based on user behavior instead of content attributes.</p>
<p>The big challenge in measuring these similarities based on behavior data is the <strong>sparsity</strong> of the data we’re working with. This means that it’s tough for collaborative filtering to work well unless you have a lot of user behavior data to work with. You can’t compute a meaningful cosine similarity between two people when they have nothing in common, or between two items when they have no people in common. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578373973291.png" alt="1578373973291"></p>
<p>This is why collaborative filtering works well for big companies like Amazon and Netflix. They have millions of users and so they have enough data to generate meaningful relations in spite of the data sparsity. </p>
<p>Sparsity also introduces some computational challenges. You don’t want to waste time storing and processing all of that missing data, so under the hood we end up using structures like <strong>sparse arrays</strong> that avoid storing all that empty spaces in this matrix. </p>
<h3 id="2-Similarity-Metrics"><a href="#2-Similarity-Metrics" class="headerlink" title="2. Similarity Metrics"></a>2. Similarity Metrics</h3><h4 id="Adjusted-Cosine"><a href="#Adjusted-Cosine" class="headerlink" title="Adjusted Cosine"></a>Adjusted Cosine</h4><p>It’s applicable mostly to measuring the similarity between users based on their ratings. It’s based on the idea that different people might have different baselines. What Bob considers a three star movie, maybe different from what Alice considers a three star movie. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578374644148.png" alt="1578374644148"></p>
<p>Adjusted cosine attempts to normalize these differences. Instead of measuring similarities between people based on their raw rating values, we instead measure similarities based on the difference between a user’s rating for an item and their average rating for all items. </p>
<p>Now this sounds good on paper, but in practice, data sparsity can really mess you up here. You can only get a meaningful average, or a baseline of an individual’s ratings if they have rated a lot of stuff for you to take the average of in the first place. 若有许多用户只评价了一部电影，then that data will be totally wasted with the adjusted cosine metric. 不管他们评了多少分，the difference between it and that user’s mean will be zero at that point. </p>
<p>So, adjusted cosine might be worth experimenting with, but only if you know that most of your users have rated a lot of stuff implicitly or explicitly. And if you have that much data to begin with, these differences between individuals will start to work themselves out anyway. So, you’re not likely to see as much of a difference as you might expect when using adjusted cosine. </p>
<h4 id="item-based-pearson-similarity"><a href="#item-based-pearson-similarity" class="headerlink" title="(item-based) pearson similarity"></a>(item-based) pearson similarity</h4><p>与adjusted cosine的区别在于, we look at the difference between rating and the average from all users for that given item.  </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376440604.png" alt="1578376440604"></p>
<p>You can think of pearson similarity as measuring the similarity between people by how much they diverge from the average person’s behavior. 例如，假设大多数人都喜欢Star Wars, people who hate Star Wars are going to get a very strong similarity score from pearson similarity, because they share opinions that are not mainstream.</p>
<p>Note that the only difference between this and adjusted cosine is whether we’re talking about users or items. 这门课使用的suprise library, refers to adjusted cosine as user-based pearson similarity, because it’s basically the same thing.</p>
<h4 id="spearman-rank-correlation"><a href="#spearman-rank-correlation" class="headerlink" title="spearman rank correlation"></a>spearman rank correlation</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376851254.png" alt="1578376851254"></p>
<ul>
<li>Instead of using an average rating value for a movie, 我们使用 its rank amongst all movies based on their average rating. </li>
<li>Instead of individual ratings for a movie, we’d rank that movie amongst all that individual’s ratings. </li>
</ul>
<p>Spearman的主要优势在于 it can deal with ordinal data effectively. 例如，if you had a rating scale, where the difference in meaning between different rating values were not the same. I’ve never seen this actually used in real world applications, but you may encounter it in the academic literature.</p>
<h4 id="mean-squared-difference"><a href="#mean-squared-difference" class="headerlink" title="mean squared difference"></a>mean squared difference</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578377776225.png" alt="1578377776225"></p>
<p>另一方面，我们可以将它应用到item上：x和y指两个不同的item, and then we’d be looking at the differences in ratings from the people these items have in common (所有评价过这两个item的人对这两个item评分的差异).</p>
<p>There are two ways of doing collaborative filtering, item based and user based, and it’s important to remember that most of these similarity metrics can apply to either approach. </p>
<p>MSD 要比余弦相似度更好理解， 但 in practice, 你通常会发现cosine works better.</p>
<h4 id="jaccard-similarity"><a href="#jaccard-similarity" class="headerlink" title="jaccard similarity"></a>jaccard similarity</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385168727.png" alt="1578385168727"></p>
<p>jaccard similarity 没有使用实际的rating vlaue. If you are dealing with implicit ratings, for example, just the fact that somebody watched something, in this case, Jaccard can be a reasonable choice that’s very fast to compute. </p>
<h4 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385386398.png" alt="1578385386398"></p>
<ul>
<li>Cosine similarity is almost always a reasonable thing to start with.</li>
<li>Adjust cosine and Pearson are two different terms for basically the same thing. It’s mean centered cosine similarities. The idea is to deal with unusual rating behavior that deviates from the mean, but in practice, it can sometimes do more harm than good.</li>
<li>Spearman ranking correlation is the same idea as Pearson, using ranking instead of raw ratings, and it’s not something you are likely to be using in practice.</li>
<li>MSD is mean squared difference, which is just an easier similarity metric to warp your head around than cosine similarity, but in practice, it usually doesn’t perform better.</li>
<li>Jaccard similarity is just looking at how many items two users have in common, or how many users two items have in common, divided by how many items or users they have between both of them. It’s really simple and well suited to implicit ratings, like binary actions, like purchasing or view something. But you can also apply cosine similarities to implicit ratings too.</li>
<li>So, and the end of the day, cosine similarity remains my default go to similarity metric. </li>
</ul>
<h3 id="3-协同过滤"><a href="#3-协同过滤" class="headerlink" title="3. 协同过滤"></a>3. 协同过滤</h3><h4 id="3-1-User-based-Collaborative-Filtering-基于用户的协同过滤-UserCF"><a href="#3-1-User-based-Collaborative-Filtering-基于用户的协同过滤-UserCF" class="headerlink" title="3.1 User-based Collaborative Filtering 基于用户的协同过滤(UserCF)"></a>3.1 User-based Collaborative Filtering 基于用户的协同过滤(UserCF)</h4><p>与基于物品的协同过滤类似的，不同的是，基于物品的协同过滤的原理是用户 U 购买了 A 物品，推荐给用户 U 和 A 相似的物品 B、C、D。而基于用户的协同过滤，是先计算用户 U 与其他的用户的相似度，然后取和 U 最相似的几个用户，把他们购买过的物品推荐给用户U。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386125836.png" alt="1578386125836"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386158223.png" alt="1578386158223"></p>
<hr>
<h5 id="3-1-1-计算用户之间的相似度"><a href="#3-1-1-计算用户之间的相似度" class="headerlink" title="3.1.1 计算用户之间的相似度"></a>3.1.1 计算用户之间的相似度</h5><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>为了计算用户相似度，我们首先要把用户购买过物品的索引数据转化成物品被用户购买过的索引数据，即物品的倒排索引：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012706765.png" alt="1596012706765"></p>
<p>建立好物品的倒排索引后，就可以根据相似度公式计算用户之间的相似度：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012763141.png" alt="1596012763141"></p>
<p>其中 $N(a)$ 表示用户 $a$ 购买物品的数量，$N(b)$ 表示用户 $b$ 购买物品的数量，$N(a)∩N(b)$ 表示用户 $a$ 和 $b$ 购买相同物品的数量。有了用户的相似数据，针对用户 U 挑选 k 个最相似的用户，把他们购买过的物品中，U 未购买过的物品推荐给用户 U 即可。</p>
<hr>
<h5 id="3-1-2-举例"><a href="#3-1-2-举例" class="headerlink" title="3.1.2 举例"></a>3.1.2 举例</h5><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455133171.png" alt="1578455133171"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455288882.png" alt="1578455288882"></p>
<ul>
<li>每个人和自己的余弦相似度是1</li>
<li>Bob 和 Ted的余弦相似度是0，因为他们没有评价过相同的电影</li>
<li>矩阵的上三角部分和下三角部分是对称的</li>
<li>对于 Bob 和 Ann, 虽然他们评价过不同的电影，当我们考虑相似度时，我们只看他们共同评价过的电影。在这个例子中，他们共同评价过的电影只有一部，并且评分都为5，所以他们的相似度得分为1 (100%)。</li>
</ul>
<blockquote>
<p>注：两个用户的相似度为100%并不一定代表他们喜欢相同的东西，也可以代表他们都讨厌相同的东西（例如，若 Bob 和 Ann 都给Star Wars打1分，他们仍然是100% similar）。事实上，the math behind cosine similarity works out such that <strong>if you only have one movie in common, you end up with 100% similarity no matter what. </strong>Even if Bob loved Star Wars and Ann hated it, in a sparse data situation, they both end up 100% similar. Sparse data is a huge problem with collaborative filtering, and it can lead to weird results. And sometimes, you need to enforce a minimum threshold on how many movies users have in common before you consider them at all.</p>
</blockquote>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578456962753.png" alt="1578456962753"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457107702.png" alt="1578457107702"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457502291.png" alt="1578457502291"></p>
<p>除了normalizing, 还可以例如将评分为1、2的转换成negative score, 方法不唯一，没有标准的方法，可通过试验看 what works best for the data you have.</p>
<p>应该adding in the score for a given movie if we encounter it more than once.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457620591.png" alt="1578457620591"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457759908.png" alt="1578457759908"></p>
<h5 id="3-1-3-Recap"><a href="#3-1-3-Recap" class="headerlink" title="3.1.3 Recap"></a>3.1.3 Recap</h5><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457999015.png" alt="1578457999015"></p>
<h5 id="3-1-4-User-based-Collaborative-Filtering-Hands-On"><a href="#3-1-4-User-based-Collaborative-Filtering-Hands-On" class="headerlink" title="3.1.4 User-based Collaborative Filtering, Hands-On"></a>3.1.4 User-based Collaborative Filtering, Hands-On</h5><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleUserCF.py</p>
<h4 id="3-2-Item-based-Collaborative-Filtering-基于物品的协同过滤-ItemCF"><a href="#3-2-Item-based-Collaborative-Filtering-基于物品的协同过滤-ItemCF" class="headerlink" title="3.2 Item-based Collaborative Filtering 基于物品的协同过滤(ItemCF)"></a>3.2 Item-based Collaborative Filtering 基于物品的协同过滤(ItemCF)</h4><p>Look at the things you liked, and recommend stuff that’s similar to those things. </p>
<p>核心思想：给用户推荐那些和他们之前喜欢的物品相似的物品。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458842316.png" alt="1578458842316"></p>
<p>一些原因为什么使用物品之间的相似度可能比使用用户之间的相似度更好：</p>
<ul>
<li>Items tend to be of a more permanent nature than people. An individual’s test may change very quickly over the span of their lives. Your math book will always be similar to other math books. As such, you can get away with computing an item similarity matrix less often than user similarities, because it won’t change very quickly.</li>
<li>You usually have far fewer items to deal with than people. There are way more people than there are things to recommend to them in most cases. 即物品相似度矩阵会比用户相似度矩阵会小很多，这样不仅 make it simpler to store that matrix, it makes faster to compute as well. And when you’re dealing with massive systems like Amazon and Netflix, computational efficiency is very important. Not only does it require fewer resources, it means you can regenerate your similarities between items more often, making your system more responsive when new items are introduced.</li>
<li>使用 item similarities also makes for a better experience for new users. 一个新用户只要表现出了对某个物品的兴趣，你可以推荐与那个物品相似的物品给该用户，而使用基于用户的协同过滤，you wouldn’t have any recommendations for a new user at all until they make it into the next build of your user similarity matrix.</li>
</ul>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463648320.png" alt="1578463648320"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463881122.png" alt="1578463881122"></p>
<p>在这个例子中，所有的相似度都为0或1，是因为数据量比较小。In the real world, you’d see more interesting and meaningful numbers here.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578464579773.png" alt="1578464579773"></p>
<hr>
<h5 id="3-2-1-计算物品相似度的方法"><a href="#3-2-1-计算物品相似度的方法" class="headerlink" title="3.2.1 计算物品相似度的方法"></a>3.2.1 计算物品相似度的方法</h5><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>基于物品的协同过滤算法首先计算物品之间的相似度， 计算相似度的方法有以下几种：</p>
<p><strong>1. 基于共同喜欢物品的用户列表计算</strong></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011528508.png" alt="1596011528508"></p>
<p>在此，分母中 $N(i)$ 是购买物品 $i$ 的用户数，$N(j)$ 是购买物品 $j$ 的用户数，而分子 $N(i)∩N(j)$是同时购买物品 $i$ 和物品 $j$ 的用户数。可见上述的公式的核心是计算同时购买这件商品的人数比例 。当同时购买这两个物品的人数越多，他们的相似度也就越高。另外值得注意的是，在分母中我们用了物品总购买人数做惩罚，也就是说某个物品可能很热门，导致它经常会被和其他物品一起购买，所以除以它的总购买人数，来降低它和其他物品的相似分数。</p>
<p><strong>2. 基于余弦的相似度计算</strong></p>
<p>上面的方法计算物品相似度是直接计算同时购买这两个物品的人数。但是也可能存在用户购买了但不喜欢的情况，所以如果数据集包含了具体的<strong>评分数据</strong>，我们可以进一步把用户评分引入到相似度计算中 。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011935928.png" alt="1596011935928"></p>
<p>其中 $n_{ki}$ 是用户 $k$ 对物品 $i$ 的评分，如果没有评分则为 0。</p>
<p><strong>3. 热门物品的惩罚</strong></p>
<p>对于热门物品的问题，可以用如下公式解决：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012034088.png" alt="1596012034088"></p>
<p>当 $\alpha ∈ (0，0.5)$时，$N(i)$ 越小，惩罚得越厉害，从而会使热门物品相关性分数下降。</p>
<hr>
<h5 id="3-2-2-Item-based-Collaborative-Filtering-Hands-On"><a href="#3-2-2-Item-based-Collaborative-Filtering-Hands-On" class="headerlink" title="3.2.2 Item-based Collaborative Filtering, Hands-On"></a>3.2.2 Item-based Collaborative Filtering, Hands-On</h5><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleItemCF.py</p>
<p>Item-based collaborative filtering is what Amazon used with outstanding success.</p>
<p>You need to test it out on several real people if possible, and then move to a large scale A/B test to see if this algorithm really is better or worse than whatever you might have today.</p>
<hr>
<h4 id="3-3-矩阵分解"><a href="#3-3-矩阵分解" class="headerlink" title="3.3 矩阵分解"></a>3.3 矩阵分解</h4><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>上述计算会得到一个相似度矩阵，而这个矩阵的大小和维度都是很大的，需要进行降维处理，用到的是SVD的降维方法，具体可以参考：<a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Machine Learning/8. ML特征工程和优化方法#25-降维方法" target="_blank" rel="noopener">降维方法</a></p>
<p><strong>基于稀疏自编码的矩阵分解</strong></p>
<p>矩阵分解技术在推荐领域的应用比较成熟，但是通过上一节的介绍，我们不难发现矩阵分解本质上只通过一次分解来对原矩阵进行逼近，特征挖掘的层次不够深入。另外矩阵分解也没有运用到物品本身的内容特征，例如书本的类别分类、音乐的流派分类等。随着神经网络技术的兴起，笔者发现通过多层感知机，可以得到更加深度的特征表示，并且可以对内容分类特征加以应用。首先，我们介绍一下稀疏自编码神经网络的设计思路。</p>
<ol>
<li><p><strong>基础的自编码结构</strong></p>
<p>最简单的自编码结构如下图，构造个三层的神经网络，我们让输出层等于输入层，且中间层的维度远低于输入层和输出层，这样就得到了第一层的特征压缩。</p>
<p><img src="https://camo.githubusercontent.com/c056188f3498f28ff6bfe618b81642ba7711a797/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d32342d34382e706e67" alt="img"></p>
<p>简单来说自编码神经网络尝试学习<strong>中间层约等于输入层</strong>的函数。换句话说，它尝试逼近一个恒等函数。如果网络的输入数据是完全随机的，比如每一个输入都是一个跟其他特征完全无关的独立同分布高斯随机变 ，那么这一压缩表示将会非常难于学习。但是如果输入数据中隐含着 些特定的结构，比如某些输入特征是彼此相关的，那么这一算法就可以发现输入数据中的这些相关性。</p>
</li>
<li><p><strong>多层结构</strong></p>
<p>基于以上的单层隐藏层的网络结构，我们可以扩展至多层网络结构，学习到更高层次的抽象特征。</p>
<p><img src="https://camo.githubusercontent.com/77fdc47c74a72f3b3c1b57ab29ec08452697eb42/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d33362d35312e6a7067" alt="img"></p>
</li>
</ol>
<hr>
<h3 id="4-Exercise"><a href="#4-Exercise" class="headerlink" title="4. Exercise"></a>4. Exercise</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468263883.png" alt="1578468263883"></p>
<p>我们之前是选取的top-n，例如item-based: 选择用户评价前10的电影，再找similar items；user-based: 选择与用户相似度排前10的用户，再…</p>
<p>Maybe it would be better if instead of taking the top k sources for recommendation candidates, we just use any source above some given quality threshold. 例如，用户评价4星以上的电影 should generate item-based recommendation candidates, no matter how many or how few of them there may be.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468513742.png" alt="1578468513742"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468541742.png" alt="1578468541742"></p>
<p>可以发现一个小的改变可以使得结果很不一样。Often, you don’t just want to test different recommendation algorithms, you want to test different variations and parameters on those algorithms. In this case, I not only want to test the idea of using a threshold instead of a top k approach, I’d also want to test many different threshold values to find the best one. In the real world, you’ll find that your biggest problem is just not having enough time to run all of the different experiments you want to run to make your recommendations  better. </p>
<h3 id="5-Evaluating-Collaborative-Filtering-Systems-Offline"><a href="#5-Evaluating-Collaborative-Filtering-Systems-Offline" class="headerlink" title="5. Evaluating Collaborative Filtering Systems Offline"></a>5. Evaluating Collaborative Filtering Systems Offline</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469111053.png" alt="1578469111053"></p>
<p>Now, although <strong>we can’t measure accuracy with user based or item based collaborative filtering, because they don’t make rating predictions</strong>, we can still measure hit rate, because it is still a top-N recommender.</p>
<h4 id="code-walkthrough"><a href="#code-walkthrough" class="headerlink" title="code walkthrough"></a>code walkthrough</h4><p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行EvaluateUserCF.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469413099.png" alt="1578469413099"></p>
<p>That was surprisingly fast. One really nice property of collaborative filtering is how quickly it can generate recommendations for any given individual, once we’ve built up the similarity matrix.</p>
<p>结果5.5% is pretty good.</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469688733.png" alt="1578469688733"></p>
<p>与EvaluateUserCF.py相比需要改变的地方：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578470341309.png" alt="1578470341309"></p>
<p>item-based的hit rate只有0.5%，相比user-based的5.5%，要差一点。</p>
<p>Item-based should be a superior approach, and that’s been proven in industry. 这里item-based要差一点应该是数据的原因。而且这只是offline evaluation. If we were to test both algorithms on real-world people using real-world data in an A/B test, the results could end up being very different.</p>
<h3 id="6-KNN-Recommenders"><a href="#6-KNN-Recommenders" class="headerlink" title="6. KNN Recommenders"></a>6. KNN Recommenders</h3><p>The concept of collaborative filtering has been applied to recommender systems that do make rating predictions, and these are generally referred to in the literature as KNN recommenders.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578471356190.png" alt="1578471356190"></p>
<p>In this sort of system, we generate recommendation candidates by predicting the ratings of everything a user hasn’t already rated, and selecting the top k items with the highest predicted ratings. This obviously isn’t a terribly efficient approach, but since we’re predicting rating values, we can measure the offline accuracy of the system using train/test or cross-validation, which is useful in the research world.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578478326957.png" alt="1578478326957"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479201990.png" alt="1578479201990"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479315924.png" alt="1578479315924"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479574982.png" alt="1578479574982"></p>
<h4 id="Running-User-and-Item-based-KNN-on-MovieLens"><a href="#Running-User-and-Item-based-KNN-on-MovieLens" class="headerlink" title="Running User and Item-based KNN on MovieLens"></a>Running User and Item-based KNN on MovieLens</h4><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行KNNBakeOff.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479972763.png" alt="1578479972763"></p>
<p>如果只看accuracy, KNN recommendation看上去是一个好方法，但是如果看 top-n recommendations, item-based和user-based推荐的都是些没听说过的电影 (obscure)，反而 random recommendation looks a lot better from a subjective standpoint.</p>
<p>So, on the surface, it looks like we may have made a system that’s pretty good at predicting ratings of movies people have already seen, but might not be very good at producing top-n recommendations.</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><p>Experiment with different KNN parameters.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480409983.png" alt="1578480409983"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480533805.png" alt="1578480533805"></p>
<p>虽然msd比cosine的RMSE要低一点，但它们推荐的内容是一样的</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480727372.png" alt="1578480727372"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480843642.png" alt="1578480843642"></p>
<p>Well, it’s actually pretty well known that KNN doesn’t work well in practice. Unfortunately, some people conclude that collaborative filtering in general is some naive approach that should be replaced with completely different techniques. But as we’ve seen, collaborative filtering isn’t the problem, it’s forcing collaborative filtering to make rating predictions — that’s the problem. We had some pretty exciting results when we just focused on making top-N recommendations, and completely forgot about optimizing for rating accuracy, and it turns out that’s what at the heart of the problem. <strong>使用user-based CF和item-based CF,   top-N 推荐结果都是不错的。</strong></p>
<p>Ratings are not continuous in nature, and KNN treats them as though they are continuous values that can be predicted on a continuous scale. If you really want to go with KNN, it would be more appropriate to treat it as a rating classification problem than as a rating prediction problem. KNN is also very sensitive to sparse data.</p>
<p>The most fundamental thing is that accuracy isn’t everything. The main reason KNN produces underwhelming results is because it’s trying to solve the wrong problem. <strong>KNN recommender之所以推荐结果不好，是因为它解决的是rating prediction的问题，而不是推荐问题</strong>。</p>
<h3 id="7-Bleeding-Edge-Alert"><a href="#7-Bleeding-Edge-Alert" class="headerlink" title="7. Bleeding Edge Alert"></a>7. Bleeding Edge Alert</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491595381.png" alt="1578491595381"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491659157.png" alt="1578491659157"></p>
<p>The idea behind it is that users are modeled as vectors moving from one item to another in a multidimensional space. And you can predict sequences of events, like which movie a user is likely to watch next, by modeling these vectors.</p>
<p>The reason this paper is exciting is because it outperformed all of the best existing methods for recommending sequences of events in all but one case in one data set.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491938065.png" alt="1578491938065"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578492119528.png" alt="1578492119528"></p>
<p>Basic idea: You position individual items, like movies, in a transition space, where neighborhoods within this   space represent similarity between items. So items close together in this space are similar to each other. The dimensions corresponds to complex transition relationships between items. Since this technique depends on arranging items together into local, similar neighborhoods, I still classify it as a neighborhood -based method. </p>
<p>In this space, we can learn the vectors associated with individual users. Maybe a user who watches a Tom Cruise movie, is likely to move along to the next Tom Cruise movie, for example, and that transition would be represented by a vector in this space. We can then predict the next movie a user is like to watch by extrapolating along the vector we’ve associated with that user.</p>
<p>The paper provide the code in C++.</p>
<p>It’s all very advanced stuff, but it seems to work. So if you find yourself in the situation where you need to predict a sequence of events, like which movies or videos a person is likely to watch next given theirs past history, you might wanna do a search for translation-based recommendations and how it’s coming along in the real world.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Recommender-System/" rel="tag"># Recommender System</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/01/06/Content-Based-Filtering/" rel="next" title="Content-Based Filtering">
                <i class="fa fa-chevron-left"></i> Content-Based Filtering
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/01/09/Matrix-Factorization-Methods/" rel="prev" title="Matrix Factorization Methods">
                Matrix Factorization Methods <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="qypx">
            
              <p class="site-author-name" itemprop="name">qypx</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">51</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/qypx" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          


          
          

          
          

          


          <!-- 新增的内容 -->
          <!-- require APlayer -->
          <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
          <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
          <!-- require MetingJS -->
          <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

          <meting-js server="netease" type="playlist" id="4870130923" list-folded="true" order="random">
          </meting-js>
          <!-- 新增的内容end -->

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Measuring-Similarity-and-Sparsity"><span class="nav-text">1. Measuring Similarity, and Sparsity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Similarity-Metrics"><span class="nav-text">2. Similarity Metrics</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Adjusted-Cosine"><span class="nav-text">Adjusted Cosine</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#item-based-pearson-similarity"><span class="nav-text">(item-based) pearson similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#spearman-rank-correlation"><span class="nav-text">spearman rank correlation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#mean-squared-difference"><span class="nav-text">mean squared difference</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jaccard-similarity"><span class="nav-text">jaccard similarity</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Recap"><span class="nav-text">Recap</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-协同过滤"><span class="nav-text">3. 协同过滤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-User-based-Collaborative-Filtering-基于用户的协同过滤-UserCF"><span class="nav-text">3.1 User-based Collaborative Filtering 基于用户的协同过滤(UserCF)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-1-计算用户之间的相似度"><span class="nav-text">3.1.1 计算用户之间的相似度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-2-举例"><span class="nav-text">3.1.2 举例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-3-Recap"><span class="nav-text">3.1.3 Recap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1-4-User-based-Collaborative-Filtering-Hands-On"><span class="nav-text">3.1.4 User-based Collaborative Filtering, Hands-On</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-Item-based-Collaborative-Filtering-基于物品的协同过滤-ItemCF"><span class="nav-text">3.2 Item-based Collaborative Filtering 基于物品的协同过滤(ItemCF)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-计算物品相似度的方法"><span class="nav-text">3.2.1 计算物品相似度的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-Item-based-Collaborative-Filtering-Hands-On"><span class="nav-text">3.2.2 Item-based Collaborative Filtering, Hands-On</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-矩阵分解"><span class="nav-text">3.3 矩阵分解</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Exercise"><span class="nav-text">4. Exercise</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Evaluating-Collaborative-Filtering-Systems-Offline"><span class="nav-text">5. Evaluating Collaborative Filtering Systems Offline</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#code-walkthrough"><span class="nav-text">code walkthrough</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise"><span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-KNN-Recommenders"><span class="nav-text">6. KNN Recommenders</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Running-User-and-Item-based-KNN-on-MovieLens"><span class="nav-text">Running User and Item-based KNN on MovieLens</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Exercise-1"><span class="nav-text">Exercise</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Bleeding-Edge-Alert"><span class="nav-text">7. Bleeding Edge Alert</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qypx</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  



<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left"},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
