<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>B树介绍</title>
    <url>/2020/02/16/B%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#b树">B树</a></li>
<li><a href="#b树">B+树</a></li>
<li><a href="#b树">B*树</a></li>
<li><a href="#总结">总结</a></li>
</ul>
<!-- tocstop -->

<blockquote>
<p>参考：<a href="https://blog.csdn.net/A_zhangq/article/details/99662693" target="_blank" rel="noopener">https://blog.csdn.net/A_zhangq/article/details/99662693</a></p>
</blockquote>
<h3><span id="b树">B树</span></h3><p>B-树就是B树（可能有部分人会习惯上把B-树读为B减树，其实并不存在B减树，只是读法上的不同而已），B就是balanced，平衡的意思。<strong>B-树就是指的B树</strong>。</p>
<p>B-树是一种多路搜索树（并不是二叉的）：    </p>
<ol>
<li><p>定义任意非叶子结点最多只有M个儿子，且M&gt;2；    </p>
</li>
<li><p>根结点的儿子数为 [2, M]；    </p>
</li>
<li><p>除根结点以外的非叶子结点的儿子数为 [M/2, M]；    </p>
</li>
<li><p>每个结点存放至少 M/2-1（取上整）和至多  M-1 个关键字；（至少 2个关键字）    </p>
</li>
<li><p>非叶子结点的关键字个数 = 指向儿子的指针个数 - 1；    </p>
</li>
<li><p>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且 K[i] &lt; K[i+1] ；    </p>
</li>
<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1] 指向关键字小于 K[1] 的子树，P[M] 指向关键字大于            K[M-1] 的子树，其它 P[i] 指向关键字属于(K[i-1], K[i]) 的子树；    </p>
</li>
<li><p>所有叶子结点位于同一层；    </p>
</li>
</ol>
<p>如 (M = 3)：</p>
<p><img src="https://img-blog.csdnimg.cn/20190815211241789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>B-树的搜索：</strong></p>
<p>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点.</p>
<p><strong>B-树的特性：</strong></p>
<ul>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ul>
<hr>
<a id="more"></a>

<h3><span id="b树">B+树</span></h3><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>其定义基本与B-树同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1]]的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p>如（M=3）:</p>
<p><img src="https://img-blog.csdnimg.cn/20190817142029576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>B+树的搜索</strong>：</p>
<p>与B-树基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p><strong>B+树的特性：</strong></p>
<ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是<strong>有序</strong>的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ul>
<blockquote>
<p>关于稠密索引与稀疏索引：<a href="https://blog.csdn.net/Qmen_Crow/article/details/51052160" target="_blank" rel="noopener">https://blog.csdn.net/Qmen_Crow/article/details/51052160</a></p>
</blockquote>
<p><strong>B+树的分裂：</strong></p>
<p>当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</p>
<hr>
<h3><span id="b树">B*树</span></h3><p>B*树是B+树的一种变形，它是在B+树的基础上，将索引层以指针连接起来（在B+树的非根和非叶子结点再增加指向兄弟的指针），使搜索取值更加快捷。 </p>
<p>如下图（M = 3）：</p>
<p><img src="https://img-blog.csdnimg.cn/20190817142644325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>B*树在B+树的基础上产生了一系列的变化，如下：</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）；</li>
<li><strong>B *树的分裂：</strong>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</li>
</ol>
<p>B*树相对于B+树，空间利用率上有所提高，查询速率也有所提高。</p>
<hr>
<h3><span id="总结">总结</span></h3><ul>
<li><p>二叉搜索树：二叉树，每个结点只存储一个关键字且值大于左子树，小于右子树。</p>
</li>
<li><p>B（B-）树：多路搜索树，每个结点存储 M/2-1 到 M - 1 个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
</li>
<li><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p>
</li>
<li><p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p>
</li>
</ul>
<p><img src="/2020/02/16/B树介绍/1581863461822.png" alt="1581863461822"></p>
<p>这两种树都是平衡的多分树，它们都可以用于文件的索引结构，但B树只能支持随机检索，而B+树是有序的树，既能支持随机检索，又能支持顺序检索。</p>
]]></content>
      <tags>
        <tag>B树</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN相关资料（LSTM, GRU）</title>
    <url>/2020/02/15/RNN%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h4><span id="pdf">pdf：</span></h4><p><a href="https://www.aclweb.org/anthology/C16-1311.pdf" target="_blank" rel="noopener">Effective LSTMs for Target-Dependent Sentiment Classification</a></p>
<h4><span id="网页">网页：</span></h4><p><a href="https://www.jianshu.com/p/95d5c461924c" target="_blank" rel="noopener">【译】理解LSTM（通俗易懂版）</a></p>
<p><a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be" target="_blank" rel="noopener">Understanding GRU Networks</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32481747" target="_blank" rel="noopener">人人都能看懂的GRU</a></p>
<p><a href="https://www.cnblogs.com/jiangxinyang/p/9376021.html" target="_blank" rel="noopener">深度学习之GRU网络</a></p>
<p><a href="https://www.jianshu.com/p/3774d46b665e" target="_blank" rel="noopener">lstm和gru结构的再理解</a></p>
<p><a href="http://www.sohu.com/a/336551522_99979179" target="_blank" rel="noopener">图解LSTM与GRU单元的各个公式和区别 </a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN相关资料</title>
    <url>/2020/02/15/CNN%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<h4><span id="pdf">pdf：</span></h4><p><a href="https://www.aclweb.org/anthology/D14-1181.pdf" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></p>
<h4><span id="网页">网页：</span></h4><p><a href="https://www.cnblogs.com/yelbosh/p/5808706.html" target="_blank" rel="noopener">卷积神经网络CNN在自然语言处理中的应用</a></p>
<h4><span id="卷积与矩阵乘法">卷积与矩阵乘法：</span></h4><p><img src="/2020/02/15/CNN相关资料/%E5%8D%B7%E7%A7%AF%E4%B8%8E%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95.jpg" alt="卷积与矩阵乘法"></p>
<p><img src="/2020/02/15/CNN相关资料/example.jpg" alt="example"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2020/02/05/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零（难度：简答）</a></p>
<p><img src="/2020/02/05/移动零/1580888243775.png" alt="1580888243775"></p>
<p>问题的两个要求是：</p>
<ul>
<li>将所有 0 移动到数组末尾。</li>
<li>所有非零元素必须保持其原始顺序。</li>
</ul>
<p>这里很好地认识到这两个需求是相互排斥的，也就是说，你可以解决单独的子问题，然后将它们组合在一起以得到最终的解决方案。</p>
<h4><span id="方法">方法：</span></h4><ul>
<li>一个指针<code>i</code>从前到后遍历数组，每当遇到非0数时，令 <code>nums[cur] = nums[i]; cur++;</code>，<code>cur</code>是另一个指针（从0开始），记录当前位置。</li>
<li>当<code>i</code>遍历完后，此时<code>cur</code>指向的位置到数组的末尾全赋为0即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[cur] = nums[i];</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur &lt; nums.length)&#123;</span><br><span class="line">            nums[cur] = <span class="number">0</span>;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/02/05/移动零/1580890229187.png" alt="1580890229187"></p>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小覆盖子串</title>
    <url>/2020/01/28/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串（难度：困难）</a></p>
<p><img src="/2020/01/28/最小覆盖子串/1580195563488.png" alt="1580195563488"></p>
<h4><span id="方法滑动窗口">方法：滑动窗口</span></h4><h5><span id="算法">算法</span></h5><ol>
<li><p>初始，<code>left</code>指针和<code>right</code>指针都指向<code>s</code>的第一个元素.</p>
</li>
<li><p>将 <code>right</code>指针右移，扩张窗口，直到得到一个可行窗口，亦即包含<code>t</code>的全部字母的窗口。</p>
</li>
<li><p>得到可行的窗口后，将<code>left</code>指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。</p>
</li>
<li><p>若窗口不再可行，则跳转至 2。</p>
</li>
</ol>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        need = defaultdict(int)</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        minLen = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            need[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">            window[s[right]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.con(need,window):</span><br><span class="line">                <span class="keyword">if</span> len(s[left:right+<span class="number">1</span>]) &lt; minLen:</span><br><span class="line">                    minLen = len(s[left:right+<span class="number">1</span>])</span><br><span class="line">                    res = s[left:right+<span class="number">1</span>]</span><br><span class="line">                window[s[left]] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">con</span><span class="params">(self, need, window)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> need.keys():</span><br><span class="line">            <span class="keyword">if</span> need[key] &gt; window[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p><img src="/2020/01/28/最小覆盖子串/1580201292271.png" alt="1580201292271"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/01/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值（难度：困难）</a></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579702056767.png" alt="1579702056767"></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579702078067.png" alt="1579702078067"></p>
<h4><span id="方法一暴力法">方法一：暴力法</span></h4><p>遍历每个滑动窗口，找到每个窗口的最大值。一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为 O(Nk)，表现较差。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)-(k<span class="number">-1</span>)):</span><br><span class="line">            j = i + k<span class="number">-1</span></span><br><span class="line">            res.append(max(nums[i:j+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/22/滑动窗口最大值/1579666044377.png" alt="1579666044377"></p>
<h5><span id="复杂度">复杂度</span></h5><ul>
<li>时间复杂度：O(Nk)。其中 <code>N</code> 为数组中元素个数。</li>
<li>空间复杂度：O<em>(</em>N<em>−</em>k+1)，用于输出数组。</li>
</ul>
<h4><span id="方法二递归">方法二：递归</span></h4><p>详细讲解见<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/</a></p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = [<span class="number">0</span>]*n</span><br><span class="line">        right = [<span class="number">0</span>]*n</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">if</span> i % k == <span class="number">0</span>: </span><br><span class="line">                <span class="comment"># block start</span></span><br><span class="line">                left[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left[i] = max(left[i<span class="number">-1</span>], nums[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            j = n - i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block end</span></span><br><span class="line">                right[j] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = max(right[j+<span class="number">1</span>], nums[j])</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n-k+<span class="number">1</span>):</span><br><span class="line">            j = i+k<span class="number">-1</span></span><br><span class="line">            res.append(max(right[i], left[j]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/22/滑动窗口最大值/1579669254322.png" alt="1579669254322"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(N)，我们对长度为 N 的数组处理了 3次。</p>
<p>空间复杂度：O(N)，用于存储长度为 N 的 left 和 right 数组，以及长度为 N - k + 1的输出数组。</p>
<h4><span id="方法三双端队列">方法三：双端队列</span></h4><p><img src="/2020/01/22/滑动窗口最大值/1579703855488.png" alt="1579703855488"></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579703901936.png" alt="1579703901936"></p>
<p>思路：维护窗口，向右移动时左侧超出窗口的值弹出，因为需要的是窗口内的最大值，所以只要保证窗口内的值是递减的即可，小于新加入的值全部弹出。最左端即为窗口最大值 </p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        temp = []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums): <span class="comment"># i是索引，v是值</span></span><br><span class="line">            <span class="comment"># 左侧超出窗口的值弹出</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=k <span class="keyword">and</span> temp[<span class="number">0</span>]&lt;=i-k:</span><br><span class="line">                temp.pop(<span class="number">0</span>) <span class="comment"># pop索引为0的数</span></span><br><span class="line">            <span class="keyword">while</span> temp <span class="keyword">and</span> nums[temp[<span class="number">-1</span>]] &lt;= v:</span><br><span class="line">                temp.pop() <span class="comment"># pop最后一个数</span></span><br><span class="line">            temp.append(i)</span><br><span class="line">            <span class="keyword">if</span> i&gt;=k<span class="number">-1</span>:</span><br><span class="line">                res.append(nums[temp[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/22/滑动窗口最大值/1579704974700.png" alt="1579704974700"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(N)，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。</p>
<p>空间复杂度：O(N)，输出数组使用了O(N−k+1) 空间，双向队列使用了 O(k)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2020/01/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历（难度：中等）</a></p>
<p><img src="/2020/01/21/二叉树的中序遍历/1579622453083.png" alt="1579622453083"></p>
<p><strong>中序遍历：左-中-右</strong></p>
<h4><span id="方法一递归">方法一：递归</span></h4><p>定义一个辅助函数来实现递归。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List &lt; Integer &gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。递归函数 T(n) = 2 T(n/2)+1。<br>空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。</p>
<h4><span id="方法二迭代">方法二：迭代</span></h4><p>颜色标记法：</p>
<blockquote>
<p>作者：hzhu212<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>其核心思想如下：</p>
<ul>
<li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li>
<li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li>
<li>如果遇到的节点为灰色，则将节点的值输出。</li>
</ul>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        WHITE, GRAY = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(WHITE, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color, node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                stack.append((WHITE, node.right))</span><br><span class="line">                stack.append((GRAY, node))</span><br><span class="line">                stack.append((WHITE, node.left))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p>如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。</p>
<h5><span id="另一种写法">另一种写法：</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/21/二叉树的中序遍历/1579622422214.png" alt="1579622422214"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。</p>
<p>空间复杂度：O(n)。</p>
<table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">执行用时</th>
<th align="left">内存消耗</th>
<th align="left">语言</th>
</tr>
</thead>
<tbody><tr>
<td align="left">方法二：迭代（另一种写法）</td>
<td align="left">28 ms</td>
<td align="left">13 MB</td>
<td align="left">Python3</td>
</tr>
<tr>
<td align="left">方法二：迭代（颜色标价法）</td>
<td align="left">36 ms</td>
<td align="left">12.7 MB</td>
<td align="left">Python3</td>
</tr>
<tr>
<td align="left">方法一：递归</td>
<td align="left">0 ms</td>
<td align="left">34.6 MB</td>
<td align="left">Java</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中第k小的元素</title>
    <url>/2020/01/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素（难度：中等）</a></p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620616705.png" alt="1579620616705"></p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620662544.png" alt="1579620662544"></p>
<p>此题与<a href="https://qypx.github.io/2020/01/21/二叉树的中序遍历/">二叉树的中序遍历（难度：中等）</a>类似，只需稍加变化。</p>
<h4><span id="方法一递归">方法一：递归</span></h4><p>通过构造 BST 的中序遍历序列，则第 <code>k-1</code> 个元素就是第 <code>k</code> 小的元素。</p>
<p><img src="https://pic.leetcode-cn.com/7dc3fe454519e27105c5aaf57d20b26137bd77c56bb0289830bf18116627de12-file_1579413216156" alt="在这里插入图片描述"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,arr);</span><br><span class="line">        <span class="keyword">return</span> arr.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">                inorder(root.left, arr);</span><br><span class="line">            arr.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">                inorder(root.right, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620513520.png" alt="1579620513520"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(N)，遍历了整个树。</p>
<p>空间复杂度：O(N)，用了一个数组存储中序序列。</p>
<h4><span id="方法二迭代">方法二：迭代</span></h4><p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p>
<p><img src="https://pic.leetcode-cn.com/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176" alt="在这里插入图片描述"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579621550313.png" alt="1579621550313"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(H+k)，其中 H指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为O(logN+k)。当树是一个不平衡树时：复杂度为 O(N+k)，此时所有的节点都在左子树。</p>
<p>空间复杂度：O(H+k)。当树是一个平衡树时：O(logN+k)。当树是一个非平衡树时：O(N+k)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续序列</title>
    <url>/2020/01/20/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">最长连续序列（难度：困难）</a></p>
<p><img src="/2020/01/20/最长连续序列/1579513410172.png" alt="1579513410172"></p>
<h4><span id="方法哈希表hashset">方法：哈希表（HashSet）</span></h4><p>因为一个序列可能在 <code>nums</code> 数组的任意一个数字开始，我们可以枚举每个数字作为序列的第一个数字，搜索所有的可能性 （暴力法）。优化：将数组中的数字用HashSet保存，实现O(1)的时间查询，同时，我们只对 <code>当前数字 - 1</code> 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">            </span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(nums[i]-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> curNum = nums[i];</span><br><span class="line">                <span class="keyword">while</span>(hashSet.contains(curNum+<span class="number">1</span>))&#123;</span><br><span class="line">                    curLen++;</span><br><span class="line">                    curNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen,curLen);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。尽管在 for 循环中嵌套了一个 while 循环，时间复杂度看起来像是二次方级别的。但其实它是线性的算法。因为只有当 curNum 遇到了一个序列的开始， while 循环才会被执行（也就是 curNum-1 不在数组 nums 里）， while 循环在整个运行过程中只会被迭代 n 次。这意味着尽管看起来时间复杂度为 O(n⋅n) ，实际这个嵌套循环只会运行O(n+n)=O(n) 次。所有的计算都是线性时间的，所以总的时间复杂度是 O(n)的。</p>
<p>空间复杂度：O(n)。为了实现 O(1)的查询，我们对哈希表分配线性空间，以保存 nums 数组中的 O(n)个数字。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet</title>
    <url>/2020/01/20/HashSet/</url>
    <content><![CDATA[<ul>
<li>无序列表HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。 </li>
<li>无序列表列表TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Feeding Data to your Cluster - Kafka &amp; Flume</title>
    <url>/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#kafka">Kafka</a><ul>
<li><a href="#what-is-streaming">What is streaming?</a></li>
<li><a href="#enter-kafka">Enter Kafka</a></li>
<li><a href="#kafka-architecture">Kafka architecture</a></li>
<li><a href="#how-kafka-scales">How Kafka scales</a></li>
</ul>
</li>
<li><a href="#lets-play">Let’s play</a><ul>
<li><a href="#activity-setting-up-kafka-and-publishing-some-data">[Activity] Setting up Kafka, and publishing some data</a></li>
<li><a href="#activity-publishing-web-logs-with-kafka">[Activity] Publishing web logs with Kafka</a></li>
</ul>
</li>
<li><a href="#flume">Flume</a><ul>
<li><a href="#what-is-flume">What is Flume?</a></li>
<li><a href="#flume-agent">Flume Agent</a></li>
<li><a href="#built-in-source-types">Built-in Source Types</a></li>
<li><a href="#built-in-sink-types">Built-in Sink Types</a></li>
</ul>
</li>
<li><a href="#lets-play-1">Let’s play</a><ul>
<li><a href="#activity-set-up-flume-and-publish-logs-with-it">[Activity] Set up Flume and publish logs with it</a></li>
<li><a href="#activity-set-up-flume-to-monitor-a-directory-and-store-its-data-in-hdfs">[Activity] Set up Flume to monitor a directory and store its data in HDFS</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h3><span id="kafka">Kafka</span></h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579416693703.png" alt="1579416693703"></p>
<h4><span id="what-is-streaming">What is streaming?</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579417084705.png" alt="1579417084705"></p>
<p>With streaming technologies such as Kafka, you can actually process new data as it’s generated into your cluster, maybe you’re gonna save it into HDFS, maybe you’ll save it into HBase or some other database or maybe you’ll actually process it in real time as it comes in.</p>
<p>Usually when we’re talking about Big Data, there’s a big flow of it coming in all the time and you want to be dealing with it as it comes instead of storing it up and dealing with it in batches. </p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579417930302.png" alt="1579417930302"></p>
<h4><span id="enter-kafka">Enter Kafka</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579418299281.png" alt="1579418299281"></p>
<p>The good thing is that Kafka because it stores it, consumers can catch up from where they last left off, so it will maintain the point where each consumer left off and allow them to just pick up whenever they want to. So it can publish data in real time to your consumers, but if your consumer goes off line or just wants to catch up from some point in the past, it can do that too.</p>
<a id="more"></a>

<h4><span id="kafka-architecture">Kafka architecture</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419075767.png" alt="1579419075767"></p>
<p>Even though it says app, that doesn’t necessarily mean you’re going to be developing an app in order to use Kafka, often there are ones you can just use off the shelf and Kafka even comes with some built-in that might serve your purposes.</p>
<p>You can make these pretty fancy systems that are very scalable, very fast, that can transform data and store it, and do whatever you want with it really, as it comes in.</p>
<h4><span id="how-kafka-scales">How Kafka scales</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419261062.png" alt="1579419261062"></p>
<h3><span id="lets-play">Let’s play</span></h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419425921.png" alt="1579419425921"></p>
<h4><span id="activity-setting-up-kafka-and-publishing-some-data">[Activity] Setting up Kafka, and publishing some data</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963832#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963832#overview</a></p>
<p>Kafka depends on ZooKeeper to keep track of what topics exists.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579420886266.png" alt="1579420886266"></p>
<p>in the real world, this would be massive floods of data coming in from massive web server fleets and things. It can handle that and publish it scalably and reliably to wherever it needs to go. So that’s really what it’s all about, it’s a scalable and reliable mechanism for publishing and subscribing to massive data streams.</p>
<h4><span id="activity-publishing-web-logs-with-kafka">[Activity] Publishing web logs with Kafka</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963846#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963846#overview</a></p>
<p>So let’s do something a little bit closer to what you might do in reality. Let’s use a built-in Kafka connector to actually monitor a file and publish new lines on that file to a given Kafka topic that then get written out to some other file somewhere else.</p>
<p>使用的一些Linux语句：</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422270057.png" alt="1579422270057"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422355086.png" alt="1579422355086"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422381621.png" alt="1579422381621"></p>
<h3><span id="flume">Flume</span></h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422490612.png" alt="1579422490612"></p>
<h4><span id="what-is-flume">What is Flume?</span></h4><p>You can really think of Flume as a bonafide part of the Hadoop ecosystem, as opposed to Kafka which is much more general purpose in its design.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579423582139.png" alt="1579423582139"></p>
<p>Now you might think to yourself “Why can’t I just directly transfer data across to my HDFS cluster?” Well, you need some sort of a buffer in between these two things.</p>
<h4><span id="flume-agent">Flume Agent</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579423781528.png" alt="1579423781528"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425760102.png" alt="1579425760102"></p>
<p>Flume与Kafka的一个区别：It’s not really like Kafka where Kafka just stores up data indefinitely and people can pull that data in whenever they want to. Kafka does expire data after some amount of time, but with Flume, basically your sink grabs data from Flume and once it’s been grabbed from the channel it gets deleted, so flume does not hang onto your messages or your events any longer than it needs to, as soon as your sync processes it, it throws it away. Kafka is a little bit more easier to set up if you have data going to multiple different places that might be pulling at different rates.</p>
<h4><span id="built-in-source-types">Built-in Source Types</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425301835.png" alt="1579425301835"></p>
<h4><span id="built-in-sink-types">Built-in Sink Types</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579424846813.png" alt="1579424846813"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579424947616.png" alt="1579424947616"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425396680.png" alt="1579425396680"></p>
<p>It’s basically a way of smoothing out the traffic between the data coming in from your logs or whatever your source might be and where you’re writing it to.</p>
<h3><span id="lets-play">Let’s play</span></h3><h4><span id="activity-set-up-flume-and-publish-logs-with-it">[Activity] Set up Flume and publish logs with it</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963868#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963868#overview</a></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425190618.png" alt="1579425190618"></p>
<p>All you really need to do to get Flume running is write a configuration file that defines what sources channels and sinks are associated with each agent that you want in your Flume setup.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425924768.png" alt="1579425924768"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579427003629.png" alt="1579427003629"></p>
<h4><span id="activity-set-up-flume-to-monitor-a-directory-and-store-its-data-in-hdfs">[Activity] Set up Flume to monitor a directory and store its data in HDFS</span></h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425361515.png" alt="1579425361515"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579426725240.png" alt="1579426725240"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579426873190.png" alt="1579426873190"></p>
<p>What ends up happening is that we get new subdirectories being generated for each 10 minute interval that goes by.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579427060001.png" alt="1579427060001"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Kafka</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Using non-relational data stores with Hadoop - NoSQL &amp; HBase &amp; MongoDB</title>
    <url>/2020/01/16/Using-non-relational-data-stores-with-Hadoop/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#why-nosql">Why NoSQL?</a></li>
<li><a href="#what-is-hbase">What is HBase</a><ul>
<li><a href="#crud">CRUD</a></li>
<li><a href="#hbase-architecture">HBase architecture</a></li>
<li><a href="#hbase-data-model">HBase data model</a></li>
<li><a href="#ways-to-access-hbase">Ways to access HBase</a></li>
</ul>
</li>
<li><a href="#activity-import-movie-ratings-into-hbase">[Activity] Import movie ratings into HBase</a></li>
<li><a href="#mongodb-overview">MongoDB Overview</a><ul>
<li><a href="#document-based-data-model">Document-based data model</a></li>
<li><a href="#mongodb-terminology">MongoDB terminology</a></li>
<li><a href="#replication-sets">Replication Sets</a></li>
<li><a href="#sharding-how-mongodb-handles-big-data">Sharding (How MongoDB handles big data)</a></li>
<li><a href="#neat-things-about-mongodb">Neat Things about MongoDB</a></li>
</ul>
</li>
<li><a href="#activity-install-mongodb-and-integrate-spark-with-mongodb">[Activity] Install MongoDB and integrate Spark with MongoDB</a></li>
<li><a href="#activity-using-the-mongodb-shell">[Activity] Using the MongoDB Shell</a></li>
<li><a href="#choosing-a-database-technology">Choosing a database technology</a><ul>
<li><a href="#integration-considerations">Integration considerations</a></li>
<li><a href="#scaling-requirements">Scaling requirements</a></li>
<li><a href="#support-considerations">Support considerations</a></li>
<li><a href="#cap-considerations">CAP considerations</a></li>
<li><a href="#simplicity">Simplicity</a></li>
<li><a href="#examples">Examples</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h3><span id="why-nosql">Why NoSQL?</span></h3><p>We’ve talked about integrating Hadoop with SQL solutions - MySQL - RDBMSs, if you will - relational database management systems - and those are very handy for giving you the power of a rich analytical query language like SQL to answer your business questions. But, you know, they do take a little bit of time to execute. So *<em>if you’re doing analytic work, relational databases are awesome. *</em>Even if you’re running a small, like, say, an internal web site or a very small-scale web site, something like MySQL can even vend that data to the outside world pretty well.</p>
<p>BUT let’s imagine you need to take things up to the next level. You’re going to start to run into some limitations with SQL and relational database systems.</p>
<p>Maybe you don’t really need the ability to issue arbitrary queries across your entire dataset. Maybe all you need is just the ability to *<em>very quickly answer a specific question *</em>like “What movie should I recommend for this customer?” or “What web pages has this customer looked at in the past?” </p>
<p>And if you need to do that <strong>at a very large scale very quickly across a massive dataset</strong>, something like MySQL might not cut it. You know, if you’re an Amazon or a Google, you might need something that can even <strong>handle tens of thousands of transactions per second without breaking a sweat. And that’s where NoSQL comes in.</strong></p>
<p>These are alternative database systems that <em>give up</em> a rich query language like SQL <em>for</em> the ability to very quickly and at great scale answer very simple questions. So for systems like that you want something called NoSQL, also known as non-relational databases, or not only SQL - that’s a term that comes up sometimes, too. And <strong>these systems are built to scale horizontally forever, and also built to be very fast and very resilient.</strong></p>
<p>Up first, let’s talk about HBase. HBase is actually built on top of HDFS, so it allows you to have a very fast, very scalable transactional system to query your data that’s stored on a horizontally partitioned HDFS file system. So if you need to expose your massive data that’s sitting on your Hadoop cluster, Hbase can be a great way to expose that data to a web service, to web applications, anything that needs to operate very quickly and at a very high scale.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579161940219.png" alt="1579161940219"></p>
<a id="more"></a>

<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579162098786.png" alt="1579162098786"></p>
<p>if you think about things like Amazon or Google, people are always buying new things or always searching for new things, new web sites are always coming out, so this data is always just getting bigger and bigger and bigger over time. So that has to live on some sort of a distributed cluster, like a Hadoop cluster. You’re just not going to fit that into a single hard drive on a single database. You need something that’s more horizontally scalable, where you can keep on adding capacity as your data continues to grow over time.</p>
<p>It’s not just about random access to planet-size data - it’s also planet-size access to that data. Imagine you’re running a web site like Amazon, where you need to very quickly retrieve the list of things people ordered, or the things they looked at, or what movies they should be recommended, or on Google - what they searched for in the past. That all has to happen at extremely large scale. Tens of thousands of people per second might be hitting your service to actually retrieve this information in real time.</p>
<p>Again, a single Oracle database or MySQL database is not gonna cut it, when you’re talking about that kind of transaction rates on that large of a data set.</p>
<p>过去没有NoSQL, Hadoop时，采用的方法：</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579162897675.png" alt="1579162897675"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579163190865.png" alt="1579163190865"></p>
<p>All you need is an API that says, “given this customer ID, give me back this list of information”, or “given</p>
<p>this item identifier, give me back this information about this item”. So, more often than not, all you really need at runtime is a simple API that allows you to get information for a given key or put information into a given key.</p>
<p>These are basically, key-value data stores at a high level. And if that’s all you need, then you don’t need a big fancy relational database. All you need is a more scalable system that can be very easily horizontally partitioned for given key ranges, that just answers the question: “Give me this stuff for this key”.</p>
<p>And you can always do both, too. For example, you can have a Hadoop cluster that you’re running Hive on, or Pig, or Spark, to actually answer the more complex questions that you have, but for the things you are doing at a very high scale, at very high transaction rates, you can bolt on a NoSQL database to actually handle that part of the problem. It’s not a question of one or the other - it’s about having the right tools in place for the right jobs.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579163943922.png" alt="1579163943922"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579165798303.png" alt="1579165798303"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579165874566.png" alt="1579165874566"></p>
<h3><span id="what-is-hbase">What is HBase</span></h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579166108894.png" alt="1579166108894"></p>
<p>HBase is built on top of HDFS. So if you’re storing massive datasets on an HDFS file system, HBase can be used to actually vend that to the outside world at a very large scale.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579170600274.png" alt="1579170600274"></p>
<p>Just like every other NoSQL solution, it <strong>does not have a query language, but it does have an API</strong> that can very quickly answer the question “what are the values for this key?” or “store this value for this key”.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579170812851.png" alt="1579170812851"></p>
<h4><span id="crud">CRUD</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579171017155.png" alt="1579171017155"></p>
<h4><span id="hbase-architecture">HBase architecture</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579172096734.png" alt="1579172096734"></p>
<p>Basically, it’s split up into different region servers. This is the core of HBase itself. When we talk about regions, we’re talking about ranges of keys, so it’s just like sharding or range partitioning in more traditional database systems. But the magic of it all is that it can automatically adapt, so, as your data grows, it can automatically repartition things, and if you add more servers to the mix, it can automatically deal with that at runtime.</p>
<p>So there’s a very complex mechanism that involves write-ahead commit logs and, merging things together over time asynchronously. But you don’t have to worry about those details - HBase does it for you. All you need to know is that it can automatically distribute your data amongst a fleet of region servers, so an entire cluster, if you will.</p>
<p>Now, when you have an application that’s actually talking to HBase - a web application or a web server - it’s not actually going to talk to these master nodes directly, it’s going to be talking to region servers directly.</p>
<h4><span id="hbase-data-model">HBase data model</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579172733321.png" alt="1579172733321"></p>
<p>What’s different about HBase is that it has the concept of column families. So you don’t define a fixed set of columns for each row in your database. Instead you define column families, and each column family can contain a very large number of individual columns.</p>
<p>This comes in handy where you have cases of sparse data.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579174693898.png" alt="1579174693898"></p>
<h4><span id="ways-to-access-hbase">Ways to access HBase</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579175017006.png" alt="1579175017006"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579174915921.png" alt="1579174915921"></p>
<h3><span id="activity-import-movie-ratings-into-hbase">[Activity] Import movie ratings into HBase</span></h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579178657253.png" alt="1579178657253"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579179141807.png" alt="1579179141807"></p>
<p>Now we’re going to run a REST service on top of HBase. It’s just a service that you can query through</p>
<p>HTTP requests, and we’re going to write a client that actually queries that service to store and retrieve</p>
<p>data through the REST service.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963426#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963426#overview</a></p>
<p>返回结果：</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579179897880.png" alt="1579179897880"></p>
<h3><span id="mongodb-overview">MongoDB Overview</span></h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579180346655.png" alt="1579180346655"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579180457304.png" alt="1579180457304"></p>
<p>CAP theorem: <strong>MongoDB chooses consistency and partition-tolerance.</strong></p>
<p>Since it dose have to deal with big data, partition-tolerance is something is has to do, and MongoDB chooses consistency over availability.</p>
<p>So MongoDB has a single master, a single primary database that you have to talk to all the time to ensure consistency. But if that master goes down, it will result in a period of unavailability, while a new primary database is put into place.</p>
<h4><span id="document-based-data-model">Document-based data model</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579235814767.png" alt="1579235814767"></p>
<p>The big thing that’s different about MongoDB is that you can stick pretty much anything you want into MongoDB - basically, any JSON blob of data you can shove into a document in MongoDB. It doesn’t have to be structured, you don’t have to have the same schema across each document. You can put whatever you want in there.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579236174990.png" alt="1579236174990"></p>
<p>You still need to think about what the queries are you going to be performing on this database and design your database schema accordingly. Think about what indices you might need for fast lookups for the queries you’re going to do. At the end of the day, it’s still a NoSQL database, so you cannot do joins efficiently, so you want to make sure your schema is denormalized as much as you can. </p>
<h4><span id="mongodb-terminology">MongoDB terminology</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579238197250.png" alt="1579238197250"></p>
<p>在MongoDB中我们讨论 Databse, Collection, 和 Document, 而不是 Database, Table, 和 Row.</p>
<p>A MongoDB database contains collections, and a collection contains a collection of documents.</p>
<p>And the main restriction here is simply that you cannot move data between collections across different databases, so if you do need to reference data between different collections, they do need to be within the same database.</p>
<h4><span id="replication-sets">Replication Sets</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579250924977.png" alt="1579250924977"></p>
<p>MongoDB has a single-master architecture, the idea being that we want to have consistency over availability, but you can have these secondary databases that maintain copies over time from your primary database, so, as writes happen to your primary database, those writes get replicated through an operation log to any secondary nodes that you might have attached to it.</p>
<p>The way that replication chain works is kind of arbitrary. It actually just tries to figure out which server can it talk to most quickly.</p>
<p>And I want to stress again that we haven’t even talked about big data yet. What we’re talking about here in replica sets is just having a single monolithic MongoDB server, where all of the data sits on that single server, and we’re replicating that data to backup servers.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254081608.png" alt="1579254081608"></p>
<h4><span id="sharding-how-mongodb-handles-big-data">Sharding (How MongoDB handles big data)</span></h4><p>For actually scaling out data across more than one server with MongoDB, we need to set up something called sharding.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254450944.png" alt="1579254450944"></p>
<p>The way sharding works is that we actually have multiple replica sets, where each replica set is responsible for some range of values on some indexed value in my database. So in order to get sharding to work, it requires that you set up an index on some unique value on your collection, and that index is used to actually balance the load of information among multiple replica sets, and then on each application server, whatever you’re using to talk to MongoDB, you’ll run a process called “mongos”, and “mongos” talks to exactly three configuration servers that you have running somewhere that knows about how things are partitioned and then uses that to figure out which replica set do I talk to to get the information that I want.</p>
<p>“mongos” is running something called a balancer in the background. So, over time, if it finds that it actually doesn’t have an even distribution of values in whatever field you’re partitioning on, it can rebalance things across your replica sets in real time over time.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254879640.png" alt="1579254879640"></p>
<h4><span id="neat-things-about-mongodb">Neat Things about MongoDB</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579255204023.png" alt="1579255204023"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579255278039.png" alt="1579255278039"></p>
<h3><span id="activity-install-mongodb-and-integrate-spark-with-mongodb">[Activity] Install MongoDB and integrate Spark with MongoDB</span></h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963458#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963458#overview</a></p>
<p>We’re going to read in the “u.user” data file from the MovieLens dataset, convert that into a dataframe in Spark and then write that dataframe out to MongoDB, and then we’re going to read it back and do a little query on it.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579328591006.png" alt="1579328591006"></p>
<p>What we’re not doing is loading this data into Spark locally and then running a query on it - what it’s</p>
<p>actually doing is figuring out how do I translate this SQL query into a MongoDB query and actually</p>
<p>execute that on MongoDB and return the results back from MongoDB.</p>
<h3><span id="activity-using-the-mongodb-shell">[Activity] Using the MongoDB Shell</span></h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963462#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963462#overview</a></p>
<p>启动MongoDB Shell:</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406411404.png" alt="1579406411404"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579331041897.png" alt="1579331041897"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579331085161.png" alt="1579331085161"></p>
<p>注意一点：we never set up an index. So when I said, “go find user ID 100”, it couldn’t do that very efficiently, and I actually had to do a full table scan, because MongoDB doesn’t automatically index things for you.</p>
<p>I can do <code>db.users.explain().find( {user_id: 100} )</code> , and that will do an explain on the query, telling you what it will do under the hood to actually execute the command “find” on the expression “{user_id: 100}”. And you can see here all it’s doing is a scan on the “winningPlan”, looking for user ID 100 going forward. So it’s kind of just starts at the beginning of the entire database and chugs through it forward one record, one document at a time, until it stumbles across user ID 100, so, obviously, not the most efficient way of doing a lookup.</p>
<p>So to fix that, let’s make an index. To do that, I can say, <code>db.users.createIndex( {user_id: 1} )</code> -and what this means is I want to create an index on the “user_id” field and the “1” just means it’s ascending. So that’s going to give you back a sort order that’s in ascending order, if you want to optimize sorts as well.</p>
<p>Once it has its index on the “user_id” field, it can much more quickly look up where to find a given document for that user ID.</p>
<p><strong>MongoDB does not set up an index for you on your primary key. You have to do it by hand, and if you forget to do it, your database is going to be horribly inefficient when you do lookups.</strong></p>
<p>Let’s aggregate all of the users by occupation and figure out the average age for each occupation.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405319292.png" alt="1579405319292"></p>
<p>In MongoDB things that start with a dollar sign mean that this has some sort of a special meaning to MongoDB, so “$group” is a command that MongoDB recognizes.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405698972.png" alt="1579405698972"></p>
<p>How many users are in our database?</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405757587.png" alt="1579405757587"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406239652.png" alt="1579406239652"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406303820.png" alt="1579406303820"></p>
<h3><span id="choosing-a-database-technology">Choosing a database technology</span></h3><h4><span id="integration-considerations">Integration considerations</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406708880.png" alt="1579406708880"></p>
<p>Different technologies have different connectors for different other technologies. </p>
<p>例如, if you have a big analytics job that’s currently running in Apache Spark, then you probably want to limit yourself to external databases that can connect easily to Apache Spark.</p>
<p>又例如, Maybe you have some front-end system that actually depends on having a SQL interface to a back-end database, and you’re thinking about moving from a monolithic relational database to a distributed non-relational database. In that case, it might make life a lot easier if the non-relational database you’re moving to offers some sort of SQL-like interface that can be easily migrated to from your front-end application.</p>
<h4><span id="scaling-requirements">Scaling requirements</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406971416.png" alt="1579406971416"></p>
<p>How much data are you really talking about? Is it going to grow unbounded over time?</p>
<p>If so, then you need some sort of a database technology that is not limited to the data that you can store on one PC, right? You’re going to have to look at something like Cassandra or MongoDB or HBase, where you can actually distribute the storage of your data across an entire cluster and scale horizontally instead of vertically.</p>
<p>Think, too, about your transaction rates: how many requests do you intend to get per second? You know, if we’re talking about thousands, then, again, a single database server is not going to cut it. You need something that’s distributed, where you can spread out the load of those transactions more evenly.</p>
<h4><span id="support-considerations">Support considerations</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579407277634.png" alt="1579407277634"></p>
<p>So do you actually have the in-house expertise to spin up this new technology and actually configure it properly? It’s going to be harder than you think, especially if you’re using this in the real world or in any sort of situation, where you have personally identifiable information in the mix from your end users. In that case, you need to make sure you’re thinking very deeply about the <strong>security</strong> of your system, and the truth is most of the NoSQL databases we talked about, if you just configure them with their default settings, there’ll be no security at all. Anybody at all can connect to these things and retrieve data or write data into them, so you need to make sure you have someone available who knows what they’re doing for setting this up in a secure manner.</p>
<p>That might mean if you are in a big organization that has these experts in house, that’s great, don’t even think about it - but if you’re in a smaller organization, you might want to consider: does this technology I’m choosing actually offer professional paid support that will help guide me through these setup decisions and the initial administration of my server over time? Or are there administrators that I can outsource the ongoing administration to over time? So in this case, you know, a more corporate solution like MongoDB might actually be a good choice, because, you know, they have paid support, and even for the more open-source Apache projects, there are companies out there that do offer paid professional support for them as well, so do your homework and try to figure out: can I really do this on my own, and if not, what resources are out there in the marketplace to help me? </p>
<h4><span id="cap-considerations">CAP considerations</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579407517312.png" alt="1579407517312"></p>
<p>So again, the way to think about this is when you’re thinking about the scale of your requirements, do you need to have partition tolerance? Do you have sufficient scale, where you know you’re going to eventually need more than one server serving up the data just for handling the transactions you’re talking about, and also for the scale of the data that you’re talking about? If so, partition tolerance is non-negotiable, you need that one, and your only real choice in that case is consistency or availability.</p>
<p>And that will determine which one of these sides of the triangle you might want to lean toward. So the type of application will determine what you want there. Is it actually OK if your system goes down for a few seconds or a few minutes? If not, then availability’s going to be your prime concern. Is it OK if you have eventual consistency, where, if you write something, people might get the old value back on subsequent reads for a few seconds? If so, who cares about consistency, right? Again, I would take availability instead. But if you’re dealing with something that’s dealing with real transactional information like, you know, stock transactions or some sort of financial transactions, you might value consistency above all else, and in that case, you want to really focus on that corner of the triangle.</p>
<blockquote>
<p>注：Now, I should point out that the CAP theorem isn’t really a hard-and-fast rule. The reality is these tradeoffs have become a little bit more loose in recent years. For example, consider Cassandra: is it really trading off consistency for availability and partition tolerance? Well, you can actually configure the amount of consistency that you want from Cassandra - you can tell it, “I want to make sure I get back the same result from every replica of this data before I actually consider that transaction to be final”, and if you’re running it in that mode, you’re kind of getting all three.</p>
<p>The lines are getting blurred between these different tradeoffs over time. So the honest truth is any of these technologies can be made to work in pretty much any situation, if you try hard enough. It’s really a question of choosing the technology that’s best suited to the tradeoffs that you want to make.</p>
</blockquote>
<h4><span id="simplicity">Simplicity</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579408720595.png" alt="1579408720595"></p>
<p>If you don’t need to set up a highly complex NoSQL cluster and something that needs a lot of maintenance, like, you know, MongoDB or HBase, where you have all these external servers that maintain its configuration, don’t do it, if you don’t need to. </p>
<p><strong>Think about the minimum requirements that you need for your system and keep it as simple as possible.</strong></p>
<p>If you don’t need to deal with massive scale, don’t deploy a NoSQL database, if you don’t already have one, right? Just use a MySQL instance somewhere, it will be fine.</p>
<p>So keep it simple, do not deploy a whole new system that does not have good expertise within your organization, unless you really need to. Simple technologies and simple architectures are going to be a lot easier to maintain.</p>
<h4><span id="examples">Examples</span></h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579408982980.png" alt="1579408982980"></p>
<p>Go with MySQL.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409021695.png" alt="1579409021695"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409163590.png" alt="1579409163590"></p>
<p>Well, first of all, step back and ask yourself, “do I even have enough scale here to warrant a non-relational database at all? Why am I even thinking about this question - right? - if all I’m doing is analytics, that’s what Hadoop is for, that’s what Spark is for.”</p>
<p>如果只是需要分析：You can import this data into HDFS on your cluster and analyze it offline. </p>
<p>如果是想要很快的得到结果：If we’re not talking about high transaction rates here, where we care about very quickly getting the answer to a specific query over and over and over again, thousands of times per second, - that’s the sort of a problem that NoSQL databases are meant for.</p>
<p>You could solve this problem just by importing your log data into HDFS, but it doesn’t involve external databases at all. Once that data is residing on my HDFS cluster, I can write a Spark job that mines that data, assigns the appropriate structure to it, and it can actually run machine learning algorithms on it even using Spark’s MLlib.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409497341.png" alt="1579409497341"></p>
<p>Just use your Hadoop cluster and the capabilities that the Hadoop ecosystem gives you, without resorting to outside database technologies.</p>
<p>There’s no need here to set up an external database at all necessarily, unless you need to vend this data to a very large audience externally. So if you were actually building Google Analytics for real, where you had, you know, millions of people that wanted to hit it and get answers from it at once, then, sure, you’d want to expose that through some sort of an external database system that’s integrated with your cluster.</p>
<p>But if you’re just using this internally for analytic use, there’s no need to even talk about things like NoSQL or Mongo or Cassandra or something like that.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409662825.png" alt="1579409662825"></p>
<p>Consistency:  it’s OK if, for a few seconds after new recommendations have been computed for a user, that you’re still getting the old recommendations.</p>
<p>So, thinking back to the CAP theorem, we care about availability, we care about partition tolerance very much, the thing that we’re willing to give up, maybe, is consistency.</p>
<p>In that case, Cassandra might be a good choice. </p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409873125.png" alt="1579409873125"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579410043297.png" alt="1579410043297"></p>
<p>We posed this scenario, where you’re building a massive stock trading system, where maybe you want to run a big analytics job on Hadoop or Spark in the background, but you still need to have some sort of a front-end interface to the actual stock trades themselves, so what would be a good choice of a database in this situation?</p>
<p>选择 MongoDB 或者 HBase 都可以。对于 MongoDB, there is a big company behind it that makes its living selling support for it. 另一方面，Now, there are other companies out there that do specialize in offering support for things like HBase or other Apache projects, so don’t make that a hard decision there.</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
        <tag>HBase</tag>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Using relational data stores with Hadoop —— Hive &amp; Sqoop</title>
    <url>/2020/01/15/Using-relational-data-stores-with-Hadoop-%E2%80%94%E2%80%94-Hive/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#hive">HIVE</a><ul>
<li><a href="#what-is-hive">What is Hive?</a><ul>
<li><a href="#why-hive">Why Hive</a></li>
<li><a href="#why-not-hive">Why not Hive</a></li>
<li><a href="#hiveql">HiveQL</a></li>
</ul>
</li>
<li><a href="#activity-use-hive-to-find-the-most-popular-movie">[Activity] Use Hive to find the most popular movie</a></li>
<li><a href="#how-hive-works">How Hive works?</a><ul>
<li><a href="#schema-on-read">Schema on read</a></li>
<li><a href="#where-is-the-data-内部表与外部表">Where is the data? (内部表与外部表)</a></li>
<li><a href="#partitioning-分区">Partitioning 分区</a></li>
<li><a href="#ways-to-use-hive">Ways to use Hive</a></li>
</ul>
</li>
<li><a href="#activity-use-hive-to-find-the-movie-with-the-highest-average-rating">[Activity] Use Hive to find the movie with the highest average rating</a></li>
</ul>
</li>
<li><a href="#sqoop">Sqoop</a><ul>
<li><a href="#integrating-mysql-with-hadoop">Integrating MySQL with Hadoop</a></li>
<li><a href="#importexport-data-mysql-hdfshadoop">Import/Export data (MySQL &lt;-&gt; HDFS/Hadoop)</a></li>
<li><a href="#play-with-mysql-and-sqoop">Play with MySQL and Sqoop</a><ul>
<li><a href="#activity-install-mysql-and-import-our-movie-data">[Activity] Install MySQL and import our movie data</a></li>
<li><a href="#activity-use-sqoop-to-import-data-from-mysql-to-hdfshive">[Activity] Use Sqoop to import data from MySQL to HDFS/Hive</a></li>
<li><a href="#activity-use-sqoop-tp-export-data-from-hadoop-to-mysql">[Activity] Use Sqoop tp export data from Hadoop to MySQL</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#结语">结语</a></li>
</ul>
<!-- tocstop -->

<h2><span id="hive">HIVE</span></h2><p>We can actually make your Hadoop cluster look like a relational database through a technology called <strong>Hive</strong>. And there’s also ways of integrating a new Hadoop cluster with a MySQL database.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579064046135.png" alt="1579064046135"></p>
<h3><span id="what-is-hive">What is Hive?</span></h3><p>It lets you write standard SQL queries that look just like you’d be using them on MySQL, but actually execute them on data that’s stored across your entire cluster, maybe on an HDFS cluster as well.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579064255091.png" alt="1579064255091"></p>
<h4><span id="why-hive">Why Hive</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579082214734.png" alt="1579082214734"></p>
<h4><span id="why-not-hive">Why not Hive</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579083363568.png" alt="1579083363568"></p>
<p>It’s not really meant for being hit with tons of queries all at once, from a website or something like that. That’s where you use something like HBase instead.</p>
<p>Hive is a bunch of smoke and mirrors to make it look like a database, so you can issue SQL queries on it, but it isn’t really.</p>
<a id="more"></a>

<h4><span id="hiveql">HiveQL</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579084456353.png" alt="1579084456353"></p>
<h3><span id="activity-use-hive-to-find-the-most-popular-movie">[Activity] Use Hive to find the most popular movie</span></h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963170#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963170#overview</a></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085359675.png" alt="1579085359675"></p>
<p>或写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT title, COUNT(movieID) AS ratingCount</span><br><span class="line">FROM ratings JOIN names ON ratings.movieID = names.movieID</span><br><span class="line">GROUP BY ratings.movieID</span><br><span class="line">ORDER BY ratingCount DESC;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085980578.png" alt="1579085980578"></p>
<p>We used views in Hive to split up a more complicated query into something more readable and more manageable.</p>
<p>执行时会花一点时间，remember this isn’t really a relational database, so things like joins are kind of painful when you’re not dealing with normalized data.</p>
<p>执行后会发现新创建的view出现在了Database里：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085692727.png" alt="1579085692727"></p>
<p>Your views are persistent, they’re stored to disk.</p>
<p>若此时再执行会出错，可写成： <code>CREATE VIEW IF NOT EXISTS topMovieIDs ...</code></p>
<p>Just to clean up our mess and not leave that around: <code>DROP VIEW topMovieIDs;</code></p>
<h3><span id="how-hive-works">How Hive works?</span></h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579086892876.png" alt="1579086892876"></p>
<h4><span id="schema-on-read">Schema on read</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579087836551.png" alt="1579087836551"></p>
<p>One of the basic concepts pf Hive is something called <em>schema on read</em>, and this is what separates it from a more traditional database. With a real relational database, it uses something called <em>schema on write</em> where you define the schema of your database before you load the data into it, and it’s actually enforced at the time that you write the data to disk. </p>
<p>Hive flips that on its head. It takes unstructured data and just sort of applies a schema to it as it’s being read instead.</p>
<p>So, Hive isn’t creating some structured relational database under the hood, that would be very inefficient, it’s just taking the existing data that you have on your cluster and imparting a schema to it when it’s read in.</p>
<h4><span id="where-is-the-data-内部表与外部表">Where is the data? (内部表与外部表)</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579089471741.png" alt="1579089471741"></p>
<p>对于 managed table, if you do a “DROP TABLE” command from Hive, then that data is gone.</p>
<p>But sometimes you want to share that data with other systems that are outside of Hive. So that’s where external tables come in. “CREATE EXTERNAL TABLE” with “Location” says, “I’m going to use Hive on this data here, but I’m not going to own it anymore”. So I drop this table, it’s going to drop the metadata, 但是原数据不会被删除。</p>
<h4><span id="partitioning-分区">Partitioning 分区</span></h4><p>If you do have a massive dataset and your queries tend to be on a specific partition of that data, partitioning in Hive can be a very important optimization. </p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579096514448.png" alt="1579096514448"></p>
<p>We wouldn’t have to scan over the entire customer database, we could just scan over the actual files that are specific to the country that I’m interested in.</p>
<h4><span id="ways-to-use-hive">Ways to use Hive</span></h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579096909189.png" alt="1579096909189"></p>
<h3><span id="activity-use-hive-to-find-the-movie-with-the-highest-average-rating">[Activity] Use Hive to find the movie with the highest average rating</span></h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579149719149.png" alt="1579149719149"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579097528758.png" alt="1579097528758"></p>
<p>或写成：？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT title, AVG(rating) as avgRating</span><br><span class="line">FROM ratings JOIN names on ratings.movieID = names.movieID</span><br><span class="line">GROUP BY ratings.movieID</span><br><span class="line">HAVING COUNT(ratings.movieID)  &gt; 10</span><br><span class="line">ORDER BY avgRating DESC;</span><br></pre></td></tr></table></figure>

<h2><span id="sqoop">Sqoop</span></h2><h3><span id="integrating-mysql-with-hadoop">Integrating MySQL with Hadoop</span></h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579149997458.png" alt="1579149997458"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579150738331.png" alt="1579150738331"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579150774304.png" alt="1579150774304"></p>
<h3><span id="importexport-data-mysql-lt-gt-hdfshadoop">Import/Export data (MySQL &lt;-&gt; HDFS/Hadoop)</span></h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579151204058.png" alt="1579151204058"></p>
<p>Export data from your database into Hadoop:</p>
<ol>
<li>kick off a bunch of mappers (只有mappers, all we’re doing is moving data and transforming it from one place to another, there’s no real reduce going on here.)</li>
<li>all these mappers are going to talk to your HDFS cluster on your Hadoop cluster and populate a big old table on HDFS, which is a giant text file (例如逗号分隔的数据), and from there, you can use tools like Hive or Pig on it.</li>
</ol>
<p>REMEMBER, the power of HDFS is that file might be distributed across many different hosts, blocks, and also stored redundantly. We’ve done more than just dump our database to a file here - we’ve dumped it into HDFS, which opens up a whole world of possibilities for analyzing it in a robust, scalable and a manner that can be resilient to failure.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579156422401.png" alt="1579156422401"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579157592193.png" alt="1579157592193"></p>
<p>与导入HDFS一样，导入Hive同样会kick off a MapReduce job.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579154105803.png" alt="1579154105803"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159508995.png" alt="1579159508995"></p>
<h3><span id="play-with-mysql-and-sqoop">Play with MySQL and Sqoop</span></h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579154231118.png" alt="1579154231118"></p>
<h4><span id="activity-install-mysql-and-import-our-movie-data">[Activity] Install MySQL and import our movie data</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963236#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963236#overview</a></p>
<h4><span id="activity-use-sqoop-to-import-data-from-mysql-to-hdfshive">[Activity] Use Sqoop to import data from MySQL to HDFS/Hive</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963266#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963266#overview</a></p>
<p>由 MySQL 导入 HDFS 后：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579156905400.png" alt="1579156905400"></p>
<p>由 MySQL 导入Hive后：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579157822360.png" alt="1579157822360"></p>
<blockquote>
<p>注：These sorts of tools that we’re using with Hadoop are really intended for big datasets, so there’s a lot of overhead for doing what’s actually a pretty simple operation. It doesn’t make sense if you’re using small datasets. 如果数据集很小，在一个host就能装下，没必要用这些工具，用MySQL就足够了。</p>
</blockquote>
<h4><span id="activity-use-sqoop-tp-export-data-from-hadoop-to-mysql">[Activity] Use Sqoop tp export data from Hadoop to MySQL</span></h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963272#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963272#overview</a></p>
<ol>
<li>首先需要知道 where the data in Hive actually resides. REMEMBER, Hive is just a schema-on-read sort of deal. The actual data itself if just stored as a plain old text somewhere, and all Hive is doing is imparting structure to it when it’s being read. </li>
</ol>
<p>On Hortonworks:</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579158771230.png" alt="1579158771230"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579158823550.png" alt="1579158823550"></p>
<p>不是靠逗号分隔的，Hive actually uses low ASCII values, like 1 and 2 and 3, to delimit its data. </p>
<ol start="2">
<li>在导入前，MySQL中要先有 target table</li>
</ol>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159104056.png" alt="1579159104056"></p>
<p>3.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159601163.png" alt="1579159601163"></p>
<p>和import一样，export也会kick off a bunch of mappers using MapReduce.</p>
<blockquote>
<p>什么时候需要从Hive导入MySQL: From a practical standpoint, if you need to expose your data to a database that’s more well-suited for OLTP. Sometimes you’ll be doing some huge operation using Hive or some other tool on your cluster, but the output of that operation might be small enough to fit on a single database.</p>
</blockquote>
<h2><span id="结语">结语</span></h2><p>We talked about making your Hadoop cluster look like a MySQL database or a SQL database, using Hive.</p>
<p>And we also talked about using your Hadoop cluster with a real MySQL database as well. Kind of two different directions there.</p>
<p>Next, let’s talk about <strong>NoSQL</strong>. Sometimes you actually want to expose your data in a way that’s more amenable to <strong>real-time queries</strong>, and there’s a bunch of ways to do that and also ways of integrating Hadoop with systems that are more real-time in nature.</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Course Overview</title>
    <url>/2020/01/14/Hadoop-Course-Overview/</url>
    <content><![CDATA[<p>课程：</p>
<p><a href="https://www.udemy.com/course-dashboard-redirect/?course_id=996228" target="_blank" rel="noopener"><img src="https://i.udemycdn.com/course/240x135/996228_af5f_3.jpg" alt="The Ultimate Hands-On Hadoop - Tame your Big Data!"></a><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/" target="_blank" rel="noopener"><strong>The Ultimate Hands-On Hadoop - Tame your Big Data!</strong></a></p>
<p><a href="https://sundog-education.com/hadoop-materials/" target="_blank" rel="noopener">Course Materials</a></p>
<h4><span id="what-youll-learn">What you’ll learn</span></h4><ul>
<li>Design distributed systems that manage “big data” using Hadoop and related technologies.</li>
<li>Use HDFS and MapReduce for storing and analyzing data at scale.</li>
<li>Use Pig and Spark to create scripts to process data on a Hadoop cluster in more complex ways.</li>
<li>Analyze relational data using Hive and MySQL</li>
<li>Analyze non-relational data using HBase, Cassandra, and MongoDB</li>
<li>Query data interactively with Drill, Phoenix, and Presto</li>
<li>Choose an appropriate data storage technology for your application</li>
<li>Understand how Hadoop clusters are managed by YARN, Tez, Mesos, Zookeeper, Zeppelin, Hue, and Oozie.</li>
<li>Publish data to your Hadoop cluster using Kafka, Sqoop, and Flume</li>
<li>Consume streaming data using Spark Streaming, Flink, and Storm</li>
</ul>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2020/01/14/Spark/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#introduction-to-spark">Introduction to Spark</a><ul>
<li><a href="#scalable">Scalable</a></li>
<li><a href="#fast">Fast</a></li>
<li><a href="#hot">Hot</a></li>
<li><a href="#not-that-hard-可使用的语言rdd">Not that hard (可使用的语言，RDD)</a></li>
<li><a href="#components-of-spark">Components of Spark</a></li>
<li><a href="#这门课将使用的语言及scala">这门课将使用的语言及Scala</a></li>
</ul>
</li>
<li><a href="#rdd-the-resilient-distributed-dataset">RDD (The Resilient Distributed Dataset)</a><ul>
<li><a href="#what-is-rdd">What is RDD?</a></li>
<li><a href="#how-do-you-make-rdd">How do you make RDD</a></li>
<li><a href="#create-rdd">Create RDD</a></li>
<li><a href="#transform-rdd">Transform RDD</a></li>
<li><a href="#rdd-actions">RDD actions</a></li>
<li><a href="#lazy-evaluation">Lazy evaluation</a></li>
<li><a href="#using-rdds-in-spark">Using RDD’s in Spark</a></li>
</ul>
</li>
<li><a href="#spark-sql-dataframes-and-datasets">Spark SQL (DataFrames and DataSets)</a><ul>
<li><a href="#using-datasets-in-spark-2">Using DataSets in Spark 2</a></li>
</ul>
</li>
<li><a href="#using-mllib-in-spark">Using MLLib in Spark</a></li>
<li><a href="#exercise">Exercise</a></li>
</ul>
<!-- tocstop -->

<h3><span id="introduction-to-spark">Introduction to Spark</span></h3><p><img src="/2020/01/14/Spark/1578976053911.png" alt="1578976053911"></p>
<p><img src="/2020/01/14/Spark/1578976261212.png" alt="1578976261212"></p>
<p>There’s a lot of cool features built on top of Spark, like things for machine learning and graph analysis and streaming data.</p>
<h4><span id="scalable">Scalable</span></h4><p><img src="/2020/01/14/Spark/%E6%8D%95%E8%8E%B7.JPG" alt="捕获"></p>
<h4><span id="fast">Fast</span></h4><p><img src="/2020/01/14/Spark/1578977218206.png" alt="1578977218206"></p>
<p>Spark除了比MapReduce更快以外，还有一个优势：MapReduce is very limited in what it can do. You have to think about things in terms of mappers and reducers, whereas Spark provides a framework for removing that level of though from you, you can just think more about your end results and program toward that and think less about how to actual distribute it across the cluster.</p>
<a id="more"></a>



<h4><span id="hot">Hot</span></h4><p><img src="/2020/01/14/Spark/1578977501017.png" alt="1578977501017"></p>
<h4><span id="not-that-hard-可使用的语言rdd">Not that hard (可使用的语言，RDD)</span></h4><p><img src="/2020/01/14/Spark/1578977890605.png" alt="1578977890605"></p>
<p>A few lines of code can actually kick off some very complex analysis on a cluster.</p>
<p>Spark 2.0 which came out in 2006, they’ve built on top of RDDs to produce something called a data set. That’s a little bit more of a SQL focused take on an RDD, but at the end of the day, it’s still built around the RDD.</p>
<h4><span id="components-of-spark">Components of Spark</span></h4><p><img src="/2020/01/14/Spark/1578978133377.png" alt="1578978133377"></p>
<p>Spark has a lot of depth to it, so while you could just program at the RDD level within <strong>Spark Core</strong>, there are also libraries built on top of Spark that are part of Spark itself.</p>
<p><strong>Spark Streaming</strong>: Instead of doing batch processing of data, you can actually input data in real time. Data can be ingested as it’s being produced, and then Spark can analyze it across some window of time, and you can output the results of that analysis to a database or some NoSQL data store, all within a few lines of code.</p>
<p><strong>Spark SQL</strong>: Very hot area right now. It’s basically a SQL interface to Spark. You can write SQL queries against your data using Spark SQL. It allows us to do more optimizations beyond the directed acyclic graph, because it can do SQL optimizations on the queries that you’re actually running.</p>
<p><strong>MLLib</strong>: An entire library of machine learning and data mining tools that you can run on a data set that’s in Spark.</p>
<p><strong>GraphX</strong>: That’s the graph in terms of graph theory. Imagine for example, you have a social network graph, and you want to analyze the properties of that graph, and see who’s connected to who and what way, and what are the shortest path and things like that, GraphX provides a very extensible way of doing that.</p>
<p>SO, very rich ecosystem surrounding Spark that lets you do a wide variety of tasks on big data across the cluster.</p>
<h4><span id="这门课将使用的语言及scala">这门课将使用的语言及Scala</span></h4><p><img src="/2020/01/14/Spark/1578979417251.png" alt="1578979417251"></p>
<p>If you do want to end up using Spark in production in the real world, Python is OK to start with, but you probably want to move to Scala. </p>
<p><img src="/2020/01/14/Spark/1578979634184.png" alt="1578979634184"></p>
<p>It’s not very hard to move from Python to Scala. </p>
<h3><span id="rdd-the-resilient-distributed-dataset">RDD (The Resilient Distributed Dataset)</span></h3><p><img src="/2020/01/14/Spark/1578989468387.png" alt="1578989468387"></p>
<h4><span id="what-is-rdd">What is RDD?</span></h4><p><img src="/2020/01/14/Spark/1578989673088.png" alt="1578989673088"></p>
<p>It’s an abstraction across all the nastiness that happens under the hood to actually make sure your job is evenly distributed across your cluster that it can handle failures in a resilient manner, and at the end of the day, it just looks like a dataset to you.</p>
<p>From a programming standpoint, an RDD is just a dataset to you. But under the hood, it’s resilient and distributed and you don’t have to think about that very much.</p>
<h4><span id="how-do-you-make-rdd">How do you make RDD</span></h4><p><img src="/2020/01/14/Spark/1578989938843.png" alt="1578989938843"></p>
<p>The SparkContext is sort of the environment that your driver program runs within Spark, and it is what creates RDDs.</p>
<h4><span id="create-rdd">Create RDD</span></h4><p><img src="/2020/01/14/Spark/1578990141827.png" alt="1578990141827"></p>
<p><img src="/2020/01/14/Spark/1579012530332.png" alt="1579012530332"></p>
<p><img src="/2020/01/14/Spark/1578990969096.png" alt="1578990969096"></p>
<p>Once you have an RDD, what do you do with it?</p>
<h4><span id="transform-rdd">Transform RDD</span></h4><p><img src="/2020/01/14/Spark/1579008653516.png" alt="1579008653516"></p>
<p><em>map</em>: apply some function to every input row of your RDD and create a new RDD that is transformed in some way. Map is used when you have a one to one relationship </p>
<p><em>flatmap</em>: 与map的区别在于，使用map, input于output是一对一的关系，使用flatmap, can have any relationship, where your input lines may or may not result in one or more output lines. 例如，maybe you want to split out each input line into multiple rows, or maybe you want to discard some of the input lines if they’re invalid.</p>
<p><em>filter</em>: can be used to take stuff out of an RDD so you can provide that with some function that determines whether or not a row survives.</p>
<p><em>distinct</em>: gives you back the distinct unique values in an RDD. </p>
<p><em>sample</em>: sample them randomly.</p>
<p><img src="/2020/01/14/Spark/1579008991727.png" alt="1579008991727"></p>
<p><img src="/2020/01/14/Spark/1579009321705.png" alt="1579009321705"></p>
<h4><span id="rdd-actions">RDD actions</span></h4><p><img src="/2020/01/14/Spark/1579009474269.png" alt="1579009474269"></p>
<h4><span id="lazy-evaluation">Lazy evaluation</span></h4><p><img src="/2020/01/14/Spark/1579009528882.png" alt="1579009528882"></p>
<p>So basically, as you go through this script and transform your RDD’s, until you hit an action, all that’s doing is building up this graph, this chain of dependencies within your driver script, and only when that action is called does it actually figure out the quickest path through those dependencies. And it’s at that point that it actually kicks off the job on your cluster.</p>
<h4><span id="using-rdds-in-spark">Using RDD’s in Spark</span></h4><p>Find the movie with the lowest average rating - with RDD’s.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6082670#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6082670#overview</a></p>
<p><img src="/2020/01/14/Spark/1579014872589.png" alt="1579014872589"></p>
<h3><span id="spark-sql-dataframes-and-datasets">Spark SQL (DataFrames and DataSets)</span></h3><p><img src="/2020/01/14/Spark/1579012722667.png" alt="1579012722667"></p>
<p>Now, let’s talk about Spark SQL and the Spark 2.0 way of doing things using dataframes and datasets.</p>
<p><img src="/2020/01/14/Spark/1579012953410.png" alt="1579012953410"></p>
<p><img src="/2020/01/14/Spark/1579013215223.png" alt="1579013215223"></p>
<p><img src="/2020/01/14/Spark/1579013233354.png" alt="1579013233354"></p>
<p><img src="/2020/01/14/Spark/1579013961536.png" alt="1579013961536"></p>
<p>DataFrame is really a dataset of row objects, and DataSet is a more general term that can contain any sort of typed information, not necessarily a row like you have in a DataFrame.</p>
<p><img src="/2020/01/14/Spark/1579014168231.png" alt="1579014168231"></p>
<p><img src="/2020/01/14/Spark/1579014221441.png" alt="1579014221441"></p>
<p>Spark SQL is very extensible, you can create user defined functions that plug into a SQL and create your own functions you can use within your SQL queries.</p>
<p>SO, this is the power of DataFrames and DataSets in Spark 2.0 and Spark SQL. The other thing that’s worth noting is that this is sort of the unified API between different subsystems of Spark going forward. You’ll see that in Spark 2 the MLLib machine learning library of the Spark streaming library, all now have DataSet based APIs that you can use, so DataSets are kind of the common denominator between these different systems that allow you to pass data between them. </p>
<p>So, not only do you get performance benefits by using DataSets in Spark 2, you also get easier ways of actually using all these capabilities built on top of Spark we can mix and match them in interesting ways.</p>
<h4><span id="using-datasets-in-spark-2">Using DataSets in Spark 2</span></h4><p>Find the movie with lowest average rating - with DataFrames.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963108#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963108#overview</a></p>
<p><img src="/2020/01/14/Spark/1579014920753.png" alt="1579014920753"></p>
<h3><span id="using-mllib-in-spark">Using MLLib in Spark</span></h3><p>movie recommendations (通过predict rating)</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963112#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963112#overview</a></p>
<p><img src="/2020/01/14/Spark/1579059887637.png" alt="1579059887637"></p>
<h3><span id="exercise">Exercise</span></h3><p><img src="/2020/01/14/Spark/1579060756315.png" alt="1579060756315"></p>
<p><img src="/2020/01/14/Spark/1579062594969.png" alt="1579062594969"></p>
<p><img src="/2020/01/14/Spark/1579062687242.png" alt="1579062687242"></p>
<p>check your result</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6115596#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6115596#overview</a></p>
<p>The DataFrame approach is a lot easier to use, and when you’re running it at a large scale it’s going to be faster as well.</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程</title>
    <url>/2020/01/13/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p>
<p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p>
<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<h4><span id="什么是存储过程">什么是存储过程？</span></h4><p>存储过程就是作为可执行对象存放在数据库中的一个或多个SQL命令。<br>通俗来讲：存储过程其实就是能完成一定操作的一组SQL语句。</p>
<h4><span id="为什么要使用存储过程">为什么要使用存储过程？</span></h4><p>1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。<br>2.当对数据库进行复杂操作时，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。<br>3.存储过程可以重复使用，可减少数据库开发人员的工作量。<br>4.安全性高，可设定只有某些用户才具有对指定存储过程的使用权</p>
<h4><span id="优点">优点</span></h4><ul>
<li>存储过程可封装，并隐藏复杂的商业逻辑。</li>
<li>存储过程可以回传值，并可以接受参数。</li>
<li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li>
<li>存储过程可以用在数据检验，强制实行商业逻辑等。</li>
</ul>
<h4><span id="缺点">缺点</span></h4><ul>
<li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同，当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li>
<li>存储过程的性能调校与撰写，受限于各种数据库系统。</li>
</ul>
<p>存储过程：存储过程就是编译好了的一些sql语句。</p>
<ol>
<li><p>存储过程因为SQL语句已经预编绎过了，因此运行的速度比较快。</p>
</li>
<li><p>可保证数据的安全性和完整性。通过存储过程可以使没有权限的用户在控制之下间接地存取数据库，从而保证数据的安全。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。</p>
</li>
<li><p>可以降低网络的通信量。存储过程主要是在服务器上运行，减少对客户机的压力。</p>
</li>
<li><p>存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值。可以向程序返回错误原因</p>
</li>
<li><p>存储过程可以包含程序流、逻辑以及对数据库的查询。同时可以实体封装和隐藏数据逻辑。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>事务与锁</title>
    <url>/2020/01/13/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#事务-transaction">事务 Transaction</a></li>
<li><a href="#并发控制-concurrency-control">并发控制 Concurrency Control</a><ul>
<li><a href="#共享锁与排他锁或叫互斥锁">共享锁与排他锁（或叫互斥锁）</a></li>
<li><a href="#两段锁协议two-phase-locking-2pl">两段锁协议（Two-Phase Locking —— 2PL）</a></li>
<li><a href="#死锁">死锁</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h4><span id="事务-transaction">事务 Transaction</span></h4><p>事务：是一系列的数据库操作 (a group of SQL statement)，是数据库应用的基本逻辑单位。</p>
<p>事务性质：(<span style="color:red">ACID</span>)</p>
<ul>
<li>原子性（atomicity）。即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性或可串性（consistency）。事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li>
<li>隔离性（isolation）。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。</li>
<li>持久性（durability）。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</li>
</ul>
<p><img src="/2020/01/13/事务与锁/1578903852566.png" alt="1578903852566"></p>
<p><img src="/2020/01/13/事务与锁/1578903920125.png" alt="1578903920125"></p>
<p><img src="/2020/01/13/事务与锁/1578904033183.png" alt="1578904033183"></p>
<p><img src="/2020/01/13/事务与锁/1578904133622.png" alt="1578904133622"></p>
<p><img src="/2020/01/13/事务与锁/1578904156358.png" alt="1578904156358"></p>
<a id="more"></a>

<p><img src="/2020/01/13/事务与锁/1578904553025.png" alt="1578904553025"></p>
<p><img src="/2020/01/13/事务与锁/1578904582538.png" alt="1578904582538"></p>
<p><img src="/2020/01/13/事务与锁/1578904641058.png" alt="1578904641058"></p>
<p><img src="/2020/01/13/事务与锁/1578904660894.png" alt="1578904660894"></p>
<p><img src="/2020/01/13/事务与锁/1578904679577.png" alt="1578904679577"></p>
<p><code>可串行化</code>：多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是可串行化调度。</p>
<p><img src="/2020/01/13/事务与锁/1578904744883.png" alt="1578904744883"></p>
<h4><span id="并发控制-concurrency-control">并发控制 Concurrency Control</span></h4><p><strong>并发控制：</strong> 所谓并发控制，是指多用户共享的系统中，许多用户可能同时对同一数据进行操作。</p>
<p><img src="/2020/01/13/事务与锁/1578904973251.png" alt="1578904973251"></p>
<p><img src="/2020/01/13/事务与锁/1578905068177.png" alt="1578905068177"></p>
<p><img src="/2020/01/13/事务与锁/1578905172492.png" alt="1578905172492"></p>
<p><img src="/2020/01/13/事务与锁/1578905192362.png" alt="1578905192362"></p>
<h5><span id="共享锁与排他锁或叫互斥锁">共享锁与排他锁（或叫互斥锁）</span></h5><p><img src="/2020/01/13/事务与锁/1578905290193.png" alt="1578905290193"></p>
<p><img src="/2020/01/13/事务与锁/1578905458095.png" alt="1578905458095"></p>
<h5><span id="两段锁协议two-phase-locking-2pl">两段锁协议（Two-Phase Locking —— 2PL）</span></h5><p><a href="https://www.jianshu.com/p/5c78f5c4d57b" target="_blank" rel="noopener">https://www.jianshu.com/p/5c78f5c4d57b</a></p>
<p>两段锁协议规定所有的事务应遵守的规则：</p>
<p>① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。</p>
<p>② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。</p>
<p>即事务的执行分为两个阶段：</p>
<p>第一阶段是获得封锁的阶段，称为扩展阶段。</p>
<p>第二阶段是释放封锁的阶段，称为收缩阶段。</p>
<p><em>若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。</em></p>
<p><img src="/2020/01/13/事务与锁/1578923170158.png" alt="1578923170158"></p>
<blockquote>
<p>简单的理解两段锁，就是分为两个阶段：<br>第一阶段 只能去申请锁<br>第二阶段 只能去释放锁</p>
</blockquote>
<p><a href="https://blog.csdn.net/weixin_38118016/article/details/90271468" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/90271468</a></p>
<p>举个例子，假设有一个表 t，主键是 id，其中一个字段是 k，在下面的操作中，事务 B 的 update 语句执行时，会是什么现象呢 ？</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203512941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这个问题的结论取决于事务 A 执行完前两条语句后，持有哪些锁，以及在什么时候释放。</p>
<p>实际上，事务 A 持有两个记录的行锁，都是在 commit 的时候才释放的，所以事务 B 的 update 就会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能被继续执行。也就是说，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，需要等事务结束时才释放，这就是两阶段锁协议，分为加锁阶段和解锁阶段，所有的 lock 操作都在 unlock 操作之后。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客 userA 要在影院 cinema 购买电影票，需要涉及以下操作：</p>
<ol>
<li><p>扣除顾客 userA 账户余额</p>
</li>
<li><p>增加影院 cinema 账户余额</p>
</li>
<li><p>记录一条交易日志</p>
</li>
</ol>
<p>也就是说，完成这次交易，需要 update 两条记录， insert 一条记录。当然为了保证交易的原子性，我们需要这三个操作放在一个事务中。与此同时，还有顾客 userB 也在影院购买电影票，那么你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>首先发现冲突的部分是语句 2，就是两个事务都要给 cinema 的账户余额增加电影票价。根据两阶段协议，不论怎么安排语句，所有的操作需要的行锁都是在事务提交的时候才释放的，要想使行锁在事务中不会停留太长时间，最大程度的减少事务之间的锁等待，应该把语句 2 放在最后面。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203204823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5><span id="死锁">死锁</span></h5><p>死锁：事务循环等待数据锁，则会死锁。<br>死锁处理：预防死锁协议，死锁恢复机制。</p>
<p><img src="/2020/01/13/事务与锁/1578905609640.png" alt="1578905609640"></p>
<p><a href="https://blog.csdn.net/weixin_38118016/article/details/90271468" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/90271468</a></p>
<p>如下图所示，事务 A 在等待事务 B 释放 id = 2 的行锁，而事务 B 在等待 事务 A 释放 id = 1 的行锁，事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203204496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在并发系统中，<strong>不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程进入无限等待的状态</strong>，成为死锁。</p>
<p>当进入死锁状态时，有下列 2 种策略：</p>
<ol>
<li><p>设置超时时间，第一个被锁住的事务 A 等待超过多少秒会超时退出（例如50s），其他事务得以执行。然而对于在线服务来说，这个等待时间往往是无法接受的。如果设置太短 (如1s)，可能有的事务只是简单的锁等待，就被退出了，会出现很多误伤。</p>
</li>
<li><p>发起死锁检测，发现死锁之后主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。比如回滚事务 A，让事务 B 继续执行。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>索引Index</title>
    <url>/2020/01/13/%E7%B4%A2%E5%BC%95Index/</url>
    <content><![CDATA[<p><img src="/2020/01/13/索引Index/1578902807233.png" alt="1578902807233"></p>
<p><img src="/2020/01/13/索引Index/1578902869016.png" alt="1578902869016"></p>
<p><code>Create UNIQUE INDEX index_name ON TableName(col_name);</code> //建索引</p>
<p><img src="/2020/01/13/索引Index/1578902891139.png" alt="1578902891139"></p>
<p><img src="/2020/01/13/索引Index/1578902910331.png" alt="1578902910331"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>视图View</title>
    <url>/2020/01/13/%E8%A7%86%E5%9B%BEView/</url>
    <content><![CDATA[<p><img src="/2020/01/13/视图View/1578902313361.png" alt="1578902313361"></p>
<p><img src="/2020/01/13/视图View/1578902382330.png" alt="1578902382330"></p>
<p><img src="/2020/01/13/视图View/1578902994931.png" alt="1578902994931"></p>
<p><img src="/2020/01/13/视图View/1578903023109.png" alt="1578903023109"></p>
<p><code>INSERT INTO Viewname {column1,column2,…} values(exp1,exp2,…);</code>//插入视图实际影响表</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive介绍</title>
    <url>/2020/01/12/Hive%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/PowerBlogger/article/details/83626449" target="_blank" rel="noopener">https://blog.csdn.net/PowerBlogger/article/details/83626449</a></p>
<p><a href="https://blog.csdn.net/u010886217/article/details/83796151" target="_blank" rel="noopener">https://blog.csdn.net/u010886217/article/details/83796151</a></p>
<!-- toc -->

<ul>
<li><a href="#什么是hive">什么是Hive？</a></li>
<li><a href="#hive的原理">Hive的原理</a></li>
<li><a href="#hive中表的类型">Hive中表的类型</a><ul>
<li><a href="#1-内部表">1. 内部表</a></li>
<li><a href="#2-外部表">2. 外部表</a></li>
<li><a href="#3-临时表">3. 临时表</a></li>
<li><a href="#4-分区表">4. 分区表</a></li>
<li><a href="#5-分桶表">5. 分桶表</a></li>
</ul>
</li>
</ul>
<!-- tocstop -->

<h3><span id="什么是hive">什么是Hive？</span></h3><p>Hive是建立在Hadoop上的，用来构建数据仓库的工具，里面有表的概念，可以使用SQL语句实现存储、查询和分析存储在 HDFS上的数据，这些SQL语句在Hive中称为HQL，语法和SQL语句基本一样。<br>由于数据是杂乱无章的，所以Hive需要一份关于这些数据的元数据来管理和操作这些数据。这份元数据包括：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">元数据（</span><br><span class="line">行的分隔符（在映射成表的时候知道在哪里分行显示）</span><br><span class="line">字段分隔符（在映射成表的时候知道在哪里分列显示）</span><br><span class="line">字段的类型</span><br><span class="line">字段的名称</span><br><span class="line">）</span><br></pre></td></tr></table></figure>

<p>在Hive中，我们把数据存储在HDFS中，元数据默认存储在Hive自带的Derby数据库中，由于Derby不能实现并发访问，所以我们一般使用mysql进行替换。</p>
<h3><span id="hive的原理">Hive的原理</span></h3><p><strong>Hive 将用户的 HQL 语句进行解析，优化，最终把一个个的HQL语句转换为 MapReduce 作业提交到 Hadoop 集群上，Hadoop进行作业的调度及监控，作业完成后将执行结果返回给用户。</strong>所以，<strong>Hive并不进行计算，只是把HQL解析为MapperReduce在HDFS集群中运行而已</strong>，所以Hive的效率并不高。</p>
<h3><span id="hive中表的类型">Hive中表的类型</span></h3><p>Hive中有5种表：内部表，外部表，临时表，分区表，桶表（分桶表）</p>
<h4><span id="1-内部表">1. 内部表</span></h4><p>数据默认存储在/user/hive/warehouse，由Hive自身管理，删除内部表会同时删除存储数据和元数据。</p>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">// 建表方式一</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">	    <span class="keyword">id</span>	<span class="built_in">INT</span>，</span><br><span class="line">	    <span class="keyword">name</span> <span class="keyword">STRING</span>，</span><br><span class="line">	    age <span class="built_in">INT</span>,</span><br><span class="line">		gfs <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,</span><br><span class="line">		address <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>,<span class="keyword">STRING</span>&gt;,</span><br><span class="line">		info <span class="keyword">STRUCT</span>&lt;country:<span class="keyword">String</span>,province:<span class="keyword">String</span>,shi:<span class="keyword">String</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">' '</span> </span><br><span class="line">COLLECTION ITEMS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></span><br><span class="line"><span class="keyword">MAP</span> <span class="keyword">KEYS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">':'</span> </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line">LOCATION <span class="string">"/test"</span>;//可以设置源数据的位置，若不设置默认就在Hive的工作目录区</span><br><span class="line"></span><br><span class="line">// 建表方式二</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> gfstbl1 <span class="keyword">like</span> gfstbl;只是创建表结构</span><br><span class="line"></span><br><span class="line">// 建表方式三</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> gfstbl2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gfs,address <span class="keyword">from</span> gfstbl; </span><br><span class="line">  会创建相应的表结构，并且插入数据，相当于完整的赋值</span><br></pre></td></tr></table></figure>

<p><strong>加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/gfs.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> gfstbl;</span><br></pre></td></tr></table></figure>

<p><strong>查看表描述信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> [<span class="keyword">EXTENDED</span>|FORMATTED] table_name</span><br><span class="line"><span class="keyword">EXTENDED</span> 极简的方式显示</span><br><span class="line">FORMATTED 格式化方式来显示</span><br><span class="line"><span class="keyword">DESCRIBE</span> <span class="keyword">EXTENDED</span> gfstbl;默认就是EXTENDED</span><br><span class="line"><span class="keyword">DESCRIBE</span> FORMATTED gfstbl;</span><br></pre></td></tr></table></figure>

<p><strong>插入数据的其他方式：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">插入数据的方式：</span><br><span class="line">	1、<span class="keyword">insert</span> 新数据</span><br><span class="line">	<span class="number">2</span>、<span class="keyword">load</span></span><br><span class="line">	<span class="number">3</span>、查询其他表数据 <span class="keyword">insert</span> 到新表中</span><br><span class="line">	模板：</span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...)] </span><br><span class="line">		select_statement1 <span class="keyword">FROM</span> from_statement;</span><br><span class="line">		</span><br><span class="line">		FROM from_statement</span><br><span class="line">		<span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...) </span><br><span class="line">		[<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] select_statement1</span><br><span class="line"></span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> rest <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="keyword">table</span>;</span><br><span class="line">		</span><br><span class="line">		习惯写法 from提前  减少SQL代码的冗余</span><br><span class="line">		from day_hour_table</span><br><span class="line">		<span class="keyword">insert</span> <span class="keyword">into</span> rest </span><br><span class="line">			<span class="keyword">select</span> <span class="keyword">count</span>(*) ;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4><span id="2-外部表">2. 外部表</span></h4><p>数据存储位置由用户自己指定，由HDFS管理，<strong>删除外部表时仅仅会删除元数据，存储数据不会受到影响。</strong></p>
<ul>
<li><p>适用情形：</p>
<p>当一份日志需要多个小组一起分析，分析完了之后创建的表就可以删除了。但是普通的表删除的同时也会把数据删除，这样就会影响到其他小组的分析，而且日志数据也不能随便删除。所以，需要外部表，删除外部表，不会删除对应的HDFS上的数据。</p>
</li>
<li><p>对比外部表和内部表区别<br>删除外部表，数据不会有任何改变，只是mysql中的元数据被修改，但是删除内部表（管理表），数据就会被删除。</p>
</li>
</ul>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> wc_external </span><br><span class="line">   (word1 <span class="keyword">STRING</span>, </span><br><span class="line">   word2 <span class="keyword">STRING</span>) </span><br><span class="line">   <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">' '</span> </span><br><span class="line">   location <span class="string">'/test/external'</span>; location可加可不加，不加location默认是在hive的工作目录区</span><br></pre></td></tr></table></figure>

<blockquote>
<p>总结：hive内部表和外部表的区别<br>    1）创建表时：创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径， 不对数据的位置做任何改变。<br>    2）删除表时：在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据。这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据</p>
</blockquote>
<h4><span id="3-临时表">3. 临时表</span></h4><p>在当前会话期间存在，会话结束后自动销毁。</p>
<ul>
<li><p>适用情形</p>
<p>临时分析，在关闭hive客户端后，临时表就会消失。主要用于存储不重要中间结果集，不重要的表。</p>
</li>
</ul>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TEMPORARY</span> <span class="keyword">table</span> ttabc(<span class="keyword">id</span> <span class="built_in">Int</span>,<span class="keyword">name</span> <span class="keyword">String</span>) 临时表的声明周期是一次会话</span><br><span class="line">进入hive shell 创建一张表，关闭shell后，表丢失，临时表不支持分区</span><br></pre></td></tr></table></figure>

<p><strong>建表并加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TEMPORARY</span> <span class="keyword">table</span> dept_tmp(  </span><br><span class="line">deptno <span class="built_in">int</span>,  </span><br><span class="line">dname <span class="keyword">string</span>,</span><br><span class="line">loc <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span>  <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/datas/dept.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> dept_tmp;</span><br></pre></td></tr></table></figure>

<p><strong>查看location信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc formatted dept_tmp;</span><br><span class="line">Location:               hdfs://172.19.199.187:8020/tmp/hive/hadoop/68174383-f427-4629-9707-0ab1c9b07726/_tmp_space.db/d872efec-1294-48b0-9071-31cf98d46400    </span><br><span class="line">Table Type:             MANAGED_TABLE</span><br></pre></td></tr></table></figure>

<h4><span id="4-分区表">4. 分区表</span></h4><p>将数据按照某个字段或者关键字分成多个子目录来存储，防止暴力扫描全表。</p>
<ul>
<li><p>适用情形</p>
<p>普通的表：select * from logs where date = ‘20171209’，执行流程：对全表的数据进行查询，然后才过滤操作。</p>
<p>分区表：select * from logs where date = ‘20171209’，执行流程：直接加载对应文件路径下的数据。</p>
<p>适用于大数据量，可以通过分区快速定位需要查询的数据，<strong>分区表的作用主要是提高查询检索的效率 。</strong></p>
</li>
</ul>
<p><strong>静态分区表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> day_hour_table (<span class="keyword">id</span> <span class="built_in">int</span>, <span class="keyword">content</span> <span class="keyword">string</span>) partitioned <span class="keyword">by</span> (dt <span class="built_in">int</span>,<span class="keyword">hour</span> <span class="built_in">int</span>) </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\t'</span> ;</span><br></pre></td></tr></table></figure>

<p><strong>加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- insert单条插入的方式往分区表中插入数据：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">9</span>,<span class="keyword">hour</span>=<span class="number">1</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">9</span>,<span class="keyword">hour</span>=<span class="number">2</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">8</span>,<span class="keyword">hour</span>=<span class="number">1</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">8</span>,<span class="keyword">hour</span>=<span class="number">2</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="comment">-- load批量插入的方式往分区表中插入数据：</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">"/root/ceshi"</span> <span class="keyword">into</span> <span class="keyword">table</span> day_table <span class="keyword">partition</span> (dt=<span class="number">10</span>,<span class="keyword">hour</span>=<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除Hive分区表中的分区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_table <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10</span>,<span class="keyword">hour</span>=<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>创建\添加分区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="keyword">PARTITION</span> partition_spec [LOCATION <span class="string">'location'</span>]</span><br><span class="line">[, <span class="keyword">PARTITION</span> partition_spec [LOCATION <span class="string">'location'</span>], ...];</span><br><span class="line"></span><br><span class="line">partition_spec:</span><br><span class="line">	  : (partition_column = partition_col_value, partition_column = partition_col_value, ...) </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建一个空分区：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_hour_table <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10000</span>, <span class="keyword">hour</span>=<span class="number">2000</span>);</span><br><span class="line"><span class="comment">-- 然后将数据上传到空分区对应的目录下，分区表中就会显示数据</span></span><br><span class="line">	HDFS dfs -put ........</span><br><span class="line"><span class="comment">-- 创建一个空分区并且将空分区指向数据位置：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_hour_table <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10000</span>, <span class="keyword">hour</span>=<span class="number">2000</span>) location <span class="string">"/test"</span></span><br></pre></td></tr></table></figure>

<p><strong>动态分区表：</strong></p>
<p>动态分区表和静态分区表建表语句相同，插入数据的方式不同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure>

<p>动态分区可以根据数据本身的特征自动来划分分区，load data …只是将数据上传到HDFS指定目录，所以我们需要使用from insert的方式插入数据，hive才会根据分区设置自动将数据进行分区。</p>
<h4><span id="5-分桶表">5. 分桶表</span></h4><p>将数据按照某个字段和桶的数量，对指定字段进行取模运算，拆分成多个小文件来存储，模相同的存储在同一个小文件中，提高join以及抽样的效率。</p>
<ul>
<li><p>适用情形</p>
<p>数据有严重的数据倾斜，分布不均匀，但是相对来说每个桶中的数据量会比较平均。桶与桶之间做join等查询的时候，会有优化。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_bu(  </span><br><span class="line">empno <span class="built_in">int</span>,  </span><br><span class="line">ename <span class="keyword">string</span>,</span><br><span class="line">job <span class="keyword">string</span>,  </span><br><span class="line">mgr <span class="built_in">int</span>,</span><br><span class="line">hiredate <span class="keyword">string</span>,  </span><br><span class="line">sal <span class="keyword">double</span>,  </span><br><span class="line">comm <span class="keyword">double</span>,  </span><br><span class="line">deptno <span class="built_in">int</span></span><br><span class="line">)CLUSTERED <span class="keyword">BY</span>(deptno) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span>  <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> emp_bu_2 <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>

<p>分桶表是对列值取哈希值的方式，将不同数据放到不同文件中存储<br>由列的哈希值除以桶的个数来决定每条数据划分在哪个桶中<br>对于hive中每一个表、分区都可以进一步进行分桶</p>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> psnbucket( <span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">STRING</span>, age <span class="built_in">INT</span>) </span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (age) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure>

<p><strong>插入数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> psnbucket <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age <span class="keyword">from</span> original;</span><br></pre></td></tr></table></figure>

<p><strong>分桶表+分区表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> psnbucket_partition( <span class="keyword">id</span> <span class="built_in">INT</span>, <span class="keyword">name</span> <span class="keyword">STRING</span>, age <span class="built_in">INT</span>) </span><br><span class="line">PARTITIONED <span class="keyword">BY</span>(height <span class="keyword">DOUBLE</span>) </span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (age) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试知识点</title>
    <url>/2020/01/12/%E7%AC%94%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#hbase">Hbase</a><ul>
<li><a href="#hfile">HFile</a></li>
</ul>
</li>
<li><a href="#sql面试题">SQL面试题</a></li>
</ul>
<!-- tocstop -->

<ul>
<li><p>时间序列模型中，哪一个模型可以较好的拟合波动性的分析和预测 (D)</p>
<p>A. AR模型</p>
<p>B. MA模型</p>
<p>C. ARMA模型</p>
<p>D. GARCH模型</p>
</li>
</ul>
<p>解析：</p>
<p>参考 <a href="https://blog.csdn.net/s1491695565/article/details/52093003" target="_blank" rel="noopener">https://blog.csdn.net/s1491695565/article/details/52093003</a></p>
<p>时间序列中常用预测技术  一个时间序列是一组对于某一变量连续时间点或连续时段上的观测值。</p>
<p><strong>1.  移动平均法 (MA)</strong></p>
<p>1.1. 简单移动平均法</p>
<p>设有一时间序列y1,y2,…, 则按数据点的顺序逐点推移求出N个数的平均数，即可得到一次移动平均数.</p>
<p> 1.2 趋势移动平均法  </p>
<p>当时间序列没有明显的趋势变动时，使用一次移动平均就能够准确地反映实际情况，直接用第t周期的一次移动平均数就可预测第t+1周期之值。</p>
<p>时间序列出现线性变动趋势时，用一次移动平均数来预测就会出现滞后偏差。修正的方法是在一次移动平均的基础上再做二次移动平均，利用移动平均滞后偏差的规律找出曲线的发展方向和发展趋势，然后才建立直线趋势的预测模型。故称为趋势移动平均法。</p>
<p><strong>2.  自回归模型(AR)</strong></p>
<p>AR模型是一种线性预测，即已知N个数据，可由模型推出第N点前面或后面的数据（设推出P点）.</p>
<p>本质类似于插值，其目的都是为了增加有效数据，只是AR模型是由N点递推，而插值是由两点（或少数几点）去推导多点，所以AR模型要比插值方法效果更好。</p>
<p><strong>3. 自回归滑动平均模型(ARMA)</strong></p>
<p>其建模思想可概括为：逐渐增加模型的阶数，拟合较高阶模型，直到再增加模型的阶数而剩余残差方差不再显著减小为止。</p>
<p><strong>4. GARCH模型</strong></p>
<p>回归模型。除去和普通回归模型相同的之处，GARCH对误差的方差进行了进一步的建模。特别适用于波动性的分析和预测。</p>
<p><strong>4. 指数平滑法</strong></p>
<p>移动平均法的预测值实质上是以前观测值的加权和，且对不同时期的数据给予相同的加权。这往往不符合实际情况。</p>
<p>指数平滑法则对移动平均法进行了改进和发展，其应用较为广泛。</p>
<p>基本思想都是：预测值是以前观测值的加权和，且对不同的数据给予不同的权，新数据给较大的权，旧数据给较小的权。</p>
<p>根据平滑次数不同，指数平滑法分为：一次指数平滑法、二次指数平滑法和三次指数平滑法等。</p>
<hr>
<ul>
<li><p>下面对集成学习模型中的弱学习者描述错误的是 (C)</p>
<p>A. 他们经常不会过拟合</p>
<p>B. 他们通常带有高偏差，所以其并不能解决复杂学习问题</p>
<p>C. 他们通常会过拟合</p>
</li>
</ul>
<p>弱学习器：略优于随机猜测的学习器。（西瓜书）</p>
<hr>
<ul>
<li><p>xgboost对缺失值的处理方法：</p>
<p>把缺失值分别放到左叶子节点和右叶子节点中，计算增益。哪个增益大就放到哪个叶子节点。</p>
</li>
</ul>
<hr>
<ul>
<li>Hive四大表类型：<ul>
<li>内部表</li>
<li>外部表</li>
<li>分区表</li>
<li>桶表（或叫分桶表）</li>
</ul>
</li>
</ul>
<hr>
<h4><span id="hbase">Hbase</span></h4><p>HBase是一个分布式的、面向列的开源数据库。</p>
<p>题目来源于：<a href="https://www.cnblogs.com/cxchanpin/p/7381890.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxchanpin/p/7381890.html</a></p>
<ul>
<li><p>HBase来源于哪篇博文？ C</p>
<p>A. The Google File System</p>
<p>B. MapReduce</p>
<p>C. BigTable</p>
<p>D. Chubby</p>
</li>
</ul>
<hr>
<ul>
<li><p>下对HBase的描写叙述哪些是正确的？ B、C、D</p>
<p>A. 不是开源的</p>
<p>B. 是面向列的</p>
<p>C. 是分布式的</p>
<p>D. 是一种NoSQL数据库</p>
</li>
</ul>
<a id="more"></a>

<hr>
<ul>
<li><p>HBase依靠（）存储底层数据 A</p>
<p>A. HDFS</p>
<p>B. Hadoop</p>
<p>C. Memory</p>
<p>D. MapReduce</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase依赖（）提供消息通信机制 A</p>
<p>A. Zookeeper</p>
<p>B. Chubby</p>
<p>C. RPC</p>
<p>D. Socket</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase依赖（）提供强大的计算能力 D</p>
<p>A. Zookeeper</p>
<p>B. Chubby</p>
<p>C. RPC</p>
<p>D. MapReduce</p>
</li>
</ul>
<hr>
<ul>
<li><p>MapReduce与HBase的关系，哪些描写叙述是正确的？ B、C</p>
<p>A. 两者不可或缺。MapReduce是HBase能够正常执行的保证</p>
<p>B. 两者不是强关联关系，没有MapReduce，HBase能够正常执行</p>
<p>C. MapReduce能够直接訪问HBase</p>
<p>D. 它们之间没有不论什么关系</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下哪些选项正确描写叙述了HBase的特性？ A、B、C、D</p>
<p>A. 高可靠性</p>
<p>B. 高性能</p>
<p>C. 面向列</p>
<p>D. 可伸缩</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下与Zookeeper类似的框架是？D</p>
<p>A. Protobuf</p>
<p>B. Java</p>
<p>C. Kafka </p>
<p>D. Chubby</p>
</li>
</ul>
<p>Kafka是一个高吞吐量分布式消息系统。kafka的数据仅仅会顺序append。数据的删除策略是累积到一定程度或者超过一定时间再删除。Kafka还有一个独特的地方是将消费者信息保存在client而不是MQserver。这样server就不用记录消息的投递过程，每一个client都自己知道自己下一次应该从什么地方什么位置读取消息。消息的投递过程也是采用client主动pull的模型，这样大大减轻了server的负担。Kafka还强调降低数据的序列化和拷贝开销，它会将一些消息组织成Message Set做批量存储和发送，而且client在pull数据的时候，尽量以zero-copy的方式传输。利用sendfile（相应java里的 FileChannel.transferTo/transferFrom）这种高级IO函数来降低拷贝开销。可见，kafka是一个精心设计，特定于某些应用的MQ系统，这种偏向特定领域的MQ系统我预计会越来越多，垂直化的产品策略值的考虑。</p>
<p>Chubby首先是一个分布式的文件系统。Chubby可以提供机制使得client可以在Chubby service上创建文件和运行一些文件的基本操作。说它是分布式的文件系统，是由于一个Chubby cell是一个分布式的系统。一般包括了5台机器，整个文件系统是部署在这5台机器上的。</p>
<p>从更高一点的语义层面上，Chubby是一个 lock service。一个针对松耦合的分布式系统的lock service。所谓lock service，就是这个service可以提供开发者经经常使用的“锁”，“解锁”功能。通过Chubby，一个分布式系统中的上千个client都可以 对于某项资源进行“加锁”，“解锁”。</p>
<p>那么，Chubby是如何实现这种“锁”功能的？就是通过文件。Chubby中的“锁”就是文件。在上例中，创建文件事实上就是进行“加锁”操作，创建文件成功的那个server事实上就是抢占到了“锁”。用户通过打开、关闭和读取文件。获取共享锁或者独占锁； 而且通过通信机制，向用户发送更新信息。</p>
<p>综上所述。Chubby是一个lock service。通过这个lock service能够解决分布式中的一致性问题。而这个lock service的实现是一个分布式的文件系统。</p>
<hr>
<ul>
<li><p>以下与HDFS类似的框架是？C</p>
<p>A. NTFS</p>
<p>B. FAT32</p>
<p>C. GFS (也是分布式文件系统，谷歌自己的分布式文件系统)</p>
<p>D. EXT3</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下哪些概念是HBase框架中使用的？A、C</p>
<p>A. HDFS</p>
<p>B. GridFS</p>
<p>C. Zookeeper</p>
<p>D. EXT3</p>
</li>
</ul>
<hr>
<h5><span id="hfile">HFile</span></h5><p><span style="color:red">HFile是HBase存储数据的文件组织形式</span></p>
<ul>
<li><p>HFile数据格式中的Data字段用于（）。A</p>
<p>A. 存储实际的KeyValue数据</p>
<p>B. 存储数据的起点</p>
<p>C. 指定字段的长度</p>
<p>D. 存储数据块的起点</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的MetaIndex字段用于（）。D</p>
<p>A. Meta块的长度</p>
<p>B. Meta块的结束点</p>
<p>C. Meta块数据内容</p>
<p>D. Meta块的起始点</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的Magic字段用于（）。A</p>
<p>A. 存储随机数，防止数据损坏</p>
<p>B. 存储数据的起点</p>
<p>C. 存储数据块的起点</p>
<p>D. 指定字段的长度</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的KeyValue数据格式，下列选项描写叙述正确的是（）。A、D</p>
<p>A. 是byte[]数组</p>
<p>B. 没有固定的结构</p>
<p>C. 数据的大小是定长的</p>
<p>D. 有固定的结构</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的KeyValue数据格式中Value部分是（）。C</p>
<p>A. 拥有复杂结构的字符串</p>
<p>B. 字符串</p>
<p>C. 二进制数据</p>
<p>D. 压缩数据</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase中的批量载入底层使用（）实现。A</p>
<p>A. MapReduce</p>
<p>B. Hive</p>
<p>C. Coprocessor</p>
<p>D. Bloom Filter</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase性能优化包括以下的哪些选项？A、B、C、D</p>
<p>A. 读优化</p>
<p>B. 写优化</p>
<p>C. 配置优化</p>
<p>D. JVM优化</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase构建二级索引的实现方式有哪些？ A、B</p>
<p>A. MapReduce</p>
<p>B. Coprocessor</p>
<p>(HBase在0.92之后引入了协处理器(coprocessors)，实现一些激动人心的新特性：可以轻易建立二次索引、复杂过滤器(谓词下推)以及訪问控制等)</p>
<p>C. Bloom Filter</p>
<p>D. Filter</p>
</li>
</ul>
<hr>
<ul>
<li><p>关于HBase二级索引的描写叙述。哪些是正确的？A、B</p>
<p>A. 核心是倒排表</p>
<p>B. 二级索引概念是相应Rowkey这个“一级”索引</p>
<p>C. 二级索引使用平衡二叉树</p>
<p>D. 二级索引使用LSM结构</p>
</li>
</ul>
<hr>
<ul>
<li><p>下列关于Bloom Filter的描写叙述正确的是？A、C</p>
<p>A. 是一个非常长的二进制向量和一系列随机映射函数</p>
<p>B. 没有误算率</p>
<p>C. 有一定的误算率</p>
<p>D. 能够在Bloom Filter中删除元素</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase官方版本号能够安装在什么操作系统上？A、B、C</p>
<p>A. CentOS</p>
<p>B. Ubuntu</p>
<p>C. RedHat</p>
<p>D. Windows</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase虚拟分布式模式须要（）个节点？A</p>
<p>A. 1</p>
<p>B. 2</p>
<p>C. 3</p>
<p>D. 最少3个</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase分布式模式最好须要（）个节点？C</p>
<p>A. 1</p>
<p>B. 2</p>
<p>C. 3</p>
</li>
</ul>
<hr>
<ul>
<li><p>下列哪些选项是安装HBase前所必须安装的？A、B</p>
<p>A. 操作系统</p>
<p>B. JDK</p>
<p>C. Shell Script</p>
<p>D. Java Code</p>
</li>
</ul>
<hr>
<ul>
<li><p>解压.tar.gz结尾的HBase压缩包使用的Linux命令是？A</p>
<p>A. tar -zxvf</p>
<p>B. tar -zx</p>
<p>C. tar -s</p>
<p>D. tar -nf</p>
</li>
</ul>
<hr>
<ul>
<li>从Hadoop 2.7.3 版本开始，HDFS中Block size 的默认大小为128MB.</li>
</ul>
<hr>
<h4><span id="sql面试题">SQL面试题</span></h4><p><a href="https://www.cnblogs.com/huolong-blog/p/7603454.html" target="_blank" rel="noopener">https://www.cnblogs.com/huolong-blog/p/7603454.html</a></p>
<ul>
<li><p>触发器的作用？</p>
<p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么是存储过程？用什么来调用？</p>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。</p>
</li>
</ul>
<hr>
<ul>
<li><p>索引的作用？和它的优点缺点是什么？</p>
<p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么是事务？什么是锁？</p>
<p>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就失败，以后操作就会回滚到操作前状态，或者是上个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。</p>
<p>锁：在所有的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么叫视图？游标是什么？</p>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。游标用于定位结果集的行。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语言</title>
    <url>/2020/01/12/sql%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<!-- toc -->

<ul>
<li><a href="#ddl与dml">DDL与DML</a><ul>
<li><a href="#insert">INSERT</a></li>
<li><a href="#delete">DELETE</a></li>
<li><a href="#update">UPDATE</a></li>
<li><a href="#create">CREATE</a></li>
<li><a href="#drop">DROP</a></li>
<li><a href="#alter">ALTER</a></li>
<li><a href="#rename">RENAME</a></li>
</ul>
</li>
<li><a href="#语法顺序与执行顺序">语法顺序与执行顺序</a></li>
</ul>
<!-- tocstop -->

<h3><span id="ddl与dml">DDL与DML</span></h3><p>DDL: maintaining structure of database. (CREATE, DROP, ALTER, RENAME)</p>
<p>DML: maintaining contents of database. (SELECT, INSERT, DELETE, UPDATE)</p>
<p><img src="/2020/01/12/sql语言/1578825616684.png" alt="1578825616684"></p>
<a id="more"></a>

<h5><span id="insert">INSERT</span></h5><p><img src="/2020/01/12/sql语言/1578900159995.png" alt="1578900159995"></p>
<blockquote>
<p>注：字符为单引号</p>
</blockquote>
<p><code>INSERT INTO tablename {column1,column2,…}values(exp1,exp2,…);</code>  //插入</p>
<h5><span id="delete">DELETE</span></h5><p><img src="/2020/01/12/sql语言/1578900315795.png" alt="1578900315795"></p>
<h5><span id="update">UPDATE</span></h5><p><img src="/2020/01/12/sql语言/1578900364614.png" alt="1578900364614"></p>
<h5><span id="create">CREATE</span></h5><p><img src="/2020/01/12/sql语言/1578899962419.png" alt="1578899962419"></p>
<p><strong>CREATE的时候，先CREATE没有外键的表，最后CREATE右外键的表</strong></p>
<h5><span id="drop">DROP</span></h5><p><img src="/2020/01/12/sql语言/1578900950689.png" alt="1578900950689"></p>
<p><strong>DROP的时候，先DROP有外键的表，最后DROP没有外键的表</strong></p>
<h5><span id="alter">ALTER</span></h5><p>例如增加一列</p>
<p><img src="/2020/01/12/sql语言/1578901179360.png" alt="1578901179360"></p>
<h5><span id="rename">RENAME</span></h5><p><img src="/2020/01/12/sql语言/1578901685944.png" alt="1578901685944"></p>
<h3><span id="语法顺序与执行顺序">语法顺序与执行顺序</span></h3><p><img src="/2020/01/12/sql语言/1578825674160.png" alt="1578825674160"></p>
<p><img src="/2020/01/12/sql语言/1578825736061.png" alt="1578825736061"></p>
<p>相当于就是 SELECT [DISTINCT] 的顺序换了一下。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语句中的drop, truncate, delete</title>
    <url>/2020/01/12/sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84drop-truncate-delete/</url>
    <content><![CDATA[<p>参考：</p>
<p><a href="https://blog.csdn.net/lovezhaohaimig/article/details/80184994" target="_blank" rel="noopener">https://blog.csdn.net/lovezhaohaimig/article/details/80184994</a></p>
<p><a href="https://www.cnblogs.com/xianyao/p/11613021.html" target="_blank" rel="noopener">https://www.cnblogs.com/xianyao/p/11613021.html</a></p>
<ol>
<li><code>drop table 表名称</code></li>
</ol>
<p>作用：删除内容和定义，释放空间。简单来说就是把整个表去掉.以后要新增数据是不可能的,除非新增一个表。</p>
<p>把表的结构也删除了 下次要使用的时候要重新创建表的结构再插入数据。</p>
<p><strong>即删除表内容及表结构（或表定义）</strong>。</p>
<p><strong>不能回滚</strong></p>
<ol start="2">
<li><code>truncate table 表名称</code></li>
</ol>
<p>作用：删除内容、释放空间但不删除定义。与drop不同的是,他只是清空表数据而已,不删除表结构。</p>
<p>truncate table test 后，向test表添加数据，id标识列连续了(体现了truncate删除是释放空间）</p>
<p>插入的字段的id重新从1开始递增 1、2、3…..<br><strong>即删除表内容，不删除表结构</strong>。</p>
<p><strong>in MySQL, resets auto_increment PKs</strong></p>
<p><strong>不能回滚</strong></p>
<ol start="3">
<li><code>delete from 表名称 where 列名称 = 值</code></li>
</ol>
<p>作用：删除整表中的行，表结构不会删除。</p>
<p>删除内容不删除定义，不释放空间。</p>
<p>用delete删除数据，然后添加。可以看到添加之后id标识不连续。（说明delete删除不释放空间）</p>
<p>如果重新插入数据时对应的id在上次基础之上递增 4、5、6….</p>
<p>delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存,以便进行回滚操作。</p>
<p><strong>即不带where的delete: 删除表内容，不删除表结构</strong></p>
<p><strong>可回滚</strong></p>
<ul>
<li><p>执行速度，一般来说: drop&gt; truncate &gt; delete。</p>
</li>
<li><p>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segment中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。</p>
</li>
<li><p>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/01/12/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和（难度：简单）</a></p>
<p><img src="/2020/01/12/两数之和/1578808347100.png" alt="1578808347100"></p>
<h4><span id="方法一暴力法">方法一：暴力法</span></h4><p>遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。\</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h4><span id="方法二两遍哈希表">方法二：两遍哈希表</span></h4><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。<strong>哈希表正是为此目的而构建的，它支持以 近似恒定的时间进行快速查找</strong>。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p>
<p><strong>使用两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</strong>注意，该目标元素不能是 nums[i]本身！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)，遍历两次，由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量。</p>
<hr>
<h4><span id="方法三一遍哈希表">方法三：一遍哈希表</span></h4><p>在进行迭代并将元素插入到表中的同时，回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)，只遍历一次。</p>
<p>空间复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续递增序列</title>
    <url>/2020/01/12/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">最长连续递增序列（难度：简单）</a></p>
<p><img src="/2020/01/12/最长连续递增序列/1578807734778.png" alt="1578807734778"></p>
<p><img src="/2020/01/12/最长连续递增序列/1578807775519.png" alt="1578807775519"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                max = Math.max(max,count);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/12/最长连续递增序列/1578807884555.png" alt="1578807884555"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/01/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p><img src="/2020/01/10/排序算法/1578640411160.png" alt="1578640411160"></p>
<p>排序算法的稳定性，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Factorization Methods</title>
    <url>/2020/01/09/Matrix-Factorization-Methods/</url>
    <content><![CDATA[<p>Collaborative Filtering has been criticized as having limited scalability, since computing similarity matrices on very large sets of items or users can take a lot of computing horsepower. I don’t really buy this, however. Technologies such as Apache Spark allow you to distribute the construction of this matrix across a cluster if you need to. *<em>A legitimate problem with collaborative filtering is that it’s sensitive to noisy data and sparse data. You’ll only get really good results if you have a large data set to work with that’s nice and clean. *</em></p>
<p>接下来介绍一些<strong>Model-based methods</strong>. Instead of 寻找相似的物品或相似的用户, we apply data science and machine learning techniques to extract predictions from our ratings data.</p>
<p><img src="/2020/01/09/Matrix-Factorization-Methods/1578547347570.png" alt="1578547347570"></p>
<p>There are a wide variety of techniques that fall under the category of matrix factorization. They managed to find broader features of users and items on their own, like action movies or romantic. They are described by matrices. The general idea is to describe users and movies as combinations of different amounts of each feature. For example, Bob is defined as being 80% an action fan and 20% a comedy fan. We’d then know to match him up with movies that are blend about 80% action and 20% comedy. </p>
<p><img src="/2020/01/09/Matrix-Factorization-Methods/1578559424817.png" alt="1578559424817"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Neighborhood-Based Collaborative Filtering</title>
    <url>/2020/01/07/Neighborhood-Based-Collaborative-Filtering/</url>
    <content><![CDATA[<p>This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean finding other things similar to the thing that you like. </p>
<p>That’s why we call it collaborative filtering. It’s recommending stuff based on other people’s collaborative behavior. </p>
<p>The heart of neighborhood-based collaborative filtering is the ability to find people similar to you, or items similar to items you’ve liked.</p>
<h3><span id="measuring-similarity-and-sparsity">Measuring Similarity, and Sparsity</span></h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372382962.png" alt="1578372382962"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372454415.png" alt="1578372454415"></p>
<p>这里的余弦相似度和前面content-based中的余弦相似度的区别在于：Our dimensions would be things like his: Did this user like this thing? Or was this thing liked by this user? So every user or every thing might constitute its own dimension, and the dimensions are based on user behavior instead of content attributes.</p>
<p>The big challenge in measuring these similarities based on behavior data is the <strong>sparsity</strong> of the data we’re working with. This means that it’s tough for collaborative filtering to work well unless you have a lot of user behavior data to work with. You can’t compute a meaningful cosine similarity between two people when they have nothing in common, or between two items when they have no people in common. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578373973291.png" alt="1578373973291"></p>
<p>This is why collaborative filtering works well for big companies like Amazon and Netflix. They have millions of users and so they have enough data to generate meaningful relations in spite of the data sparsity. </p>
<p>Sparsity also introduces some computational challenges. You don’t want to waste time storing and processing all of that missing data, so under the hood we end up using structures like <strong>sparse arrays</strong> that avoid storing all that empty spaces in this matrix. </p>
<h3><span id="similarity-metrics">Similarity Metrics</span></h3><h4><span id="adjusted-cosine">Adjusted Cosine</span></h4><p>It’s applicable mostly to measuring the similarity between users based on their ratings. It’s based on the idea that different people might have different baselines. What Bob considers a three star movie, maybe different from what Alice considers a three star movie. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578374644148.png" alt="1578374644148"></p>
<p>Adjusted cosine attempts to normalize these differences. Instead of measuring similarities between people based on their raw rating values, we instead measure similarities based on the difference between a user’s rating for an item and their average rating for all items. </p>
<p>Now this sounds good on paper, but in practice, data sparsity can really mess you up here. You can only get a meaningful average, or a baseline of an individual’s ratings if they have rated a lot of stuff for you to take the average of in the first place. 若有许多用户只评价了一部电影，then that data will be totally wasted with the adjusted cosine metric. 不管他们评了多少分，the difference between it and that user’s mean will be zero at that point. </p>
<p>So, adjusted cosine might be worth experimenting with, but only if you know that most of your users have rated a lot of stuff implicitly or explicitly. And if you have that much data to begin with, these differences between individuals will start to work themselves out anyway. So, you’re not likely to see as much of a difference as you might expect when using adjusted cosine. </p>
<h4><span id="item-based-pearson-similarity">(item-based) pearson similarity</span></h4><p>与adjusted cosine的区别在于, we look at the difference between rating and the average from all users for that given item.  </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376440604.png" alt="1578376440604"></p>
<p>You can think of pearson similarity as measuring the similarity between people by how much they diverge from the average person’s behavior. 例如，假设大多数人都喜欢Star Wars, people who hate Star Wars are going to get a very strong similarity score from pearson similarity, because they share opinions that are not mainstream.</p>
<p>Note that the only difference between this and adjusted cosine is whether we’re talking about users or items. 这门课使用的suprise library, refers to adjusted cosine as user-based pearson similarity, because it’s basically the same thing.</p>
<h4><span id="spearman-rank-correlation">spearman rank correlation</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376851254.png" alt="1578376851254"></p>
<ul>
<li>Instead of using an average rating value for a movie, 我们使用 its rank amongst all movies based on their average rating. </li>
<li>Instead of individual ratings for a movie, we’d rank that movie amongst all that individual’s ratings. </li>
</ul>
<p>Spearman的主要优势在于 it can deal with ordinal data effectively. 例如，if you had a rating scale, where the difference in meaning between different rating values were not the same. I’ve never seen this actually used in real world applications, but you may encounter it in the academic literature.</p>
<h4><span id="mean-squared-difference">mean squared difference</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578377776225.png" alt="1578377776225"></p>
<p>另一方面，我们可以将它应用到item上：x和y指两个不同的item, and then we’d be looking at the differences in ratings from the people these items have in common (所有评价过这两个item的人对这两个item评分的差异).</p>
<p>There are two ways of doing collaborative filtering, item based and user based, and it’s important to remember that most of these similarity metrics can apply to either approach. </p>
<p>MSD 要比余弦相似度更好理解， 但 in practice, 你通常会发现cosine works better.</p>
<h4><span id="jaccard-similarity">jaccard similarity</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385168727.png" alt="1578385168727"></p>
<p>jaccard similarity 没有使用实际的rating vlaue. If you are dealing with implicit ratings, for example, just the fact that somebody watched something, in this case, Jaccard can be a reasonable choice that’s very fast to compute. </p>
<h4><span id="recap">Recap</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385386398.png" alt="1578385386398"></p>
<ul>
<li>Cosine similarity is almost always a reasonable thing to start with.</li>
<li>Adjust cosine and Pearson are two different terms for basically the same thing. It’s mean centered cosine similarities. The idea is to deal with unusual rating behavior that deviates from the mean, but in practice, it can sometimes do more harm than good.</li>
<li>Spearman ranking correlation is the same idea as Pearson, using ranking instead of raw ratings, and it’s not something you are likely to be using in practice.</li>
<li>MSD is mean squared difference, which is just an easier similarity metric to warp your head around than cosine similarity, but in practice, it usually doesn’t perform better.</li>
<li>Jaccard similarity is just looking at how many items two users have in common, or how many users two items have in common, divided by how many items or users they have between both of them. It’s really simple and well suited to implicit ratings, like binary actions, like purchasing or view something. But you can also apply cosine similarities to implicit ratings too.</li>
<li>So, and the end of the day, cosine similarity remains my default go to similarity metric. </li>
</ul>
<h3><span id="user-based-collaborative-filtering">User-based Collaborative Filtering</span></h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386125836.png" alt="1578386125836"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386158223.png" alt="1578386158223"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455133171.png" alt="1578455133171"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455288882.png" alt="1578455288882"></p>
<ul>
<li>每个人和自己的余弦相似度是1</li>
<li>Bob 和 Ted的余弦相似度是0，因为他们没有评价过相同的电影</li>
<li>矩阵的上三角部分和下三角部分是对称的</li>
<li>对于 Bob 和 Ann, 虽然他们评价过不同的电影，当我们考虑相似度时，我们只看他们共同评价过的电影。在这个例子中，他们共同评价过的电影只有一部，并且评分都为5，所以他们的相似度得分为1 (100%)。</li>
</ul>
<blockquote>
<p>注：两个用户的相似度为100%并不一定代表他们喜欢相同的东西，也可以代表他们都讨厌相同的东西（例如，若 Bob 和 Ann 都给Star Wars打1分，他们仍然是100% similar）。事实上，the math behind cosine similarity works out such that *<em>if you only have one movie in common, you end up with 100% similarity no matter what. *</em>Even if Bob loved Star Wars and Ann hated it, in a sparse data situation, they both end up 100% similar. Sparse data is a huge problem with collaborative filtering, and it can lead to weird results. And sometimes, you need to enforce a minimum threshold on how many movies users have in common before you consider them at all.</p>
</blockquote>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578456962753.png" alt="1578456962753"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457107702.png" alt="1578457107702"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457502291.png" alt="1578457502291"></p>
<p>除了normalizing, 还可以例如将评分为1、2的转换成negative score, 方法不唯一，没有标准的方法，可通过试验看 what works best for the data you have.</p>
<p>应该adding in the score for a given movie if we encounter it more than once.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457620591.png" alt="1578457620591"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457759908.png" alt="1578457759908"></p>
<h4><span id="recap">Recap</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457999015.png" alt="1578457999015"></p>
<h4><span id="user-based-collaborative-filtering-hands-on">User-based Collaborative Filtering, Hands-On</span></h4><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleUserCF.py</p>
<h3><span id="item-based-collaborative-filtering">Item-based Collaborative Filtering</span></h3><p>Look at the things you liked, and recommend stuff that’s similar to those things. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458842316.png" alt="1578458842316"></p>
<p>一些原因为什么使用物品之间的相似度可能比使用用户之间的相似度更好：</p>
<ul>
<li>Items tend to be of a more permanent nature than people. An individual’s test may change very quickly over the span of their lives. Your math book will always be similar to other math books. As such, you can get away with computing an item similarity matrix less often than user similarities, because it won’t change very quickly.</li>
<li>You usually have far fewer items to deal with than people. There are way more people than there are things to recommend to them in most cases. 即物品相似度矩阵会比用户相似度矩阵会小很多，这样不仅 make it simpler to store that matrix, it makes faster to compute as well. And when you’re dealing with massive systems like Amazon and Netflix, computational efficiency is very important. Not only does it require fewer resources, it means you can regenerate your similarities between items more often, making your system more responsive when new items are introduced.</li>
<li>使用 item similarities also makes for a better experience for new users. 一个新用户只要表现出了对某个物品的兴趣，你可以推荐与那个物品相似的物品给该用户，而使用基于用户的协同过滤，you wouldn’t have any recommendations for a new user at all until they make it into the next build of your user similarity matrix.</li>
</ul>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463648320.png" alt="1578463648320"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463881122.png" alt="1578463881122"></p>
<p>在这个例子中，所有的相似度都为0或1，是因为数据量比较小。In the real world, you’d see more interesting and meaningful numbers here.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578464579773.png" alt="1578464579773"></p>
<h4><span id="item-based-collaborative-filtering-hands-on">Item-based Collaborative Filtering, Hands-On</span></h4><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleItemCF.py</p>
<p>Item-based collaborative filtering is what Amazon used with outstanding success.</p>
<p>You need to test it out on several real people if possible, and then move to a large scale A/B test to see if this algorithm really is better or worse than whatever you might have today.</p>
<h3><span id="exercise">Exercise</span></h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468263883.png" alt="1578468263883"></p>
<p>我们之前是选取的top-n，例如item-based: 选择用户评价前10的电影，再找similar items；user-based: 选择与用户相似度排前10的用户，再…</p>
<p>Maybe it would be better if instead of taking the top k sources for recommendation candidates, we just use any source above some given quality threshold. 例如，用户评价4星以上的电影 should generate item-based recommendation candidates, no matter how many or how few of them there may be.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468513742.png" alt="1578468513742"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468541742.png" alt="1578468541742"></p>
<p>可以发现一个小的改变可以使得结果很不一样。Often, you don’t just want to test different recommendation algorithms, you want to test different variations and parameters on those algorithms. In this case, I not only want to test the idea of using a threshold instead of a top k approach, I’d also want to test many different threshold values to find the best one. In the real world, you’ll find that your biggest problem is just not having enough time to run all of the different experiments you want to run to make your recommendations  better. </p>
<h3><span id="evaluating-collaborative-filtering-systems-offline">Evaluating Collaborative Filtering Systems Offline</span></h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469111053.png" alt="1578469111053"></p>
<p>Now, although <strong>we can’t measure accuracy with user based or item based collaborative filtering, because they don’t making rating predictions</strong>, we can still measure hit rate, because it is still a top-N recommender.</p>
<h4><span id="code-walkthrough">code walkthrough</span></h4><p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行EvaluateUserCF.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469413099.png" alt="1578469413099"></p>
<p>That was surprisingly fast. One really nice property of collaborative filtering is how quickly it can generate recommendations for any given individual, once we’ve built up the similarity matrix.</p>
<p>结果5.5% is pretty good.</p>
<h4><span id="exercise">Exercise</span></h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469688733.png" alt="1578469688733"></p>
<p>与EvaluateUserCF.py相比需要改变的地方：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578470341309.png" alt="1578470341309"></p>
<p>item-based的hit rate只有0.5%，相比user-based的5.5%，要差一点。</p>
<p>Item-based should be a superior approach, and that’s been proven in industry. 这里item-based要差一点应该是数据的原因。而且这只是offline evaluation. If we were to test both algorithms on real-world people using real-world data in an A/B test, the results could end up being very different.</p>
<h3><span id="knn-recommenders">KNN Recommenders</span></h3><p>The concept of collaborative filtering has been applied to recommender systems that do make rating predictions, and these are generally referred to in the literature as KNN recommenders.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578471356190.png" alt="1578471356190"></p>
<p>In this sort of system, we generate recommendation candidates by predicting the ratings of everything a user hasn’t already rated, and selecting the top k items with the highest predicted ratings. This obviously isn’t a terribly efficient approach, but since we’re predicting rating values, we can measure the offline accuracy of the system using train/test or cross-validation, which is useful in the research world.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578478326957.png" alt="1578478326957"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479201990.png" alt="1578479201990"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479315924.png" alt="1578479315924"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479574982.png" alt="1578479574982"></p>
<h4><span id="running-user-and-item-based-knn-on-movielens">Running User and Item-based KNN on MovieLens</span></h4><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行KNNBakeOff.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479972763.png" alt="1578479972763"></p>
<p>如果只看accuracy, KNN recommendation看上去是一个好方法，但是如果看 top-n recommendations, item-based和user-based推荐的都是些没听说过的电影 (obscure)，反而 random recommendation looks a lot better from a subjective standpoint.</p>
<p>So, on the surface, it looks like we may have made a system that’s pretty good at predicting ratings of movies people have already seen, but might not be very good at producing top-n recommendations.</p>
<h4><span id="exercise">Exercise</span></h4><p>Experiment with different KNN parameters.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480409983.png" alt="1578480409983"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480533805.png" alt="1578480533805"></p>
<p>虽然msd比cosine的RMSE要低一点，但它们推荐的内容是一样的</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480727372.png" alt="1578480727372"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480843642.png" alt="1578480843642"></p>
<p>Well, it’s actually pretty well known that KNN doesn’t work well in practice. Unfortunately, some people conclude that collaborative filtering in general is some naive approach that should be replaced with completely different techniques. But as we’ve seen, collaborative filtering isn’t the problem, it’s forcing collaborative filtering to make rating predictions – that’s the problem. We had some pretty exciting results when we just focused on making top-N recommendations, and completely forgot about optimizing for rating accuracy, and it turns out that’s what at the heart of the problem. <strong>使用user-based CF和item-based CF,   top-N 推荐结果都是不错的。</strong></p>
<p>Ratings are not continuous in nature, and KNN treats them as though they are continuous values that can be predicted on a continuous scale. If you really want to go with KNN, it would be more appropriate to treat it as a rating classification problem than as a rating prediction problem. KNN is also very sensitive to sparse data.</p>
<p>The most fundamental thing is that accuracy isn’t everything. The main reason KNN produces underwhelming results is because it’s trying to solve the wrong problem. <strong>KNN recommender之所以推荐结果不好，是因为它解决的是rating prediction的问题，而不是推荐问题</strong>。</p>
<h3><span id="bleeding-edge-alert">Bleeding Edge Alert</span></h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491595381.png" alt="1578491595381"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491659157.png" alt="1578491659157"></p>
<p>The idea behind it is that users are modeled as vectors moving from one item to another in a multidimensional space. And you can predict sequences of events, like which movie a user is likely to watch next, by modeling these vectors.</p>
<p>The reason this paper is exciting is because it outperformed all of the best existing methods for recommending sequences of events in all but one case in one data set.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491938065.png" alt="1578491938065"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578492119528.png" alt="1578492119528"></p>
<p>Basic idea: You position individual items, like movies, in a transition space, where neighborhoods within this   space represent similarity between items. So items close together in this space are similar to each other. The dimensions corresponds to complex transition relationships between items. Since this technique depends on arranging items together into local, similar neighborhoods, I still classify it as a neighborhood -based method. </p>
<p>In this space, we can learn the vectors associated with individual users. Maybe a user who watches a Tom Cruise movie, is likely to move along to the next Tom Cruise movie, for example, and that transition would be represented by a vector in this space. We can then predict the next movie a user is like to watch by extrapolating along the vector we’ve associated with that user.</p>
<p>The paper provide the code in C++.</p>
<p>It’s all very advanced stuff, but it seems to work. So if you find yourself in the situation where you need to predict a sequence of events, like which movies or videos a person is likely to watch next given theirs past history, you might wanna do a search for translation-based recommendations and how it’s coming along in the real world.</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Content-Based Filtering</title>
    <url>/2020/01/06/Content-Based-Filtering/</url>
    <content><![CDATA[<p>Recommending items just based on the attributes of those items, instead of trying to use aggregate user behavior data.</p>
<h3><span id="cosine-similarity">Cosine Similarity</span></h3><p><img src="/2020/01/06/Content-Based-Filtering/1578288453177.png" alt="1578288453177"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578288708324.png" alt="1578288708324"></p>
<p>为简单起见，假设电影只有两种类型：adventure和comedy. 一部电影若属于某种类型则为1，若不属于则为0.</p>
<p>角度 θ 一定程度上刻画了它们之间的相似度。我们想要将相似度刻画成[0,1]范围内的数，zero means not at all similar, and one means totally the same thing. 而 θ 的余弦值正好可以达到这个目的：θ 为90度，余弦值为0；θ 为0度，余弦值为1.  </p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289233556.png" alt="1578289233556"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289272295.png" alt="1578289272295"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289294315.png" alt="1578289294315"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289387292.png" alt="1578289387292"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289605079.png" alt="1578289605079"></p>
<p>How do we assign a similarity score based on release years alone?</p>
<p>This is where some of the art of recommender systems comes in. You have to think about the nature of the data you have and what makes sense.</p>
<p>How far apart would two movies have to be for their release date alone to signify they are substantially different? A decade seems like a reasonable starting point. </p>
<p>Now we need to come up with some sort of mathematical function that smoothly scales that into the range zero to one. -&gt; 可选择指数衰减函数。</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578291075846.png" alt="1578291075846"></p>
<p>The choice of this function is completely arbitrary, but it seems like a reasonable starting point. In the real world, you’d test many variations of this function to see what really produces the best recommendations with real people. </p>
<h3><span id="k-nearest-neighbors">K-nearest-neighbors</span></h3><p>So how do we turn these similarities between movies based on their attributes into actual rating predictions?</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578292209772.png" alt="1578292209772"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578293123577.png" alt="1578293123577"></p>
<h3><span id="code-walkthrough">Code Walkthrough</span></h3><p>ContentBased里的文件：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578309826515.png" alt="1578309826515"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578310985921.png" alt="1578310985921"></p>
<p>从结果可以看到，Content-based algorithm比random recommendations 表现得要好。</p>
<h3><span id="bleeding-edge-alert">Bleeding Edge Alert</span></h3><blockquote>
<p>注：We often refer to the current state of the art as leading edge, but technology that’s still so new that it’s unproven in the real world can be risky to work with, and so we call that bleeding edge. </p>
<p>This is where we highlight some new research that looks interesting and promising, but hasn’t really made it into mainstream yet with recommender systems. </p>
</blockquote>
<h4><span id="mise-en-scene">mise en scene</span></h4><p>Some recent research and content based filtering has surrounded the use of mise en scene data. Technically, mise en scene refers to the placement of objects in a scene, but the researchers are using this term a bit more loosely to refer to the properties of the scenes in a movie or movie trailer. </p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578311747376.png" alt="1578311747376"></p>
<p>The idea is to extract properties from the film itself that can be quantified and analyzed, and see if we can come up with better movie recommendations by examining the content of the movie itself scene by scene.</p>
<p>What sort of attributes are we talking about：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578311877667.png" alt="1578311877667"></p>
<p>In principle, this should give us a feel as to the pacing and mood of the film, just based on the film itself.</p>
<p>Q：这样的数据和原来使用的 human generated genre classification 相比，是否更加有效？</p>
<p>更改代码：</p>
<p>去掉ContentKNNAlgorithm.py中第45行的注释，再在第46行上加上 <code>* mesSimilarity</code>:</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578312959234.png" alt="1578312959234"></p>
<p>再运行ContentRec.py，可得到结果如下：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578314301934.png" alt="1578314301934"></p>
<p>从结果上看，RMSE actually got a lot worse. 一方面，This could just be an artifact of how we chose to compute mise en scene similarity scores. 另一方面，Accuracy isn’t really what we’re concerned with.</p>
<p>Again, sometimes developing recommendation systems is more an art than a science. You can’t really predict how real people will react to new recommendations they haven’t seen before. Personally, I’d be tempted to test this in an A/B test to see how it performs. </p>
<p>If you look at the research literature associated with mise en scene recommendations however, they note that it doesn’t do any favors to accuracy, but it does increase diversity. But again, increased diversity isn’t always a good thing when it comes to recommendations. It may just mean that you’re recommending random stuff that has no correlation to the user’s actually interest. Still, it was interesting to experiment with it, and it would be even more interesting to experiment with it using real people</p>
<p>Here’s a reference to the original research paper:</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578313486050.png" alt="1578313486050"></p>
<h3><span id="exercise">Exercise</span></h3><ul>
<li>Use genre, release year, and mise en scene data independently.</li>
</ul>
<p><img src="/2020/01/06/Content-Based-Filtering/1578314783671.png" alt="1578314783671"></p>
<ul>
<li>See if you improve the release year based recommendations by sorting the k nearest neighbors within a given year by popularity. (sort the year-based recommendations by popularity as a secondary sort)</li>
</ul>
<p><img src="/2020/01/06/Content-Based-Filtering/1578315361933.png" alt="1578315361933"></p>
<p>Now by using popularity data, technically we’re no longer limiting our recommendations to content attributes. Popularity is behavior-based data.</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>A Recommender Engine Framework</title>
    <url>/2020/01/05/A-Recommender-Engine-Framework/</url>
    <content><![CDATA[<p>What we need now is a framework to let us easily experiment with new recommender system algorithms, evaluate them, and compare them against each other.</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578205315867.jpg" alt="1578205315867"></p>
<h3><span id="1-our-recommender-engine-architecture">1. Our Recommender Engine Architecture</span></h3><p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578205676375.png" alt="1578205676375"></p>
<p>Object oriented design allows us to have base classes, for example, AlgoBase, that contain functions and variables that can be shared by other classes that inherit from that base class. 例如AlgoBase中实现了fit和test方法，则无论我们实际上使用的是什么算法，我们都可以调用fit和test方法。</p>
<p>Custom指的是any custom algorithm we might develop (自己写的recommender system), and make them part of the supriselib framework.</p>
<h4><span id="create-a-custom-algorithm">Create a custom algorithm</span></h4><p>So, how do you write your own recommender algorithm that’s compatible with surpiselib?</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578207092161.png" alt="1578207092161"></p>
<p>All you have to do is create a new class that inherits form AlgoBase, and as far as supriselib is concerned, your algorithm has one job: to predict ratings.</p>
<blockquote>
<p>As we mentioned, supriselib is built around the architecture of predicting the ratings of every movie for every user, and giving back the top predictions as your recommendations. </p>
</blockquote>
<p>Your class have to implement an estimate function.</p>
<p>When estimate is called by supriselib framework, it’s asking you to predict a rating for the user and item passed in. </p>
<blockquote>
<p>注：这里的user id和item id是inner id. Must be mapped back to the raw user and item ids in your source data.</p>
</blockquote>
<ul>
<li>Now, we want to do more than just predict ratings. 我们想要很简单的将之前在<code>RecommenderMetrics</code>中实现的不同的evaluation metrics应用到algorithms we work with. </li>
</ul>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578207683880.png" alt="1578207683880"></p>
<p>为了做到这一点，我们将创建一个新的class叫做<code>EvaluatedAlgoritm</code>，里面创建了一个新的函数叫做<code>Evaluate</code>，that runs all the metrics in RecommenderMetrics on that algorithm. So this class makes it easy to measure accuracy, coverage, diversity and everything else on a given algorithm.</p>
<ul>
<li><p>不同的评估方法，要求对数据集的不同分割方式，于是我们创建了另一个新的class: <code>EvaluationData</code>来做到这一点。</p>
</li>
<li><p>如何连接这一切？</p>
</li>
</ul>
<p>We create an <code>EvaluationData</code> instance with our data set, create an <code>EvaluatedAlgorithm</code> for each algorithm we want to evaluate, and call <code>Evaluate</code> on each algorithm using the same <code>EvaluationData</code>. Under the hood, <code>EvaluatedAlgorithm</code> will use all the functions we defined in <code>RecommenderMetrics</code> to measure accuracy, hit rate, diversity, novelty, and coverage.</p>
<ul>
<li>Since what we generally want to do is 比较不同推荐系统, we can make life even easier by writing a class that takes care of all the comparison for us. 于是我们创建了新的class：<code>Evaluator</code>.</li>
</ul>
<p>Ideally, we want to just submit algorithms we want to evaluate against each other into this class, and let it do everything from there.</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578208719473.png" alt="1578208719473"></p>
<p>The beauty of this is that you don’t even have to use the <code>EvalutedAlgorithm</code> or <code>EvaluatedData</code> classed at all, when you want to start playing around with new algorithms and testing them against each other. All you need to do is use this <code>Evaluator</code> class, which has a really simple interface.</p>
<p>将上述framework写好后，如下这是我们比较SVD算法与random算法所需要的所有代码：</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578208901255.png" alt="1578208901255"></p>
<h3><span id="2-code-walkthrough">2. Code Walkthrough</span></h3><p>Framework文件夹里：</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578209106245.png" alt="1578209106245"></p>
<h4><span id="结果分析">结果分析</span></h4><p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578283638478.png" alt="1578283638478"></p>
<p>我们比较的是SVD和随机推荐。SVD is one of the best algorithms available right now, so it shouldn’t be surprise that SVD beats random recommendation in accuracy and hit rate no matter how we measure it.</p>
<ul>
<li>RMSE和MAE: lower is better.</li>
<li>Hit rate,包括cHR, ARHR: higher is better.</li>
<li>Coverage, diversity, novelty: need to apply some common sense to, as it’s not a clear higher-is-better sort of thing. There are trade-offs involved with these metrics.</li>
</ul>
<p>就Coverage而言，SVD的要低一些: that’s just because we are enforcing a quality threshold on the top-N recommendations we’re making with SVD, while our random recommender isn’t actually making totally random recommendations, it’s predicting movie ratings using what’s called a normal distribution centered around the average rating value, which ends up meaning all of the rating predictions it makes fall above our rating threshold, giving us 100% coverage. Having 100% coverage at the expense of having bad recommendations isn’t a trade-off worth making.</p>
<p>就Diversity和Novelty而言，SVD的都要低一些，这是我们所预期会出现的。</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluate Recommender System</title>
    <url>/2020/01/04/Evaluate-Recommender-System/</url>
    <content><![CDATA[<h3><span id="1-the-methodology-for-testing-recommender-systems-offline">1. The methodology for testing recommender systems offline.</span></h3><h4><span id="11-traintest-split">1.1 train/test split</span></h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578116193748.jpg" alt="1578116193748"></p>
<p>You measure your recommender system’s ability to predict how people rated things in the past.</p>
<p>If you do this over enough people, you can end up with a meaningful number that tells you <strong>how good your recommender system is at recommending things, or more specifically, recommending things people already watched and rated.</strong> That’s really all you can do, if you can’t test things out in an online system.</p>
<h4><span id="12-k-fold-cross-validation">1.2 k-fold cross-validation</span></h4><p>If you really want to get fancy, it’s possible to improve on a single train/test split by using  a technique called k-fold cross validation.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578116897885.jpg" alt="1578116897885"></p>
<p>Instead of a single training set, we create many randomly assigned training sets. Each individual training set, or fold, is used to train your recommender system independently, and then we measure the accuracy of the resulting systems against your test set. So we end up with a score of how accurate each fold ends up predicting user ratings, and we can average them together.</p>
<p>This obviously takes a lot more computing power to do, but the advantage is that you don’t end up over-fitting to a single training set.</p>
<blockquote>
<p>注：By using train/test, all we can do is test our ability to predict how people rated movies they already saw. That’s not the point of a recommender system.  We want to recommend new things to people that they haven’t seen, but find interesting. However, that’s fundamentally impossible to test offline.</p>
</blockquote>
<p>We haven’t talked about how to actually come up with an accuracy metric when testing our recommender systems, so let’s cover a couple of different ways to do it.</p>
<h3><span id="2-accuracy-metrics-rmse-mae">2. Accuracy Metrics (RMSE, MAE)</span></h3><h4><span id="21-mae">2.1 MAE</span></h4><p>We want to minimize MAE.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578117806539.JPG" alt="1578117806539"></p>
<h4><span id="22-rmse">2.2 RMSE</span></h4><p>We want to minimize RMSE.</p>
<p>This is a more popular metric for a few reasons, but one is that <strong>it penalizes you more when your rating prediction is way off, and penalizes you less when your are reasonably close.</strong></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578117900853.jpg" alt="1578117900853"></p>
<blockquote>
<p>注：就推荐系统而言，RMSE just doesn’t matter much in the real world. 人们并不关心你的系统对他们已经看过的电影的评分预测是否准确。What does matter is which movie you put in front of users in a top-N recommender list, and how those users react to those movies when they see them recommended.</p>
</blockquote>
<h3><span id="3-top-n-hit-rate-many-ways">3. Top-N Hit Rate - Many Ways</span></h3><p>Different ways to measure the effectivenss of top-n recommenders offline:</p>
<h4><span id="31-hit-rate">3.1 Hit Rate</span></h4><p>You generate top-n recommendations for all of the users in your test set. <strong>If one of the recommendations in a user’s top-n recommendations is something  they actually rated, you consider that a hit.</strong> You actually managed to show the user something that they found interesting enough to watch on their own already, so we consider that a success. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578119273699.jpg" alt="1578119273699"></p>
<p>How to measure hit rate? Use leave-one-out cross validation.</p>
<h4><span id="32-leave-one-out-cross-validation">3.2 leave-one-out cross validation</span></h4><p>What we do is compute the top-n recommendations for each user in our training data, and intentionally remove one of those items from that user’s training data. We then test our recommender system’s ability to recommend that item that was left out in the top-n results it creates for that user in the testing phase.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578120352619.jpg" alt="1578120352619"></p>
<p>The trouble is that it’s a lot harder to get one specific movie right while testing than to just get one of the n recommendations. So “hit rate” with “leave-one-out” tends to be very small and difficult to measure, unless you have a very large data set to work with. But it’s a much more <strong>user focused metric</strong> when you know your recommender system will be producing top-n lists in the real world, which most of them do. </p>
<h4><span id="33-arhr">3.3 ARHR</span></h4><p>This metric is just like “hit rate”, but it accounts for where in the top-n list you hits appear. Instead of summing up the number of hits, we sum up the reciprocal ranking of each hit.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578122155631.jpg" alt="1578122155631"></p>
<p>You end up getting more credit for successfully recommending an item in the top slot than in the bottom slot. Again, this is a more <strong>user focused metric</strong>, since users tend to focus on the beginning of lists. </p>
<h4><span id="34-chr">3.4 cHR</span></h4><p>Throw away hits if our predicted rating is below some threshold.</p>
<p>The idea is that we shouldn’t get credit for recommending items to a user that we think they won’t actually enjoy. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578122704818.jpg" alt="1578122704818"></p>
<p>In this example, if we had a cutoff of three stars, we throw away the hits for the second and fourth items in these test results and our hit rate metric wouldn’t count them at all. </p>
<h4><span id="35-rhr">3.5 rHR</span></h4><p>Another way to look at hit rate is to break it down by predicted rating score.</p>
<p>It can be a good way to get an idea of the distribution of how good your algorithm thinks recommended movies are that actually get a hit.  Ideally, you want to recommend movies that they actually like, and breaking down the distribution gives you some sense of how well you’re doing in more detail.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578123016707.jpg" alt="1578123016707"></p>
<p>对每一个rating type (1,2,3,4,5), print out its hit rate.</p>
<h3><span id="4-coverage-diversity-and-novelty">4. Coverage, Diversity and Novelty</span></h3><p>Accuracy isn’t the only thing that matters.</p>
<h4><span id="41-coverage">4.1 Coverage</span></h4><p>The percentage of possible recommendations that your system is able to provide. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578123495150.jpg" alt="1578123495150"></p>
<p>It’s worth noting that coverage can be at odds with accuracy. If you enforce a higher quality threshold on the recommendations you make, then you might improve your accuracy at the expense of coverage. Finding the balance of where exactly you’re better off recommending nothing at all can be delicate. </p>
<p>Coverage can also be important to watch, because it gives you a sense of how quickly new items in your catalog will start to appear in your recommendations. When a new book come out on Amazon, it won’t appear in recommendations until at least a few people buy it, therefore establishing patterns with the purchase of other items. Until those patterns exist, that new book will reduce Amazon’s coverage metric.</p>
<h4><span id="42-diversity">4.2 Diversity</span></h4><p>You can think of this as measure of how broad a variety of items your recommender system is putting in front of people. An example of low diversity would be a recommender system that just recommends the next books in a series that you’ve started reading, but doesn’t recommend book from different authors, or movies related to what you’ve read.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578124451718.jpg" alt="1578124451718"></p>
<p>Diversity, at least in the context of recommender systems, isn’t always a good thing. You can achieve very high diversity by just recommending completely random items. Unusually high diversity scores mean that you just have bad recommendations more often than not. You always need to look at diversity alongside metrics that measure the quality of the recommendations as well. </p>
<h4><span id="43-novelty">4.3 Novelty</span></h4><p>Similarly, novelty sounds like a good thing, but often it isn’t. Novelty is a measure of how popular the items are that you are recommending. And again, just recommending random stuff would yield very high novelty scores, since the vast majority of items are not top sellers. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578124908363.jpg" alt="1578124908363"></p>
<p>Although novelty is measurable, what to do with it is in many ways subjective. There’s a concept of user trust in a recommender system. People want to see at least a few familiar items in their recommendations that make them say, “Yeah, that’s a good recommendation for me. The system seems good”. If you only recommend things people never heard of, they may conclude that your system doesn’t really know them. Also, popular items are usually popular for a reason. They’re enjoyable by a large segment of the population, so you would expect them to be good recommendations for a large segment of the population who hasn’t read or watched them yet. If you’re not recommending some popular items, you should probably question whether your recommender system is really working as it should.</p>
<p><strong>You need to strike a balance between familiar, popular items and what we call serendipitous discovery of new items that user has never heard of before. (balance between novelty and trust)</strong>. The familiar items establish trust with the user, and the new ones allow the user to discover entirely new things that they might love. </p>
<p>Novelty is important, because the whole point of recommender systems is to surface items in what we call “the long tail”.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578125635846.jpg" alt="1578125635846"></p>
<p>Imagine this is a plot of the sales of every item in you catalog, sorted by sales. Y 轴代表sales (popularity)，X轴代表products. Most of sales来自于一小部分items，但是”long tail” makes up a large amount of sales as well. 黄色部分的item代表了人们各自感兴趣的东西. Recommender systems can help people discover those items in the long tail that are relevant to their own unique niche interests. If you can do that successfully, then the recommendations your system makes can help new authors get discovered, can help people explore their own passions, and make money for whoever you’re building the system for as well. Everybody wins.</p>
<h3><span id="5-churn-responsiveness-and-ab-tests">5. Churn, Responsiveness, and A/B Tests</span></h3><h4><span id="51-churn">5.1 Churn</span></h4><p>Another thing we can measure is Churn. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578127764650.jpg" alt="1578127764650"></p>
<p>Churn can measure how sensitive your recommender system is to new user behavior. 如果用户rate了一部新电影，会使得他的推荐内容发生很大的变化吗？If so, your churn score will be high. Maybe just showing the same recommendations too many times is a bad idea itself. 如果一个用户总是看到相同的推荐，但是不点击进去，在某个时候你应该停止推荐它而给用户推荐其他的东西。Sometimes, a little bit of randomization in your top-n recommendations can keep them looking fresh, and expose your users to more items.</p>
<p>But, just like diversity and novelty, high churn is not in itself a good thing. You could maximize your churn metric by just recommending items completely at random, 但显然这不是好的推荐。</p>
<p>*<em>All these metrics need to be looked at together, and you need to understand the trade-offs between them. *</em></p>
<h4><span id="52-responsiveness">5.2 Responsiveness</span></h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578128338650.jpg" alt="1578128338650"></p>
<p>If you rate  a new movie, does it affect your recommendations immediately or next day after some nightly job runs? More responsiveness would always seem to be a good thing, but in the world of business, you have to decide how responsive your recommender really needs to be, since recommender systems that have instantaneous responsiveness are complex, difficult to maintain, and expensive to build. You need to strike your own balance between responsiveness and simplicity.</p>
<blockquote>
<p> ? What’s important</p>
<p>前面讲了许多evaluate推荐系统的方法：MAE, RMSE, Hit rate in various forms, coverage, diversity, novelty, churn, and responsiveness.</p>
<p>So how do you know what to focus on? It depends.</p>
<p>It may even depend on cultural factors. Some cultures may want more diversity and novelty, while other cultures may want to stick to things that are familiar with them. </p>
<p>It also depends on what you’re trying to achieve as a business. And usually,  a business is just trying to make money, which leads to one more way to evaluate recommender systems that is arguably the most important of all: online A/B tests!</p>
</blockquote>
<h4><span id="53-online-ab-tests">5.3 Online A/B Tests</span></h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578129032852.jpg" alt="1578129032852"></p>
<p>Doing online A/B tests to tune your recommender system using your real customers, and measuring how they react to your recommendations. You can put recommendations from different algorithms in front of different sets of users, and measure if they actually buy, watch, or otherwise indicate interest in the recommendations you’ve presented. </p>
<p>By always testing changes to your recommender system using controlled, online experiments, you can see if they actually cause people to discover and purchase more new things than they would have otherwise.</p>
<p>None of the metrics we’ve discussed matter more than how real customers react to the recommendations you produce in the real world. You can have the most accurate rating predictions in the world, but if customers can’t find new items to buy or watch from your system, it will be worthless from a practical standpoint. </p>
<p>Online tests can help you to avoid introducing complexity that adds no value, and remember, complex systems are difficult to maintain.</p>
<p>SO REMEMBER, offline metrics such as accuracy, diversity, and novelty can all be indicators you can look at while developing recommender systems offline, but you should never declare victory until you’ve measured a real impact on real users from your work. <strong>User behavior is the ultimate test of your work.</strong></p>
<p><strong>Accurately predicted ratings don’t necessarily make for good video recommendations. At the end of the day, the results of online A/B tests are the only evaluation that matters for your recommender system.</strong></p>
<p>Another thing you can do is just straight up ask your users, if they think specific recommendations are good. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578129889414.jpg" alt="1578129889414"></p>
<p>In practice though, it’s a tough thing to do. Users will probably be confused over whether you’re asking them to rate the item or rate the recommendation, so you won’t really know how to interpret this data. It also requires extra work form your customers with no clear payoff for them, so you’re unlikely to get enough ratings on your recommendations to be useful. </p>
<p>It’s best to just stick with online A/B tests, and measure how your customers vote with their wallets on the quality of your recommendations.</p>
<h3><span id="quiz">Quiz</span></h3><p><img src="/2020/01/04/Evaluate-Recommender-System/1578196100106.jpg" alt="1578196100106"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196212178.jpg" alt="1578196212178"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196333798.jpg" alt="1578196333798"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196377981.jpg" alt="1578196377981"></p>
<h3><span id="code-walkthrough">Code Walkthrough</span></h3><p>使用Python中的library: Suprise. <a href="supriselib.com">SupriseLib’s documentation online</a></p>
<p>Suprise is built around measuring the accuracy of recommender systems. Although this is the wrong thing to focus on, it’s really the best we can do without access to a real, large-scale website of our own.</p>
<p>Evaluating文件夹里的：</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578201480503.jpg" alt="1578201480503"></p>
<p>RecommenderMetrics中实现了前面讲到的用来evaluate recommender system的各种metrics.</p>
<p>TestMetrics中调用了RecommenderMetrics中的方法来实现一个real recommender system并evaluate it.</p>
<h4><span id="结果分析">结果分析</span></h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578201799750.jpg" alt="1578201799750"></p>
<ul>
<li><p>RMSE大概0.9，MAE大概0.7。</p>
<p>On average, our guess of rating for a given movie for a given user, was off by about 0.7 stars. RMSE is higher, meaning that we got penalized for being way off more often than we’d like.</p>
<p>Remember, error metrics are bad.  你想要RMSE与MAE越低越好，if accuracy is your goal.</p>
</li>
</ul>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578201882902.jpg" alt="1578201882902"></p>
<ul>
<li>Hit Rate大概 3%，which actually isn’t that bad, considering that only one movie was left out from each user’s rating to test with. 这个数值本身很难解释是好是坏，除非有其他的推荐系统可供比较。</li>
<li>If we break it down by rating value, you can see that our hit rate did better at higher rating predictions, which make sense and it’s what we want to see. Hit Rate在评分越高的类型中表现得更好（例如，在评分为5的电影中，Hit Rate为 6%）。</li>
<li>Cumulative Hit Rate with a 4.0 threshold isn’t much lower than the raw hit rate, meaning that we’re doing a good job of recommending items we think are good recommendations.</li>
<li>ARHR is 0.01. It takes the ranking of the hits into account. Again, it has no real value until we have other recommender systems to compare it against.</li>
</ul>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578203470922.jpg" alt="1578203470922"></p>
<ul>
<li><p>We look at user coverage for which we have at least one 4-star rating prediction, ant it’s pretty high. That’s good.</p>
</li>
<li><p>Diversity is really high at 0.96, and novelty seems pretty high, with an average popularity rank of 491. Remember there are only a few thousand movies in our data set to begin with. </p>
<p>This tells us that our algorithm is going pretty deep into the long tail to get its recommendations and that could be a problem in the real world. Novelty比较高（平均受欢迎程度排名比较靠后），说明推荐的都是比较小众的电影（long tail）.</p>
</li>
</ul>
<h4><span id="总结">总结</span></h4><p>So even though our accuracy metrics look okay here, diversity and novelty is telling us that we’re recommending a lot of really obscure stuff. And that could be an issue when trying to establish user trust in the system. People generally want to see a few things that at least look familiar. So I would expect this particular algorithm wouldn’t do that well in an online A/B test, but you can never really know until  you actually try it. </p>
<p>Anyhow, we now have working code now for evaluating real recommender systems!</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Top-N Recommender Architecture</title>
    <url>/2020/01/03/Top-N-Recommender-Architecture/</url>
    <content><![CDATA[<p><img src="/2020/01/03/Top-N-Recommender-Architecture/1578052647526.jpg" alt="1578052647526"></p>
<p><img src="/2020/01/03/Top-N-Recommender-Architecture/1578471196924.png" alt="1578471196924"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>RecSys Course Overview</title>
    <url>/2020/01/03/RecSys-Course-Overview/</url>
    <content><![CDATA[<p>课程：</p>
<p><a href="https://www.udemy.com/course-dashboard-redirect/?course_id=1726410" target="_blank" rel="noopener"><img src="https://i.udemycdn.com/course/240x135/1726410_7b86.jpg" alt="Building Recommender Systems with Machine Learning and AI"></a><a href="https://www.udemy.com/course/building-recommender-systems-with-machine-learning-and-ai/learn/" target="_blank" rel="noopener"><strong>Building Recommender Systems with Machine Learning and AI</strong> </a></p>
<p><a href="https://sundog-education.com/RecSys/" target="_blank" rel="noopener">Course Materials</a></p>
<p><img src="/2020/01/03/RecSys-Course-Overview/1578048175249.jpg" alt="1578048175249"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2020/01/03/MapReduce/</url>
    <content><![CDATA[<h4><span id="1-mapreduce-fundamental-concepts">1. MapReduce fundamental concepts</span></h4><p><img src="/2020/01/03/MapReduce/1578032618932.jpg" alt="1"></p>
<p><img src="/2020/01/03/MapReduce/20200103-142610.jpg" alt="20200103-142610"></p>
<p><img src="/2020/01/03/MapReduce/1578032937052.jpg" alt="1578032937052"></p>
<h5><span id="11-mapper">1.1 Mapper</span></h5><p><img src="/2020/01/03/MapReduce/1578033123727.jpg" alt="1578033123727"></p>
<p><img src="/2020/01/03/MapReduce/20200103-143446.jpg" alt="20200103-143446"></p>
<p><img src="/2020/01/03/MapReduce/1578033212508.jpg" alt="1578033212508"></p>
<p><img src="/2020/01/03/MapReduce/1578033238182.jpg" alt="1578033238182"></p>
<p>Mapper: Extract and organize what we care about.</p>
<h5><span id="12-shuffle-and-sort">1.2 Shuffle and Sort</span></h5><p><img src="/2020/01/03/MapReduce/1578033463232.jpg" alt="1578033463232"></p>
<p><img src="/2020/01/03/MapReduce/20200103-144645.jpg" alt="20200103-144645"></p>
<h5><span id="13-reducer">1.3 Reducer</span></h5><p><img src="/2020/01/03/MapReduce/1578034121206.jpg" alt="1578034121206"></p>
<p><img src="/2020/01/03/MapReduce/20200103-144953.jpg" alt="20200103-144953"></p>
<p><img src="/2020/01/03/MapReduce/1578034303323.jpg" alt="1578034303323"></p>
<hr>
<h4><span id="2-how-mapreduce-distributes-processing">2. How MapReduce distributes processing</span></h4><p><img src="/2020/01/03/MapReduce/1578034389919.jpg" alt="1578034389919"></p>
<p><img src="/2020/01/03/MapReduce/0002.jpg" alt="0002"></p>
<hr>
<h4><span id="3-mapreduce-a-real-example">3. MapReduce: a real example</span></h4><p><img src="/2020/01/03/MapReduce/1578035985411.jpg" alt="1578035985411"></p>
<p><img src="/2020/01/03/MapReduce/1578036687341.jpg" alt="1578036687341"></p>
<p>Sometimes, it’s not easy to try to force a problem into this way of thinking, and that’s a big reason why other frameworks like Spark or Hive, or other ways of processing SQL style queries have become a little bit more popular that just writing raw MapReduce code.</p>
<p>But, still, if you can easily express something in terms of mapping and reducing, this can sometimes be the most efficient way of doing it.</p>
<p><img src="/2020/01/03/MapReduce/1578037510439.jpg" alt="1578037510439"></p>
<p>Then, the results all get passed into the MapReduce framework which does shuffle and sort for us. And then, we just have to write the Reducer.</p>
<p><img src="/2020/01/03/MapReduce/1578038403968.jpg" alt="1578038403968"></p>
<p>Here’s a complete Python MapReduce script.</p>
<p><img src="/2020/01/03/MapReduce/1578039179773.jpg" alt="1578039179773"></p>
<p>This is an entire MRJOB script in Python that would use MapReduce streaming to actually execute across a cluster.</p>
<hr>
<h4><span id="4-runing-mapreduce-with-mrjob">4. Runing MapReduce with MRJOB</span></h4><p>首先需要安装一些东西</p>
<p>Run our MapReduce job in our Hadoop installation.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963054#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963054#overview</a></p>
<p><img src="/2020/01/03/MapReduce/1578041252394.jpg" alt="1578041252394"></p>
<p><img src="/2020/01/03/MapReduce/1578041273664.jpg" alt="1578041273664"></p>
<p><img src="/2020/01/03/MapReduce/1578041300494.jpg" alt="1578041300494"></p>
<hr>
<h4><span id="5-challenge-exercise">5. Challenge Exercise</span></h4><p><img src="/2020/01/03/MapReduce/1578043490000.jpg" alt="1578043490000"></p>
<p><img src="/2020/01/03/MapReduce/1578043550225.jpg" alt="1578043550225"></p>
<p><img src="/2020/01/03/MapReduce/1578043582794.jpg" alt="1578043582794"></p>
<p><img src="/2020/01/03/MapReduce/1578043608450.jpg" alt="1578043608450"></p>
<p><img src="/2020/01/03/MapReduce/1578043786325.jpg" alt="1578043786325"></p>
<hr>
<h4><span id="6-check-your-results">6. Check your results</span></h4><p><img src="/2020/01/03/MapReduce/1578044582388.jpg" alt="1578044582388"></p>
<p>结果：</p>
<p><img src="/2020/01/03/MapReduce/1578044858078.jpg" alt="1578044858078"></p>
<p>movieId 50 是最popular的电影。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS and MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2020/01/02/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词（难度：简单）</a></p>
<p><img src="/2020/01/02/有效的字母异位词/1.jpg" alt="1"></p>
<h4><span id="方法一哈希表">方法一：哈希表</span></h4><h5><span id="思路">思路</span></h5><ul>
<li>首先判断两个字符串长度是否相等，不相等则直接返回 false。</li>
<li>若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t</li>
<li><strong>s 负责在对应位置增加，t 负责在对应位置减少，如果哈希表的值都为 0，则二者是字母异位词</strong></li>
</ul>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。尽管我们使用了额外的空间，但是空间的复杂性是 O(1)，因为无论 N 有多大，表的大小都保持不变。</p>
<h5><span id="代码">代码</span></h5><p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            alpha[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            alpha[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : alpha)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/有效的字母异位词/4.jpg" alt="4"></p>
<hr>
<h4><span id="方法二排序">方法二：排序</span></h4><h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(nlogn)。</p>
<p>空间复杂度：O(1)，空间取决于排序实现，如果使用 <code>heapsort</code>，通常需要 O(1)辅助空间。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/有效的字母异位词/3.jpg" alt="3"></p>
<hr>
<h4><span id="方法三利用python中的set">方法三：利用Python中的set()</span></h4><p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        set1 = set(s)</span><br><span class="line">        set2 = set(t)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> set2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> s.count(i) != t.count(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/有效的字母异位词/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2020/01/02/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一（难度：简单）</a></p>
<p><img src="/2020/01/02/加一/1.jpg" alt="1"></p>
<h4><span id="方法数组遍历">方法：数组遍历</span></h4><p><img src="/2020/01/02/加一/2.jpg" alt="2"></p>
<p>时间复杂度：O(n)</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            digits[i] = (digits[i]+<span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/加一/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/2020/01/02/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合（难度：中等）</a></p>
<p><img src="/2020/01/02/电话号码的字母组合/1.jpg" alt="1"></p>
<h4><span id="方法回溯">方法：回溯</span></h4><p><img src="/2020/01/02/电话号码的字母组合/2.jpg" alt="2"></p>
<p><img src="https://pic.leetcode-cn.com/0ac574ab37f620221e702f57d6c4ffd0ba246abe41c43f9fc9637ab8f3365377-image.png" alt="img"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        phone = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">                <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>],</span><br><span class="line">                <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>],</span><br><span class="line">                <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>],</span><br><span class="line">                <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>],</span><br><span class="line">                <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">                <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>],</span><br><span class="line">                <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">if</span> digits:</span><br><span class="line">            self.backtrack(<span class="string">""</span>, digits, phone, output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(self, combination, digit, phone, output)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(digit)==<span class="number">0</span>:</span><br><span class="line">            output.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> phone[digit[<span class="number">0</span>]]:</span><br><span class="line">            self.backtrack(combination+letter,digit[<span class="number">1</span>:], phone, output)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/电话号码的字母组合/4.jpg" alt="4"></p>
<p><img src="/2020/01/02/电话号码的字母组合/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2020/01/02/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器（难度：中等）</a></p>
<p><img src="/2020/01/02/盛最多水的容器/1.jpg" alt="1"></p>
<h4><span id="方法双指针">方法：双指针</span></h4><h5><span id="思路">思路</span></h5><p>两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p>
<h5><span id="算法">算法</span></h5><ul>
<li><strong>在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾</strong>。</li>
<li>使用变量 max_area来持续存储到目前为止所获得的最大面积。 </li>
<li>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 max_area，<strong>并将指向较短线段的指针向较长线段那端移动一步</strong>。</li>
</ul>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)，一次扫描。</p>
<p>空间复杂度：O(1)，使用恒定的空间。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max_area = Math.max(max_area, Math.min(height[left],height[right]) * (right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/盛最多水的容器/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/01/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">正则表达式匹配（难度：困难）</a></p>
<p><img src="/2020/01/02/正则表达式匹配/1.jpg" alt="1"></p>
<p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<h4><span id="一-处理点号通配符">一、处理点号「.」通配符</span></h4><p>点号可以匹配任意一个字符，其实是最简单的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern: <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<h4><span id="二-处理通配符">二、处理「*」通配符</span></h4><p>星号通配符可以让前一个字符重复任意次数，包括零次。那到底是重复几次呢？这需要计算机暴力穷举来算，假设重复 N 次吧。写递归的技巧是管好当下，之后的事抛给递归。具体到这里，不管 N 是多少，当前的选择只有两个：匹配 0 次、匹配 1 次。所以可以这样处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern: <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">        <span class="comment"># 发现 '*' 通配符</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">                first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern)</span><br><span class="line">    	<span class="comment"># 解释：如果发现有字符和 '*' 结合，</span></span><br><span class="line">        	<span class="comment"># 或者匹配该字符 0 次，然后跳过该字符和 '*'</span></span><br><span class="line">        	<span class="comment"># 或者当 pattern[0] 和 text[0] 匹配后，移动 text</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p>可以看到，我们是通过保留 pattern 中的「*」，同时向后推移 text，来实现「*」将字符重复匹配多次的功能。</p>
<h4><span id="三-动态规划">三、动态规划</span></h4><h5><span id="暴力解法">暴力解法</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        </span><br><span class="line">        first = s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s,p[<span class="number">2</span>:]) <span class="keyword">or</span> (first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:],p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:],p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/正则表达式匹配/2.jpg" alt="2"></p>
<h5><span id="优化解法">优化解法</span></h5><p>使用两个变量 <code>i</code>, <code>j</code> 记录当前匹配到的位置，从而避免使用子字符串切片，并且将 <code>i</code>, <code>j</code> 存入memo，避免重复计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[(i,j)]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> j==len(p):</span><br><span class="line">                <span class="keyword">return</span> i==len(s)</span><br><span class="line">            </span><br><span class="line">            first = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> &#123;s[i],<span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(p) &gt;= j+<span class="number">2</span> <span class="keyword">and</span> p[j+<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> dp(i,j+<span class="number">2</span>) <span class="keyword">or</span> (first <span class="keyword">and</span> dp(i+<span class="number">1</span>,j))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> first <span class="keyword">and</span> dp(i+<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            memo[(i,j)] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/正则表达式匹配/3.jpg" alt="3"></p>
<h6><span id="复杂度">复杂度</span></h6><p>时间复杂度：用 T 和 P 分别表示匹配串和模式串的长度。对于 i=0, … , T 和 j=0, … , P 每一个 dp(i, j) 只会被计算一次，所以后面每次调用都是 O(1)的时间。因此，总时间复杂度为 O(TP) 。</p>
<p>空间复杂度：我们用到的空间仅有 O(TP)个 boolean 类型的缓存变量。所以，空间复杂度为 O(TP) 。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单调递增的数字</title>
    <url>/2020/01/02/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字（难度：中等）</a></p>
<p><img src="/2020/01/02/单调递增的数字/1.jpg" alt="1"></p>
<h4><span id="方法">方法：</span></h4><p><img src="/2020/01/02/单调递增的数字/2.jpg" alt="2"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        s = list(str(N))</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(s) <span class="keyword">and</span> s[i<span class="number">-1</span>] &lt;= s[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt; i &lt; len(s) <span class="keyword">and</span> s[i<span class="number">-1</span>] &gt; s[i]:</span><br><span class="line">            s[i<span class="number">-1</span>] = str(int(s[i<span class="number">-1</span>])<span class="number">-1</span>)</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">        s[i+<span class="number">1</span>:] = <span class="string">'9'</span>*(len(s)-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(s))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/单调递增的数字/3.jpg" alt="3"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(D)。其中 D≈logN，N 是数字的长度。<br>空间复杂度：O(D)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>整数</tag>
      </tags>
  </entry>
  <entry>
    <title>移掉K位数字</title>
    <url>/2020/01/02/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字（难度：中等）</a></p>
<p><img src="/2020/01/02/移掉K位数字/1.jpg" alt="1"></p>
<h4><span id="方法单调栈">方法：单调栈</span></h4><p>维护一个递增栈，但当前元素小于栈顶元素，则移掉栈顶元素。</p>
<h5><span id="思路">思路</span></h5><p>转自</p>
<blockquote>
<p>作者：monkeybing<br>链接：<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/cyu-yan-zhan-shi-xian-tan-xin-suan-fa-by-monkeybin/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/cyu-yan-zhan-shi-xian-tan-xin-suan-fa-by-monkeybin/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本题采用贪心思路：</p>
<ol>
<li>如果字符串按照数字大小升序排列，只需要删除最后K个字符即可；</li>
<li>如果非升序排列，需要从前到后遍历，删除字符串中每个逆序排列的字符。由于是从前到后遍历，所以先删除的一定是高位的数字，可以保证删除后得到的最终数字最小。</li>
</ol>
<p>举例来说：如果字符串num = “123456789”, k = 3，我们只需要删除最后3个数字，得到”123456”.<br>如果字符串num = “1432219”, k = 3，需要从前到后遍历查找逆序数字，进行删除，第一个逆序数字为’4’，第二个逆序数字为’3’，第三个逆序数字为第二个’2’，最后得到”1219”。</p>
<p><strong>所以可以采用栈实现，每次遍历，判断如果栈非空，且当前数字大于栈顶数字，且k还有剩余（不为0），将栈顶数字出栈。最后将当前数字入栈。</strong><br>如果遍历完成后，k仍有剩余，则依次将栈顶数字出栈。最后栈中保存的数字即为所求。按照从栈底到栈顶输出即可。<br>注意：特判场景，如果最后所有数字均出栈，即栈为空，需要返回”0”。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; c:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str(int(<span class="string">''</span>.join(stack)))</span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/02/移掉K位数字/2.jpg" alt="2"></p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n).</p>
<p>空间复杂度：O(n).</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/01/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<p>然而，大部分问题明显不具有贪心选择性质。比如打牌，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文<a href="https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/" target="_blank" rel="noopener">动态规划解决博弈问题</a>。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>无重叠区间</title>
    <url>/2020/01/01/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">无重叠区间（难度：中等）</a></p>
<p><img src="/2020/01/01/无重叠区间/1.jpg" alt="1"></p>
<p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 <code>[start, end]</code>的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。<br>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天最多能参加几个活动呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
<h4><span id="方法贪心算法">方法：贪心算法</span></h4><h5><span id="思路">思路</span></h5><ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/678752f150168fc2e53a36d30e589b76ef81a95943c018b01bef6a548bfafeeb-file_1566313617208" alt="1"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 按区间的end升序排列</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] intv:intervals)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = intv[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(x_end &lt;= start)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                x_end = intv[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(nlogn). 排序需要O(nlogn)的时间。</p>
<p>空间复杂度：O(1). 不需要额外空间。</p>
<p><img src="/2020/01/01/无重叠区间/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>区间</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子序列</title>
    <url>/2020/01/01/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列（难度：简单）</a></p>
<p><img src="/2020/01/01/判断子序列/3.jpg" alt="3"></p>
<h4><span id="方法一">方法一</span></h4><p>利用Python切片，对s中的每个字符，若在t中，下一步比较index+1开始的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> t:</span><br><span class="line">                t = t[t.index(i)+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/01/判断子序列/1.jpg" alt="1"></p>
<hr>
<h4><span id="方法二双指针">方法二：双指针</span></h4><p>若相等，两个指针都往前移，若不等，快指针往前移。最后比较慢指针与s的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(s) <span class="keyword">and</span> p2 &lt; len(t):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == t[p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p1 == len(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p><img src="/2020/01/01/判断子序列/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2019/12/31/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数（难度：困难）</a></p>
<p><img src="/2019/12/31/缺失的第一个正数/4.jpg" alt="4"></p>
<h4><span id="方法一空间复杂度不满足要求">方法一（空间复杂度不满足要求）</span></h4><p>遍历一遍数组，将元素装入HashSet，再从1开始，判断元素是否在HashSet中，若不存在，则该数为缺失的第一个正数。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n).</p>
<p>空间复杂度：O(n). </p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num))</span><br><span class="line">                set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(n))</span><br><span class="line">                n++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/缺失的第一个正数/1.jpg" alt="1"></p>
<hr>
<h4><span id="方法二">方法二</span></h4><h5><span id="思路">思路</span></h5><p>通过预处理保证数组中的数全为正数，遍历数组，当读到数字 a 时，替换索引a 处元素的符号为负数。最后返回正数所对应的索引。</p>
<h5><span id="算法">算法</span></h5><ul>
<li>首先检查1是否存在于数组中。如果没有，则已经完成，1 即为答案。</li>
<li>若1在数组中，则可将负数，零，和大于 n 的数替换为 1 。</li>
<li>遍历数组。当读到数字 a 时，替换索引a 处元素的符号。（即若数组中出现1，改变nums[1]的符号；若出现2，改变nums[2]的符号）<br>注意重复元素：只能改变一次符号。由于遇到数字n时，没有下标 n ，则使用索引0 处的元素来保存是否存在数字 n。</li>
<li>返回结果：<ul>
<li>从1开始遍历数组。返回第一个正数元素的下标。</li>
<li>如果 nums[0] &gt; 0，则返回 n 。</li>
<li>如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。</li>
</ul>
</li>
</ul>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n).所有的操作一共只会遍历长度为 <code>N</code> 的数组 4 次。</p>
<p>空间复杂度：O(1).只使用了常数的空间。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看数组中是否包含1</span></span><br><span class="line">        <span class="keyword">int</span> contains = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                contains += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(contains==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换小于等于0的数及大于n的数为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(a==n)</span><br><span class="line">                nums[<span class="number">0</span>] = -Math.abs(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[a] = -Math.abs(nums[a]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果（索引0处要单独判断，因为若数组中未出现n,则nums[0]处的值会为正数，但不该返回索引0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/缺失的第一个正数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找重复数</title>
    <url>/2019/12/31/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数（难度：中等）</a></p>
<p><img src="/2019/12/31/寻找重复数/1.jpg" alt="1"></p>
<h4><span id="方法一排序">方法一：排序</span></h4><h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：<em>O</em>(nlog(n))。</p>
<p>空间复杂度：O(1) (or O(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/寻找重复数/2.jpg" alt="2"></p>
<hr>
<h4><span id="方法二集合哈希表">方法二：集合（哈希表）</span></h4><h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/寻找重复数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失数字</title>
    <url>/2019/12/31/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">缺失数字（难度：简单）</a></p>
<p><img src="/2019/12/31/缺失数字/3.jpg" alt="3"></p>
<h4><span id="方法一数学方法">方法一：数学方法</span></h4><p>用序列<code>[0,1,...,n]</code>的和减去给定的<code>nums</code>的和，可得到缺失的数字。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。</p>
<p>空间复杂度：O(1)。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        sum1 = sum(range(<span class="number">0</span>,len(nums)+<span class="number">1</span>)) <span class="comment"># 0,1,...,n 序列的和(或用高斯求和公式)</span></span><br><span class="line">        sum2 = sum(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum1 - sum2</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/缺失数字/1.jpg" alt="1"></p>
<p>高斯求和有溢出风险</p>
<hr>
<h4><span id="方法二位运算异或运算">方法二：位运算（异或运算）</span></h4><p>先得到<code>[0,1,...,n]</code>的异或值，再将结果对数组<code>nums</code>中的每一个数进行一次异或运算，最终的异或结果即为这个缺失的数字。</p>
<p>在编写代码时，由于<code>[0,1,...,n]</code>恰好是这个数组的下标加上 n，因此可以用一次循环完成所有的异或运算。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。假设异或运算的时间复杂度是常数的。</p>
<p>空间复杂度：O(1)。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = len(nums) <span class="comment"># 一开始初始化为n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            res ^=  i ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/31/缺失数字/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2019/12/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表（难度：简单）</a></p>
<p><img src="/2019/12/29/回文链表/1.jpg" alt="1"></p>
<h4><span id="思路">思路</span></h4><p>使用快慢指针找到中点，对链表前半部分进行翻转。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = head, prepre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一遍遍历实现翻转前半部分</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next; <span class="comment">// 若链表长度为偶数，则fast最后会指向null，若为奇数，fast最后会指向最后一个元素</span></span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，若为偶数，slow指向后半部分第一个元素，若为奇数，slow指向中间的那个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span> &amp;&amp; slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/回文链表/2.jpg" alt="2"></p>
<p><img src="/2019/12/29/回文链表/20191229-214756.jpg" alt="20191229-214756"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转二叉树</title>
    <url>/2019/12/29/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树（难度：简单）</a></p>
<p><img src="/2019/12/29/翻转二叉树/1.jpg" alt="1"></p>
<h4><span id="方法-递归">方法： 递归</span></h4><h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n). 每个节点只被访问了一次。</p>
<p>空间复杂度：最坏情况下栈内需要存放 O(h)个方法调用，其中 h是树的高度。由于 h<em>∈</em>O<em>(</em>n)，可得出空间复杂度为 O(n)。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode temp = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/翻转二叉树/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素2</title>
    <url>/2019/12/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">存在重复元素2（难度：简单）</a></p>
<p><img src="/2019/12/29/存在重复元素2/1.jpg" alt="1"></p>
<h4><span id="方法哈希表">方法：哈希表</span></h4><p>维护一个哈希表，里面始终最多包含 k 个元素，当出现重复值时则说明在 k 距离内存在重复元素。<br>每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 k，则移除最前面的数字。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。我们会做 n 次 搜索，删除，插入操作，每次操作都耗费常数时间。</p>
<p>空间复杂度：O(min(n,k))。开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 因为res的大小维持为k</span></span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.size()&gt;k)</span><br><span class="line">                res.remove(nums[i-k]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/存在重复元素2/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2019/12/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素（难度：简单）</a></p>
<p><img src="/2019/12/29/存在重复元素/1.jpg" alt="1"></p>
<h4><span id="方法一哈希表">方法一：哈希表</span></h4><h5><span id="复杂度">复杂度</span></h5><p>时间复杂度 : O(n)。search() 和 insert() 各自使用 n 次，每个操作耗费常数时间。</p>
<p>空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(num))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            res.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/存在重复元素/3.jpg" alt="3"></p>
<p>另一种思路：利用Python中的set()，判断所得结果长度与原数组长度的关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(set1) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/存在重复元素/2.jpg" alt="2"></p>
<hr>
<h4><span id="方法二-排序">方法二： 排序</span></h4><p>如果存在重复元素，排序后它们应该相邻。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度 : O<em>(</em>nlogn)。</p>
<p>空间复杂度 : O(1)。这取决于具体的排序算法实现，通常而言，使用 <code>堆排序</code> 的话，是 O(1)。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/存在重复元素/4.jpg" alt="4"></p>
<blockquote>
<p>注：对于一些特定的 n不太大的测试样例，方法一的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 <strong>充分</strong>大的输入下，算法的相对快慢。因此，在 n不够大的情况下， O(n)的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第K个最大元素</title>
    <url>/2019/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素（难度：中等）</a></p>
<p><img src="/2019/12/29/数组中的第K个最大元素/3.jpg" alt="3"></p>
<h4><span id="方法一排序">方法一：排序</span></h4><p>先对数组进行排序，再返回倒数第 k 个元素。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<p>这个时间复杂度并不令人满意</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/数组中的第K个最大元素/1.jpg" alt="1"></p>
<hr>
<h4><span id="方法二最小堆">方法二：最小堆</span></h4><p>建一个只能存K个数字的小顶堆，超过K时候，每加进来一个，堆顶就要弹出一个。数组遍历完，最终堆顶的元素就是第K大的（堆里其他元素都比它还要大）。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(nlogk). 向大小为 k 的堆中添加元素的时间复杂度为O(logk)，我们将重复该操作 n 次，故总时间复杂度为O(nlogk)。</p>
<p>空间复杂度：O(k).</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size()&gt;k)</span><br><span class="line">                minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.poll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/29/数组中的第K个最大元素/2.jpg" alt="2"></p>
<hr>
<h4><span id="方法三快速选择">方法三：快速选择</span></h4><p>详见<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode/" target="_blank" rel="noopener">这里</a>.</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度 : 平均情况O<em>(</em>N)，最坏情况 O(N^2)。</p>
<p>空间复杂度 : O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2019/12/29/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素（难度：简单）</a></p>
<p><img src="/2019/12/29/移除链表元素/1.jpg" alt="1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：添加虚拟头节点解决头节点是要被删除的情况</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数</title>
    <url>/2019/12/28/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">快乐数（难度：简单）</a></p>
<p><img src="/2019/12/28/快乐数/2.jpg" alt="2"></p>
<h4><span id="方法一使用快慢指针思想找出循环">方法一：使用“快慢指针”思想找出循环</span></h4><p>“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n;</span><br><span class="line">        <span class="keyword">int</span> fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = helper(slow);</span><br><span class="line">            fast = helper(fast);</span><br><span class="line">            fast = helper(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> re = n%<span class="number">10</span>;</span><br><span class="line">            sum += re*re;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/快乐数/1.jpg" alt="1"></p>
<hr>
<h4><span id="方法二递归">方法二：递归</span></h4><ul>
<li>不是快乐数的数称为不快乐数(unhappy number)，所有不快乐数的数位平方和计算，最后都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中</li>
<li>已知规律： [1 ~ 4] 中只有 1 是快乐数，[5 ~ ∞] 的数字要么回归到 1 要么回归到 4 或 3</li>
<li>因此仅需在 n &gt; 4 时调用递归</li>
</ul>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.isHappy(sum(int(i) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> str(n))) <span class="keyword">if</span> n &gt; <span class="number">4</span> <span class="keyword">else</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/快乐数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>求众数2</title>
    <url>/2019/12/28/%E6%B1%82%E4%BC%97%E6%95%B02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">求众数2（难度：中等）</a></p>
<p><img src="/2019/12/28/求众数2/1.jpg" alt="1"></p>
<h4><span id="方法一">方法一：</span></h4><p>在Python中，先用set()找出所有出现的元素，再使用count()判断出现次数大于n/3的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">return</span> [s <span class="keyword">for</span> s <span class="keyword">in</span> set1 <span class="keyword">if</span> nums.count(s) &gt; len(nums)//<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/求众数2/2.jpg" alt="2"></p>
<p>然而时间复杂度不为O(n)。</p>
<hr>
<h4><span id="方法二boyer-moore-投票算法">方法二：Boyer-Moore 投票算法</span></h4><p>超过n/3的数最多只能有两个。先选出两个候选人A,B（都令为nums[0]）。 遍历数组：</p>
<ol>
<li><p>若当前元素等于A，则A的票数++;</p>
</li>
<li><p>若当前元素等于B，则B的票数++；</p>
</li>
<li><p>若当前元素与A，B都不相等，那么检查此时A或B的票数是否减为0：</p>
<ul>
<li><p>若为0，则当前元素成为新的候选人；</p>
</li>
<li><p>若A、B票数均不为0，则A、B两个候选人的票数均减一；</p>
</li>
</ul>
</li>
</ol>
<p>遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt;n//3，还需要再遍历一遍数组，找出两个候选人的具体票数。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p><strong>代码</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span>(len(nums)==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        count1 = <span class="number">0</span></span><br><span class="line">        count2 = <span class="number">0</span></span><br><span class="line">        candidate1 = nums[<span class="number">0</span>]</span><br><span class="line">        candidate2 = nums[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == candidate1:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num == candidate2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> count1 == <span class="number">0</span>:</span><br><span class="line">                    candidate1 = num</span><br><span class="line">                    count1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                    candidate2 = num</span><br><span class="line">                    count2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count1 -= <span class="number">1</span>;</span><br><span class="line">                    count2 -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> set([num <span class="keyword">for</span> num <span class="keyword">in</span> [candidate1, candidate2] <span class="keyword">if</span> nums.count(num) &gt; len(nums)//<span class="number">3</span>]) <span class="comment">#加set的原因是避免返回两个相同的数</span></span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/求众数2/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2019/12/28/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素（难度：简单）</a></p>
<p><img src="/2019/12/28/多数元素/1.jpg" alt="1"></p>
<p><strong>注意：这样的元素只存在一个，因为出现次数大于n/2，若存在两个，则数组长度会超过n。</strong></p>
<h4><span id="方法一">方法一：</span></h4><p>在Python中，先用set()找出所有出现的元素，再使用count()判断出现次数大于n/2的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> nums.count(s) &gt; len(nums)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/多数元素/2.jpg" alt="2"></p>
<hr>
<h4><span id="方法二">方法二：</span></h4><p>先排序，再返回位于n/2位置的元素。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(nlogn)。用 Python 和 Java 将数组排序开销都为 O(nlogn)，它占据了运行的主要时间。</p>
<p>空间复杂度：O(1)或O(n)。就地排序或使用线性空间将 <code>nums</code> 数组拷贝，然后再排序。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/多数元素/3.jpg" alt="3"></p>
<hr>
<h4><span id="方法三boyer-moore-投票算法">方法三：Boyer-Moore 投票算法</span></h4><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，最后总能找到最多的那个。</p>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n)。严格执行了 n 次循环。</p>
<p>空间复杂度：O(1)。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        candidate = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            <span class="keyword">if</span> num==candidate:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/多数元素/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找峰值</title>
    <url>/2019/12/28/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">寻找峰值（难度：中等）</a></p>
<p><img src="/2019/12/28/寻找峰值/1.jpg" alt="1"></p>
<h4><span id="方法一线性扫描">方法一：线性扫描</span></h4><p>利用连续的两个元素 <code>nums[j]</code> 和 <code>nums[j+1]</code> 不会相等这一事实，我们可以从头开始遍历 <code>nums</code>数组，当遇到<code>nums[i] &gt; nums[i+1]</code> ，即可判断 <code>nums[i]</code>为峰值。</p>
<p><strong>注意：不需要判断<code>nums[i]&gt;nums[i-1]</code>。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第i- 1个）不满足 <code>nums[i] &gt; nums[i+1]</code>这一条件，也就说明 <code>nums[i-1] &lt; nums[i]</code>。</strong></p>
<h5><span id="复杂度分析">复杂度分析</span></h5><p>时间复杂度 : O(n)。  只进行一次遍历。<br>空间复杂度 : O(1)。 只使用了常数空间。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4><span id="方法二二分法查找">方法二：二分法查找</span></h4><h5><span id="复杂度分析">复杂度分析</span></h5><p>时间复杂度 : O(logn)。  每一步都将搜索空间减半。<br>空间复杂度 : O(1)。 只使用了常数空间。</p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="comment">// 往左搜索</span></span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[mid+<span class="number">1</span>]) <span class="comment">// 往右搜索</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/寻找峰值/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最长重复子数组</title>
    <url>/2019/12/28/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组（难度：中等）</a></p>
<p><img src="/2019/12/28/最长重复子数组/1.jpg" alt="1"></p>
<h4><span id="方法动态规划">方法：动态规划</span></h4><blockquote>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>设 <code>dp[i][j]</code>为 <code>A[i:]</code> 和 <code>B[j:]</code> 的最长公共前缀，那么答案为所有 <code>dp[i][j]</code> 中的最大值 <code>max(dp[i][j])</code>。若 <code>A[i] == B[j]</code>，状态转移方程为 <code>dp[i][j] = dp[i + 1][j + 1] + 1</code>，否则为 <code>dp[i][j] = 0</code>。</p>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(M*N)，其中 M和 N是数组 A 和 B 的长度。<br>空间复杂度：O(M*N)，即为数组 <code>dp</code> 使用的空间。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][B.length+<span class="number">1</span>]; <span class="comment">// 长度加1是为了后面的dp[i+1][j+1]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = B.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/28/最长重复子数组/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续1的个数</title>
    <url>/2019/12/27/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">最大连续1的个数（难度：简单）</a></p>
<p><img src="/2019/12/27/最大连续1的个数/1.jpg" alt="1"></p>
<h4><span id="方法一一次遍历">方法一：一次遍历</span></h4><p><img src="/2019/12/27/最大连续1的个数/2.jpg" alt="2"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)。N是数组的长度。</li>
<li>空间复杂度：O(1)，仅仅使用了 <code>count</code> 和 <code>maxCount</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        maxcount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                maxcount = max(maxcount, count)</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(maxcount,count)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/27/最大连续1的个数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>区域和检索 - 数组不可变</title>
    <url>/2019/12/27/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变（难度：简单）</a></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/1.jpg" alt="1"></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/2.jpg" alt="2"></p>
<hr>
<h5><span id="方法二-缓存">方法二： 缓存</span></h5><p><img src="/2019/12/27/区域和检索-数组不可变/3.jpg" alt="3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>]; <span class="comment">// 多增加一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 sumrange 函数中进行额外的条件检查。</p>
</blockquote>
<p><img src="/2019/12/27/区域和检索-数组不可变/4.jpg" alt="4"></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2019/12/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列（难度：中等）</a></p>
<p><img src="/2019/12/27/最长上升子序列/1.jpg" alt="1"></p>
<h4><span id="方法动态规划">方法：动态规划</span></h4><p><img src="/2019/12/27/最长上升子序列/2.jpg" alt="2"></p>
<p><img src="/2019/12/27/最长上升子序列/3.jpg" alt="3"></p>
<p><img src="/2019/12/27/最长上升子序列/4.jpg" alt="4"></p>
<h4><span id="代码">代码</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = Math.max(dp[i], <span class="number">1</span> + dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/27/最长上升子序列/5.jpg" alt="5"></p>
<h5><span id="进阶将时间复杂度降低到onlogn-使用贪心算法二分查找">进阶：将时间复杂度降低到O(nlogn)。 使用贪心算法+二分查找</span></h5>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2019/12/27/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数（难度：中等）</a></p>
<p><img src="/2019/12/27/完全平方数/1.jpg" alt="1"></p>
<h4><span id="方法一动态规划">方法一：动态规划</span></h4><p>dp[i]表示i最少可以由几个平方数构成。</p>
<p>初试化dp=[0,1,2,…, n]，长度为n+1，最多次数就是全由1构成。</p>
<p>遍历dp，对于i，遍历区间[1,n]：</p>
<p>​        遍历所有平方数小于i的数j，遍历区间[1, sqrt(i)]</p>
<p>动态转移方程：</p>
<blockquote>
<p> dp[i] = min(dp[i], dp[i - j * j]+1)，i表示当前数字，j*j表示平方数</p>
</blockquote>
<h5><span id="复杂度">复杂度</span></h5><p>时间复杂度：O(n*sqrt(n))</p>
<p>空间复杂度：O(n)</p>
<h4><span id="代码">代码</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">//dp[i]存放的是i最少可以由几个平方数构成， 初始化为[0,1,...,n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i-j*j &gt;= <span class="number">0</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/27/完全平方数/2.jpg" alt="2"></p>
<hr>
<h4><span id="方法二广度优先搜索bfs">方法二：广度优先搜索（BFS）</span></h4><p><img src="/2019/12/27/完全平方数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子序列</title>
    <url>/2019/12/26/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子序列（难度：中等）</a></p>
<p><img src="/2019/12/26/乘积最大子序列/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/乘积最大子序列/2.jpg" alt="2"></p>
<blockquote>
<p><strong>注意：不能只保存到当前为止的最大值，还需保存到当前为止的最小值，因为若下一个数是负数，那么以前的最小值（若为负数）会变成现在的最大值</strong>.</p>
</blockquote>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> imax = nums[<span class="number">0</span>], imin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = imin;</span><br><span class="line">                imin = imax;</span><br><span class="line">                imax = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            imax = Math.max(imax*nums[i], nums[i]);</span><br><span class="line">            imin = Math.min(imin*nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(ans,imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/26/乘积最大子序列/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中的下一个更大节点</title>
    <url>/2019/12/26/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">链表中的下一个更大节点（难度：中等）</a></p>
<p><img src="/2019/12/26/链表中的下一个更大节点/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/链表中的下一个更大节点/2.jpg" alt="2"></p>
<h4><span id="方法单调栈">方法：单调栈</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 栈里存放索引</span></span><br><span class="line">            arr2[length] = head.val;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; arr2[stack.peek()] &lt; head.val)&#123;</span><br><span class="line">                arr[stack.pop()] = head.val;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(length);</span><br><span class="line">            head = head.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/26/链表中的下一个更大节点/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素2</title>
    <url>/2019/12/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素2（难度：中等）</a></p>
<p><img src="/2019/12/26/下一个更大元素2/1.jpg" alt="1"></p>
<h4><span id="方法单调栈">方法：单调栈</span></h4><h4><span id="思路">思路</span></h4><p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？</p>
<p>首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = arr.length, index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    print(arr[index % n]);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：<strong>这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边。</strong></p>
<p>我们可以考虑这样的思路：<strong>将原始数组 “翻倍”，</strong>就是在后面再接一个原始数组，这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。</p>
<p><img src="https://pic.leetcode-cn.com/c6dda3c6d50dddbd4518619829834235a8f84be0f34f3b32974ad6d8e76cc3b1-file_1560500960943" alt="ink-image (2)"></p>
<h4><span id="复杂度">复杂度</span></h4><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h4><span id="代码">代码</span></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// i从2*n-1开始</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() &lt;= nums[i%n])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i%n] = stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2019/12/26/下一个更大元素2/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍3</title>
    <url>/2019/12/26/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍3（难度：中等）</a></p>
<p><img src="/2019/12/26/打家劫舍3/1.jpg" alt="题目"></p>
<p>以下内容转载自：</p>
<blockquote>
<p>作者：reals<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过3个方法不断递进解决问题</p>
<ul>
<li>解法1通过递归实现，虽然解决了问题，但是复杂度太高</li>
<li>解法2通过解决方法1中的重复子问题，实现了性能的百倍提升</li>
<li>解法3 直接省去了重复子问题，性能又提升了一步</li>
</ul>
<p><img src="/2019/12/26/打家劫舍3/2.jpg" alt="2"></p>
<p><img src="/2019/12/26/打家劫舍3/3.jpg" alt="3"></p>
<p><img src="/2019/12/26/打家劫舍3/4.jpg" alt="4"></p>
<p><img src="/2019/12/26/打家劫舍3/5.jpg" alt="5"></p>
<p><img src="/2019/12/26/打家劫舍3/6.jpg" alt="6"></p>
<p><img src="/2019/12/26/打家劫舍3/7.jpg" alt="7"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍2</title>
    <url>/2019/12/26/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍2（难度：中等）</a></p>
<p><img src="/2019/12/26/打家劫舍2/%E9%A2%98%E7%9B%AE.jpg" alt="题目"></p>
<h4><span id="思路">思路</span></h4><p><strong>此题是 <a href>198. 打家劫舍</a> 的拓展版：</strong> 唯一的区别是此题中的房间是<strong>环状排列</strong>的（即首尾相接），而 198 题中的房间是<strong>单排排列</strong>的。</p>
<p><img src="/2019/12/26/打家劫舍2/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/打家劫舍2/2.jpg" alt="2"></p>
<h4><span id="代码">代码</span></h4><p><img src="/2019/12/26/打家劫舍2/3.jpg" alt="3"></p>
<p><img src="/2019/12/26/打家劫舍2/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>创建单链表的头插法与尾插法</title>
    <url>/2019/12/26/%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%B0%BE%E6%8F%92%E6%B3%95/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41028985/article/details/82859199" target="_blank" rel="noopener">原文</a></p>
<h4><span id="头插法创建单链表">头插法创建单链表</span></h4><p><img src="/2019/12/26/创建单链表的头插法与尾插法/1577345110132.jpg" alt="图1"></p>
<p><img src="/2019/12/26/创建单链表的头插法与尾插法/1.jpg" alt="1"></p>
<h4><span id="尾插法创建单链表">尾插法创建单链表</span></h4><p><img src="/2019/12/26/创建单链表的头插法与尾插法/2.jpg" alt="2"></p>
<p><img src="/2019/12/26/创建单链表的头插法与尾插法/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加2</title>
    <url>/2019/12/26/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">两数相加2（难度：中等）</a></p>
<p><img src="/2019/12/26/两数相加2/1577344361644.jpg" alt="题目"></p>
<h4><span id="方法双栈-头插法">方法：双栈 + 头插法</span></h4><p><img src="/2019/12/26/两数相加2/1577344797002.jpg" alt="code"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素1</title>
    <url>/2019/12/25/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素1（难度：简单）</a></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281453752.jpg" alt="题目"></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281497407.jpg" alt="方法"></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281548614.jpg" alt="code"></p>
<h4><span id="图解">图解</span></h4><p><img src="/2019/12/25/下一个更大元素1/20191225-215434.jpg" alt="图解"></p>
<hr>
<h4><span id="另一种写法从后往前">另一种写法（从后往前）</span></h4><p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p><img src="/2019/12/25/下一个更大元素1/1.jpg" alt="1"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(nums.size()); <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。</p>
<p>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。</p>
<p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p>
<h5><span id="本题代码">本题代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; nums2[i]&gt;=stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],stack.empty()?-<span class="number">1</span>:stack.peek());</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums1.length; i++)</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>删除列表中的节点</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除列表中的节点（难度：简单）</a></p>
<p><img src="/2019/12/25/删除列表中的节点/%E6%8D%95%E8%8E%B7.JPG" alt="题目"></p>
<p><img src="/2019/12/25/删除列表中的节点/1577280000099.jpg" alt="方法"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素2</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素2（难度：中等）</a></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577278156148.jpg" alt="题目"></p>
<h4><span id="思路">思路</span></h4><p><img src="/2019/12/25/删除排序链表中的重复元素2/1577278207894.jpg" alt="1577278207894"></p>
<h4><span id="画解">画解</span></h4><p><img src="/2019/12/25/删除排序链表中的重复元素2/20191225-210253.jpg" alt="画解"></p>
<h4><span id="代码">代码</span></h4><p>(Java)</p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577279243671.jpg" alt="code"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577279306551.jpg" alt="结果"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素（难度：简单）</a></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268363569.jpg" alt="题目"></p>
<h4><span id="思路">思路</span></h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268482086.jpg" alt="思路"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268503067.jpg" alt="1577268503067"></p>
<h4><span id="代码">代码</span></h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268572469.jpg" alt="1577268572469"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268850082.jpg" alt="结果"></p>
<h4><span id="画解">画解</span></h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268614488.jpg" alt="画解1"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268643223.jpg" alt="画解2"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268718737.jpg" alt="画解3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文串</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串（难度：简单）</a></p>
<p><img src="/2019/12/25/最长回文串/1577266515330.jpg" alt="题目"></p>
<p><img src="/2019/12/25/最长回文串/20191225-174159.jpg" alt="思路"></p>
<p><img src="/2019/12/25/最长回文串/1577267022201.jpg" alt="code"></p>
<p><img src="/2019/12/25/最长回文串/1577267058050.jpg" alt="结果"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串（难度：中等）</a></p>
<p><img src="/2019/12/25/最长回文子串/0001.jpg" alt="0001"></p>
<p><img src="/2019/12/25/最长回文子串/0002.jpg" alt="0002"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列（难度：中等）</a></p>
<p><img src="/2019/12/25/最长公共子序列/question.JPG" alt="题目"></p>
<h3><span id="方法动态规划">方法：动态规划</span></h3><p><img src="/2019/12/25/最长公共子序列/1.JPG" alt="图1"></p>
<p><img src="/2019/12/25/最长公共子序列/2.JPG" alt="图2"></p>
<h5><span id="代码">代码</span></h5><p><img src="/2019/12/25/最长公共子序列/code.JPG" alt="code"></p>
<p><img src="/2019/12/25/最长公共子序列/3.JPG" alt="图3"></p>
<h5><span id="复杂度">复杂度</span></h5><p>数据复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h4><span id="最长公共子串">最长公共子串</span></h4><p>最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别： <strong>子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续</strong>。例如X = {a, Q, 1, 1}; Y = {a, 1, 1, d, f}那么，{a, 1, 1}是X和Y的最长公共子序列，但不是它们的最长公共字串。</p>
<p><strong>描述：</strong></p>
<p>计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符不区分大小写。</p>
<p><strong>方法</strong></p>
<p>求子串的方法和求子序列方法类似：</p>
<p><img src="/2019/12/25/最长公共子序列/1578644196190.png" alt="1578644196190"></p>
<h5><span id="代码">代码</span></h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n1+<span class="number">1</span>][n2+<span class="number">1</span>]; <span class="comment">//多增加一行一列</span></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    longest = Math.max(longest,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS-Overview</title>
    <url>/2019/12/16/HDFS-Overview/</url>
    <content><![CDATA[<p><img src="/2019/12/16/HDFS-Overview/0001.jpg" alt="0001"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS and MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Introduction</title>
    <url>/2019/12/15/Hadoop-Introduction/</url>
    <content><![CDATA[<h1><span id="history">History</span></h1><p><img src="/2019/12/15/Hadoop-Introduction/hadoop-history.JPG" alt="hadoop-history"></p>
<h1><span id="hadoop-ecosystem">Hadoop Ecosystem</span></h1><p><img src="/2019/12/15/Hadoop-Introduction/hadoop-ecosystem.JPG" alt="hadoop-ecosystem"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hadoop Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Preprocessing</title>
    <url>/2019/09/21/Data-Preprocessing/</url>
    <content><![CDATA[<p>以下内容来自Udemy上的课程: <a href="https://www.udemy.com/machinelearning/" target="_blank" rel="noopener"><strong>Machine Learing A-Z: Hands-On Python &amp; R in Data Science</strong></a>.</p>
<p><a href="https://www.superdatascience.com/pages/machine-learning" target="_blank" rel="noopener">datasets download</a></p>
<p>使用数据：</p>
<p><img src="/2019/09/21/Data-Preprocessing/data.JPG" alt="data"></p>
<h2><span id="1-missing-data">1. Missing data</span></h2><p>Common strategy: replace the missing data by the mean, median, or most frequent value of the feature column.</p>
<h4><span id="python">Python</span></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking care of missing data</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> Imputer</span><br><span class="line">imputer = Imputer(missing_values = <span class="string">'NaN'</span>, strategy = <span class="string">'mean'</span>, axis = <span class="number">0</span>)</span><br><span class="line">imputer = imputer.fit(X[:, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">X[:, <span class="number">1</span>:<span class="number">3</span>] = imputer.transform(X[:, <span class="number">1</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<h4><span id="r">R</span></h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = read.csv(<span class="string">'Data.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking care of missing data</span></span><br><span class="line">dataset$Age = ifelse(is.na(dataset$Age),</span><br><span class="line">                     ave(dataset$Age, FUN = <span class="keyword">function</span>(x) mean(x, na.rm = <span class="literal">TRUE</span>)),</span><br><span class="line">                     dataset$Age)</span><br><span class="line">dataset$Salary = ifelse(is.na(dataset$Salary),</span><br><span class="line">                        ave(dataset$Salary, FUN = <span class="keyword">function</span>(x) mean(x, na.rm = <span class="literal">TRUE</span>)),</span><br><span class="line">                        dataset$Salary)</span><br><span class="line">                        </span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line">dataset$Age = ifelse(is.na(dataset$Age),</span><br><span class="line">                     mean(dataset$Age, na.rm = <span class="literal">TRUE</span>),</span><br><span class="line">                     dataset$Age)</span><br><span class="line"></span><br><span class="line">dataset$Salary = ifelse(is.na(dataset$Salary),</span><br><span class="line">                        mean(dataset$Salary, na.rm = <span class="literal">TRUE</span>),</span><br><span class="line">                        dataset$Salary)</span><br></pre></td></tr></table></figure>

<h2><span id="2-categorical-data">2. Categorical data</span></h2><h4><span id="python">Python</span></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/21/Data-Preprocessing/pic1.JPG" alt="pic1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/21/Data-Preprocessing/pic2.JPG" alt="pic2"></p>
<p>But the model will think that France has higher value than Spain -&gt; that’s not the case, we have no order here. 如果是S, M, L of a T-shirt, 不必使用下面的OneHotEncoder方法</p>
<p><img src="/2019/09/21/Data-Preprocessing/dummy-encoding.JPG" alt="dummy encoding"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="number">0</span>])  <span class="comment"># which column you want to encode</span></span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/21/Data-Preprocessing/result1.JPG" alt="result1"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding the Dependent Variable</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">For the dependent variable, we are only going to use LabelEncoder, </span></span><br><span class="line"><span class="string">because since this is the dpendent variable, the machine learning model will know</span></span><br><span class="line"><span class="string">that it's a category, and that there is no oder between the two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">labelencoder_y = LabelEncoder()</span><br><span class="line">y = labelencoder_y.fit_transform(y)</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/21/Data-Preprocessing/result2.JPG" alt="result2"></p>
<a id="more"></a>

<p>完整代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding categorical data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding the Independent Variable</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="number">0</span>])  <span class="comment"># which column you want to encode</span></span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding the Dependent Variable</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">For the dependent variable, we are only going to use LabelEncoder, </span></span><br><span class="line"><span class="string">because since this is the dpendent variable, the machine learning model will know</span></span><br><span class="line"><span class="string">that it's a category, and that there is no oder between the two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">labelencoder_y = LabelEncoder()</span><br><span class="line">y = labelencoder_y.fit_transform(y)</span><br></pre></td></tr></table></figure>

<h4><span id="r">R</span></h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding categorical data</span></span><br><span class="line">dataset$Country = factor(dataset$Country,</span><br><span class="line">                         levels = c(<span class="string">'France'</span>, <span class="string">'Spain'</span>, <span class="string">'Germany'</span>),</span><br><span class="line">                         labels = c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">dataset$Purchased = factor(dataset$Purchased,</span><br><span class="line">                           levels = c(<span class="string">'No'</span>, <span class="string">'Yes'</span>),</span><br><span class="line">                           labels = c(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/21/Data-Preprocessing/result3.JPG" alt="result3"></p>
<p><img src="/2019/09/21/Data-Preprocessing/result4.JPG" alt="result4"></p>
<h2><span id="3-train_test_split">3. train_test_split</span></h2><h4><span id="python">Python</span></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values <span class="comment"># :-1 -&gt; take all the column except the last one</span></span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4><span id="r">R</span></h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = read.csv(<span class="string">'Data.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="comment"># install.packages('caTools')</span></span><br><span class="line"><span class="keyword">library</span>(caTools)</span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">split = sample.split(dataset$Purchased, SplitRatio = <span class="number">0.8</span>) <span class="comment"># 这里取因变量</span></span><br><span class="line"><span class="comment"># spilt结果为TRUE,FALSE, TRUE -&gt; go to training set, FALSE -&gt; go to test set</span></span><br><span class="line">training_set = subset(dataset, split == <span class="literal">TRUE</span>)</span><br><span class="line">test_set = subset(dataset, split == <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="4-feature-scaling">4. Feature Scaling</span></h2><p>Lots of machine learning models are based on Euclidean distance. Since the salary has a much wider range of values, the eulidean distance will be dominated by the salary. </p>
<p>Even if the machine learning models are not based on euclidean distance, we will still need to do feature scaling, because the algorithms will converge much faster, that will be the case for decision trees.</p>
<p><strong><em>Feature Scaling:</em></strong> Putting our variables in the same range (in the same scale),  so that no varaible is dominated by the other.</p>
<p><img src="/2019/09/21/Data-Preprocessing/feature-scaling.JPG" alt="feature scaling"></p>
<p><strong><em>Question 1: Do we need to fit and transform dummy variables?</em></strong></p>
<p><img src="/2019/09/21/Data-Preprocessing/show1.JPG" alt="show1"></p>
<p>It depends on the context. Depends on how much you want to keep interpretation in your models. Because if we scale dummy variables, it will be good because everything will be on the same scale, it will be good for our predicitons, but we will lose interpretation of knowing which observation belongs to which country.</p>
<p><strong><em>Qustion 2: Do we need to apply feature scaling to y?</em></strong></p>
<p>we don’t need to do it if it is a classification problem  with categorical dependent variable. But for regression, where the dependent variable will take a huge range of values, we will need to apply feature scaling to y as well.</p>
<h4><span id="python">Python</span></h4><p>以下代码中scale了dummy variable</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values <span class="comment"># :-1 -&gt; take all the column except the last one</span></span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Scaling</span></span><br><span class="line"><span class="comment"># most of time we don't need to do feature scaling, beacuse feature scaling is a tool</span></span><br><span class="line"><span class="comment"># included most of time in the machine learning libraries, </span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">X_train = sc_X.fit_transform(X_train)</span><br><span class="line">X_test = sc_X.transform(X_test)</span><br></pre></td></tr></table></figure>

<p>Feature scaling on X_test is the same as the feature scaling on the X_train(scaled on the same bases)</p>
<p><img src="/2019/09/21/Data-Preprocessing/result5.JPG" alt="result5"></p>
<p>The result is between -1 and 1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc_y = StandardScaler()</span><br><span class="line">y_train = sc_y.fit_transform(y_train.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h4><span id="r">R</span></h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="comment"># install.packages('caTools')</span></span><br><span class="line"><span class="keyword">library</span>(caTools)</span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">split = sample.split(dataset$Purchased, SplitRatio = <span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># spilt结果为TRUE,FALSE, TRUE -&gt; go to training set, FALSE -&gt; go to test set</span></span><br><span class="line">training_set = subset(dataset, split == <span class="literal">TRUE</span>)</span><br><span class="line">test_set = subset(dataset, split == <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Scaling</span></span><br><span class="line">training_set = scale(training_set)</span><br><span class="line">test_set = scale(test_set)</span><br></pre></td></tr></table></figure>

<p>直接这样运行会出错：</p>
<p><img src="/2019/09/21/Data-Preprocessing/result6.JPG" alt="result6"></p>
<p><img src="/2019/09/21/Data-Preprocessing/result7.JPG" alt="result7"></p>
<p>We’re going to exclude categories from the feature scaling, we’re not going to apply feature scaling on those columns.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">training_set[,<span class="number">2</span>:<span class="number">3</span>] = scale(training_set[,<span class="number">2</span>:<span class="number">3</span>])</span><br><span class="line">test_set[,<span class="number">2</span>:<span class="number">3</span>] = scale(test_set[,<span class="number">2</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MachineLearningA-Z</tag>
      </tags>
  </entry>
  <entry>
    <title>Python working directory</title>
    <url>/2019/09/17/Python-working-directory/</url>
    <content><![CDATA[<ul>
<li>更改当前路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">"E:/machine learning"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>获取当前路径</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据框操作</title>
    <url>/2019/09/02/dataframe-operation/</url>
    <content><![CDATA[<p>一、创建dataframe</p>
<ul>
<li>法一</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = (&#123;<span class="string">'id'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">'string'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>,<span class="string">'c'</span>]&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>法二（若已有现成的list）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = pd.DataFrame([n_clusters_start, score], columns = [<span class="string">"分类数"</span>, <span class="string">"得分"</span>])</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exclamationCount = <span class="keyword">lambda</span> text: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text <span class="keyword">if</span> x == <span class="string">'!'</span>])</span><br><span class="line">EC = tweet.apply(<span class="keyword">lambda</span> x:exclamationCount(x))</span><br><span class="line">EC = EC.tolist()</span><br><span class="line">questionMarkCount = <span class="keyword">lambda</span> text: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text <span class="keyword">if</span> x == <span class="string">'?'</span>])</span><br><span class="line">QC = tweet.apply(<span class="keyword">lambda</span> x:questionMarkCount(x))</span><br><span class="line">QC = QC.tolist()</span><br><span class="line">dat = pd.DataFrame(&#123;<span class="string">'EC'</span>:EC,<span class="string">'QC'</span>:QC&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eachLetterCount = <span class="keyword">lambda</span> text,letter: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text.lower() <span class="keyword">if</span> x == letter])</span><br><span class="line"></span><br><span class="line">FList = []</span><br><span class="line">pattern = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">  F = tweet.apply(<span class="keyword">lambda</span> x:eachLetterCount(x,i))</span><br><span class="line">  F = F.tolist()</span><br><span class="line">  FList.append(F)</span><br><span class="line"></span><br><span class="line">res = pd.DataFrame(FList)</span><br><span class="line">res = res.transpose()</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">name = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">  name.append(<span class="string">"freqOf "</span> + i)</span><br><span class="line">res.columns = name</span><br></pre></td></tr></table></figure>

<p><img src="/2019/09/02/dataframe-operation/outcome.JPG" alt="结果"></p>
<p>二、数据框拼接（ignore_index = True, 重新分配索引）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 两种方式，concat、 append都可以</span></span><br><span class="line">result = pd.concat([result1, result2], ignore_index = <span class="literal">True</span>) <span class="comment"># 默认axis = 0 -&gt; 粘贴行 </span></span><br><span class="line">result = result1.append(result2, ignore_index = <span class="literal">True</span>) <span class="comment"># 粘贴行</span></span><br><span class="line"></span><br><span class="line">RF_eval = pd.concat([RF_eval, eval_raw], axis = <span class="number">1</span>) <span class="comment"># 粘贴列</span></span><br></pre></td></tr></table></figure>

<p>三、删掉列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RF_eval.drop([<span class="string">'raw'</span>], axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>四、删掉行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = dat.drop(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>五、提取行索引</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index0 = res.index[res[<span class="string">'label'</span>] == <span class="number">0</span>].tolist()</span><br><span class="line">X0 = X[index0] <span class="comment"># X为矩阵</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>读取与保存csv和txt文件</title>
    <url>/2019/09/02/%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98csv%E5%92%8Ctxt%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>一、csv文件</p>
<ol>
<li>读取</li>
</ol>
<ul>
<li><p>法一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">eval_raw = pd.read_csv(<span class="string">'eval-tweets.csv'</span>, sep = <span class="string">'\t'</span>, header = <span class="literal">None</span>)  <span class="comment">#若文件中无列表头 -&gt; header = None</span></span><br><span class="line">eval_raw.columns = [<span class="string">'ID'</span>, <span class="string">'tweet'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>法二：用names指定需要的列表头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">eval_raw = pd.read_csv(<span class="string">'eval-tweets.csv'</span>, sep = <span class="string">'\t'</span>, names = [<span class="string">'ID'</span>,<span class="string">'tweet'</span>])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>保存<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">save = pd.DataFrame(np_data, columns = [<span class="string">'year'</span>, <span class="string">'month'</span>, <span class="string">'day'</span>])</span><br><span class="line">save.to_csv(<span class="string">'E:\test\modified.csv'</span>, index = <span class="literal">False</span>, header = <span class="literal">False</span>) <span class="comment"># index = False, header = False表示不保存行索引和列标题</span></span><br><span class="line"><span class="comment"># save.to_csv("RF_test.csv", index = False)</span></span><br><span class="line"><span class="comment"># save.to_csv("RF_test.csv", sep = '\t', index = False)</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>二、txt文件</p>
<ol>
<li>读取(注：法一和法二都有可能会造成行数缺少或数据分割不正确的现象，建议采用法三)</li>
</ol>
<ul>
<li><p>法一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train = pd.read_table(<span class="string">'train_tweets.txt'</span>, sep = <span class="string">'\t'</span>, header = <span class="literal">None</span>, encoding = <span class="string">"UTF-8"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train = pd.read_fwf(<span class="string">'train_tweets.txt'</span>, sep = <span class="string">'\t'</span>, header = <span class="literal">None</span>, encoding = <span class="string">"UTF-8"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>法三</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">####### example 1 #########</span></span><br><span class="line">ids = []</span><br><span class="line">tweets = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'/content/Twitter-Authorship/train_tweets.txt'</span>, encoding=<span class="string">'utf-8'</span>):</span><br><span class="line">    (id,tweet) = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">    ids.append(id)</span><br><span class="line">    tweets.append(tweet)</span><br><span class="line">train = pd.DataFrame(&#123;<span class="string">"ID"</span>: ids, <span class="string">"tweet"</span>: tweets&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">####### example 2 #########</span></span><br><span class="line">stream = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'dataset.txt'</span>):</span><br><span class="line">    row = [eval(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.strip().split(<span class="string">' '</span>)]</span><br><span class="line">    stream.append(row)</span><br><span class="line">    </span><br><span class="line">arms = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    temp = stream[i][<span class="number">0</span>]</span><br><span class="line">    arms.append(temp)</span><br><span class="line">    </span><br><span class="line">rewards = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    temp = stream[i][<span class="number">1</span>]</span><br><span class="line">    rewards.append(temp)</span><br><span class="line">    </span><br><span class="line">contexts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    contexts.append(stream[i][<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li>保存(方法同csv)<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RF_test.to_csv(<span class="string">"RF_test.txt"</span>, sep = <span class="string">'\t'</span>, index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2019/06/27/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>(本文参考<a href="https://www.markdowntutorial.com/" target="_blank" rel="noopener">Markdown Tutorial</a>)</p>
<h4><span id="1-加粗与斜体">1. 加粗与斜体</span></h4><ul>
<li>斜体：在文本两侧加上一个星号或一个下划线，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_unknown_或*unkown*</span><br></pre></td></tr></table></figure>

<p>效果如下：<em>unknown</em></p>
<ul>
<li>加粗：在文本两侧加上两个星号或两个下划线, 例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__unknown__或**unknown**</span><br></pre></td></tr></table></figure>

<p>效果如下：<strong>unknown</strong></p>
<ul>
<li>注：斜体和加粗可以一起用，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">**_of course_**</span><br></pre></td></tr></table></figure>

<p>效果如下：<strong><em>of course</em></strong></p>
<h4><span id="2标题headers">2.标题(Headers)</span></h4><p>在前面加#号, 一共有六级标题。一级标题为在前面加一个#号（# 一级标题），二级标题为在前面加两个#号（## 二级标题）。效果如下：</p>
<blockquote>
<h1><span id="header-one">Header one</span></h1><h2><span id="header-two">Header two</span></h2><h3><span id="header-three">Header three</span></h3><h4><span id="header-four">Header four</span></h4><h5><span id="header-five">Header five</span></h5><h6><span id="header-six">Header six</span></h6><p>plain text</p>
</blockquote>
<p>注：#号与文本之间有一个空格。</p>
<h4><span id="3链接">3.链接</span></h4><ul>
<li><p>inline link</p>
<p>语法如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Visit GitHub!](www.github.com)</span><br></pre></td></tr></table></figure>

<p><a href="www.github.com">Visit GitHub!</a></p>
<p>再比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Yo<span class="string">u're **really, really** going to see this.](www.dailykitten.com)</span></span><br></pre></td></tr></table></figure>

<p><a href="www.dailykitten.com">You’re <strong>really, really</strong> going to see this.</a></p>
<ul>
<li>reference link</li>
</ul>
<p>语法如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do you want to [see something fun][a fun place]?  </span><br><span class="line"></span><br><span class="line">Well, I have [a website <span class="keyword">for</span> you][another fun place]!</span><br><span class="line"></span><br><span class="line">[a fun place]: www.zombo.com</span><br><span class="line">    </span><br><span class="line">[another fun place]: www.stumbleupon.com</span><br></pre></td></tr></table></figure>

<p>效果如下：<br>Do you want to <a href="www.zombo.com">see something fun</a>?  </p>
<p>Well, I have <a href="www.stumbleupon.com">a website for you</a>!</p>
<p>一般可将链接地址写在Markdown文件的最后。使用refrence的好处是如果有许多链接都是指向一个地方，那么需要更改的时候只需要修改一次就行了。</p>
<h4><span id="4图片">4.图片</span></h4><ul>
<li>inline link</li>
</ul>
<p>插入图片和插入链接类似，语法如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">![A pretty tiger](https://upload.wikimedia.org/wikipedia/commons/<span class="number">5</span>/<span class="number">56</span>/Tiger<span class="number">.50</span>.jpg)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Tiger.50.jpg" alt="A pretty tiger"></p>
<p>注：</p>
<ol>
<li>[ ]中的内容可以空着，当网络不好，图片无法显示时（或某些其它原因）会显示[ ]中的文字</li>
<li>!和[ ]之间不要加空格</li>
</ol>
<ul>
<li>reference link</li>
</ul>
<p>语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">![Black cat][Black]</span><br><span class="line"></span><br><span class="line">![Orange cat][Orange]</span><br><span class="line"></span><br><span class="line">[Black]: https://upload.wikimedia.org/wikipedia/commons/a/a3/<span class="number">81</span>_INF_DIV_SSI.jpg  </span><br><span class="line">        </span><br><span class="line">[Orange]:http://icons.iconarchive.com/icons/google/noto-emoji-animals-nature/<span class="number">256</span>/<span class="number">22221</span>-cat-icon.png</span><br></pre></td></tr></table></figure>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a3/81_INF_DIV_SSI.jpg" alt="Black cat"></p>
<p><img src="http://icons.iconarchive.com/icons/google/noto-emoji-animals-nature/256/22221-cat-icon.png" alt="Orange cat"></p>
<h4><span id="5blockquotes">5.Blockquotes</span></h4><p>当想引用一段话并让读者注意到时，可以采用如下方法：在文本前加上”&gt;”</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="string">"In a few moments he was barefoot, his stockings folded in his pockets and his</span></span><br><span class="line"><span class="string">  canvas shoes dangling by their knotted laces over his shoulders and, picking a</span></span><br><span class="line"><span class="string">  pointed salt-eaten stick out of the jetsam among the rocks, he clambered down</span></span><br><span class="line"><span class="string">  the slope of the breakwater."</span></span><br></pre></td></tr></table></figure>

<p> 效果如下：</p>
<blockquote>
<p>“In a few moments he was barefoot, his stockings folded in his pockets and his<br>  canvas shoes dangling by their knotted laces over his shoulders and, picking a<br>  pointed salt-eaten stick out of the jetsam among the rocks, he clambered down<br>  the slope of the breakwater.”</p>
</blockquote>
<p>当引用多段话时，可以在每一部分前加上”&gt;”，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; His words seemed to have struck some deep chord <span class="keyword">in</span> his own nature. Had he spoken</span><br><span class="line">of himself, of himself as he was or wished to be? Stephen watched his face for some</span><br><span class="line">moments <span class="keyword">in</span> silence. A cold sadness was there. He had spoken of himself, of his own</span><br><span class="line">loneliness which he feared.  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; —Of whom are you speaking? Stephen asked at length.  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; Cranly did <span class="keyword">not</span> answer.</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>His words seemed to have struck some deep chord in his own nature. Had he spoken<br>of himself, of himself as he was or wished to be? Stephen watched his face for some<br>moments in silence. A cold sadness was there. He had spoken of himself, of his own<br>loneliness which he feared.</p>
<p>—Of whom are you speaking? Stephen asked at length.</p>
<p>Cranly did not answer.</p>
</blockquote>
<p>Note: even blank lines must contain the caret character. This ensures that the entire blockquote is grouped together.</p>
<h4><span id="6列表lists">6.列表(Lists)</span></h4><h4><span id="unordered-list">* unordered list</span></h4><p>在前面加星号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* Milk  </span><br><span class="line">* Eggs  </span><br><span class="line">* Salmon  </span><br><span class="line">* Butter</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>Milk</li>
<li>Eggs</li>
<li>Salmon</li>
<li>Butter</li>
</ul>
<h5><span id="odered-list">* odered list</span></h5><p>在前面加数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Crack three eggs over a bowl</span><br><span class="line"><span class="number">2.</span> Pour a gallon of milk into the bowl</span><br><span class="line"><span class="number">3.</span> Rub the salmon vigorously <span class="keyword">with</span> butter</span><br><span class="line"><span class="number">4.</span> Drop the salmon into the egg-milk bowl</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>Crack three eggs over a bowl</li>
<li>Pour a gallon of milk into the bowl</li>
<li>Rub the salmon vigorously with butter</li>
<li>Drop the salmon into the egg-milk bowl</li>
</ol>
<h5><span id="nest-one-list-within-another">* nest one list within another</span></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* Tintin</span><br><span class="line"> * A reporter</span><br><span class="line"> * Has poofy orange hair</span><br><span class="line"> * Friends <span class="keyword">with</span> the world<span class="string">'s most awesome dog</span></span><br><span class="line"><span class="string">* Haddock</span></span><br><span class="line"><span class="string"> * A sea captain</span></span><br><span class="line"><span class="string"> * Has a fantastic beard</span></span><br><span class="line"><span class="string"> * Loves whiskey</span></span><br><span class="line"><span class="string">   * Possibly also scotch?</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Tintin<ul>
<li>A reporter</li>
<li>Has poofy orange hair</li>
<li>Friends with the world’s most awesome dog</li>
</ul>
</li>
<li>Haddock<ul>
<li>A sea captain</li>
<li>Has a fantastic beard</li>
<li>Loves whiskey<ul>
<li>Possibly also scotch?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议最多建三层，否则文章结构会变得太混乱</p>
<h4><span id="7段落">7.段落</span></h4><ul>
<li>hard break</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do I contradict myself?</span><br><span class="line"></span><br><span class="line">Very well then I contradict myself,</span><br><span class="line"></span><br><span class="line">(I am large, I contain multitudes.)</span><br></pre></td></tr></table></figure>

<p>想换行时，空一行。效果如下：</p>
<p>Do I contradict myself?</p>
<p>Very well then I contradict myself,</p>
<p>(I am large, I contain multitudes.)</p>
<ul>
<li>soft break</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do I contradict myself?··</span><br><span class="line">Very well then I contradict myself,··</span><br><span class="line">(I am large, I contain multitudes.)</span><br></pre></td></tr></table></figure>

<p>想换行时，打两个空格。上面每个点 ( · ) 代表一个空格。效果如下：</p>
<p>Do I contradict myself?<br>Very well then I contradict myself,<br>(I am large, I contain multitudes.)</p>
<h4><span id="8-latex数学表达式">8. LaTex数学表达式</span></h4><p>在Markdown文档中，可以使用<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a>符号创建数学表达式。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">y = \frac&#123;a&#125;&#123;b+c&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>

<p>$$<br>y = \frac{a}{b+c}<br>$$</p>
<p>注：可能有的Markdown软件不支持Latex公式。</p>
<h4><span id="9-typora中字体颜色">9. Typora中，字体颜色</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style=&apos;color:red&apos;&gt;This is red&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p><span style="color:red">This is red</span></p>
<p>以上，本文介绍了一些基础的Markdown语法，想了解更多的Markdown知识可查询相关资料。</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook中的快捷键</title>
    <url>/2019/06/27/Jupyter-Notebook%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<ul>
<li>shift+enter: 运行代码块</li>
<li>shift+tab: show the documentation pop up for the method</li>
<li>Esc+m: markdown语句</li>
</ul>
]]></content>
      <categories>
        <category>Jupyter Notebook</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced Python Types</title>
    <url>/2019/06/27/Advanced-Python-Types/</url>
    <content><![CDATA[<ul>
<li>List</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure>

<pre><code>[1, 2, 3]</code></pre><p><img src="/2019/06/27/Advanced-Python-Types/1578053721585.jpg" alt="1578053721585"></p>
<p>List的拼接</p>
<p>注意：[1,2]是List不是Array（Array要用np.array()）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> chain</span><br><span class="line">features = []</span><br><span class="line"><span class="keyword">for</span> (vec, wt) <span class="keyword">in</span> vecs_wt[<span class="number">0</span>:<span class="number">2</span>]:</span><br><span class="line">	features.append(vec)</span><br><span class="line">	newfeatures = list(chain(*features))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>] + [<span class="number">3</span>] + [<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<pre><code>[1, 2, 3, 4]</code></pre><p>排序：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578053775703.jpg" alt="1578053775703"></p>
<ul>
<li><p>Tuple</p>
<p>Tuples are a lot like lists, but the main difference is that they are <strong>immutable</strong>. Once you create a tuple, you can’t change them.</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054069373.jpg" alt="1578054069373"></p>
</li>
</ul>
<ul>
<li><p>Dictionary</p>
<p>In other languages, you might know this as a map, or a hash table. It’s basically a lookup table, where you store values associated with some unique set of key values.</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'foo'</span>:<span class="number">1</span>, <span class="string">'bar'</span>:<span class="number">2.3</span>, <span class="string">'s'</span>:<span class="string">'my first dictionary'</span>&#125;</span><br><span class="line">print(d)</span><br></pre></td></tr></table></figure>

<pre><code>{&apos;s&apos;: &apos;my first dictionary&apos;, &apos;bar&apos;: 2.3, &apos;foo&apos;: 1}</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(d[<span class="string">'foo'</span>])</span><br></pre></td></tr></table></figure>

<pre><code>1</code></pre><p><img src="/2019/06/27/Advanced-Python-Types/1578054637299.jpg" alt="1578054637299"></p>
<p>If you try to retrieve a value for a key that doesn’t exist, you will get an exception. </p>
<p>One way to avoid that is to use the <em>get</em> function on the dictionary:</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054512678.jpg" alt="1578054512678"></p>
<p>Iterate:</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054588653.jpg" alt="1578054588653"></p>
<ul>
<li>Array</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(np.array([<span class="number">1</span>,<span class="number">2</span>]))</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[1 2]</span><br></pre></td></tr></table></figure>

<p>Array的合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.concatenate(要拼接的多个数组, axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的简单语法</title>
    <url>/2019/06/27/basic-python-type/</url>
    <content><![CDATA[<p><strong><em>缩进是python的灵魂</em></strong></p>
<ul>
<li>查看内置函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dir(__builtins)</span><br></pre></td></tr></table></figure>

<ul>
<li>逻辑运算符</li>
</ul>
<p><img src="/2019/06/27/basic-python-type/logic-operator.jpg" alt="逻辑运算符"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[(df[<span class="string">'id'</span>]&gt;=<span class="number">1</span>) &amp;&amp; (df[<span class="string">'id'</span>]&lt;=<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>

<ul>
<li>比较操作符</li>
</ul>
<blockquote>
<p>&gt;, &lt;, &gt;=, &lt;=, ==, != </p>
</blockquote>
<ul>
<li>Python中的双引号</li>
</ul>
<p>Python中双引号和单引号作用一样，即字符串可以用单引号也可以用双引号</p>
<ul>
<li>type()函数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line">type(i)</span><br></pre></td></tr></table></figure>

<pre><code>int</code></pre><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">n = <span class="literal">None</span></span><br><span class="line">type(n)</span><br></pre></td></tr></table></figure>

<pre><code>NoneType</code></pre><ul>
<li>dtype</li>
</ul>
<p>查看type</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">"ID"</span>].dtype</span><br></pre></td></tr></table></figure>

<blockquote>
<p>dtype(‘O’)</p>
</blockquote>
<p>转换type</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">"ID"</span>] = train[<span class="string">"ID"</span>].astype(np.int32)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>test blog</title>
    <url>/2019/06/26/test-blog/</url>
    <content><![CDATA[<p>一篇测试文章.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/06/26/hello-world/</url>
    <content><![CDATA[<a id="more"></a>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
