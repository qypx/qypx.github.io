<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>&#39;Python中运行linux命令&#39;</title>
    <url>/2022/05/17/Python%E4%B8%AD%E8%BF%90%E8%A1%8Clinux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="https://www.cnblogs.com/cwp-bg/p/8465566.html" target="_blank" rel="noopener">https://www.cnblogs.com/cwp-bg/p/8465566.html</a></p>
</blockquote>
<h3 id="os的system原理"><a href="#os的system原理" class="headerlink" title="os的system原理"></a>os的system原理</h3><p>system函数可以将字符串转化成命令在服务器上运行；其原理是每一条system函数执行时，其会创建一个子进程在系统上执行命令行，子进程的执行结果无法影响主进程；</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'mkdir /usr/local'</span>)</span><br></pre></td></tr></table></figure>
<p>使用system执行多条命令时，为保证命令可以成功，多条命令需要在同一个子进程中运行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'cd /usr/local &amp;&amp; mkdir aaa.txt'</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">os.system(<span class="string">'cd /usr/local ; mkdir aaa.txt'</span>)</span><br></pre></td></tr></table></figure>
<p>↑如果写在两个system()中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.system(<span class="string">'cd /usr/local'</span>)</span><br><span class="line">os.mkdir(<span class="string">'aaa.txt)</span></span><br></pre></td></tr></table></figure>
<p>会发现txt文件并没有创建在/usr/local文件夹下，而是在当前的目录下</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于python2与python3使用上的差异</title>
    <url>/2022/01/05/%E5%85%B3%E4%BA%8Epython2%E4%B8%8Epython3%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%9A%84%E5%B7%AE%E5%BC%82/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>主要对比版本：python27与python36</p>
<h4 id="1-关于copy"><a href="#1-关于copy" class="headerlink" title="1. 关于copy()"></a>1. 关于copy()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">values2 = values.copy()</span><br></pre></td></tr></table></figure>
<p>python3中没问题，python2中报错：</p>
<p><img src="/2022/01/05/关于python2与python3使用上的差异/image-20220105160555692.png" alt="image-20220105160555692"></p>
<p>解决方法：改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values2 = list(values)</span><br><span class="line"><span class="comment"># 或 values2 = values[:]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-Python2-不支持中文问题"><a href="#2-Python2-不支持中文问题" class="headerlink" title="2. Python2 不支持中文问题"></a>2. Python2 不支持中文问题</h4><p>创建test.py程序如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;你好&quot;)</span><br></pre></td></tr></table></figure>
<p>python3运行时，输出 你好，python2运行时，输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SyntaxError: Non-ASCII character &apos;\xe4&apos; in file e:/pycharmProject/ml_module/main5.py on line 7, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details</span><br></pre></td></tr></table></figure>
<p>解决方法：在python文件最开头加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="3-关于除法"><a href="#3-关于除法" class="headerlink" title="3. 关于除法"></a>3. 关于除法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(2/3)</span><br><span class="line"></span><br><span class="line">python3中：0.6666666666666666</span><br><span class="line">pyhon2中：0</span><br></pre></td></tr></table></figure>
<p>python2中的除法等价于python3中的//</p>
<p>解决方法：</p>
<p>法一：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;float(2)/3</span><br><span class="line">0.6666666666666666</span><br><span class="line"></span><br><span class="line">不能直接float()的，例如array等，可.astype(float) </span><br><span class="line">float 应该是等价于 &quot;float64&quot;</span><br><span class="line">int 应该是等价于 &quot;int32&quot;</span><br></pre></td></tr></table></figure>
<p>法二：更简单的方法：</p>
<blockquote>
<p>参考 <a href="https://stackoverflow.com/questions/21316968/division-in-python-2-7-and-3-3" target="_blank" rel="noopener">Division in Python 2.7. and 3.3 - Stack Overflow</a></p>
</blockquote>
<p>在python文件的最开头加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from __future__ import division</span><br></pre></td></tr></table></figure>
<p>例：</p>
<p><img src="/2022/01/05/关于python2与python3使用上的差异/image-20220105162421744.png" alt="image-20220105162421744"></p>
<h4 id="4-关于在python3环境中保存，python2环境中读取文件"><a href="#4-关于在python3环境中保存，python2环境中读取文件" class="headerlink" title="4. 关于在python3环境中保存，python2环境中读取文件"></a>4. 关于在python3环境中保存，python2环境中读取文件</h4><p>详见 <a href="https://qypx.github.io/2019/09/02/%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98csv%E5%92%8Ctxt%E6%96%87%E4%BB%B6/">读取与保存csv和txt文件</a></p>
<h4 id="5-关于python2与python3中可变参数的差异"><a href="#5-关于python2与python3中可变参数的差异" class="headerlink" title="5. 关于python2与python3中可变参数的差异"></a>5. 关于python2与python3中可变参数的差异</h4><p>详见 <a href="https://qypx.github.io/2021/10/12/%E5%85%B3%E4%BA%8Epython2%E4%B8%8Epython3%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/">关于python2与python3中的可变参数</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python变量作用域（全局变量和局部变量）</title>
    <url>/2022/01/02/Python%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="http://c.biancheng.net/view/2259.html" target="_blank" rel="noopener">Python变量作用域（全局变量和局部变量） (biancheng.net)</a></p>
</blockquote>
<h4 id="1-局部变量"><a href="#1-局部变量" class="headerlink" title="1. 局部变量"></a>1. 局部变量</h4><p>在函数内部定义的变量，它的作用域也仅限于函数内部，出了函数就不能使用了，我们将这样的变量称为局部变量（Local Variable）。</p>
<p>当函数被执行时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p>
<h4 id="2-全局变量"><a href="#2-全局变量" class="headerlink" title="2. 全局变量"></a>2. 全局变量</h4><p>除了在函数内部定义变量，Python 还允许在所有函数的外部定义变量，这样的变量称为全局变量（Global Variable）。<br>和局部变量不同，全局变量的默认作用域是整个程序，即全局变量既可以在各个函数的外部使用，也可以在各函数内部使用。</p>
<p>定义全局变量的方式有以下 2 种：</p>
<ul>
<li>在函数体外定义的变量，一定是全局变量；</li>
<li>在函数体内定义全局变量。即使用 global 关键字对变量进行修饰后，该变量就会变为全局变量。例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> add</span><br><span class="line">    add= <span class="string">"http://c.biancheng.net/java/"</span></span><br><span class="line">    print(<span class="string">"函数体内访问："</span>,add)</span><br><span class="line">    </span><br><span class="line">text()</span><br><span class="line">print(<span class="string">'函数体外访问：'</span>,add)</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">函数体内访问： http://c.biancheng.net/java/</span><br><span class="line">函数体外访问： http://c.biancheng.net/java/</span><br></pre></td></tr></table></figure>
<p>注：在使用 global 关键字修饰变量名时，不能直接给变量赋初值，否则会引发语法错误</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python文件编码说明</title>
    <url>/2021/12/30/python%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考<br><a href="https://www.cnblogs.com/sixbeauty/p/4284427.html" target="_blank" rel="noopener">python文件编码说明 coding=utf-8 - 不笑猫 - 博客园 (cnblogs.com)</a><br><a href="https://www.python.org/dev/peps/pep-0263/" target="_blank" rel="noopener">PEP 263 — Defining Python Source Code Encodings | Python.org</a></p>
</blockquote>
<p>在python 文件开头（一般是第一行或第二行），用来说明你的Python源程序文件用使用的编码。缺省情况下默认使用ascii编码，但如果在其中写中文的话，python解释器一般会报错，但如果加上你所用的文件编码，python就会自动处理不再报错。</p>
<p>通常写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: &lt;encoding name&gt; -*-</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># coding=&lt;encoding name&gt;</span><br></pre></td></tr></table></figure>
<p>More precisely, the first or second line must match the following regular expression:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[ \t\f]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>关于环境变量path与classpath</title>
    <url>/2021/12/30/%E5%85%B3%E4%BA%8E%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8Fpath%E4%B8%8Eclasspath/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考<br><a href="https://blog.csdn.net/handsome_boy_wsq/article/details/82178724" target="_blank" rel="noopener">环境变量——关于PATH与CLASSPATH的区别（作用）</a><br><a href="https://blog.csdn.net/mydreamongo/article/details/8155408" target="_blank" rel="noopener">path与classpath区别</a></p>
</blockquote>
<h4 id="1-Path"><a href="#1-Path" class="headerlink" title="1. Path"></a>1. Path</h4><p>PATH是系统用来指定可执行文件的完整路径。</p>
<p>当在cmd中执行命令时，如果执行的可执行文件不在当前目录下，那么系统就会依次搜索PATH中设置的路径。例如，若在PATH中设置了python的安装目录（D:\python\python-3.6.3），那么就可以在任意路径下使用python xxx.py执行python程序，而不必在CMD中切换到python的安装目录下运行该命令。</p>
<h4 id="2-classpath"><a href="#2-classpath" class="headerlink" title="2. classpath"></a>2. classpath</h4><p>CLASSPATH是指定程序中所使用的类文件所在的位置。classpath是java专用的查找类的路径。一般只在配置java环境时会用到。</p>
<h4 id="3-用户变量与系统变量"><a href="#3-用户变量与系统变量" class="headerlink" title="3. 用户变量与系统变量"></a>3. 用户变量与系统变量</h4><p>用户变量只对当前用户有效；系统变量对所有用户有效。对于当前用户而言，设置用户变量与系统变量的效果大致相同，只是系统变量的路径排在用户变量的路径之前。</p>
<p>小结：一般安装软件时环境变量的配置，编辑系统变量下的path内容即可。</p>
]]></content>
      <categories>
        <category>软件环境配置</category>
      </categories>
  </entry>
  <entry>
    <title>关于python2与python3中的可变参数</title>
    <url>/2021/10/12/%E5%85%B3%E4%BA%8Epython2%E4%B8%8Epython3%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-函数定义中的-与"><a href="#1-函数定义中的-与" class="headerlink" title="1. 函数定义中的*与**"></a>1. 函数定义中的*与**</h4><blockquote>
<p> 参考 <a href="https://www.it1352.com/734786.html" target="_blank" rel="noopener">python2和python3中的可变参数有什么不同?</a></p>
</blockquote>
<p>python2中参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数。python3中不一定要如此。</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b=<span class="number">0</span>, *args, **kw)</span>:</span></span><br><span class="line">    print(a,b,args,kw)</span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [6]: f(1,2,3,4,c=5,d=6)</span><br><span class="line">1 2 (3, 4) &#123;&apos;c&apos;: 5, &apos;d&apos;: 6&#125;</span><br></pre></td></tr></table></figure>
<p>但是有一点，就是在调用的时候，默认参数后面必须是默认参数，也就是说，默认参数（包括关键字参数）必须在最后。（python2, python3 中均如此）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [7]: f(1,b=2,3,4,c=5,d=6)</span><br><span class="line">  File &quot;&lt;ipython-input-7-12fe2b3ef8e0&gt;&quot;, line 1</span><br><span class="line">    f(1,b=2,3,4,c=5,d=6)</span><br><span class="line">SyntaxError: non-keyword arg after keyword arg</span><br><span class="line"></span><br><span class="line">In [8]: f(1,b=2,c=5,d=6)</span><br><span class="line">1 2 () &#123;&apos;c&apos;: 5, &apos;d&apos;: 6&#125;</span><br></pre></td></tr></table></figure>
<p>↑在python2与python3中运行结果一致，都会报错，即调用时，出现了某参数=某值时，后面的参数均要加上参数名？</p>
<hr>
<p>另一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat1</span><span class="params">(*args, sep=<span class="string">"/"</span>)</span>:</span></span><br><span class="line">	print(sep.join(args))</span><br></pre></td></tr></table></figure>
<p>↑此定义在python2中会报错（默认参数应在可变参数前），在python3中不会报错。在python2中的正确写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concat2</span><span class="params">(sep=<span class="string">"/"</span>, *args)</span>:</span></span><br><span class="line">	print(sep.join(args))</span><br></pre></td></tr></table></figure>
<p>↑此定义在python2, python3中均正确.</p>
<p>调用时：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;concat2(<span class="string">"."</span>, <span class="string">"aaa"</span>, <span class="string">"bbb"</span>,<span class="string">"ccc"</span>)</span><br><span class="line">aaaa.bbb.ccc</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>不能写为 concat1(sep=<span class="string">"."</span>, <span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>)</span><br><span class="line"><span class="number">2.</span>第一个参数默认代入sep中，若写为concat1(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>)则结果为:</span><br><span class="line">bbbaaaccc</span><br><span class="line"><span class="number">3</span>并且，也不能将sep=<span class="string">"."</span>写在末尾，例如，若写为concat(<span class="string">"aaa"</span>,<span class="string">"bbb"</span>,<span class="string">"ccc"</span>,sep=<span class="string">"."</span>)</span><br><span class="line">会报错:</span><br><span class="line">TypeError: concat2() got multiple values <span class="keyword">for</span> keyword argument <span class="string">'sep'</span></span><br></pre></td></tr></table></figure>
<p>↑ python2, python3中一致</p>
<h4 id="2-函数调用中的-与"><a href="#2-函数调用中的-与" class="headerlink" title="2. 函数调用中的*与**"></a>2. 函数调用中的*与**</h4><blockquote>
<p>参考 <a href="https://blog.csdn.net/jarthong/article/details/88853156" target="_blank" rel="noopener">Python函数传参中的<em>与*</em></a></p>
</blockquote>
<p>假设有函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(a,b,c)</span>:</span></span><br><span class="line">	print(<span class="string">"a ="</span>, a, <span class="string">", b ="</span>, b, <span class="string">", c ="</span>, c)</span><br></pre></td></tr></table></figure>
<p><code>test(*args)</code>：<code>*</code>的作用其实就是把<code>args</code>中的每个元素，作为位置参数传进去。<br><code>test(**kwargs)</code>：<code>**</code> 的作用则是把 <code>kwargs</code> 变成关键字参数传递。</p>
<p>例1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">test(*args)</span><br><span class="line"><span class="comment"># 结果：a = 1 , b = 2 , c = 3</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 写成 args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] 也可以，结果一样</span><br><span class="line"><span class="number">2.</span> 若令 args = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)，报错：TypeError: test() takes <span class="number">3</span> positional arguments but <span class="number">4</span> were given</span><br></pre></td></tr></table></figure>
<p>例2：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">kwargs = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line">test(**kwargs)</span><br><span class="line"><span class="comment"># 结果：a = 1 , b = 2 , c = 3</span></span><br></pre></td></tr></table></figure>
<p>例3：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(*args)</span>:</span></span><br><span class="line">	<span class="keyword">for</span> item <span class="keyword">in</span> args:</span><br><span class="line">		print(item)</span><br><span class="line">        </span><br><span class="line">args = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">test(*args)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># ↑ 1,2,3 被看作多个参数，分别被print出来</span></span><br><span class="line"></span><br><span class="line">test(args)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># ↑ (1,2,3) 被看作一个整体</span></span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line"><span class="number">1</span>  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line"></span><br><span class="line">test((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 结果：</span></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>（↑ python2, python3 中结果一致）</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行中使用不同版本的python</title>
    <url>/2021/10/12/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84python/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>假设安装anaconda时选择的python版本为Python3.8，又新创建了虚拟环境python36（python版本选择的Python3.6），如何在命令行中使用不同版本的python：</p>
<p>由于环境变量中加入了anaconda的路径，此时直接在命令行中运行python时，默认使用的是anaconda\python.exe所对应的版本（即Python3.8）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;python --version</span><br><span class="line">Python 3.8.5</span><br></pre></td></tr></table></figure>
<p>如何使用Python3.6：</p>
<p>首先cd到对应的虚拟环境的python.exe路径下，此时执行python命令时便使用的相应版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cd d:\anaconda\anaconda\envs\python36</span><br><span class="line">&gt;python --version</span><br><span class="line">Python 3.6.12 :: Anaconda, Inc.</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>WOE编码与IV值</title>
    <url>/2021/07/17/WOE%E7%BC%96%E7%A0%81%E4%B8%8EIV%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考<br><a href="https://zhuanlan.zhihu.com/p/74165987" target="_blank" rel="noopener">WOE与IV值浅谈</a><br><a href="https://zhuanlan.zhihu.com/p/78809853" target="_blank" rel="noopener">机器学习-变量筛选之IV值和WOE</a></p>
</blockquote>
<h4 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0. Introduction"></a>0. Introduction</h4><p>WOE (weight of evidence): 证据权重<br>IV (information value): 信息值</p>
<p>计算WOE与IV值的意义：<br>（1）用woe编码可以处理缺失值问题。<br>（2）IV值可以衡量各变量对 y 的<strong>预测能力</strong>，用于筛选变量，IV值越大，表示该变量的预测能力越强。<br>（3）对离散型变量，woe可以观察各个level间的跳转对odds的提升是否呈线性，而IV可以衡量变量整体（而不是每个level）的预测能力。<br>（4）对连续型变量，woe和IV值为分箱的合理性提供了一定的依据。</p>
<a id="more"></a>
<h4 id="1-WOE"><a href="#1-WOE" class="headerlink" title="1. WOE"></a>1. WOE</h4><h5 id="1-1-WOE的计算方式"><a href="#1-1-WOE的计算方式" class="headerlink" title="1. 1 WOE的计算方式"></a>1. 1 WOE的计算方式</h5><script type="math/tex; mode=display">
WOE_i = ln(\frac{\#B_i/\#B_T}{\#G_i/\#G_T})</script><p>其中 $i$ 表示第 $i$ 个分箱，即<strong>一个变量的每个分箱都有一个 WOE 值</strong>，</p>
<p> $#B_i$ 是第 $i$ 箱中坏客户的人数<br>$#G_i$ 是第i箱中好客户人数<br>$#B_T$ 是总共坏客户人数<br>$#G_T$ 是总共好客户人数</p>
<p>实质上WOE表示的是 <em>当前分箱中好坏客户的比例</em> 与 <em>总体好坏客户比例</em>  的差异</p>
<p>如果WOE的<strong>绝对值</strong>越大，这种差异就越明显，<strong>绝对值</strong>越小就表明差异越不明显。如果WOE为0，则说明该分箱中好坏客户比例等于随机好坏客户比值，此时这个分箱就无预测能力。</p>
<blockquote>
<p>可以理解为<strong>当前组中正负样本的比值，与所有样本中正负样本比值的差异</strong>。这个差异是用这两个比值的比值，再取对数来表示的。差异越大，WOE越大，这个分组里的样本响应的可能性就越大；差异越小，WOE越小，这个分组里的样本响应的可能性就越小。<span style="color:red">WOE可能为负</span>，但其绝对值越大，对于分类贡献越大。当分箱中正负的比例等于随机（大盘）正负样本的比值时，说明这个分箱没有预测能力，即WOE=0。</p>
</blockquote>
<p><img src="/2021/07/17/WOE编码与IV值/image-20210717175233815.png" alt="image-20210717175233815"></p>
<h5 id="1-2-WOE编码的好处"><a href="#1-2-WOE编码的好处" class="headerlink" title="1.2 WOE编码的好处"></a>1.2 WOE编码的好处</h5><p><img src="/2021/07/17/WOE编码与IV值/image-20210717175451426.png" alt="image-20210717175451426" style="zoom:80%;"></p>
<h5 id="1-3-对于连续型变量，如何进行-WOE-编码"><a href="#1-3-对于连续型变量，如何进行-WOE-编码" class="headerlink" title="1.3 对于连续型变量，如何进行 WOE 编码"></a>1.3 对于连续型变量，如何进行 WOE 编码</h5><p>在计算WOE编码前需要对连续变量进行分箱（binning）处理</p>
<h6 id="1-3-1-分箱数量"><a href="#1-3-1-分箱数量" class="headerlink" title="1.3.1 分箱数量"></a>1.3.1 分箱数量</h6><p>一般来说10~20个分箱足够了，因为每个分箱应保证不少于5%的样本数。分箱数量决定了平滑程度，分箱数越少平滑度越高。所以一般采用先精细分箱（fine classing），初始将箱数分成20~50个箱，然后进行粗分箱（coarse classing），利用IV值、基尼系数、卡方统计量等值将箱数合并，通常最多10箱。目的是通过创建更少的箱子来实现简化，每个箱子具有明显不同的风险因子同时最小化信息损失。</p>
<p>如果缺失值有预测能力，则将缺失值单独分作一箱或者是合并到拥有相似风险因子的分箱中去.</p>
<p>为什么不分1000箱？更少的箱数能够捕捉到数据中的重要模式，同时忽略噪声。当某一分箱中样本数少于5%，则该箱可能不是数据分布的一个真实反映，也可能导致模型不稳定。</p>
<h6 id="1-3-2-处理分箱中没有响应样本或者全部是响应样本"><a href="#1-3-2-处理分箱中没有响应样本或者全部是响应样本" class="headerlink" title="1.3.2 处理分箱中没有响应样本或者全部是响应样本"></a>1.3.2 处理分箱中没有响应样本或者全部是响应样本</h6><p>可以用以下公式修正</p>
<script type="math/tex; mode=display">
WOE_i = ln(\frac{(\#B_i+0.5)/\#B_T}{(\#G_i+0.5)/\#G_T})</script><h6 id="1-3-3-如何用WOE检查分箱的正确性"><a href="#1-3-3-如何用WOE检查分箱的正确性" class="headerlink" title="1.3.3 如何用WOE检查分箱的正确性"></a>1.3.3 如何用WOE检查分箱的正确性</h6><p>（1）WOE应该呈单调趋势</p>
<p>（2）在预测变量做了WOE编码后跑一个单变量的逻辑回归，如果斜率（变量系数）不为1或者截距项不等于</p>
<script type="math/tex; mode=display">
\ln(\frac{\#Bad_T}{\#Good_T})</script><p>则该分箱效果不佳。</p>
<p>对于离散变量，例如职业变量包含学生、老师、工人等名义属性时，先将变量的不同level作WOE编码后，把WOE值相近的level合并在一起，这样可以减少level数量。因为有相近的WOE值的level有几乎相同的响应率/非响应率，换句话说，某几个level有相近的woe值就将他们合并成一个箱子</p>
<h5 id="1-4-WOE编码的优点与缺点"><a href="#1-4-WOE编码的优点与缺点" class="headerlink" title="1.4 WOE编码的优点与缺点"></a>1.4 WOE编码的优点与缺点</h5><p>优点：</p>
<blockquote>
<p>1.可以有效处理缺失值(把缺失值单独作为一个分箱)<br>2.可以有效处理异常值（Outlier）<br>3.WOE转换基于分布的对数值。 这与逻辑回归输出函数一致<br>4.不需要进行哑变量编码<br>5.用了合适的分箱手段后，能够建立自变量与因变量的单调关系</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>只考虑了每个分箱的相对风险，没有考虑到每个分箱样本数量占全样本的比例。可以用IV值来评估每个分箱的相对贡献</p>
</blockquote>
<h5 id="1-5-WOE-为什么被称为数据权重"><a href="#1-5-WOE-为什么被称为数据权重" class="headerlink" title="1.5 WOE 为什么被称为数据权重"></a>1.5 WOE 为什么被称为数据权重</h5><p><img src="/2021/07/17/WOE编码与IV值/image-20210717175623456.png" alt="image-20210717175623456"></p>
<h5 id="1-6-在python中计算WOE"><a href="#1-6-在python中计算WOE" class="headerlink" title="1.6 在python中计算WOE"></a>1.6 在python中计算WOE</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_woe = pd.crosstab(X[col_name], y, normalize=<span class="string">'columns'</span>).assign(woe=<span class="keyword">lambda</span> dfx: np.log(dfx[<span class="number">1</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>) / dfx[<span class="number">0</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>)))</span><br></pre></td></tr></table></figure>
<p>其中 <code>X[col_name]</code> 和 <code>y</code> 都为 Series</p>
<p>当某个分箱中，没有为0的，或没有为1的时，会使得 <code>ln(.)</code> 的分子或分母为0，可选择将其替换为0.0001</p>
<h4 id="2-IV值"><a href="#2-IV值" class="headerlink" title="2. IV值"></a>2. IV值</h4><h5 id="2-1-IV值的计算方式"><a href="#2-1-IV值的计算方式" class="headerlink" title="2.1 IV值的计算方式"></a>2.1 IV值的计算方式</h5><p>信息值是预测模型中选择重要变量的方式之一，它能根据预测变量的重要性对预测变量进行排序，IV值计算公式如下：</p>
<script type="math/tex; mode=display">
IV = \sum_i^n(响应比例-未响应比例)*WOE_i \\
=\sum_i^n(\frac{\#Bad_i}{\#Bad_T}-\frac{\#Good_i}{\#Good_T})*WOE_i</script><p>IV值是对一个变量而言，即<strong>每个变量有一个IV值</strong>（其值等于每个分箱的IV值相加）。<span style="color:red">IV值在WOE的基础上保证了结果非负</span>。</p>
<p>假设变量 $X$ 有 $n$ 个分箱，每个分箱的 WOE 编码取值为 $WOE_i$ ,该分箱的IV值就是用该分箱响应比例与未响应比例之差再乘上 $WOE_i$。注意这里的响应比例和未响应比例都是用当前分箱中响应数量/整体样本响应数量和当前分箱未响应数量/整体样本未响应数量计算得到。</p>
<p>IV值是看单个变量好坏客户分布的差异，这种差异越大表明这个变量对于好坏客户的区分度越高.</p>
<p>WOE可能为负值，IV值不可能为负，根据IV值选择变量后，用WOE替换变量各分组的值进入模型。</p>
<h5 id="2-2-利用IV值进行变量筛选"><a href="#2-2-利用IV值进行变量筛选" class="headerlink" title="2.2 利用IV值进行变量筛选"></a>2.2 利用IV值进行变量筛选</h5><p><img src="/2021/07/17/WOE编码与IV值/image-20210717175912098.png" alt="image-20210717175912098"></p>
<p>一般我们选择 IV值大于0.02的那些变量进入模型。如果IV值大于0.5，则考虑要对这个变量进行分群处理。即根据这个变量拆分成几个样本子集，分别在各个样本子集上建模。</p>
<h5 id="2-3-在python中计算IV"><a href="#2-3-在python中计算IV" class="headerlink" title="2.3 在python中计算IV"></a>2.3 在python中计算IV</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calIV</span><span class="params">(df, var, y)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算IV值</span></span><br><span class="line"><span class="string">    param df：数据集X</span></span><br><span class="line"><span class="string">    param var：已分组的列名</span></span><br><span class="line"><span class="string">    param y：响应变量y（0,1）</span></span><br><span class="line"><span class="string">    return：IV值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    df_woe_iv = pd.crosstab(df[var], y, normalize=<span class="string">'columns'</span>).assign(woe=<span class="keyword">lambda</span> dfx: np.log(dfx[<span class="number">1</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>) / dfx[<span class="number">0</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>))).assign(iv=<span class="keyword">lambda</span> dfx: np.sum(dfx[<span class="string">'woe'</span>] * (dfx[<span class="number">1</span>] - dfx[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">    a = df_woe_iv[<span class="string">'iv'</span>].reset_index()</span><br><span class="line">    <span class="keyword">return</span> a.loc[<span class="number">0</span>, <span class="string">'iv'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas中的常用函数</title>
    <url>/2021/07/17/Pandas%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="map、apply、applymap"><a href="#map、apply、applymap" class="headerlink" title="map、apply、applymap"></a>map、apply、applymap</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/100064394" target="_blank" rel="noopener">Pandas教程 | 数据处理三板斧——map、apply、applymap详解 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>在日常的数据处理中，经常会对一个<code>DataFrame</code>进行逐行、逐列和逐元素的操作，对应这些操作，Pandas中的<code>map</code>、<code>apply</code>和<code>applymap</code>可以解决绝大部分这样的数据处理需求。</p>
<p>生成100行示例数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">boolean=[<span class="literal">True</span>,<span class="literal">False</span>]</span><br><span class="line">gender=[<span class="string">"男"</span>,<span class="string">"女"</span>]</span><br><span class="line">color=[<span class="string">"white"</span>,<span class="string">"black"</span>,<span class="string">"yellow"</span>]</span><br><span class="line">data=pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">"height"</span>:np.random.randint(<span class="number">150</span>,<span class="number">190</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="string">"weight"</span>:np.random.randint(<span class="number">40</span>,<span class="number">90</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="string">"smoker"</span>:[boolean[x] <span class="keyword">for</span> x <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">100</span>)],</span><br><span class="line">    <span class="string">"gender"</span>:[gender[x] <span class="keyword">for</span> x <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,<span class="number">2</span>,<span class="number">100</span>)],</span><br><span class="line">    <span class="string">"age"</span>:np.random.randint(<span class="number">15</span>,<span class="number">90</span>,<span class="number">100</span>),</span><br><span class="line">    <span class="string">"color"</span>:[color[x] <span class="keyword">for</span> x <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,len(color),<span class="number">100</span>) ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717144622753.png" alt="image-20210717144622753"></p>
<h5 id="Series数据处理"><a href="#Series数据处理" class="headerlink" title="Series数据处理"></a>Series数据处理</h5><h6 id="1-map用法"><a href="#1-map用法" class="headerlink" title="1. map用法"></a>1. map用法</h6><p>若想把数据集中<code>gender</code>列的男替换为1，女替换为0，可使用 <code>Series.map()</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法一：使用字典进行映射</span></span><br><span class="line">data[<span class="string">"gender"</span>] = data[<span class="string">"gender"</span>].map(&#123;<span class="string">"男"</span>:<span class="number">1</span>, <span class="string">"女"</span>:<span class="number">0</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二：使用函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gender_map</span><span class="params">(x)</span>:</span></span><br><span class="line">    gender = <span class="number">1</span> <span class="keyword">if</span> x == <span class="string">"男"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> gender</span><br><span class="line"><span class="comment"># 注意这里传入的是函数名，不带括号</span></span><br><span class="line">data[<span class="string">"gender"</span>] = data[<span class="string">"gender"</span>].map(gender_map)</span><br></pre></td></tr></table></figure>
<p>不论是利用字典还是函数进行映射，<code>map</code>方法都是把对应的数据<strong>逐个当作参数</strong>传入到字典或函数中，得到映射后的值。</p>
<blockquote>
<p> 注：若该列中存在map字典中不存在的值，例如，gender 中还存在“未知”，则“未知”会被映射为Nan，此时可选择使用函数进行映射，定义一个else，同时使用函数会更加灵活，例如当满足多个条件时，都映射到某个值</p>
</blockquote>
<a id="more"></a>
<h6 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply"></a>2. apply</h6><p><code>apply</code> 方法的作用原理和 <code>map</code> 方法类似，区别在于 <code>apply</code> 能够传入功能更为复杂的函数</p>
<p>假设在数据统计的过程中，年龄<code>age</code>列有较大误差，需要对其进行调整（加上或减去一个值），由于这个加上或减去的值未知，故在定义函数时，需要加多一个参数 <code>bias</code>，此时用 <code>map</code> 方法是操作不了的（<strong>传入 <code>map</code> 的函数只能接收一个参数</strong>），<code>apply</code> 方法则可以解决这个问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_age</span><span class="params">(x,bias)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+bias</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以元组的方式传入额外的参数</span></span><br><span class="line">data[<span class="string">"age"</span>] = data[<span class="string">"age"</span>].apply(apply_age,args=(<span class="number">-3</span>,))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717164238564.png" alt="image-20210717164238564"></p>
<p>可以看到age列都减了3，当然，这里只是简单举了个例子，当需要进行复杂处理时，更能体现<code>apply</code>的作用。</p>
<p>总而言之，对于Series而言，<code>map</code>可以解决绝大多数的数据处理需求，但如果需要使用较为复杂的函数，则需要用到<code>apply</code>方法。</p>
<h5 id="DataFrame数据处理"><a href="#DataFrame数据处理" class="headerlink" title="DataFrame数据处理"></a>DataFrame数据处理</h5><h6 id="1-apply"><a href="#1-apply" class="headerlink" title="1. apply"></a>1. apply</h6><p>对<code>DataFrame</code>而言，<code>apply</code>是非常重要的数据处理方法，它可以接收各种各样的函数（Python内置的或自定义的），处理方式很灵活。</p>
<p>在进行具体介绍之前，首先需要了解一下<code>DataFrame</code>中<code>axis</code>的概念（详见我的博客<a href="https://qypx.github.io/2019/09/02/dataframe-operation/">数据框操作</a>）</p>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717171243694.png" alt="image-20210717171243694"></p>
<p>简言之，若想沿着axis=0的方向新增数据，则选择axis=0；若想沿着axis=1的方向新增数据，则选择axis=1。</p>
<p>假设现在需要对<code>data</code>中的<strong>数值列</strong>分别进行<strong>取对数</strong>和<strong>求和</strong>的操作，这时可以用 <code>apply</code> 进行相应的操作，因为是对列进行操作，所以需要指定<code>axis=0</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 沿着0轴求和</span></span><br><span class="line">data[[<span class="string">"height"</span>,<span class="string">"weight"</span>,<span class="string">"age"</span>]].apply(np.sum, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着0轴取对数</span></span><br><span class="line">data[[<span class="string">"height"</span>,<span class="string">"weight"</span>,<span class="string">"age"</span>]].apply(np.log, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717171536577.png" alt="image-20210717171536577"></p>
<p><strong>当沿着<code>轴0（axis=0）</code>进行操作时，会将各列(<code>columns</code>)默认以<code>Series</code>的形式作为参数</strong>，传入到你指定的操作函数中，操作后合并并返回相应的结果。</p>
<p>那如果在实际使用中需要按行进行操作（<code>axis=1</code>）, 例如：</p>
<p>在数据集中，有身高和体重的数据，所以根据这个，我们可以计算每个人的BMI指数（体检时常用的指标，衡量人体肥胖程度和是否健康的重要标准），计算公式是：<code>体重指数BMI=体重/身高的平方（国际单位kg/㎡）</code>，因为需要对每个样本进行操作，这里使用<code>axis=1</code>的<code>apply</code>进行操作，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BMI</span><span class="params">(series)</span>:</span></span><br><span class="line">    weight = series[<span class="string">"weight"</span>]</span><br><span class="line">    height = series[<span class="string">"height"</span>]/<span class="number">100</span></span><br><span class="line">    BMI = weight/height**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> BMI</span><br><span class="line"></span><br><span class="line">data[<span class="string">"BMI"</span>] = data.apply(BMI,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><strong>当<code>apply</code>设置了<code>axis=1</code>对行进行操作时，会默认将每一行数据以<code>Series</code>的形式（Series的索引为列名）传入指定函数</strong>，返回相应的结果。</p>
<p>总结一下对<code>DataFrame</code>的<code>apply</code>操作：</p>
<blockquote>
<ol>
<li>当<code>axis=0</code>时，对<code>每列columns</code>执行指定函数；当<code>axis=1</code>时，对<code>每行row</code>执行指定函数。</li>
<li>无论<code>axis=0</code>还是<code>axis=1</code>，其传入指定函数的默认形式均为<code>Series</code>，可以通过设置<code>raw=True</code>传入<code>numpy数组</code>。</li>
<li>对每个Series执行结果后，会将结果整合在一起返回（若想有返回值，定义函数时需要<code>return</code>相应的值）</li>
<li>当然，<code>DataFrame</code>的<code>apply</code>和<code>Series</code>的<code>apply</code>一样，也能接收更复杂的函数，如传入参数等，实现原理是一样的，具体用法详见官方文档。</li>
</ol>
</blockquote>
<h6 id="2-applymap"><a href="#2-applymap" class="headerlink" title="2. applymap"></a>2. applymap</h6><p><code>applymap</code>的用法比较简单，会对 DataFrame 中的<strong>每个单元格</strong>执行指定函数的操作</p>
<p>新生成一个 DataFrame:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"A"</span>:np.random.randn(<span class="number">5</span>),</span><br><span class="line">        <span class="string">"B"</span>:np.random.randn(<span class="number">5</span>),</span><br><span class="line">        <span class="string">"C"</span>:np.random.randn(<span class="number">5</span>),</span><br><span class="line">        <span class="string">"D"</span>:np.random.randn(<span class="number">5</span>),</span><br><span class="line">        <span class="string">"E"</span>:np.random.randn(<span class="number">5</span>),</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717172153411.png" alt="image-20210717172153411"></p>
<p>现在想将<code>DataFrame</code>中所有的值保留两位小数显示，使用<code>applymap</code>可以很快达到你想要的目的，代码和图解如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.applymap(<span class="keyword">lambda</span> x:<span class="string">"%.2f"</span> % x)</span><br></pre></td></tr></table></figure>
<p><code>applymap</code> 将 DataFrame 中的每个数据作为 x 传入匿名函数</p>
<hr>
<h4 id="groupby"><a href="#groupby" class="headerlink" title="groupby"></a>groupby</h4><blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html" target="_blank" rel="noopener">pandas.DataFrame.groupby — pandas 1.3.0 documentation (pydata.org)</a><br><a href="https://zhuanlan.zhihu.com/p/101284491?utm_source=wechat_session" target="_blank" rel="noopener">Pandas教程 | 超好用的Groupby用法详解 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>将数据根据某个（多个）字段划分为不同的群体（group）进行分析</p>
<p>例：</p>
<p>模拟生成10个样本数据：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">company=[<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>]</span><br><span class="line"></span><br><span class="line">data=pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">"company"</span>:[company[x] <span class="keyword">for</span> x <span class="keyword">in</span> np.random.randint(<span class="number">0</span>,len(company),<span class="number">10</span>)],</span><br><span class="line">    <span class="string">"salary"</span>:np.random.randint(<span class="number">5</span>,<span class="number">50</span>,<span class="number">10</span>),</span><br><span class="line">    <span class="string">"age"</span>:np.random.randint(<span class="number">15</span>,<span class="number">50</span>,<span class="number">10</span>)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717140057334.png" alt="image-20210717140057334"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">group = data.groupby(&quot;company&quot;)</span><br></pre></td></tr></table></figure>
<p><code>groupby</code>的过程就是将原有的<code>DataFrame</code>按照<code>groupby</code>的字段（这里是<code>company</code>），划分为若干个<code>子DataFrame</code>，在<code>groupby</code>之后的一系列操作（如<code>agg</code>、<code>apply</code>等），均是基于<code>子DataFrame</code>的操作。</p>
<h5 id="agg聚合操作"><a href="#agg聚合操作" class="headerlink" title="agg聚合操作"></a>agg聚合操作</h5><p>Pandas中常见的聚合操作：</p>
<blockquote>
<p>min, max, sum, mean, median, std, var, count</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; data.groupby(&quot;company&quot;).agg(&apos;mean&apos;)</span><br><span class="line">         salary    age</span><br><span class="line">company</span><br><span class="line">A         21.50  27.50</span><br><span class="line">B         13.00  29.00</span><br><span class="line">C         29.25  27.25</span><br></pre></td></tr></table></figure>
<p>👆 根据公司进行分组，对其余每一列求平均</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; data.groupby(&quot;company&quot;)[&quot;salary&quot;].agg(&apos;mean&apos;)</span><br><span class="line">         salary    age</span><br><span class="line">company</span><br><span class="line">A         21.50  27.50</span><br><span class="line">B         13.00  29.00</span><br><span class="line">C         29.25  27.25</span><br></pre></td></tr></table></figure>
<p>👆 根据公司进行分组，对 salary 列求平均</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; data.groupby(&apos;company&apos;).agg(&#123;&apos;salary&apos;:&apos;median&apos;,&apos;age&apos;:&apos;mean&apos;&#125;)</span><br><span class="line">         salary    age</span><br><span class="line">company</span><br><span class="line">A          21.5  27.50</span><br><span class="line">B          10.0  29.00</span><br><span class="line">C          30.0  27.25</span><br></pre></td></tr></table></figure>
<p>👆 根据公司进行分组，对 salary 列求中位数，对 age 列求平均</p>
<h5 id="transform操作"><a href="#transform操作" class="headerlink" title="transform操作"></a>transform操作</h5><p>若在求得不同公司员工的平均薪水后，想在原数据集中新增一列<code>avg_salary</code>，该怎么做呢？</p>
<p>不用<code>transform</code>的话，实现代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; avg_salary_dict = data.groupby(&apos;company&apos;)[&apos;salary&apos;].mean().to_dict()</span><br><span class="line">&gt; data[&apos;avg_salary&apos;] = data[&apos;company&apos;].map(avg_salary_dict)</span><br><span class="line">&gt; data</span><br><span class="line">  company  salary  age  avg_salary</span><br><span class="line">0       C      43   35       29.25</span><br><span class="line">1       C      17   25       29.25</span><br><span class="line">2       C       8   30       29.25</span><br><span class="line">3       A      20   22       21.50</span><br><span class="line">4       B      10   17       13.00</span><br><span class="line">5       B      21   40       13.00</span><br><span class="line">6       A      23   33       21.50</span><br><span class="line">7       C      49   19       29.25</span><br><span class="line">8       B       8   30       13.00</span><br></pre></td></tr></table></figure>
<p>如果使用<code>transform</code>的话，仅需要一行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; data[&apos;avg_salary&apos;] = data.groupby(&apos;company&apos;)[&apos;salary&apos;].transform(&apos;mean&apos;)</span><br><span class="line">&gt; data</span><br><span class="line">  company  salary  age  avg_salary</span><br><span class="line">0       C      43   35       29.25</span><br><span class="line">1       C      17   25       29.25</span><br><span class="line">2       C       8   30       29.25</span><br><span class="line">3       A      20   22       21.50</span><br><span class="line">4       B      10   17       13.00</span><br><span class="line">5       B      21   40       13.00</span><br><span class="line">6       A      23   33       21.50</span><br><span class="line">7       C      49   19       29.25</span><br><span class="line">8       B       8   30       13.00</span><br></pre></td></tr></table></figure>
<h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><p><code>apply</code> 相比 <code>agg</code> 和 <code>transform</code> 而言更加灵活，能够传入任意自定义的函数，实现复杂的数据操作</p>
<p>假设现在需要获取各个公司年龄最大的员工的数据，可以用以下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; def get_oldest_staff(x):</span><br><span class="line">...     df = x.sort_values(by = &apos;age&apos;,ascending=True)</span><br><span class="line">...     return df.iloc[-1,:]</span><br><span class="line">&gt; oldest_staff = data.groupby(&apos;company&apos;,as_index=False).apply(get_oldest_staff)</span><br><span class="line">&gt; oldest_staff</span><br><span class="line">  company  salary  age  </span><br><span class="line">0       A      23   33       </span><br><span class="line">1       B      21   40       </span><br><span class="line">2       C      43   35</span><br></pre></td></tr></table></figure>
<blockquote>
<p>最后，关于<code>apply</code>的使用，这里有个小建议，虽然说<code>apply</code>拥有更大的灵活性，但<code>apply</code>的运行效率会比<code>agg</code>和<code>transform</code>更慢。所以，<code>groupby</code>之后能用<code>agg</code>和<code>transform</code>解决的问题还是优先使用这两个方法，实在解决不了了才考虑使用<code>apply</code>进行操作。</p>
</blockquote>
<hr>
<h4 id="crosstab"><a href="#crosstab" class="headerlink" title="crosstab"></a>crosstab</h4><blockquote>
<p><a href="https://blog.csdn.net/houyanhua1/article/details/87865868?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-15.control" target="_blank" rel="noopener">Python pandas，分组 groupby()，分组后的聚合函数，交叉表 crosstab()_houyanhua1的专栏-CSDN博客</a></p>
</blockquote>
<p>crosstab 交叉表，用于统计分组频率的特殊透视表（列联表）</p>
<blockquote>
<p>官方文档：<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.crosstab.html" target="_blank" rel="noopener">pandas.crosstab — pandas 1.3.0 documentation (pydata.org)</a></p>
</blockquote>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 模拟用户购买商品的表(数据)</span></span><br><span class="line">my_list = [&#123;<span class="string">"user_id"</span>: <span class="number">11</span>, <span class="string">"goods"</span>: <span class="string">"苹果"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">11</span>, <span class="string">"goods"</span>: <span class="string">"苹果"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">11</span>, <span class="string">"goods"</span>: <span class="string">"香蕉"</span>&#125;,</span><br><span class="line">           &#123;<span class="string">"user_id"</span>: <span class="number">22</span>, <span class="string">"goods"</span>: <span class="string">"苹果"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">22</span>, <span class="string">"goods"</span>: <span class="string">"香蕉"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">22</span>, <span class="string">"goods"</span>: <span class="string">"香蕉"</span>&#125;,</span><br><span class="line">           &#123;<span class="string">"user_id"</span>: <span class="number">33</span>, <span class="string">"goods"</span>: <span class="string">"梨"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">33</span>, <span class="string">"goods"</span>: <span class="string">"香蕉"</span>&#125;, &#123;<span class="string">"user_id"</span>: <span class="number">33</span>, <span class="string">"goods"</span>: <span class="string">"苹果"</span>&#125;]</span><br><span class="line">df = pd.DataFrame(my_list)</span><br><span class="line">print(df)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  goods     user_id</span></span><br><span class="line"><span class="string">0    苹果       11</span></span><br><span class="line"><span class="string">1    苹果       11</span></span><br><span class="line"><span class="string">2    香蕉       11</span></span><br><span class="line"><span class="string">3    苹果       22</span></span><br><span class="line"><span class="string">4    香蕉       22</span></span><br><span class="line"><span class="string">5    香蕉       22</span></span><br><span class="line"><span class="string">6     梨        33</span></span><br><span class="line"><span class="string">7    香蕉       33</span></span><br><span class="line"><span class="string">8    苹果       33</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 交叉表 (特殊的分组工具)</span></span><br><span class="line">cross_tb = pd.crosstab(df[<span class="string">"user_id"</span>], df[<span class="string">"goods"</span>])  <span class="comment"># 交叉表，统计每个用户购买各种商品的数量</span></span><br><span class="line">print(cross_tb)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">goods    梨  苹果  香蕉</span></span><br><span class="line"><span class="string">user_id           </span></span><br><span class="line"><span class="string">11       0    2    1</span></span><br><span class="line"><span class="string">22       0    1    2</span></span><br><span class="line"><span class="string">33       1    1    1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ↑第一个参数会被放在index</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想得到占比：</span></span><br><span class="line">pd.crosstab(df[<span class="string">"user_id"</span>], df[<span class="string">"goods"</span>], normalize=<span class="string">"index"</span>) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">goods          梨       苹果      香蕉</span></span><br><span class="line"><span class="string">user_id</span></span><br><span class="line"><span class="string">11       0.000000  0.666667  0.333333</span></span><br><span class="line"><span class="string">22       0.000000  0.333333  0.666667</span></span><br><span class="line"><span class="string">33       0.333333  0.333333  0.333333</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">pd.crosstab(df[<span class="string">"user_id"</span>], df[<span class="string">"goods"</span>], normalize=<span class="string">"columns"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">goods     梨   苹果   香蕉</span></span><br><span class="line"><span class="string">user_id</span></span><br><span class="line"><span class="string">11       0.0  0.50  0.25</span></span><br><span class="line"><span class="string">22       0.0  0.25  0.50</span></span><br><span class="line"><span class="string">33       1.0  0.25  0.25</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">pd.crosstab(df[<span class="string">"user_id"</span>], df[<span class="string">"goods"</span>], normalize=<span class="string">"all"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">goods           梨      苹果       香蕉</span></span><br><span class="line"><span class="string">user_id</span></span><br><span class="line"><span class="string">11       0.000000  0.222222  0.111111</span></span><br><span class="line"><span class="string">22       0.000000  0.111111  0.222222</span></span><br><span class="line"><span class="string">33       0.111111  0.111111  0.111111</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<p>语法：</p>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717172959291.png" alt="image-20210717172959291" style="zoom:150%;"></p>
<hr>
<h4 id="assign"><a href="#assign" class="headerlink" title="assign"></a>assign</h4><blockquote>
<p>官方文档：<a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.assign.html" target="_blank" rel="noopener">pandas.DataFrame.assign — pandas 1.3.0 documentation (pydata.org)</a></p>
</blockquote>
<p>作用：Assign new columns to a DataFrame.</p>
<p>例：</p>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717173208264.png" alt="image-20210717173208264" style="zoom:150%;"></p>
<p>↑也可以写为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.assign(temp_f=<span class="keyword">lambda</span> x:x[<span class="string">'temp_c'</span>]*<span class="number">9</span>/<span class="number">5</span>+<span class="number">32</span>).assign(temp_k=<span class="keyword">lambda</span> x: (x[<span class="string">'temp_f'</span>]+<span class="number">459.67</span>)*<span class="number">5</span>/<span class="number">9</span>)</span><br></pre></td></tr></table></figure>
<p>例：利用crosstab与assign进行woe和iv的计算：</p>
<p>构造数据集：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">"col1"</span>:[<span class="string">"男"</span>,<span class="string">"女"</span>,<span class="string">"女"</span>,<span class="string">"男"</span>,<span class="string">"女"</span>], <span class="string">"y"</span>:[<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717173342027.png" alt="image-20210717173342027"></p>
<p>利用 <code>crosstab</code> 得到频率表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.crosstab(df[<span class="string">"col1"</span>], df[<span class="string">"y"</span>], normalize=<span class="string">'columns'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717173509526.png" alt="image-20210717173509526"></p>
<p>在频率表的基础上，加上woe列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.crosstab(df[<span class="string">"col1"</span>], df[<span class="string">"y"</span>], normalize=<span class="string">'columns'</span>).assign(woe=<span class="keyword">lambda</span> dfx: np.log(dfx[<span class="number">1</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>) / dfx[<span class="number">0</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>)))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717173652106.png" alt="image-20210717173652106"></p>
<p>利用woe的结果，进一步得到iv：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.crosstab(df[<span class="string">"col1"</span>], df[<span class="string">"y"</span>], normalize=<span class="string">'columns'</span>).assign(woe=<span class="keyword">lambda</span> dfx: np.log(dfx[<span class="number">1</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>) / dfx[<span class="number">0</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>))).assign(iv=<span class="keyword">lambda</span> dfx: np.sum(dfx[<span class="string">'woe'</span>] * (dfx[<span class="number">1</span>] - dfx[<span class="number">0</span>])))</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717173734785.png" alt="image-20210717173734785"></p>
<p>↑因为iv值是是对于一个变量而言（关于iv和woe的介绍详见我的博客 <a href="https://qypx.github.io/2021/07/17/WOE%E7%BC%96%E7%A0%81%E4%B8%8EIV%E5%80%BC/">WOE编码与IV值</a>），所以上面的两个iv值是一样的，那么如何从上述结果中提取出iv值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_woe_iv = pd.crosstab(df[<span class="string">"col1"</span>], df[<span class="string">"y"</span>], normalize=<span class="string">'columns'</span>).assign(woe=<span class="keyword">lambda</span> dfx: np.log(dfx[<span class="number">1</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>) / dfx[<span class="number">0</span>].replace(<span class="number">0</span>, <span class="number">0.0001</span>))).assign(iv=<span class="keyword">lambda</span> dfx: np.sum(dfx[<span class="string">'woe'</span>] * (dfx[<span class="number">1</span>] - dfx[<span class="number">0</span>])))</span><br><span class="line"></span><br><span class="line">a = df_woe_iv[<span class="string">'iv'</span>].reset_index()</span><br><span class="line">print(a.loc[<span class="number">0</span>, <span class="string">'iv'</span>])</span><br></pre></td></tr></table></figure>
<p><img src="/2021/07/17/Pandas中的常用函数/image-20210717174228449.png" alt="image-20210717174228449"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Probability, odds与logodds</title>
    <url>/2021/07/17/Probability-odds%E4%B8%8Elogodds/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><a href="https://dataunbox.com/odds-and-log-odds/" target="_blank" rel="noopener">Odds And Log Odds In Logistic Regression - Dataunbox</a><br><a href="https://towardsdatascience.com/https-towardsdatascience-com-what-and-why-of-log-odds-64ba988bf704" target="_blank" rel="noopener">WHAT and WHY of Log Odds. WHAT are Log Odds and WHY are they… | by Piyush Agarwal | Towards Data Science</a></p>
</blockquote>
<h4 id="1-probability-odds-与-log-odds"><a href="#1-probability-odds-与-log-odds" class="headerlink" title="1. probability, odds 与 log odds"></a>1. probability, odds 与 log odds</h4><p>（1）probability 是某件事与所有可能发生的事的比率。（p）</p>
<p>（2）odds 是某件事发生和某件事没有发生的比率。</p>
<script type="math/tex; mode=display">
odds = \frac{p}{1-p}</script><p>（3）log odds 即对odds取对数， log(odds)</p>
<p>例如我与人工智能(AI)系统下了10局棋，并有4次能够打败它：</p>
<p><em>Probability of winning: 4/10 = 0.40</em><br><em>Odds of winning: 4/6 = 0.6666</em><br><em>log(Odds of winning) = log(0.6666) = -0.176</em></p>
<h4 id="2-logistic-regression"><a href="#2-logistic-regression" class="headerlink" title="2. logistic regression"></a>2. logistic regression</h4><p>p 与 logodds 的相互转换关系</p>
<script type="math/tex; mode=display">
p = \frac{1}{1+e^{-(\beta_0+\beta_1x)}}\quad\quad(1)</script><p>则有，</p>
<script type="math/tex; mode=display">
1-p = \frac{e^{-(\beta_0+\beta_1x)}}{1+e^{-(\beta_0+\beta_1x)}}</script><script type="math/tex; mode=display">
odds=\frac{p}{1-p}=e^{\beta_0+\beta_1x}</script><script type="math/tex; mode=display">
log odds = ln(\frac{p}{1-p})=\beta_0+\beta_1x \quad \quad (2)</script><p>带入(1)中，可得</p>
<script type="math/tex; mode=display">
p=\frac{1}{1+e^{-logodds}}=\frac{e^{logodds}}{1+e^{logodds}} \quad \quad (3)</script><h4 id="3-logodds-与-sigmoid"><a href="#3-logodds-与-sigmoid" class="headerlink" title="3. logodds 与 sigmoid"></a>3. logodds 与 sigmoid</h4><script type="math/tex; mode=display">
logodds操作：logodds(p) = log(\frac{p}{1-p})</script><script type="math/tex; mode=display">
sigmoid function: sigmoid(x) = \frac{1}{1+e^{-x}}</script><script type="math/tex; mode=display">
p=\frac{1}{1+e^{-(\beta_0+\beta_1x)}}，其中\beta_0+\beta_1x为原始输出，即sigmoid作用在原始输出上得到概率值</script><script type="math/tex; mode=display">
logodds = ln(\frac{p}{1-p})=\beta_0+\beta_1x，即logodds作用在概率值上得到原始输出</script><p>一句话概括：<span style="color:red">sigmoid与logodds为相反操作。</span></p>
<h4 id="4-xgboost与lightgbm的几种输出结果"><a href="#4-xgboost与lightgbm的几种输出结果" class="headerlink" title="4. xgboost与lightgbm的几种输出结果"></a>4. xgboost与lightgbm的几种输出结果</h4><p>对于xgboost:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.predict(,output_margin=<span class="literal">True</span>)  <span class="comment">#原始值(output the raw untransformed margin value)(每个样本在xgboost生成的所有树中叶子节点的累加值)</span></span><br><span class="line">model.predict_proba()[:,<span class="number">1</span>]  <span class="comment"># 取1的概率</span></span><br><span class="line">model.predict()  <span class="comment"># 结果为0,1</span></span><br></pre></td></tr></table></figure>
<p>对于lightgbm:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">model.predict(,raw_score=<span class="literal">True</span>)  <span class="comment"># 原始值</span></span><br><span class="line">model.predict_proba()[:,<span class="number">1</span>]  <span class="comment"># 取1的概率</span></span><br><span class="line">model.predict()  <span class="comment"># 结果为0,1</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>find the most frequent element in a list</title>
    <url>/2021/07/17/find-the-most-frequent-element-in-a-list/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="https://www.tutorialspoint.com/find-most-frequent-element-in-a-list-in-python#:~:text=Find most frequent element in a list in,from statistics module. ... 8 Example 9 Output" target="_blank" rel="noopener">Find most frequent element in a list in Python (tutorialspoint.com)</a></p>
</blockquote>
<h4 id="1-法一：with-max-and-count"><a href="#1-法一：with-max-and-count" class="headerlink" title="1. 法一：with max and count"></a>1. 法一：with max and count</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Given list</span><br><span class="line">listA = [45, 20, 11, 50, 17, 45, 50,13, 45]</span><br><span class="line"></span><br><span class="line">res = max(set(listA), key = listA.count)</span><br><span class="line">print(&quot;Element with highest frequency:\n&quot;,res)</span><br><span class="line"># 输出 45</span><br></pre></td></tr></table></figure>
<h4 id="2-法二：with-Counter"><a href="#2-法二：with-Counter" class="headerlink" title="2. 法二：with Counter"></a>2. 法二：with Counter</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"># Given list</span><br><span class="line">listA = [45, 20, 11, 50, 17, 45, 50,13, 45]</span><br><span class="line"></span><br><span class="line">occurence_count = Counter(listA)</span><br><span class="line">res=occurence_count.most_common(1)[0][0]</span><br><span class="line">print(&quot;Element with highest frequency:\n&quot;,res)</span><br><span class="line"># 输出 45</span><br></pre></td></tr></table></figure>
<h4 id="3-法三：with-mode"><a href="#3-法三：with-mode" class="headerlink" title="3. 法三：with mode"></a>3. 法三：with mode</h4><p>返回众数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from statistics import mode</span><br><span class="line"># Given list</span><br><span class="line">listA = [45, 20, 11, 50, 17, 45, 50,13, 45]</span><br><span class="line"></span><br><span class="line">res=mode(listA)</span><br><span class="line">print(&quot;Element with highest frequency:\n&quot;,res)</span><br><span class="line"># 输出 45</span><br></pre></td></tr></table></figure>
<h4 id="补充：关于-Counter"><a href="#补充：关于-Counter" class="headerlink" title="补充：关于 Counter"></a>补充：关于 Counter</h4><p>将一个 list 传入 Counter，将返回一个包含每个元素出现次数的字典</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"># Given list</span><br><span class="line">listA = [45, 20, 11, 50, 17, 45, 50,13, 45]</span><br><span class="line"></span><br><span class="line">occurence_count = Counter(listA)</span><br><span class="line">occurence_count.keys()</span><br><span class="line"># dict_keys([45, 20, 11, 50, 17, 13])</span><br><span class="line">occurence_count.values()</span><br><span class="line">dict_values([3, 1, 1, 2, 1, 1])</span><br></pre></td></tr></table></figure>
<p><code>most_common([n])</code>方法：</p>
<p>返回前n个出现次数最多的元素及其数量。 如果省略n或None，将返回计数器中的所有元素。 具有相同计数的元素可以任意排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">occurence_count.most_common(1)</span><br><span class="line"># [(45, 3)]</span><br><span class="line"></span><br><span class="line">occurence_count.most_common(2)</span><br><span class="line">#[(45, 3), (50, 2)]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/07/17/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><a id="more"></a>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>t检验与卡方检验</title>
    <url>/2021/06/27/t%E6%A3%80%E9%AA%8C%E4%B8%8E%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考<br> <a href="https://www.statology.org/chi-square-test-vs-t-test/" target="_blank" rel="noopener">Chi-Square Test vs. t-Test: What’s the Difference? - Statology</a><br><a href="https://byjus.com/maths/chi-square-test/" target="_blank" rel="noopener">Chi-Square Test | How to Calculate Chi-square using Formula with Example (byjus.com)</a> ⬅可查看卡方表</p>
</blockquote>
<h3 id="1-卡方检验"><a href="#1-卡方检验" class="headerlink" title="1. 卡方检验"></a>1. 卡方检验</h3><p>实际上卡方检验有几种不同的版本，但最常见的是卡方独立性检验（<a href="https://www.statology.org/chi-square-test-of-independence/" target="_blank" rel="noopener">Chi-Square Test of Independence</a>）。</p>
<h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h4><p>当我们想要检验两个分类变量之间是否存在统计上显着的关联时，我们使用卡方独立性检验。</p>
<blockquote>
<p>原假设($H_0$):  两个变量之间没有显著的关联。<br>备择假设($H_a$): 两个变量之间有显著的关联。</p>
</blockquote>
<p>即：拒绝原假设，表示两个变量之间有显著的关联</p>
<h4 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h4><p>以下是可能用到卡方独立性检验的一些例子。</p>
<p>（1）案例1：<br>我们想知道性别(男性、女性)和政党偏好(共和党、民主党、独立党派)之间是否有统计学上的显著关联。为了验证这一点，我们可以随机调查100个人，记录他们的性别和政党偏好。然后，我们可以对独立性进行卡方检验，以确定性别和政党偏好之间是否有统计学上的显著关联。</p>
<p>（2）案例2：<br>我们想知道年级(大一、大二、大三、大四)和最喜欢的电影类型(惊悚片、戏剧、西部片)之间是否有统计学上的显著关联。为了验证这一点，我们可以随机调查某所学校每个年级的100名学生，并记录下他们最喜欢的电影类型。然后，我们可以对独立性进行卡方检验，以确定年级和喜爱的电影类型之间是否有统计学意义上的关联。</p>
<p>（3）案例3：<br>我们想知道一个人最喜欢的运动(篮球、棒球、足球)和他们成长的地方(城市、农村)之间是否有统计学上的显著关联。为了验证这一点，我们可以随机调查100个人，问他们在什么样的地方长大，他们最喜欢的运动是什么。然后，我们可以对独立性进行卡方检验，以确定一个人最喜欢的运动和他们成长的地方之间是否有统计学上的显著关联</p>
<h4 id="1-3-假设"><a href="#1-3-假设" class="headerlink" title="1.3 假设"></a>1.3 假设</h4><p>在对独立性进行卡方检验之前，我们首先需要确保满足以下假设，以确保检验有效</p>
<ul>
<li>随机：应该使用随机样本或随机实验来收集两个样本的数据。</li>
<li>分类型：我们正在研究的变量应该是分类型的。</li>
<li>样本量 ：变量的每个取值的预期观察数应至少为5。</li>
</ul>
<h4 id="1-4-如何计算"><a href="#1-4-如何计算" class="headerlink" title="1.4 如何计算"></a>1.4 如何计算</h4><blockquote>
<p>参考 <a href="https://www.statology.org/chi-square-test-of-independence/" target="_blank" rel="noopener">https://www.statology.org/chi-square-test-of-independence/</a></p>
</blockquote>
<script type="math/tex; mode=display">
\chi^2=\frac{\sum(O-E)^2}{E}</script><p>where:<br>$O:$ observed value<br>$E:$ expected value</p>
<p>If the p-value that corresponds to the test statistic X2 with <span style="color:red">(#rows-1)*(#columns-1)</span> degrees of freedom is less than your chosen significance level then you can reject the null hypothesis.</p>
<p>假设我们想知道性别是否与政党偏好有关。我们随机抽取500名选民，调查他们的政党偏好。下表显示了调查结果:</p>
<p><img src="/2021/06/27/t检验与卡方检验/image-20210828222123770.png" alt="image-20210828222123770"></p>
<p>接下来，我们将用下面的公式计算列联表中每个单元格的期望值</p>
<script type="math/tex; mode=display">
Expected\ value = (row\ sum * column\ sum) / table\ sum.</script><p>For example, the expected value for Male Republicans is: $(230*250) / 500 = 115$​.<br>We can repeat this formula to obtain the expected value for each cell in the table:</p>
<p><img src="/2021/06/27/t检验与卡方检验/image-20210828222349083.png" alt="image-20210828222349083"></p>
<p>下一步，对每个单元格计算$(O-E)^2/E$<br>For example, Male Republicans would have a value of: $(120-115)^2 /115 = 0.2174$.<br>We can repeat this formula for each cell in the table:</p>
<p><img src="/2021/06/27/t检验与卡方检验/image-20210828222624861.png" alt="image-20210828222624861"></p>
<p>计算检验统计量 $\chi^2$ 和相应的p值：</p>
<p>$\chi^2 = Σ(O-E)^2 / E = 0.2174 + 0.2174 + 0.0676 + 0.0676 + 0.1471 + 0.1471 =0.8642$</p>
<p>According to the <a href="https://www.statology.org/chi-square-p-value-calculator/" target="_blank" rel="noopener">Chi-Square Score to P Value Calculator</a>, the p-value associated with $\chi^2$ = 0.8642 and (2-1)*(3-1) = 2 degrees of freedom is <strong>0.649198</strong>.<br>由于这个p值不小于0.05，我们无法拒绝零假设。这意味着我们没有足够的证据表明性别和政党偏好之间存在联系。</p>
<p><strong><em>Note</em></strong> : You can also perform this entire test by simply using the <a href="https://www.statology.org/chi-square-test-of-independence-calculator/" target="_blank" rel="noopener">Chi-Square Test of Independence Calculator</a>.</p>
<a id="more"></a>
<h3 id="2-t检验"><a href="#2-t检验" class="headerlink" title="2. t检验"></a>2. t检验</h3><p>t检验也有一些不同的版本，但最常见的是均值差异的t检验 (<a href="https://www.statology.org/two-sample-t-test/" target="_blank" rel="noopener">t-test for a difference in means</a>)。</p>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>当我们想检验两个总体均值之间是否有统计学上的显著差异时，我们用t检验来检验均值的差异。</p>
<blockquote>
<p>原假设($H_0$)：两个总体均值相等。<br>备择假设($H_a$): 两个总体均值不相等。</p>
</blockquote>
<p>即：拒绝原假设，表示两个总体的均值不相等</p>
<h4 id="2-2-案例"><a href="#2-2-案例" class="headerlink" title="2.2 案例"></a>2.2 案例</h4><p>（1）案例1：<br>我们想知道饮食A或饮食B，哪一个会导致更大的体重减轻。我们随机分配100人使用A饮食2个月，另外100人使用B饮食2个月。我们可以对平均值的差异进行t检验，以确定两组之间的平均体重减轻是否有统计学上的差异。</p>
<p>（2）案例2：<br>我们想知道是否两个不同的学习计划会导致学生不同的考试成绩。我们随机分配50名学生使用一个学习计划，50名学生使用另一个学习计划，为期一个月。我们可以对平均值的差异进行t检验，以确定两个学习计划的平均考试成绩是否有统计学上的显著差异。</p>
<p>（3）案例3：<br>我们想知道来自两个不同学校的学生是否有相同的平均身高。我们测量了100名随机来自一个学校的学生和100名随机来自另一个学校的学生的身高。我们可以对平均值的差异进行t检验，以确定两所学校学生的平均身高是否有统计学上的显著差异。</p>
<h4 id="2-3-假设"><a href="#2-3-假设" class="headerlink" title="2.3 假设"></a>2.3 假设</h4><p>在对两个总体均值之间的差异进行假设检验之前，我们首先需要确保满足以下条件，以确保我们的假设检验有效：</p>
<ul>
<li>随机：应该使用随机样本或随机实验来收集两个样本的数据。</li>
<li>正态性：抽样分布为正态或近似正态。</li>
<li>独立性：两个样本是独立的。</li>
</ul>
<h3 id="3-什么时候使用哪个检验"><a href="#3-什么时候使用哪个检验" class="headerlink" title="3. 什么时候使用哪个检验"></a>3. 什么时候使用哪个检验</h3><p>总结：</p>
<p>卡方独立性检验：可以检验两个分类型变量之间是否有统计学意义上的关联。当你拒绝卡方独立检验的零假设时，这意味着在两个变量之间有显著的关联。</p>
<p>均值差异的t检验：允许你检验两个总体均值之间是否有统计学上的显著差异。拒绝均值差异的t检验的零假设意味着两个总体均值不相等。</p>
<p>想要知道是使用卡方检验还是t检验，最简单的方法就是看看变量的类型。如果你有两个变量都是分类型的，也就是说，例如男性、女性，或共和党、民主党、独立党派，那么你应该使用卡方检验。但是如果一个变量是分类型的(例如学习计划类型 - 计划1或计划2)，而另一个变量是连续型的(例如考试分数从0到100)，那么你就应该使用t检验</p>
<h3 id="4-使用-Python-进行-t检验"><a href="#4-使用-Python-进行-t检验" class="headerlink" title="4. 使用 Python 进行 t检验"></a>4. 使用 Python 进行 t检验</h3><blockquote>
<p>参考 <a href="https://www.cnblogs.com/IvyWong/p/10134012.html" target="_blank" rel="noopener">使用 Python 进行 T检验 - 败北桑 - 博客园 (cnblogs.com)</a></p>
</blockquote>
<p>利用第三方库 scipy</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ttest_1samp: 单样本t检验</span><br><span class="line">ttest_ind: 两独立样本t检验</span><br><span class="line">ttest_rel: 配对样本t检验</span><br></pre></td></tr></table></figure>
<p>注：以上三种检验均默认进行双侧检验</p>
<p>$H_0:\mu = \mu_0$<br>$H_1: \mu \neq \mu_0$</p>
<h4 id="4-1-单样本t检验"><a href="#4-1-单样本t检验" class="headerlink" title="4.1 单样本t检验"></a>4.1 单样本t检验</h4><blockquote>
<p>官方文档 <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_1samp.html" target="_blank" rel="noopener">scipy.stats.ttest_1samp — SciPy v1.7.0 Manual</a></p>
</blockquote>
<p>使用<code>ttest_1samp()</code>函数可以进行单样本t检验，比如检验一列数据的均值与1的差异是否显著：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stats.ttest_1samp(data,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>结果会返回 t值 和 p值，若 p&lt;0.05，认为有显著差异</p>
<p>语法：</p>
<p><img src="/2021/06/27/t检验与卡方检验/image-20210717192910406.png" alt="image-20210717192910406"></p>
<h4 id="4-2-两独立样本t检验"><a href="#4-2-两独立样本t检验" class="headerlink" title="4.2 两独立样本t检验"></a>4.2 两独立样本t检验</h4><blockquote>
<p>官方文档 <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_ind.html" target="_blank" rel="noopener">scipy.stats.ttest_ind — SciPy v1.7.0 Manual</a></p>
</blockquote>
<p>使用<code>ttest_ind()</code>函数可以进行两独立样本t检验。</p>
<p>当两总体方差相等时，即具有<strong>方差齐性</strong>，可以直接检验：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stats.ttest_ind(data1,data2)</span><br></pre></td></tr></table></figure>
<p>同样地，返回结果会返回 t值 和 p值。</p>
<p>当不确定两总体方差是否相等时，应先利用<strong>levene检验</strong>，检验两总体是否具有方差齐性:</p>
<blockquote>
<p>官方文档<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.levene.html" target="_blank" rel="noopener">scipy.stats.levene — SciPy v1.7.0 Manual</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stats.levene(data1,data2)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/06/27/t检验与卡方检验/image-20210717193215478.png" alt="image-20210717193215478"></p>
<p>原假设：两总体具有方差齐性。<br>如果返回结果的p值远大于0.05，那么我们认为两总体具有方差齐性。</p>
<p>如果两总体不具有方差齐性，需要加上参数<code>equal_val</code>并设定为False。如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stats.ttest_ind(data1,data2,equal_var=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-3-配对样本t检验"><a href="#4-3-配对样本t检验" class="headerlink" title="4.3 配对样本t检验"></a>4.3 配对样本t检验</h4><blockquote>
<p>官方文档：<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.ttest_rel.html" target="_blank" rel="noopener">scipy.stats.ttest_rel — SciPy v1.7.0 Manual</a></p>
</blockquote>
<p>使用<code>ttest_rel()</code>函数可以进行配对样本t检验。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stats.ttest_rel(data1,data2)</span><br></pre></td></tr></table></figure>
<p>同样地，返回结果会返回t值和p值。</p>
<h3 id="5-使用-Python-进行卡方检验"><a href="#5-使用-Python-进行卡方检验" class="headerlink" title="5. 使用 Python 进行卡方检验"></a>5. 使用 Python 进行卡方检验</h3><p>使用 <code>scipy.stats</code> 库中的 <code>chi2_contingency</code></p>
<p>传入 contingency table (列联表)，返回</p>
<ul>
<li><strong>chi2:</strong> The test statistic</li>
<li><strong>p:</strong> The p-value of the test</li>
<li><strong>dof:</strong> Degrees of freedom</li>
<li><strong>expected:</strong> The expected frequencies, based on the marginal sums of the table</li>
</ul>
<blockquote>
<p>官方文档 <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.chi2_contingency.html" target="_blank" rel="noopener">scipy.stats.chi2_contingency — SciPy v1.7.1 Manual</a></p>
</blockquote>
<p>例：(参考<a href="https://python-bloggers.com/2020/09/how-to-run-chi-square-test-in-python/#:~:text= How to run Chi-Square Test in Python,null hypothesis at 95% level of... More" target="_blank" rel="noopener">How to run Chi-Square Test in Python | Python-bloggers</a>)</p>
<p>假设我们想要检验吸烟者和非吸烟者在性别(M, F)上是否存在统计学上显著的差异。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> chi2_contingency</span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;<span class="string">'Gender'</span> : [<span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'M'</span>, <span class="string">'F'</span>, <span class="string">'F'</span>] * <span class="number">10</span>,</span><br><span class="line">                   <span class="string">'isSmoker'</span> : [<span class="string">'Smoker'</span>, <span class="string">'Smoker'</span>, <span class="string">'Non-Smpoker'</span>, <span class="string">'Non-Smpoker'</span>, <span class="string">'Smoker'</span>] * <span class="number">10</span>&#125;)</span><br><span class="line"></span><br><span class="line">df.head()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">  Gender     isSmoker</span></span><br><span class="line"><span class="string">0      M       Smoker</span></span><br><span class="line"><span class="string">1      M       Smoker</span></span><br><span class="line"><span class="string">2      M  Non-Smpoker</span></span><br><span class="line"><span class="string">3      F  Non-Smpoker</span></span><br><span class="line"><span class="string">4      F       Smoker</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算列联表</span></span><br><span class="line">contingency= pd.crosstab(df[<span class="string">'Gender'</span>], df[<span class="string">'isSmoker'</span>])</span><br><span class="line">contingency</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">isSmoker  Non-Smpoker  Smoker</span></span><br><span class="line"><span class="string">Gender</span></span><br><span class="line"><span class="string">F                  10      10</span></span><br><span class="line"><span class="string">M                  10      20</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Chi-square test of independence.</span></span><br><span class="line">c, p, dof, expected = chi2_contingency(contingency)</span><br><span class="line">p</span><br><span class="line"><span class="comment"># 0.3767591178115821</span></span><br><span class="line"><span class="comment"># 大于0.05，不拒绝原假设，（原假设：Smokers and Gender are independent.）</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>假设检验</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2021/02/21/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="0-在线使用-Linux-Shell"><a href="#0-在线使用-Linux-Shell" class="headerlink" title="0. 在线使用 Linux Shell"></a>0. 在线使用 Linux Shell</h3><blockquote>
<p>参考 <a href="https://www.sohu.com/a/343421845_298038" target="_blank" rel="noopener">https://www.sohu.com/a/343421845_298038</a></p>
</blockquote>
<p>JS/UIX - Terminal</p>
<p>地址：<a href="https://www.masswerk.at/jsuix/index.html" target="_blank" rel="noopener">https://www.masswerk.at/jsuix/index.html</a></p>
<p>进入后，点击open terminal即可。它提供简单的终端环境，没有自带gcc等编译套件，不过练习基本命令和shell脚本还是可以的。</p>
<h3 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1. 常用命令"></a>1. 常用命令</h3><h4 id="1-1-ls-命令-显示指定工作目录下的内容"><a href="#1-1-ls-命令-显示指定工作目录下的内容" class="headerlink" title="1.1 ls 命令 - 显示指定工作目录下的内容"></a>1.1 ls 命令 - 显示指定工作目录下的内容</h4><blockquote>
<p>详见 <a href="https://www.runoob.com/linux/linux-comm-ls.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-ls.html</a></p>
</blockquote>
<p>显示指定工作目录下的内容（列出目前工作目录所含之文件及子目录)</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [-alrtAFR] [name...]</span><br><span class="line"> </span><br><span class="line">参数：</span><br><span class="line">-a： 显示所有文件及目录 (.开头的隐藏文件也会列出)</span><br><span class="line">-l： 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</span><br><span class="line"></span><br><span class="line">ls -l  可写作 ll</span><br><span class="line"></span><br><span class="line">常用写法：</span><br><span class="line">ll</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/1613903492422.png" alt="1613903492422"></p>
<p>结合 <code>grep</code> 使用：</p>
<p>查看文件 log.txt 是否存在于当前目录下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;ls | grep log.txt</span><br><span class="line">log.txt</span><br><span class="line">&gt;ls -al | grep log.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>
<h4 id="1-2-查看文件内容：cat"><a href="#1-2-查看文件内容：cat" class="headerlink" title="1.2 查看文件内容：cat"></a>1.2 查看文件内容：cat</h4><p><img src="/2021/02/21/Linux常用命令/1613903531146.png" alt="1613903531146"></p>
<a id="more"></a>
<h4 id="1-3-创建文件：-touch"><a href="#1-3-创建文件：-touch" class="headerlink" title="1.3 创建文件： touch"></a>1.3 创建文件： touch</h4><p><img src="/2021/02/21/Linux常用命令/1613903625026.png" alt="1613903625026"></p>
<p>此时，若想往text2中写入内容，可用 <code>echo &quot;hello word&quot;&gt;&gt;text2</code></p>
<p><img src="/2021/02/21/Linux常用命令/1613903728662.png" alt="1613903728662"></p>
<p><code>&gt;&gt;</code>代表在末尾追加，若使用<code>&gt;</code>则会把之前的内容覆盖</p>
<p><img src="/2021/02/21/Linux常用命令/1613903859605.png" alt="1613903859605"></p>
<p>当然，也可直接<code>vim text2</code>对文件进行编辑</p>
<p>注：无论是 <code>echo &quot;hello&quot;&gt;file</code> 还是 <code>echo &quot;hello&quot;&gt;&gt;file</code> ，如果file不存在都会先创建file文件</p>
<p>类似的用法有：<code>cat ./result.lst&gt;&gt;aa.txt</code>（将result.lst文件中的内容追加到aa.txt的末尾）</p>
<p><img src="/2021/02/21/Linux常用命令/1613904004258.png" alt="1613904004258"></p>
<h4 id="1-4-mv-为文件或目录改名、或将文件或目录移入其它位置"><a href="#1-4-mv-为文件或目录改名、或将文件或目录移入其它位置" class="headerlink" title="1.4 mv - 为文件或目录改名、或将文件或目录移入其它位置"></a>1.4 mv - 为文件或目录改名、或将文件或目录移入其它位置</h4><blockquote>
<p>详见 <a href="https://www.runoob.com/linux/linux-comm-mv.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-mv.html</a></p>
</blockquote>
<p><img src="/2021/02/21/Linux常用命令/1613904102186.png" alt="1613904102186"></p>
<p><img src="/2021/02/21/Linux常用命令/1613904249971.png" alt="1613904249971"></p>
<p>👆注：若test目录不存在，则该命令将text4重命名为test</p>
<p><img src="/2021/02/21/Linux常用命令/1613904395981.png" alt="1613904395981"></p>
<h4 id="1-5-rm-删除一个文件或者目录"><a href="#1-5-rm-删除一个文件或者目录" class="headerlink" title="1.5 rm - 删除一个文件或者目录"></a>1.5 rm - 删除一个文件或者目录</h4><blockquote>
<p>详见 <a href="https://www.runoob.com/linux/linux-comm-rm.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-rm.html</a></p>
</blockquote>
<p>删除文件：<code>rm 文件名</code></p>
<p>删除文件夹：<code>rm -r 文件夹名</code>。-r 将目录及以下之档案亦逐一删除</p>
<p><img src="/2021/02/21/Linux常用命令/1613904534240.png" alt="1613904534240"></p>
<p><img src="/2021/02/21/Linux常用命令/1613904600604.png" alt="1613904600604"></p>
<p><code>-f</code> 直接删除，无需逐一确认，见如下示例：</p>
<p><img src="/2021/02/21/Linux常用命令/1613904845877.png" alt="1613904845877"></p>
<h4 id="1-6-cp-复制文件或文件夹"><a href="#1-6-cp-复制文件或文件夹" class="headerlink" title="1.6 cp - 复制文件或文件夹"></a>1.6 cp - 复制文件或文件夹</h4><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [options] source dest</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</span><br><span class="line">-d：复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。</span><br><span class="line">-f：覆盖已经存在的目标文件而不给出提示。</span><br><span class="line">-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖。</span><br><span class="line">-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</span><br><span class="line">-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span><br><span class="line">-l：不复制文件，只是生成链接文件。</span><br></pre></td></tr></table></figure>
<p>例如，将当前路径下的a.txt复制到另外一个文件夹下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cp a.txt /data/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>将文件夹xgb_pipeline复制到另一个路径下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cp -r xgb_pipeline /data/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<p>将当前路径下的多个文件复制到另一个路径下：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cp a.txt b.json /data/<span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h3 id="2-压缩打包命令-tar、zip、unzip"><a href="#2-压缩打包命令-tar、zip、unzip" class="headerlink" title="2. 压缩打包命令 - tar、zip、unzip"></a>2. 压缩打包命令 - tar、zip、unzip</h3><blockquote>
<p>来自 <a href="https://blog.csdn.net/weixin_44901564/article/details/99682926" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44901564/article/details/99682926</a></p>
</blockquote>
<p>打包与压缩的区别：</p>
<p>打包是指将多个文件或者目录放在一起，形成一个总的包，这样便于保存和传输，但是大小是没有变化的，压缩是指将一个或者多个大文件或者目录通过压缩算法使文件的体积变小以达到压缩的目的，可以节省存储空间。</p>
<p>tar命令可以进行打包或压缩、解压，zip与unzip主要进行压缩与解压。（zip命令主要用于windows 系统下，例如在linux服务器上可用zip进行压缩，下载到本地windows系统，进行解压更加方便）</p>
<h4 id="2-1-tar命令"><a href="#2-1-tar命令" class="headerlink" title="2.1 tar命令"></a>2.1 tar命令</h4><h5 id="tar命令常用参数"><a href="#tar命令常用参数" class="headerlink" title="tar命令常用参数"></a>tar命令常用参数</h5><div class="table-container">
<table>
<thead>
<tr>
<th>-z</th>
<th>是否同时具有gz属性</th>
</tr>
</thead>
<tbody>
<tr>
<td>-j</td>
<td>是否同时具有bz2属性</td>
</tr>
<tr>
<td>-J</td>
<td>是否同时具有xz属性</td>
</tr>
<tr>
<td>-x</td>
<td>解压缩、提取打包的内容</td>
</tr>
<tr>
<td>-t</td>
<td>查看压缩包内容</td>
</tr>
<tr>
<td>-c</td>
<td>建立一个压缩，打包文档</td>
</tr>
<tr>
<td>-C</td>
<td>切换到指定目录，表示指定解压缩包的内容和打包的内容存放的目录</td>
</tr>
<tr>
<td>-v</td>
<td>显示压缩或者打包的内容</td>
</tr>
<tr>
<td>-f</td>
<td>使用文件名，在f后面要接压缩后的文件的名字，只要用到tar命令，-f选项是必须要用的，-f参数在使用的时候一定排在其他参数的后面，在最右边</td>
</tr>
<tr>
<td>-p</td>
<td>保留备份数据的原本权限与属性，常用于备份（-c）重要的配置文件</td>
</tr>
<tr>
<td>-P（大写P）</td>
<td>保留绝对路径</td>
</tr>
</tbody>
</table>
</div>
<h5 id="一、打包"><a href="#一、打包" class="headerlink" title="一、打包"></a>一、打包</h5><p><img src="/2021/02/21/Linux常用命令/1613918040999.png" alt="1613918040999"></p>
<h5 id="二、压缩"><a href="#二、压缩" class="headerlink" title="二、压缩"></a>二、压缩</h5><p>linux主要有三种压缩方式：<br>1.gzip：是公认的压缩速度最快，压缩大文件的时候与其他的压缩方式相比更加明显，历史最久，应用最广泛的压缩方式<br>2.bzip：压缩形成的文件小，但是可用性不如gzip<br>3.xz：是最新的压缩方式，可以自动提供最佳的压缩率</p>
<p>建议压缩的时候标明后缀：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>命名方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>-z</td>
<td>用于gzip压缩方式</td>
<td>文件名.tar.gz</td>
</tr>
<tr>
<td>-j</td>
<td>用于bzip2压缩方式</td>
<td>文件名.tar.bz2</td>
</tr>
<tr>
<td>-J</td>
<td>用于xz压缩方式</td>
<td>文件名.tar.xz</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2021/02/21/Linux常用命令/1613918385198.png" alt="1613918385198"></p>
<p><img src="/2021/02/21/Linux常用命令/1613918409030.png" alt="1613918409030"></p>
<h5 id="三、解压"><a href="#三、解压" class="headerlink" title="三、解压"></a>三、解压</h5><p><img src="/2021/02/21/Linux常用命令/1613918570956.png" alt="1613918570956"></p>
<p>tar命令在解压时不需要指明压缩的方式，它会自己选择跟压缩方式对应的方式去解压</p>
<p><img src="/2021/02/21/Linux常用命令/1613918627839.png" alt="1613918627839"></p>
<p>👆原文中未给出命令，猜测为 <code>tar -xf Golden.apk.tar.gz</code></p>
<p><img src="/2021/02/21/Linux常用命令/1613918698529.png" alt="1613918698529"></p>
<h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h5><p>a.在打包和压缩的过程中，我们有时会看到这样的语句：<strong>tar: 从成员名中删除开头的“/”</strong>，这个并不是报错，是因为没有加上-P选项，没有保留原来的绝对路径去打包或者压缩，提取打包的内容跟解压一样，下面举一个例子：</p>
<p><img src="/2021/02/21/Linux常用命令/1613919006930.png" alt="1613919006930"></p>
<p><img src="/2021/02/21/Linux常用命令/1613919034567.png" alt="1613919034567"></p>
<p>解压的时候同理，如果在压缩文件的时候使用了-P选项，那么在解压时也要加上-P选项，不然也会出现<strong>tar: 从成员名中删除开头的“/”</strong></p>
<p>b.在使用tar压缩或者打包的时候，可以通过增加 <code>--exclude</code> 来达到排除指定的文件的目的</p>
<p><img src="/2021/02/21/Linux常用命令/1613919127279.png" alt="1613919127279"></p>
<p>压缩文件 与 想要排除指定的目录压缩或者打包 同理</p>
<p>c. 使用 <code>-r</code> 选项增加.tar归档文件的内容</p>
<p>通过 <code>tar --help</code> 命令查看帮助</p>
<p><code>-r</code> 选项的作用：把要存档的文件追加到档案文件的未尾。例如用户已经作好备份文件，又发现还有一个目录或是一些文件忘记备份了，这时可以使用该选项，将忘记的目录或文件追加到备份文件中</p>
<p><img src="/2021/02/21/Linux常用命令/1613920583973.png" alt="1613920583973"></p>
<p>使用实例：</p>
<p><img src="/2021/02/21/Linux常用命令/1613920618990.png" alt="1613920618990"></p>
<p>（先将1进行归档，再追加2）</p>
<p>1.归档操作</p>
<p><img src="/2021/02/21/Linux常用命令/1613920677791.png" alt="1613920677791"></p>
<p>生成.tar文件，目录归档完毕</p>
<p>2.将calculating_time.sh追加进入.tar文件中</p>
<p><img src="/2021/02/21/Linux常用命令/1613920716990.png" alt="1613920716990"></p>
<p>查看.tar文件的归档信息：</p>
<p><img src="/2021/02/21/Linux常用命令/1613920751128.png" alt="1613920751128"></p>
<p>可以看到calculating_time.sh文件已经被追加到档案的末尾了</p>
<p>提取Check_Configuration_20201118_PM.tar 到/mnt目录下：</p>
<p><img src="/2021/02/21/Linux常用命令/1613920796143.png" alt="1613920796143"></p>
<p>使用-r选项追加文件至.tar文件成功</p>
<h4 id="2-2-zip命令和unzip命令"><a href="#2-2-zip命令和unzip命令" class="headerlink" title="2.2 zip命令和unzip命令"></a>2.2 zip命令和unzip命令</h4><p>在使用 zip 跟 unzip 命令之前先查看系统有没有安装这两个命令的包，没有的话要自己安装<br>查看有没有安装zip跟unzip命令的命令：</p>
<p><code>rpm -q zip unzip</code></p>
<p>如果安装了，则会显示出命令的版本号</p>
<p><img src="/2021/02/21/Linux常用命令/1613919407899.png" alt="1613919407899"></p>
<h5 id="一、zip命令"><a href="#一、zip命令" class="headerlink" title="一、zip命令"></a>一、zip命令</h5><p>基本用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip [参数] [压缩包名] [压缩的目录或者文件的路径]</span><br></pre></td></tr></table></figure>
<p>示例：<br><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;zip -r xgb_pipeline.zip xgb_pipeline</span><br></pre></td></tr></table></figure></p>
<h6 id="zip命令常用参数"><a href="#zip命令常用参数" class="headerlink" title="zip命令常用参数"></a>zip命令常用参数</h6><div class="table-container">
<table>
<thead>
<tr>
<th>-m</th>
<th>将文件压缩后，删除原文件</th>
</tr>
</thead>
<tbody>
<tr>
<td>-o</td>
<td>将压缩文件内的所有文件的最新变动时间设为压缩的时间</td>
</tr>
<tr>
<td>-q</td>
<td>安静模式，在压缩的时候不显示指令执行的过程</td>
</tr>
<tr>
<td>-r</td>
<td>递归压缩，将自定目录下的所有子文件以及文件一起处理</td>
</tr>
<tr>
<td>-x</td>
<td>”文件列表“，压缩时排除文件列表中的文件</td>
</tr>
</tbody>
</table>
</div>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p><img src="/2021/02/21/Linux常用命令/1613919749742.png" alt="1613919749742"></p>
<p><img src="/2021/02/21/Linux常用命令/1613919795113.png" alt="1613919795113"></p>
<p><img src="/2021/02/21/Linux常用命令/1613919829367.png" alt="1613919829367"></p>
<p><img src="/2021/02/21/Linux常用命令/1613919855669.png" alt="1613919855669"></p>
<h5 id="二、unzip命令"><a href="#二、unzip命令" class="headerlink" title="二、unzip命令"></a>二、unzip命令</h5><p>直接使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip xxx.zip</span><br></pre></td></tr></table></figure>
<p>便可解压到当前目录下。</p>
<p>基本用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip [参数] [压缩文件]  （-d [目录]）  //如果不使用括号内的内容，则解压文件到当前工作目录</span><br></pre></td></tr></table></figure>
<h6 id="unzip命令常用参数"><a href="#unzip命令常用参数" class="headerlink" title="unzip命令常用参数"></a>unzip命令常用参数</h6><div class="table-container">
<table>
<thead>
<tr>
<th>-c</th>
<th>将解压缩的结果显示到屏幕上（显示每一个目录下的每一个文件的内容），同时对字符做适当的转换，但是并没有解压压缩包</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>显示压缩文件内所包含的文件</td>
</tr>
<tr>
<td>-t</td>
<td>检查压缩文件是否正确</td>
</tr>
<tr>
<td>-v</td>
<td>执行时显示压缩文件的详细信息</td>
</tr>
<tr>
<td>-q</td>
<td>安静模式，执行时不显示任何信息</td>
</tr>
<tr>
<td>-d</td>
<td>指定文件解压后存储的目录</td>
</tr>
<tr>
<td>-x</td>
<td>指定不要处理压缩文件中的那些文件</td>
</tr>
</tbody>
</table>
</div>
<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>a.将harry.zip压缩包解压缩的结果显示出来：</p>
<p><img src="/2021/02/21/Linux常用命令/1613920145339.png" alt="1613920145339"></p>
<p>具体会显示到每一个文件跟每一个文件的内容</p>
<p>b.显示jihe.zip压缩包里面所包含的文件</p>
<p><img src="/2021/02/21/Linux常用命令/1613920185552.png" alt="1613920185552"></p>
<p>c.检查dajihe.zip压缩文件是否正确</p>
<p><img src="/2021/02/21/Linux常用命令/1613920223598.png" alt="1613920223598"></p>
<p>全部OK表示全部文件都是正确的</p>
<p>d.不解压压缩文件dajihe.zip，查看压缩包里面的内容（查看显示的文件列表还包含压缩比率）</p>
<p><img src="/2021/02/21/Linux常用命令/1613920257695.png" alt="1613920257695"></p>
<p>使用<code>-v</code>显示的信息比使用<code>-l</code>显示的信息更加详细</p>
<p>e.将dajihe.zip压缩包解压到/opt/目录下：</p>
<p><img src="/2021/02/21/Linux常用命令/1613920322610.png" alt="1613920322610"></p>
<p>注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unzip -l dajihe.zip</span><br><span class="line">unzip -v dajihe.zip</span><br><span class="line">unzip -c dajihe.zip</span><br><span class="line">都不会解压，只是查看</span><br><span class="line">unzip dajihe.zip会解压</span><br></pre></td></tr></table></figure>
<h3 id="3-Linux属主权限，chgrp，chown，chmod"><a href="#3-Linux属主权限，chgrp，chown，chmod" class="headerlink" title="3.Linux属主权限，chgrp，chown，chmod"></a>3.Linux属主权限，chgrp，chown，chmod</h3><blockquote>
<p>来自 <a href="https://www.cnblogs.com/CYHISTW/p/11031429.html" target="_blank" rel="noopener">https://www.cnblogs.com/CYHISTW/p/11031429.html</a></p>
</blockquote>
<p><img src="/2021/02/21/Linux常用命令/1613905079507.png" alt="1613905079507"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905119945.png" alt="1613905119945"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905151971.png" alt="1613905151971"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905209772.png" alt="1613905209772"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905243202.png" alt="1613905243202"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905317808.png" alt="1613905317808"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905345753.png" alt="1613905345753"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905383386.png" alt="1613905383386"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905411968.png" alt="1613905411968"></p>
<p>可使用 <code>chmod +x 文件名</code> 使文件变为可执行文件，例如：</p>
<p><img src="/2021/02/21/Linux常用命令/1613905651103.png" alt="1613905651103"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905697607.png" alt="1613905697607"></p>
<p>输入<code>i</code>进行编辑模式，完成后，按<code>esc</code>再输入<code>:wq</code> 保存并退出</p>
<p><img src="/2021/02/21/Linux常用命令/1613905784062.png" alt="1613905784062"></p>
<p>👆可以看到此时run.sh处于不可执行状态</p>
<p><img src="/2021/02/21/Linux常用命令/1613905838720.png" alt="1613905838720"></p>
<p><img src="/2021/02/21/Linux常用命令/1613905867580.png" alt="1613905867580"></p>
<p>成功执行</p>
<h3 id="4-shell-命令行参数"><a href="#4-shell-命令行参数" class="headerlink" title="4. shell 命令行参数"></a>4. shell 命令行参数</h3><blockquote>
<p>参考<br><a href="http://c.biancheng.net/cpp/view/2739.html" target="_blank" rel="noopener">http://c.biancheng.net/cpp/view/2739.html</a><br><a href="http://blog.csdn.net/jake_tian/article/details/97274630" target="_blank" rel="noopener">http://blog.csdn.net/jake_tian/article/details/97274630</a></p>
</blockquote>
<p>运行脚本时传递给脚本的参数称为命令行参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td>$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，获取第一个参数是$1，获取第二个参数是$2，以此类推</td>
</tr>
<tr>
<td>$#</td>
<td>传递给脚本或函数的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td>$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同</td>
</tr>
<tr>
<td>$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
</tbody>
</table>
</div>
<p>例：脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;File Name: $0&quot;</span><br><span class="line">echo &quot;First Parameter : $1&quot;</span><br><span class="line">echo &quot;First Parameter : $2&quot;</span><br><span class="line">echo &quot;Quoted Values: $@&quot;</span><br><span class="line">echo &quot;Quoted Values: $*&quot;</span><br><span class="line">echo &quot;Total Number of Parameters : $#&quot;</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$./test.sh Zara Ali</span><br><span class="line">File Name : ./test.sh</span><br><span class="line">First Parameter : Zara</span><br><span class="line">Second Parameter : Ali</span><br><span class="line">Quoted Values: Zara Ali</span><br><span class="line">Quoted Values: Zara Ali</span><br><span class="line">Total Number of Parameters : 2</span><br></pre></td></tr></table></figure>
<p>关于<code>$?</code>：上条命令的返回值。0表示没有错误，其他任何数值表示有错误。</p>
<blockquote>
<p>参考<br><a href="https://blog.csdn.net/aLLLiyyy/article/details/103184367" target="_blank" rel="noopener">https://blog.csdn.net/aLLLiyyy/article/details/103184367</a><br><a href="https://blog.csdn.net/weixin_39928768/article/details/111582889" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39928768/article/details/111582889</a></p>
</blockquote>
<p>例如：如果上条命令执行失败，则重复执行，shell脚本如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python test.py</span><br><span class="line"></span><br><span class="line"><span class="meta">while(($</span><span class="bash">?==1))</span></span><br><span class="line">do </span><br><span class="line">	sleep 30   # 休眠30s</span><br><span class="line">	python test.py</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h3 id="5-shell-日期加减运算"><a href="#5-shell-日期加减运算" class="headerlink" title="5. shell 日期加减运算"></a>5. shell 日期加减运算</h3><blockquote>
<p>参考<br><a href="http://blog.sina.com.cn/s/blog_ad6555610101b5ud.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_ad6555610101b5ud.html</a><br><a href="https://www.cnblogs.com/zhzhang/p/6846300.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhzhang/p/6846300.html</a><br><a href="https://www.cnblogs.com/simple-li/p/14040777.html" target="_blank" rel="noopener">https://www.cnblogs.com/simple-li/p/14040777.html</a><br><a href="http://www.dutycode.com/post-60.html" target="_blank" rel="noopener">http://www.dutycode.com/post-60.html</a></p>
</blockquote>
<p>假如今天是 2012-04-22</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ date -d &quot;+1 day&quot; +%Y-%m-%d</span><br><span class="line">2012-04-23</span><br><span class="line"></span><br><span class="line">$ date -d &quot;-1 day&quot; +%Y-%m-%d</span><br><span class="line">2012-04-21</span><br><span class="line"></span><br><span class="line">$ date -d &quot;2012-04-10 -1 day&quot; +%Y-%m-%d</span><br><span class="line">2012-04-09</span><br><span class="line"></span><br><span class="line">$ date -d &quot;+1 week&quot; +%Y-%m-%d</span><br><span class="line">2012-04-29</span><br><span class="line"></span><br><span class="line">同理还可 month, year</span><br></pre></td></tr></table></figure>
<p>例：脚本示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">if [ $# == 0 ] ; then</span><br><span class="line">    ydate=`date -d -1days &quot;+%Y%m%d&quot;`</span><br><span class="line">    ydateother=`date -d -1days &quot;+%Y-%m-%d&quot;`</span><br><span class="line">    tdate=`date -d -0days &quot;+%Y%m%d&quot;`</span><br><span class="line">    tdateother=`date -d -0days &quot;+%Y-%m-%d&quot;`</span><br><span class="line">elif [ $# == 1 ] ; then </span><br><span class="line">    ydate=$1</span><br><span class="line">    ydateother=`date -d $&#123;ydate&#125; +&quot;%Y-%m-%d&quot;`</span><br><span class="line">    tdate=`date -d &quot;$&#123;ydate&#125; 1days&quot; +&quot;%Y%m%d&quot;`</span><br><span class="line">    tdateother=`date -d $&#123;tdate&#125; +&quot;%Y-%m-%d&quot;`</span><br><span class="line">elif [ $# == 2 ] ; then </span><br><span class="line">    ydate=$1</span><br><span class="line">    ydateother=`date -d $&#123;ydate&#125; +&quot;%Y-%m-%d&quot;`</span><br><span class="line">    tdate=$2</span><br><span class="line">    tdateother=`date -d $&#123;tdate&#125; +&quot;%Y-%m-%d&quot;`</span><br><span class="line">else</span><br><span class="line">    echo &quot;please do not input if calcute yedterday.&quot;</span><br><span class="line">    echo &quot;please input like if calcute 20170510 one day: 20170510&quot;</span><br><span class="line">    echo &quot;please input like if calcute 20170510 and 20170512 two days : 20170510 20170511&quot;</span><br><span class="line">    exit -1</span><br><span class="line">fi </span><br><span class="line">echo $&#123;ydate&#125;&apos;--&apos;$&#123;ydateother&#125;&apos;--&apos;$&#123;tdate&#125;&apos;---&apos;$&#123;tdateother&#125;</span><br></pre></td></tr></table></figure>
<p>例： 按月执行201904到202010的py脚本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">i=201904 # 定义开始月份</span><br><span class="line">while [ $i -le 202010 ] # 当i小于等于202010时执行循环语句</span><br><span class="line">  do</span><br><span class="line">    dateNo1=$(date +&quot;%Y-%m-%d %H:%M:%S&quot;) # 获取当前时间(年月日时分秒)</span><br><span class="line">    echo &quot;开始执行($dateNo1): $i&quot; # 打印当前时间(年月日时分秒)</span><br><span class="line">    python tmp_sn_union_mem_20201125.py $i # 执行python脚本，传入月份参数。  此处也可做其他操作</span><br><span class="line">    dateNo2=$(date +&quot;%Y-%m-%d %H:%M:%S&quot;) # 获取当前时间(年月日时分秒) </span><br><span class="line">    echo &quot;结束执行($dateNo2): $i&quot; # 打印当前时间(年月日时分秒)</span><br><span class="line">    i=$[$i + 1] # 当前i值加1</span><br><span class="line">    if [ $i -eq 201913 ] # 判断i值是否等于201913，条件必须写在 [] 里</span><br><span class="line">     then</span><br><span class="line">      i=202001 # 如果i值等于201913，则让i值为202001</span><br><span class="line">    fi # if结束标记</span><br><span class="line">  done # while结束标记</span><br></pre></td></tr></table></figure>
<p>注：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fi                    容易忘记判断结束标记</span><br><span class="line">done                  容易忘记循环执行结束标记</span><br><span class="line">i=$[$i + 1]           变量加减运算要写在 $[] 里面。</span><br><span class="line">if [ $i -eq 201913 ]  条件必须写在 [] 里</span><br></pre></td></tr></table></figure>
<p>附：数值比较：</p>
<p><code>-eq</code>   相等（equal）<br><code>-ne</code>   不等（not equal）<br><code>-gt</code>    大于（greater than）<br><code>-lt</code>     小于（less than）<br><code>-ge</code>  大于等于 （greater than or equal）<br><code>-le</code>   小于等于 （less than or equal）</p>
<p>注：crontab任务调度中，%是个特殊字符，要在前加”\”进行转义</p>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 10 * * * cd /home/zzh &amp;&amp; sh test.sh $(date -d &quot;1 day ago&quot; +&quot;\%Y\%m\%d&quot;) &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h3 id="6-shell-变量"><a href="#6-shell-变量" class="headerlink" title="6. shell 变量"></a>6. shell 变量</h3><blockquote>
<p>参考 runoob.com/linux/linux-shell-variable.html</p>
</blockquote>
<p>定义变量时，变量名不加<code>$</code>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br></pre></td></tr></table></figure>
<p><span style="color:red">注：变量名和等号之间不能有空格</span></p>
<p>使用一个定义过的变量时，在变量名前加 <code>$</code>，如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">echo $a</span><br><span class="line">echo $&#123;a&#125;</span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量的边界。</p>
<p>已定义的变量，可以被重新定义：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a=10</span><br><span class="line">echo $a</span><br><span class="line">a=20</span><br><span class="line">echo $a</span><br></pre></td></tr></table></figure>
<p>注：第二次赋值的时候不能写成 <script type="math/tex">a=20`，使用变量时才加 `</script></p>
<h3 id="7-shell-字符串"><a href="#7-shell-字符串" class="headerlink" title="7. shell 字符串"></a>7. shell 字符串</h3><h4 id="7-1-单引号"><a href="#7-1-单引号" class="headerlink" title="7.1 单引号"></a>7.1 单引号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">str='this is a string'</span><br></pre></td></tr></table></figure>
<p>单引号字符串的限制：</p>
<ul>
<li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li>
<li>单引号字符串中不能出现单独一个的单引号（转义后也不行），但可成对出现，作为字符串拼接使用</li>
</ul>
<h4 id="7-2-双引号"><a href="#7-2-双引号" class="headerlink" title="7.2 双引号"></a>7.2 双引号</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">your_name="runoob"</span><br><span class="line">str="Hello, I know you are \"$your_name\"!"</span><br><span class="line">echo $str</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出：</span></span><br><span class="line">Hello, I know you are "runoob"!</span><br></pre></td></tr></table></figure>
<p>双引号的优点：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义字符</li>
</ul>
<h3 id="8-shell-基本运算符"><a href="#8-shell-基本运算符" class="headerlink" title="8. shell 基本运算符"></a>8. shell 基本运算符</h3><blockquote>
<p>参考 runoob.com/linux/linux-shell-basic-operators.html</p>
</blockquote>
<p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如expr。expr是一款表达式计算工具，使用它能完成表达式的求值操作。</p>
<p>例如，两个数相加：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo "两数之和为: $val"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 结果</span></span><br><span class="line">两数之和为: 4</span><br></pre></td></tr></table></figure>
<p>注：表达式和运算符之间要有空格，例如 <code>2+2</code> 是不对的，必须写成 <code>2 + 2</code></p>
<h4 id="8-1-算数运算符"><a href="#8-1-算数运算符" class="headerlink" title="8.1 算数运算符"></a>8.1 算数运算符</h4><p><img src="/2021/02/21/Linux常用命令/image-20210904144648161.png" alt="image-20210904144648161"></p>
<p>注：<span style="color:red">条件表达式要放在方括号之间，并且要有空格</span>，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code>。（方括号之间要有空格，运算符和变量之间也要有空格）</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904145343228.png" alt="image-20210904145343228" style="zoom: 67%;"></p>
<h4 id="8-2-关系运算符"><a href="#8-2-关系运算符" class="headerlink" title="8.2 关系运算符"></a>8.2 关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904145650517.png" alt="image-20210904145650517"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904145812074.png" alt="image-20210904145812074"></p>
<h4 id="8-3-布尔运算符"><a href="#8-3-布尔运算符" class="headerlink" title="8.3 布尔运算符"></a>8.3 布尔运算符</h4><p><img src="/2021/02/21/Linux常用命令/image-20210904150231679.png" alt="image-20210904150231679"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904150309883.png" alt="image-20210904150309883"></p>
<h4 id="8-4-逻辑运算符"><a href="#8-4-逻辑运算符" class="headerlink" title="8.4 逻辑运算符"></a>8.4 逻辑运算符</h4><p><img src="/2021/02/21/Linux常用命令/image-20210904150411459.png" alt="image-20210904150411459"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904150440602.png" alt="image-20210904150440602"></p>
<h4 id="8-5-字符串运算符"><a href="#8-5-字符串运算符" class="headerlink" title="8.5 字符串运算符"></a>8.5 字符串运算符</h4><p><img src="/2021/02/21/Linux常用命令/image-20210904150658570.png" alt="image-20210904150658570"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904150725984.png" alt="image-20210904150725984"></p>
<h3 id="9-shell-中各种括号的作用"><a href="#9-shell-中各种括号的作用" class="headerlink" title="9. shell 中各种括号的作用"></a>9. shell 中各种括号的作用</h3><blockquote>
<p>参考<br><a href="https://www.jb51.net/article/123081.htm" target="_blank" rel="noopener">https://www.jb51.net/article/123081.htm</a><br><a href="https://www.jianshu.com/p/3e1eaaa3fee8" target="_blank" rel="noopener">https://www.jianshu.com/p/3e1eaaa3fee8</a></p>
</blockquote>
<h4 id="9-1-单小括号"><a href="#9-1-单小括号" class="headerlink" title="9.1 单小括号 ()"></a>9.1 单小括号 ()</h4><p>一般在命令替换的时候使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">today=$(date +%y%m%d)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> shell扫描一遍命令，发现了$()结构，便将$()中的命令执行一次，得到其标准输出，再将此输出赋值给today</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于today=`date +%y%m%d`</span></span><br></pre></td></tr></table></figure>
<h4 id="9-2-双小括号"><a href="#9-2-双小括号" class="headerlink" title="9.2 双小括号 (())"></a>9.2 双小括号 (())</h4><blockquote>
<p>参考 <a href="http://c.biancheng.net/view/2480.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2480.html</a></p>
</blockquote>
<p>使用双括号，在比较过程中使用<strong>高级数学表达式</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>val++</td>
<td>后增</td>
</tr>
<tr>
<td>val—</td>
<td>后减</td>
</tr>
<tr>
<td>++val</td>
<td>先增</td>
</tr>
<tr>
<td>—val</td>
<td>先减</td>
</tr>
<tr>
<td>!</td>
<td>逻辑求反</td>
</tr>
<tr>
<td>~</td>
<td>位求反</td>
</tr>
<tr>
<td>**</td>
<td>幂操作</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左位移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右位移</td>
</tr>
</tbody>
</table>
</div>
<p>&amp;&amp;逻辑与，||逻辑或</p>
<p>双小括号 (( )) 是 Bash Shell 中专门用来进行整数运算的命令，它的效率很高，写法灵活，是企业运维中常用的运算命令。<code>(())</code>是一种数学计算命令，它除了可以进行最基本的加减乘除运算，还可以进行大于、小于、等于等关系运算，以及与、或、非逻辑运算。</p>
<p>注：<span style="color:red">(( )) 只能进行整数运算，不能对小数（浮点数）或者字符串进行运算。</span></p>
<p>双小括号 (( )) 的语法格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((表达式))</span><br></pre></td></tr></table></figure>
<p>通俗地讲，就是将数学运算表达式放在<code>((</code>和<code>))</code>之间。</p>
<p>表达式可以只有一个，也可以有多个，多个表达式之间以逗号<code>,</code>分隔。对于多个表达式的情况，以最后一个表达式的值作为整个 (( )) 命令的执行结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以使用 $ 获取 (( )) 命令的结果，这和使用 $ 获得变量值是类似的。</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/image-20210905110953010.png" alt="image-20210905110953010" style="zoom:150%;"></p>
<p><span style="color:red">在 (( )) 中使用变量无需加上<code>$</code>前缀，(( )) 会自动解析变量名，这使得代码更加简洁，也符合程序员的书写习惯。</span></p>
<p>【实例1】利用 (( )) 进行简单的数值计算。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905111242247.png" alt="image-20210905111242247"></p>
<p>【实例2】利用 (( )) 进行逻辑运算。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905111449347.png" alt="image-20210905111449347"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905115217853.png" alt="image-20210905115217853"></p>
<p>运行结果如下：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905115317618.png" alt="image-20210905115317618"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">可以直接使用if (($i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。</span><br></pre></td></tr></table></figure>
<p>【实例3】利用 (( )) 进行自增（++）和自减（—）运算。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">val=10     </span><br><span class="line">((val++))  </span><br><span class="line">echo $val  </span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 11</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/image-20210905111705126.png" alt="image-20210905111705126" style="zoom:150%;"></p>
<p>【实例4】利用 (( )) 同时对多个表达式进行计算。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905112032741.png" alt="image-20210905112032741"></p>
<h4 id="9-3-单方括号"><a href="#9-3-单方括号" class="headerlink" title="9.3 单方括号 []"></a>9.3 单方括号 []</h4><p>方括号定义了测试条件。第一个方括号 (<code>[</code>) 后和第二个方括号 (<code>]</code>) 前都要加一个空格，否则会报错。方括号主要包括4类判断：</p>
<p>（1）数值比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ $val1 -eq $val2 ]</span><br><span class="line">if [ $val1 -le $val2 ]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>（2）字符串比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if [ $str1 = $str2 ]</span><br><span class="line">if [ $str1 != $str2 ]</span><br><span class="line">if [ -n $str1 ]   # 检查str1的长度是否非0</span><br><span class="line">if [ -z $str1 ]   # 检查str1的长度是否为0</span><br></pre></td></tr></table></figure>
<p>例：test.sh脚本如下：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904182927259.png" alt="image-20210904182927259"></p>
<p>运行结果：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904183031882.png" alt="image-20210904183031882"></p>
<p>经过测试，数值也可以使用=, !=，且对于数值与字符串，=与==效果貌似一样？</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904190918657.png" alt="image-20210904190918657"></p>
<p>运行结果：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904190947396.png" alt="image-20210904190947396"></p>
<p>（3）文件比较</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904190420085.png" alt="image-20210904190420085" style="zoom:80%;"></p>
<p><img src="/2021/02/21/Linux常用命令/image-20210904190456860.png" alt="image-20210904190456860"></p>
<p>（4）符合条件比较</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[ condition1 ] &amp;&amp; [ condition2 ]</span><br><span class="line">[ condition1 ] || [ condition2 ]</span><br></pre></td></tr></table></figure>
<p>注：[ ]中的 逻辑与 和 逻辑或 使用 -a 和 -o 表示，例： <code>if [ $a -ne 1 -a $a != 2 ]</code>，或写作：<code>if [ $a -ne 1 ] &amp;&amp; [ $a != 2 ]</code></p>
<h4 id="9-4-双方括号"><a href="#9-4-双方括号" class="headerlink" title="9.4 双方括号 [[]]"></a>9.4 双方括号 [[]]</h4><ul>
<li>双方括号提供了<strong>字符串比较</strong>的高级特性</li>
<li>括号中可以定义一些正则表达式来匹配字符串</li>
<li>注意不是所有的shell都支持双方括号</li>
</ul>
<p><img src="/2021/02/21/Linux常用命令/image-20210904190701945.png" alt="image-20210904190701945"></p>
<p>注：&amp;&amp;、||、&lt; 和 &gt; 操作符能够正常存在于[[ ]]条件判断结构中，比如可以直接使用 <code>if [[ $a != 1 &amp;&amp; $a != 2 ]]</code></p>
<h4 id="9-5-例子"><a href="#9-5-例子" class="headerlink" title="9.5 例子"></a>9.5 例子</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if ($i&lt;5) </span><br><span class="line">if [ $i -lt 5 ] </span><br><span class="line">if [ $a -ne 1 -a $a != 2 ] </span><br><span class="line">if [ $a -ne 1] &amp;&amp; [ $a != 2 ] </span><br><span class="line">if [[ $a != 1 &amp;&amp; $a != 2 ]] </span><br><span class="line">for i in $(seq 0 4);do echo $i;done</span><br><span class="line">for i in `seq 0 4`;do echo $i;done</span><br><span class="line">for ((i=0;i&lt;5;i++));do echo $i;done</span><br><span class="line">for i in &#123;0..4&#125;;do echo $i;done</span><br></pre></td></tr></table></figure>
<h3 id="10-shell-if-else-语句"><a href="#10-shell-if-else-语句" class="headerlink" title="10. shell if else 语句"></a>10. shell if else 语句</h3><blockquote>
<p>参考 <a href="http://c.biancheng.net/view/1262.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1262.html</a></p>
</blockquote>
<h4 id="10-1-if-语句"><a href="#10-1-if-语句" class="headerlink" title="10.1 if 语句"></a>10.1 if 语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if condition</span><br><span class="line">then </span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>如果要将then 和 if 写在一行，要加个分号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if  condition;  then</span><br><span class="line">    statement(s)</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p>实例1：下面的例子使用 if 语句来比较两个数字的大小：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905110030266.png" alt="image-20210905110030266"></p>
<p>实例2：在判断条件中也可以使用逻辑运算符，例如：</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905112205882.png" alt="image-20210905112205882"></p>
<h4 id="10-2-if-else-语句"><a href="#10-2-if-else-语句" class="headerlink" title="10.2 if else 语句"></a>10.2 if else 语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if  condition</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">else</span><br><span class="line">   statement2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/image-20210905113102953.png" alt="image-20210905113102953"></p>
<h4 id="10-3-if-elif-else-语句"><a href="#10-3-if-elif-else-语句" class="headerlink" title="10.3 if elif else 语句"></a>10.3 if elif else 语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">if  condition1</span><br><span class="line">then</span><br><span class="line">   statement1</span><br><span class="line">elif condition2</span><br><span class="line">then</span><br><span class="line">    statement2</span><br><span class="line">elif condition3</span><br><span class="line">then</span><br><span class="line">    statement3</span><br><span class="line">...</span><br><span class="line">else</span><br><span class="line">   statementn</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/image-20210905113316626.png" alt="image-20210905113316626"></p>
<p>例2:</p>
<blockquote>
<p>来自 <a href="https://www.tutorialspoint.com/unix/if-elif-statement.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/unix/if-elif-statement.htm</a></p>
</blockquote>
<p><img src="/2021/02/21/Linux常用命令/image-20210905113545472.png" alt="image-20210905113545472" style="zoom:67%;"></p>
<h3 id="11-shell-while"><a href="#11-shell-while" class="headerlink" title="11. shell while"></a>11. shell while</h3><blockquote>
<p>参考<br><a href="http://c.biancheng.net/view/2804.html" target="_blank" rel="noopener">http://c.biancheng.net/view/2804.html</a><br><a href="https://blog.csdn.net/weixin_44324367/article/details/111312156" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44324367/article/details/111312156</a><br><a href="https://www.cnblogs.com/simple-li/p/14040777.html" target="_blank" rel="noopener">shell 之 循环执行某操作 - Simple-Sir - 博客园 (cnblogs.com)</a></p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    statements</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<p>while 语句和 if else 语句中的 condition 用法都是一样的，可以使用 test 或 [] 命令，也可以使用 (()) 或 [[]]</p>
<p>【实例1】计算从 1 加到 100 的和。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905114028564.png" alt="image-20210905114028564"></p>
<p>【实例2】计算从 m 加到 n 的值。</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905115543470.png" alt="image-20210905115543470"></p>
<p>【实例3】输出0~10的所有整数</p>
<p><img src="/2021/02/21/Linux常用命令/image-20210905115630118.png" alt="image-20210905115630118"></p>
<h3 id="12-重定向"><a href="#12-重定向" class="headerlink" title="12. 重定向"></a>12. 重定向</h3><p>参考 <a href="https://www.cnblogs.com/zhenghongxin/p/7029173.html" target="_blank" rel="noopener">linux shell中”2&gt;&amp;1”含义 - hongxinerke - 博客园 (cnblogs.com)</a></p>
<blockquote>
<p>1表示标准输出<br>2表示标准错误<br>2&gt;&amp;1 的意思就是将标准错误重定向到标准输出</p>
</blockquote>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;./test_run.sh &gt;test_run.sh.log 2&gt;&amp;1</span><br><span class="line">输出结果保存到test_run.sh.log（标准输出与错误）（&gt;会覆盖已存在的内容）</span><br><span class="line"></span><br><span class="line">&gt;./test_run.sh &gt;&gt;test_run.sh.log 2&gt;&amp;1</span><br><span class="line">输出结果追加到test_run.sh.log（标准输出与错误）（&gt;&gt;追加到末尾）</span><br><span class="line"></span><br><span class="line">&gt;./test_run.sh &gt;test_run.sh.log</span><br><span class="line">输出结果保存到test_run.sh.log（标准输出），错误信息输出到屏幕</span><br><span class="line"></span><br><span class="line">&gt;./test_run.sh 2&gt;test_run.sh.log</span><br><span class="line">输出结果（不包含错误信息）到屏幕，错误信息保存到test_run.sh.log</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例有crontab任务：</span><br><span class="line">*/2 * * * * root cd /opt/xxxx/test_S1/html/xxxx/admin; php index.php task testOne &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">可以把/dev/null 可以看作&quot;黑洞&quot;. 它等价于一个只写文件. 所有写入它的内容都会永远丢失. 而尝试从它那儿读取内容则什么也读不到.</span><br><span class="line">可以把 &amp; 在命令的最后加上，表示让程序后台执行。</span><br><span class="line"></span><br><span class="line">0 5 * * * 表示每天5:00执行</span><br></pre></td></tr></table></figure>
<p>补充：如何既将结果保存到文件，又输出到屏幕：可使用 <code>tee</code>，示例如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;./pythonsql.sh | tee pythonsql.log</span><br></pre></td></tr></table></figure>
<h3 id="13-crontab-定时执行shell脚本"><a href="#13-crontab-定时执行shell脚本" class="headerlink" title="13. crontab 定时执行shell脚本"></a>13. crontab 定时执行shell脚本</h3><blockquote>
<p>参考<br><a href="https://www.cnblogs.com/chen-lhx/p/5996781.html" target="_blank" rel="noopener">linux crontab定时执行shell脚本 - 龙昊雪 - 博客园 (cnblogs.com)</a><br><a href="https://blog.csdn.net/ithomer/article/details/6817019" target="_blank" rel="noopener">linux定时运行命令脚本——crontab_阳光岛主-CSDN博客</a></p>
</blockquote>
<p>crontab命令说明：<br>crontab命令被用来提交和管理用户的需要周期性执行的任务，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">语法</span><br><span class="line">　crontab (选项) (参数)</span><br><span class="line">选项</span><br><span class="line">　-e：编辑该用户的计时器设置；</span><br><span class="line">　-l：列出该用户的计时器设置；</span><br><span class="line">　-r：删除该用户的计时器设置；</span><br><span class="line">　-u&lt;用户名称&gt;：指定要设定计时器的用户名称。</span><br><span class="line">参数</span><br><span class="line">　crontab文件：指定包含待执行任务的crontab文件。</span><br></pre></td></tr></table></figure>
<p>crontab命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crontab -e -&gt; 编辑（进入后，press i 进行编辑，:wq保存并退出）</span><br><span class="line">crontab -l -&gt; 查看</span><br></pre></td></tr></table></figure>
<p>crontab文件的含义：<br>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">minute hour day month week command     </span><br><span class="line">顺序：分 时 日 月 周</span><br><span class="line">其中：</span><br><span class="line">minute： 表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br><span class="line">在以上各个字段中，还可以使用以下特殊字符：</span><br><span class="line"></span><br><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</span><br><span class="line"></span><br><span class="line">注释行要在行首用#来表示</span><br></pre></td></tr></table></figure>
<p>crontab文件条目的一些例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">30 21 * * * /apps/bin/cleanup.sh</span><br><span class="line">上面的例子表示每晚的21:30运行/apps/bin目录下的cleanup.sh。</span><br><span class="line"></span><br><span class="line">45 4 1,10,22 * * /apps/bin/backup.sh</span><br><span class="line">上面的例子表示每月1、10、22日的4:45运行/apps/bin目录下的backup.sh。</span><br><span class="line"></span><br><span class="line">10 1 * * 6,0 /bin/find -name &quot;core&quot; -exec rm &#123;&#125; ;</span><br><span class="line">上面的例子表示每周六、周日的1:10运行一个find命令。</span><br><span class="line"></span><br><span class="line">0,30 18-23 * * * /apps/bin/dbcheck.sh</span><br><span class="line">上面的例子表示在每天18:00至23:00之间每隔30分钟运行/apps/bin目录下的dbcheck.sh。</span><br><span class="line"></span><br><span class="line">0 23 * * 6 /apps/bin/qtrend.sh</span><br><span class="line">上面的例子表示每星期六的23:00运行/apps/bin目录下的qtrend.sh。</span><br><span class="line"></span><br><span class="line">你可能已经注意到上面的例子中，每个命令都给出了绝对路径。当使用crontab运行shell脚本时，要由用户来给出脚本的绝对路径，设置相应的环境变量。</span><br></pre></td></tr></table></figure>
<h4 id="13-1关于路径"><a href="#13-1关于路径" class="headerlink" title="13.1关于路径"></a>13.1关于路径</h4><p>关于路径错误，因为在crontab中使用了绝对路径执行脚本，因此在该脚本中引用的其它脚本也都需要使用绝对路径，才能被crontab找到并执行。如何避免绝对路径复杂的设置呢，可采用如下格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0 5 * * * cd /data/test-ml;sh crontab_run.sh &gt;&gt;/data/test-ml/crontab_run.sh.log 2&gt;&amp;1 &amp;</span><br><span class="line">或 </span><br><span class="line">0 5 * * * cd /data/test-ml &amp;&amp; ./crontab_run.sh &gt;&gt;/data/test-ml/crontab_run.sh.log 2&gt;&amp;1 &amp;</span><br><span class="line">每天5点执行，并将输出保存至crontab_run.sh.log（包括标准输出与标准错误）</span><br></pre></td></tr></table></figure>
<p>建议使用此方式，先进入该目录，然后再执行脚本；否则，执行脚本中的其它脚本都需要加绝对路径</p>
<h4 id="13-2-crontab-中传入时间参数"><a href="#13-2-crontab-中传入时间参数" class="headerlink" title="13.2 crontab 中传入时间参数"></a>13.2 crontab 中传入时间参数</h4><p>参考 <a href="https://blog.csdn.net/weixin_45744450/article/details/108409803" target="_blank" rel="noopener">linux内crontab传时间参数_大大盒子的博客-CSDN博客</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">15 4 * * * /home/temp/post_analysis/post_analysis_sqoop.sh $(date -d &quot;1 day ago&quot; +&quot;\%Y-\%m-\%d&quot;) &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>
<h3 id="14-Linux-shell-管道"><a href="#14-Linux-shell-管道" class="headerlink" title="14 Linux shell 管道"></a>14 Linux shell 管道</h3><blockquote>
<p>参考 <a href="http://c.biancheng.net/view/3131.html" target="_blank" rel="noopener">http://c.biancheng.net/view/3131.html</a></p>
</blockquote>
<p>Shell 有一种功能，就是可以将两个或者多个命令（程序或者进程）连接到一起，把一个命令的输出作为下一个命令的输入，以这种方式连接的两个或者多个命令就形成了<strong>管道（pipe）</strong>。</p>
<p>Linux 管道使用竖线<code>|</code>连接多个命令，这被称为管道符。Linux 管道的具体语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">command1 | command2</span><br><span class="line">command1 | command2 [ | commandN... ]</span><br></pre></td></tr></table></figure>
<p> 管道符<code>|</code>与两侧的命令之间可以存在也可以不存在空格。</p>
<p>当在两个命令之间设置管道时，管道符<code>|</code>左边命令的输出就变成了右边命令的输入。只要第一个命令向标准输出写入，而第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道。大部分的 Linux 命令都可以用来形成管道。</p>
<p>使用管道的优点：省去创建临时文件。</p>
<p>【示例】将 ls 命令的输出发送到 grep 命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls | grep log.txt</span><br><span class="line">log.txt</span><br></pre></td></tr></table></figure>
<p>上述命令是查看文件 log.txt 是否存在于当前目录下。</p>
<p>我们可以在命令的后面使用选项，例如使用<code>-al</code>选项：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>
<p>我们也可以重定向管道的输出到一个文件（使用重定向操作符&gt;或&gt;&gt;将管道中的最后一个命令的标准输出进行重定向），比如将上述管道命令的输出结果发送到文件 output.txt 中： </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[c.biancheng.net]$ ls -al | grep log.txt &gt;output.txt</span><br><span class="line">[c.biancheng.net]$ cat output.txt</span><br><span class="line">-rw-rw-r--.  1 mozhiyan mozhiyan    0 4月  15 17:26 log.txt</span><br></pre></td></tr></table></figure>
<h3 id="15-在-Linux-shell-中查看与处理文件常用的命令"><a href="#15-在-Linux-shell-中查看与处理文件常用的命令" class="headerlink" title="15. 在 Linux shell 中查看与处理文件常用的命令"></a>15. 在 Linux shell 中查看与处理文件常用的命令</h3><h4 id="15-1-less"><a href="#15-1-less" class="headerlink" title="15.1 less"></a>15.1 less</h4><p>使用管道将 cat 命令的输出作为 less 命令的输入，这样就可以将 cat 命令的输出每次按照一个屏幕的长度显示，这对于查看长度大于一个屏幕的文件内容很有帮助。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">cat /var/<span class="built_in">log</span>/message | less</span><br></pre></td></tr></table></figure>
<h4 id="15-2-grep"><a href="#15-2-grep" class="headerlink" title="15.2 grep"></a>15.2 grep</h4><blockquote>
<p>参考 <a href="https://www.runoob.com/linux/linux-comm-grep.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-grep.html</a></p>
</blockquote>
<p>grep 命令用于查找文件里符合条件的字符串。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示行数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-a 或 --text : 不要忽略二进制的数据。</span><br><span class="line">-A&lt;显示行数&gt; 或 --after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</span><br><span class="line">-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</span><br><span class="line">-B&lt;显示行数&gt; 或 --before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-c 或 --count : 计算符合样式的列数。</span><br><span class="line">-C&lt;显示行数&gt; 或 --context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</span><br><span class="line">-d &lt;动作&gt; 或 --directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</span><br><span class="line">-e&lt;范本样式&gt; 或 --regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。</span><br><span class="line">-E 或 --extended-regexp : 将样式为延伸的正则表达式来使用。</span><br><span class="line">-f&lt;规则文件&gt; 或 --file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</span><br><span class="line">-F 或 --fixed-regexp : 将样式视为固定字符串的列表。</span><br><span class="line">-G 或 --basic-regexp : 将样式视为普通的表示法来使用。</span><br><span class="line">-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</span><br><span class="line">-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。</span><br><span class="line">-i 或 --ignore-case : 忽略字符大小写的差别。</span><br><span class="line">-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。</span><br><span class="line">-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。</span><br><span class="line">-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。</span><br><span class="line">-o 或 --only-matching : 只显示匹配PATTERN 部分。</span><br><span class="line">-q 或 --quiet或--silent : 不显示任何信息。</span><br><span class="line">-r 或 --recursive : 此参数的效果和指定&quot;-d recurse&quot;参数相同。</span><br><span class="line">-s 或 --no-messages : 不显示错误信息。</span><br><span class="line">-v 或 --invert-match : 显示不包含匹配文本的所有行。</span><br><span class="line">-V 或 --version : 显示版本信息。</span><br><span class="line">-w 或 --word-regexp : 只显示全字符合的列。</span><br><span class="line">-x --line-regexp : 只显示全列符合的列。</span><br><span class="line">-y : 此参数的效果和指定&quot;-i&quot;参数相同。</span><br></pre></td></tr></table></figure>
<p>【示例1】在当前路径下，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">grep <span class="built_in">test</span> *file</span><br></pre></td></tr></table></figure>
<p>结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;grep test test* #查找前缀有“test”的文件包含“test”字符串的文件  </span><br><span class="line">testfile1:This a Linux testfile! #列出testfile1 文件中包含test字符的行  </span><br><span class="line">testfile_2:This is a linux testfile! #列出testfile_2 文件中包含test字符的行  </span><br><span class="line">testfile_2:Linux test #列出testfile_2 文件中包含test字符的行</span><br></pre></td></tr></table></figure>
<p>【示例2】以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串”update”的文件，并打印出该字符串所在行的内容，使用的命令为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep -r update /etc/acpi</span><br></pre></td></tr></table></figure>
<p>【示例3】查看result.csv中出现100001的行并输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cat result.csv | grep 100001</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/1649855242323.png" alt="1649855242323"></p>
<p>将输出结果存入文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cat result.csv | grep 100001 &gt;output.txt</span><br></pre></td></tr></table></figure>
<p>查找并返回行号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;cat result.csv | grep -n 100001</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/1649856944592.png" alt="1649856944592"></p>
<p>若想在另一个文件中查看相同行号的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cat result2.csv | sed -n &apos;334007p&apos;</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/1649858199759.png" alt="1649858199759"></p>
<h4 id="15-3-wc"><a href="#15-3-wc" class="headerlink" title="15.3 wc"></a>15.3 wc</h4><blockquote>
<p>参考 <a href="https://www.runoob.com/linux/linux-comm-wc.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-comm-wc.html</a></p>
</blockquote>
<p>wc命令用于计算字数</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wc [-clw][--help][--version][文件...]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">-c或--bytes或--chars 只显示Bytes数。</span><br><span class="line">-l或--lines 显示行数。</span><br><span class="line">-w或--words 只显示字数。</span><br><span class="line">--help 在线帮助。</span><br><span class="line">--version 显示版本信息。</span><br></pre></td></tr></table></figure>
<p>【示例1】返回行数，字数，字节数</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat testfile  </span><br><span class="line">Linux networks are becoming more and more common, but scurity is often an overlooked  </span><br><span class="line">issue. Unfortunately, <span class="keyword">in</span> today’s environment all networks are potential hacker targets,  </span><br><span class="line">fro0m tp-secret military research networks to small home LANs.  </span><br><span class="line">Linux Network Securty focuses on securing Linux <span class="keyword">in</span> a networked environment, <span class="built_in">where</span> the  </span><br><span class="line">security of the entire network needs to be considered rather than just isolated machines.  </span><br><span class="line">It uses a mix of theory and practicl techniques to teach administrators how to install and  </span><br><span class="line">use security applications, as well as how the applcations work and why they are necesary. </span><br><span class="line"></span><br><span class="line">$ wc testfile           <span class="comment"># testfile文件的统计信息  </span></span><br><span class="line">3 92 598 testfile       <span class="comment"># testfile文件的行数为3、单词数92、字节数598</span></span><br></pre></td></tr></table></figure>
<p>【示例2】查看文件中包含多少个逗号，结合 <code>grep</code>：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cat result.txt | grep -o <span class="string">','</span> | wc -l</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/21/Linux常用命令/1649857332971.png" alt="1649857332971"></p>
<h4 id="15-4-sed"><a href="#15-4-sed" class="headerlink" title="15.4 sed"></a>15.4 sed</h4><p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]</span><br><span class="line"></span><br><span class="line">参数说明：</span><br><span class="line">-e&lt;script&gt;或--expression=&lt;script&gt; 以选项中指定的script来处理输入的文本文件。</span><br><span class="line">-f&lt;script文件&gt;或--file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</span><br><span class="line">-h或--help 显示帮助。</span><br><span class="line">-n或--quiet或--silent 仅显示script处理后的结果。</span><br><span class="line">-V或--version 显示版本信息。</span><br><span class="line"></span><br><span class="line">动作说明：</span><br><span class="line">a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</span><br><span class="line">c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</span><br><span class="line">d ：删除，因为是删除啊，所以 d 后面通常不接任何东东；</span><br><span class="line">i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</span><br><span class="line">s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</span><br></pre></td></tr></table></figure>
<p>假如有如下文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat testfile <span class="comment">#查看testfile 中的内容  </span></span><br><span class="line">HELLO LINUX!  </span><br><span class="line">Linux is a free unix-type opterating system.  </span><br><span class="line">This is a linux testfile!  </span><br><span class="line">Linux <span class="built_in">test</span> </span><br><span class="line">Google</span><br><span class="line">Taobao</span><br><span class="line">Runoob</span><br><span class="line">Tesetfile</span><br><span class="line">Wiki</span><br></pre></td></tr></table></figure>
<p>【示例1】列出文件的5到7行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat testfile | sed -n <span class="string">'5,7p'</span></span><br><span class="line">Google</span><br><span class="line">Taobao</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>
<p>【示例2】搜索 testfile 有 oo 关键字的行:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ cat testfile | sed -n <span class="string">'/oo/p'</span></span><br><span class="line">Google</span><br><span class="line">Runoob</span><br></pre></td></tr></table></figure>
<p>【示例3】数据的查找与替换：</p>
<p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的查找与替换</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &apos;s/要被取代的字串/新的字串/g&apos;</span><br></pre></td></tr></table></figure>
<p>将 testfile 文件中每行第一次出现的 oo 用字符串 kk 替换，然后将该文件内容输出到标准输出: </p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sed -e <span class="string">'s/oo/kk/'</span> testfile</span><br></pre></td></tr></table></figure>
<p>注：sed 后面接的动作，要以 ‘…’ 两个单引号括住</p>
<p><code>g</code> 标识符表示全局查找替换，使 sed 对文件中所有符合的字符串都被替换，修改后内容会到标准输出，不会修改原文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sed -e <span class="string">'s/oo/kk/g'</span> testfile</span><br></pre></td></tr></table></figure>
<p>选项 <code>i</code> 使 sed 修改文件:</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sed -i <span class="string">'s/oo/kk/g'</span> testfile</span><br></pre></td></tr></table></figure>
<p>批量操作当前目录下以 <strong>test</strong> 开头的文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sed -i <span class="string">'s/oo/kk/g'</span> ./<span class="built_in">test</span>*</span><br></pre></td></tr></table></figure>
<p>【示例4】将文件中的的逗号替换为\t，写入另一个文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;cat ./docs/a.txt |sed <span class="string">'s/,/\t/g'</span> &gt;./docs/b.txt</span><br></pre></td></tr></table></figure>
<p>直接修改原文件：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt;sed -i <span class="string">'s/,/\t/g'</span> ./docs/a.txt</span><br></pre></td></tr></table></figure>
<h4 id="15-5-关于vim"><a href="#15-5-关于vim" class="headerlink" title="15.5 关于vim"></a>15.5 关于vim</h4><h5 id="15-5-1-快速清空文件内容"><a href="#15-5-1-快速清空文件内容" class="headerlink" title="15.5.1 快速清空文件内容"></a>15.5.1 快速清空文件内容</h5><blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_21238607/article/details/119541193" target="_blank" rel="noopener">https://blog.csdn.net/qq_21238607/article/details/119541193</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#命令模式下</span><br><span class="line">G # 跳至文件最后一行</span><br><span class="line">d1G # 删除首行至光标所在行的所有数据</span><br></pre></td></tr></table></figure>
<p>👆 注：输入完 <code>d1G</code>后，会立马清空，不会要求确认等操作。</p>
<h5 id="15-5-2-撤销与恢复"><a href="#15-5-2-撤销与恢复" class="headerlink" title="15.5.2 撤销与恢复"></a>15.5.2 撤销与恢复</h5><blockquote>
<p>参考 <a href="http://c.biancheng.net/view/6332.html" target="_blank" rel="noopener">http://c.biancheng.net/view/6332.html</a></p>
</blockquote>
<p><img src="/2021/02/21/Linux常用命令/1650364215210.png" alt="1650364215210"></p>
<p>注意，以上这 3 种命令都必须在 Vim 编辑器处于命令模式时才能使用。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL中的各种连接join</title>
    <url>/2021/02/14/SQL%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E8%BF%9E%E6%8E%A5join/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考：<br><a href="https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html" target="_blank" rel="noopener">https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html</a><br><a href="https://www.w3school.com.cn/sql/sql_join_left.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/sql/sql_join_left.asp</a><br><a href="https://www.w3school.com.cn/sql/sql_join.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/sql/sql_join.asp</a><br><a href="https://www.cnblogs.com/yelp/p/3761443.html" target="_blank" rel="noopener">https://www.cnblogs.com/yelp/p/3761443.html</a><br><a href="https://blog.csdn.net/qq_41973536/article/details/81081024" target="_blank" rel="noopener">https://blog.csdn.net/qq_41973536/article/details/81081024</a></p>
</blockquote>
<p>最常见的 JOIN 类型：<strong>SQL INNER JOIN（等价于 JOIN）、SQL LEFT JOIN（等价于LEFT OUTER JOIN）、SQL  RIGHT JOIN（等价于RIGHT OUTER JOIN）、SQL FULL JOIN（等价于FULL OUTER JOIN），</strong>其中前一种是内连接，后三种是外连接。</p>
<ul>
<li>JOIN: 内连接，又叫等值连接，只返回两个表中连接字段相等的行。（如果表中有至少一个匹配，则返回行）</li>
<li>LEFT JOIN: 左连接，返回左表中所有的记录以及右表中连接字段相等的记录。（即使右表中没有匹配，也从左表返回所有的行）</li>
<li>RIGHT JOIN: 右连接，返回右表中所有的记录以及左表中连接字段相等的记录。（即使左表中没有匹配，也从右表返回所有的行）</li>
<li>FULL JOIN: 外连接，返回两个表中的行：left join + right join。（只要其中一个表中存在匹配，就返回行）</li>
<li>cross join: 结果是笛卡尔积，就是第一个表的行数乘以第二个表的行数。</li>
</ul>
<p>假设我们有两张表，Table A是左边的表，Table B是右边的表。</p>
<p>Table A:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Google</td>
</tr>
<tr>
<td>2</td>
<td>淘宝</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
</tr>
<tr>
<td>4</td>
<td>Facebook</td>
</tr>
</tbody>
</table>
</div>
<p>Table B:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>美国</td>
</tr>
<tr>
<td>5</td>
<td>中国</td>
</tr>
<tr>
<td>3</td>
<td>中国</td>
</tr>
<tr>
<td>6</td>
<td>美国</td>
</tr>
</tbody>
</table>
</div>
<h3 id="1-INNER-JOIN"><a href="#1-INNER-JOIN" class="headerlink" title="1. INNER JOIN"></a>1. INNER JOIN</h3><p>内连接只连接匹配的行。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span></span><br><span class="line"><span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/SQL中的各种连接join/1624780519991.png" alt="1624780519991"></p>
<p>INNER JOIN产生的结果集，是1和2的交集。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tableA.id, <span class="keyword">name</span>, address </span><br><span class="line"><span class="keyword">from</span> tableA <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> tableA.id = tableB.id</span><br></pre></td></tr></table></figure>
<p>执行以上SQL输出结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Google</td>
<td>美国</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
<td>中国</td>
</tr>
</tbody>
</table>
</div>
<p>等价于</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tableA.id, <span class="keyword">name</span>, address</span><br><span class="line"><span class="keyword">from</span> tableA, tableB</span><br><span class="line"><span class="keyword">where</span> tableA.id = tableB.id</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="2-LEFT-JOIN"><a href="#2-LEFT-JOIN" class="headerlink" title="2. LEFT JOIN"></a>2. LEFT JOIN</h3><p>LEFT JOIN返回左表的全部行和右表满足ON条件的行，如果左表的行在右表中没有匹配，那么这一行右表中对应数据用NULL代替。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/SQL中的各种连接join/1624780567674.png" alt="1624780567674"></p>
<p>LEFT JOIN产生表1的完全集，而2表中匹配的则有值，没有匹配的则以null值取代。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tableA.id, <span class="keyword">name</span>, address </span><br><span class="line"><span class="keyword">from</span> tableA <span class="keyword">left</span> <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> tableA.id = tableB.id</span><br></pre></td></tr></table></figure>
<p> 执行以上SQL输出结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Google</td>
<td>美国</td>
</tr>
<tr>
<td>2</td>
<td>淘宝</td>
<td>null</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
<td>中国</td>
</tr>
<tr>
<td>4</td>
<td>Facebook</td>
<td>null</td>
</tr>
</tbody>
</table>
</div>
<p>注：若左表中一条记录匹配右表中多行，则都会返回</p>
<p>例：</p>
<p>“Persons” 表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Id_P</th>
<th style="text-align:left">LastName</th>
<th style="text-align:left">FirstName</th>
<th style="text-align:left">Address</th>
<th style="text-align:left">City</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">Adams</td>
<td style="text-align:left">John</td>
<td style="text-align:left">Oxford Street</td>
<td style="text-align:left">London</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">Bush</td>
<td style="text-align:left">George</td>
<td style="text-align:left">Fifth Avenue</td>
<td style="text-align:left">New York</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">Carter</td>
<td style="text-align:left">Thomas</td>
<td style="text-align:left">Changan St</td>
<td style="text-align:left">Beijing</td>
</tr>
</tbody>
</table>
</div>
<p>“Orders” 表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Id_O</th>
<th style="text-align:left">OrderNo</th>
<th style="text-align:left">Id_P</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">77895</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">44678</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">22456</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">24562</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">34764</td>
<td style="text-align:left">65</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P = Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName</span><br></pre></td></tr></table></figure>
<p>结果集：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">LastName</th>
<th style="text-align:left">FirstName</th>
<th style="text-align:left">OrderNo</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Adams</td>
<td style="text-align:left">John</td>
<td style="text-align:left">22456</td>
</tr>
<tr>
<td style="text-align:left">Adams</td>
<td style="text-align:left">John</td>
<td style="text-align:left">24562</td>
</tr>
<tr>
<td style="text-align:left">Bush</td>
<td style="text-align:left">George</td>
<td style="text-align:left">null</td>
</tr>
<tr>
<td style="text-align:left">Carter</td>
<td style="text-align:left">Thomas</td>
<td style="text-align:left">44678</td>
</tr>
<tr>
<td style="text-align:left">Carter</td>
<td style="text-align:left">Thomas</td>
<td style="text-align:left">77895</td>
</tr>
</tbody>
</table>
</div>
<p>LEFT JOIN 关键字会从左表 (Persons) 那里返回所有的行，即使在右表 (Orders) 中没有匹配的行。</p>
<h3 id="3-RIGHT-JOIN"><a href="#3-RIGHT-JOIN" class="headerlink" title="3. RIGHT JOIN"></a>3. RIGHT JOIN</h3><p>RIGHT JOIN返回右表的全部行和左表满足ON条件的行，如果右表的行在左表中没有匹配，那么这一行左表中对应数据用NULL代替。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/SQL中的各种连接join/1624780592546.png" alt="1624780592546"></p>
<p>RIGHT JOIN产生表2的完全集，而1表中匹配的则有值，没有匹配的则以null值取代。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tableA.id, <span class="keyword">name</span>, address </span><br><span class="line"><span class="keyword">from</span> tableA <span class="keyword">right</span> <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> tableA.id = tableB.id</span><br></pre></td></tr></table></figure>
<p>执行以上SQL输出结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Google</td>
<td>美国</td>
</tr>
<tr>
<td>5</td>
<td>null</td>
<td>中国</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
<td>中国</td>
</tr>
<tr>
<td>6</td>
<td>null</td>
<td>美国</td>
</tr>
</tbody>
</table>
</div>
<h3 id="4-FULL-OUTER-JOIN"><a href="#4-FULL-OUTER-JOIN" class="headerlink" title="4. FULL OUTER JOIN"></a>4. FULL OUTER JOIN</h3><p>FULL JOIN 会从左表和右表中返回所有的行。如果其中一个表的数据行在另一个表中没有匹配的行，那么对面的数据用NULL代替。</p>
<p>语法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name(s)</span><br><span class="line"><span class="keyword">from</span> <span class="keyword">table</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">FULL</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> <span class="keyword">table</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">table</span> <span class="number">1.</span>column_name=<span class="keyword">table</span> <span class="number">2.</span>column_name</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/14/SQL中的各种连接join/1624780609082.png" alt="1624780609082"></p>
<p>FULL OUTER JOIN产生1和2的并集。对于没有匹配的记录，会以null做为值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> tableA.id, <span class="keyword">name</span>, address </span><br><span class="line"><span class="keyword">from</span> tableA <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> tableB</span><br><span class="line"><span class="keyword">on</span> tableA.id = tableB.id</span><br></pre></td></tr></table></figure>
<p>执行以上SQL输出结果如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>address</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Google</td>
<td>美国</td>
</tr>
<tr>
<td>2</td>
<td>淘宝</td>
<td>null</td>
</tr>
<tr>
<td>3</td>
<td>微博</td>
<td>中国</td>
</tr>
<tr>
<td>4</td>
<td>Facebook</td>
<td>null</td>
</tr>
<tr>
<td>5</td>
<td>null</td>
<td>中国</td>
</tr>
<tr>
<td>6</td>
<td>null</td>
<td>美国</td>
</tr>
</tbody>
</table>
</div>
<h3 id="5-join中on与where的区别"><a href="#5-join中on与where的区别" class="headerlink" title="5. join中on与where的区别"></a>5. join中on与where的区别</h3><p>数据库在通过连接两张或多张表来返回记录时，都会生成一张中间的临时表，然后再将这张临时表返回给用户。</p>
<p>在使用left join时，on和where条件的区别如下：</p>
<p>1、 on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</p>
<p>2、where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</p>
<p>假设有两张表：</p>
<p>表1：table1</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>size</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
</tr>
</tbody>
</table>
</div>
<p>表2：table2</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>size</th>
<th>name</th>
</tr>
</thead>
<tbody>
<tr>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>20</td>
<td>CCC</td>
</tr>
</tbody>
</table>
</div>
<p>两条SQL:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * form table1 left join table2 on (table1.size = table2.size) where table2.name=’AAA’</span><br><span class="line"></span><br><span class="line">2、select * form table1 left join table2 on (table1.size = table2.size and table2.name=’AAA’)</span><br></pre></td></tr></table></figure>
<p>第一条SQL的过程：</p>
<p>1、中间表on条件:<br>table1.size = table2.size</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>table1.id</th>
<th>table1.size</th>
<th>table2.size</th>
<th>table2.name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>BBB</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>20</td>
<td>CCC</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
</tbody>
</table>
</div>
<p>2、再对中间表过滤<br>where 条件：<br>table2.name=’AAA’</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>table1.id</th>
<th>table1.size</th>
<th>table2.size</th>
<th>table2.name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
</tbody>
</table>
</div>
<p>第二条SQL的过程：</p>
<p>1、中间表on条件:<br>table1.size = table2.size and table2.name=’AAA’<br>(条件不为真也会返回左表中的记录)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>table1.id</th>
<th>table1.size</th>
<th>table2.size</th>
<th>table2.name</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10</td>
<td>10</td>
<td>AAA</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>(null)</td>
<td>(null)</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>(null)</td>
<td>(null)</td>
</tr>
</tbody>
</table>
</div>
<p><strong>on条件是在left join之前先进行条件筛选，而后才对两个表格join操作</strong>。on比where起作用更早，先根据on条件进行多表的连接操作，生成一个临时表再通过where来筛选。</p>
<p>以上结果的关键原因在于left join,right join,full join的特殊性，不管on上的条件是否为真都会返回 left 或 right 表中的记录，full则具有left和right的特性的并集。 而inner join没这个特殊性，则条件放在on中和where中，返回的结果集是相同的。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>数据框</tag>
      </tags>
  </entry>
  <entry>
    <title>Python直接赋值、浅拷贝和深拷贝以及切片</title>
    <url>/2020/11/15/Python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html</a></p>
</blockquote>
<h3 id="1-直接赋值"><a href="#1-直接赋值" class="headerlink" title="1. 直接赋值"></a>1. 直接赋值</h3><p>直接赋值： <code>b = a</code> , a 和 b 都指向同一个对象，则若改变a或b，另一个变量的值会跟着改变。</p>
<p><strong>直接赋值：其实就是对象的引用（别名）。</strong></p>
<p><img src="/2020/11/15/Python直接赋值、浅拷贝和深拷贝以及切片/1605435974588.png" alt="1605435974588"></p>
<a id="more"></a>
<p>例：</p>
<h4 id="1-1-列表赋值实例"><a href="#1-1-列表赋值实例" class="headerlink" title="1.1 列表赋值实例"></a>1.1 列表赋值实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>👆 改变a -&gt; b会跟着变；改变b -&gt; a会跟着变</p>
<h4 id="1-2-字典赋值实例"><a href="#1-2-字典赋值实例" class="headerlink" title="1.2 字典赋值实例"></a>1.2 字典赋值实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>👆 改变a -&gt; b会跟着变；改变b -&gt; a会跟着变</p>
<h3 id="2-浅拷贝"><a href="#2-浅拷贝" class="headerlink" title="2. 浅拷贝"></a>2. 浅拷贝</h3><p>浅拷贝： <code>b = a.copy()</code> ，a 和 b 是一个独立的对象，但他们的子对象还是指向同一对象（是引用）。浅拷贝拷贝父对象，改变其中一个，另一个不会变，但如果a中还有子对象，则改变子对象中的内容，另一个的子对象中的内容会跟着变 (见下面示例)。</p>
<p><strong>浅拷贝（copy）：拷贝父对象，不会拷贝对象内部的子对象。</strong>（即拷贝了父对象，现在改变父对象的话，不会影响到另一个变量的值，但由于子对象没有被拷贝，改变一个变量的子对象的值会影响另一个变量的值）</p>
<p><img src="/2020/11/15/Python直接赋值、浅拷贝和深拷贝以及切片/1605436105042.png" alt="1605436105042"></p>
<p>例：</p>
<h4 id="2-1-列表浅拷贝实例"><a href="#2-1-列表浅拷贝实例" class="headerlink" title="2.1 列表浅拷贝实例"></a>2.1 列表浅拷贝实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>👆 改变a -&gt; b不会跟着变；改变b -&gt; a不会跟着变</p>
<h4 id="2-2-字典浅拷贝实例"><a href="#2-2-字典浅拷贝实例" class="headerlink" title="2.2 字典浅拷贝实例"></a>2.2 字典浅拷贝实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a.copy()</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>👆 改变子对象内容时：改变a -&gt; b会跟着变；改变b -&gt; a会跟着变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">3</span>] = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">2</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>👆 改变父对象内容时：改变a -&gt; b不会跟着变；改变b -&gt; a不会跟着变</p>
<h3 id="3-深拷贝"><a href="#3-深拷贝" class="headerlink" title="3. 深拷贝"></a>3. 深拷贝</h3><p>深度拷贝：<code>b = copy.deepcopy(a)</code>，a 和 b 完全拷贝了父对象及其子对象，两者是完全独立的。无论改变a中的任何内容，b中都没有影响，反之亦然。</p>
<p><strong>深拷贝（deepcopy）：copy模块的deepcopy方法，完全拷贝了父对象及其子对象。</strong></p>
<p><img src="/2020/11/15/Python直接赋值、浅拷贝和深拷贝以及切片/1605437439875.png" alt="1605437439875"></p>
<p>例：</p>
<h4 id="2-1-列表深拷贝实例"><a href="#2-1-列表深拷贝实例" class="headerlink" title="2.1 列表深拷贝实例"></a>2.1 列表深拷贝实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>
<p>👆 改变a -&gt; b不会跟着变；改变b -&gt; a不会跟着变</p>
<h4 id="2-2-字典深拷贝实例"><a href="#2-2-字典深拷贝实例" class="headerlink" title="2.2 字典深拷贝实例"></a>2.2 字典深拷贝实例</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = &#123;<span class="number">1</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = copy.deepcopy(a)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>👆 改变子对象内容时：改变a -&gt; b不会跟着变；改变b -&gt; a不会跟着变</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a[<span class="number">2</span>] = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[<span class="number">3</span>] = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a,b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>: [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>], <span class="number">3</span>: [<span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>]&#125;)</span><br></pre></td></tr></table></figure>
<p>👆 改变父对象内容时：改变a -&gt; b不会跟着变；改变b -&gt; a不会跟着变</p>
<h3 id="4-更多实例"><a href="#4-更多实例" class="headerlink" title="4. 更多实例"></a>4. 更多实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,[<span class="string">'a'</span>,<span class="string">'b'</span>]] <span class="comment"># 原始对象</span></span><br><span class="line">b = a <span class="comment"># 赋值，传对象的引用</span></span><br><span class="line">c = a.copy() <span class="comment"># 对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a) <span class="comment"># 对象拷贝，深拷贝</span></span><br><span class="line"></span><br><span class="line">a.append(<span class="number">5</span>) <span class="comment"># 修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">'c'</span>) <span class="comment">#修改对象a中的['a','b']数组对象</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'a = '</span>, a)</span><br><span class="line">print(<span class="string">'b = '</span>, b)</span><br><span class="line">print(<span class="string">'c = '</span>, c)</span><br><span class="line">print(<span class="string">'d = '</span>, d)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>], <span class="number">5</span>]</span><br><span class="line">c =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]]</span><br><span class="line">d =  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">'a'</span>, <span class="string">'b'</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="5-切片操作"><a href="#5-切片操作" class="headerlink" title="5. 切片操作"></a>5. 切片操作</h3><p>Python切片操作可作用于 list（包括 tuple, string）</p>
<p><strong>切片操作相当于浅拷贝</strong></p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,[<span class="number">3</span>]]</span><br><span class="line">b = a[:]</span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a[<span class="number">2</span>].append(<span class="number">4</span>)</span><br><span class="line">print(<span class="string">'a = '</span>, a)</span><br><span class="line">print(<span class="string">'b = '</span>, b)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a =  [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]</span><br><span class="line">b =  [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>conda常用命令</title>
    <url>/2020/11/15/conda%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="https://blog.csdn.net/Destiny_zz/article/details/88634513" target="_blank" rel="noopener">https://blog.csdn.net/Destiny_zz/article/details/88634513</a></p>
</blockquote>
<p><code>conda -V</code> 检查是否安装以及当前conda的版本<br><code>conda list</code> 查看安装了哪些包<br><code>conda update conda</code> 检查更新当前conda</p>
<h3 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h3><h4 id="1-创建python虚拟环境"><a href="#1-创建python虚拟环境" class="headerlink" title="1. 创建python虚拟环境"></a>1. 创建python虚拟环境</h4><p><code>conda create -n your_env_name python=X.X (2.7、3.6等)</code> 创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可在Anaconda安装目录envs文件夹下找到。</p>
<h4 id="2-激活或切换不同的虚拟环境"><a href="#2-激活或切换不同的虚拟环境" class="headerlink" title="2. 激活或切换不同的虚拟环境"></a>2. 激活或切换不同的虚拟环境</h4><p><code>python --version</code> 检查当前 python 版本</p>
<p>切换虚拟环境：<br>Linux: <code>source activate your_env_name(虚拟环境名称)</code><br>Windows: <code>activate your_env_name(虚拟环境名称)</code></p>
<a id="more"></a>
<h4 id="3-查看当前存在哪些虚拟环境"><a href="#3-查看当前存在哪些虚拟环境" class="headerlink" title="3. 查看当前存在哪些虚拟环境"></a>3. 查看当前存在哪些虚拟环境</h4><p><code>conda env list</code> 或 <code>conda info -e</code> 查看当前存在哪些虚拟环境</p>
<h4 id="4-对虚拟环境中安装额外的包"><a href="#4-对虚拟环境中安装额外的包" class="headerlink" title="4. 对虚拟环境中安装额外的包"></a>4. 对虚拟环境中安装额外的包</h4><p><code>conda install -n your_env_name [package]</code> 即可安装package到your_env_name中</p>
<h4 id="5-关闭或退出虚拟环境"><a href="#5-关闭或退出虚拟环境" class="headerlink" title="5. 关闭或退出虚拟环境"></a>5. 关闭或退出虚拟环境</h4><p>Linux: <code>conda deactivate</code><br>Windows: <code>deactivate</code></p>
<h4 id="6-删除虚拟环境"><a href="#6-删除虚拟环境" class="headerlink" title="6. 删除虚拟环境"></a>6. 删除虚拟环境</h4><p><code>conda remove -n your_env_name(虚拟环境名称) --all</code>，即可删除</p>
<h4 id="7-删除环境中的某个包"><a href="#7-删除环境中的某个包" class="headerlink" title="7. 删除环境中的某个包"></a>7. 删除环境中的某个包</h4><p><code>conda remove --name your_env_name package_name</code></p>
]]></content>
      <categories>
        <category>Jupyter Notebook</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的reverse, reversed, sort, sorted</title>
    <url>/2020/10/30/Python%E4%B8%AD%E7%9A%84reverse-reversed-sort-sorted/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考:<br><a href="https://note.nkmk.me/en/python-reverse-reversed/" target="_blank" rel="noopener">https://note.nkmk.me/en/python-reverse-reversed/</a><br><a href="https://note.nkmk.me/en/python-list-sort-sorted/" target="_blank" rel="noopener">https://note.nkmk.me/en/python-list-sort-sorted/</a></p>
</blockquote>
<h3 id="1-Reverse"><a href="#1-Reverse" class="headerlink" title="1. Reverse"></a>1. Reverse</h3><p><span style="color:red">对于list, 可以使用reverse(), reversed(), 和切片</span><br><span style="color:red">对于字符串和元组（都不可变），可以使用reversed()和切片</span></p>
<h4 id="1-1-list"><a href="#1-1-list" class="headerlink" title="1.1 list"></a>1.1 list</h4><ul>
<li>List type method <code>reverse()</code> reverses the original list.</li>
</ul>
<p>reverse()是列表的一个内置方法，改变原列表，reverse()返回None</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">org_list.reverse()</span><br><span class="line">print(org_list)</span><br><span class="line"><span class="comment"># [5, 4, 3, 2, 1]</span></span><br><span class="line"></span><br><span class="line">print(org_list.reverse())</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Built-in function <code>reversed()</code> returns a reverse iterator</li>
</ul>
<p>reversed()是python的一个内置方法，不会改变原列表，返回一个迭代器，可用list()获取作用后的值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">reverse_iterator = reversed(org_list)</span><br><span class="line">print(org_list)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">print(reverse_iterator)</span><br><span class="line"><span class="comment">#&lt;list_reverseiterator object at 0x7fdd7151a940&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(reverse_iterator))</span><br><span class="line"><span class="comment"># &lt;class 'list_reverseiterator'&gt;</span></span><br><span class="line"></span><br><span class="line">new_list = list(reversed(org_list))</span><br><span class="line">print(org_list)</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>切片：$[start:end:step]$</li>
</ul>
<p>忽略start和end时，选取整个list，step=-1，从后往前依次遍历</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">new_list = org_list[::<span class="number">-1</span>]</span><br><span class="line">print(org_list)</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<h4 id="1-2-string"><a href="#1-2-string" class="headerlink" title="1.2 string"></a>1.2 string</h4><p>不能使用s.reverse()方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">'abcde'</span></span><br><span class="line">s.reverse()</span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#  File "script.py", line 7, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    org_str.reverse()</span></span><br><span class="line"><span class="comment">#AttributeError: 'str' object has no attribute 'reverse'</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#Exited with error status 1</span></span><br></pre></td></tr></table></figure>
<p>法一：reversed()</p>
<p>因为迭代器不能直接转换成字符串，转换成list后还需使用join()方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_str = <span class="string">'abcde'</span></span><br><span class="line"></span><br><span class="line">new_str_list = list(reversed(org_str))</span><br><span class="line">print(new_str_list)</span><br><span class="line"><span class="comment"># ['e', 'd', 'c', 'b', 'a']</span></span><br><span class="line"></span><br><span class="line">new_str = <span class="string">''</span>.join(list(reversed(org_str)))</span><br><span class="line">print(new_str)</span><br><span class="line"><span class="comment"># edcba</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可直接''.join(reversed(..))?</span></span><br><span class="line">new_str = <span class="string">''</span>.join(reversed(org_str))</span><br><span class="line">print(new_str)</span><br><span class="line"><span class="comment"># edcba</span></span><br></pre></td></tr></table></figure>
<p>法二：切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_str = org_str[::<span class="number">-1</span>]</span><br><span class="line">print(new_str)</span><br><span class="line"><span class="comment"># edcba</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-tuple"><a href="#1-3-tuple" class="headerlink" title="1.3 tuple"></a>1.3 tuple</h4><p>法一：reversed()</p>
<p>使用tuple()将迭代器转换成tuple</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_tuple = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">new_tuple = tuple(reversed(org_tuple))</span><br><span class="line">print(new_tuple)</span><br><span class="line"><span class="comment"># (5, 4, 3, 2, 1)</span></span><br></pre></td></tr></table></figure>
<p>法二：切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_tuple = org_tuple[::<span class="number">-1</span>]</span><br><span class="line">print(new_tuple)</span><br><span class="line"><span class="comment"># (5, 4, 3, 2, 1)</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-Sort"><a href="#2-Sort" class="headerlink" title="2. Sort"></a>2. Sort</h3><p><span style="color:red">对于list，可使用sort()或sorted()</span><br><span style="color:red">对于字符串和元组，可使用sorted()</span></p>
<h4 id="2-1-list"><a href="#2-1-list" class="headerlink" title="2.1 list"></a>2.1 list</h4><ul>
<li>List type method <code>sort()</code> sorts the original list</li>
</ul>
<p>sort()是列表的一个内置方法，改变原列表，sort()返回None，默认按升序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">org_list.sort()</span><br><span class="line"><span class="comment"># sort in-place</span></span><br><span class="line">print(org_list)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">print(org_list.sort())</span><br><span class="line"><span class="comment"># None</span></span><br></pre></td></tr></table></figure>
<p>降序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">print(org_list)</span><br><span class="line"><span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Built-in function <code>sorted()</code> returns a sorted list</li>
</ul>
<p>sorted()是python的一个内置方法，不会改变原列表，返回一个sorted list，默认按升序排列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_list = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">new_list = sorted(org_list)</span><br><span class="line">print(org_list)</span><br><span class="line">print(new_list)</span><br><span class="line"><span class="comment"># [3, 1, 4, 5, 2]</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>降序排列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new_list_reverse = sorted(org_list, reverse=<span class="literal">True</span>)</span><br><span class="line">print(org_list)</span><br><span class="line">print(new_list_reverse)</span><br><span class="line"><span class="comment"># [3, 1, 4, 5, 2]</span></span><br><span class="line"><span class="comment"># [5, 4, 3, 2, 1]</span></span><br></pre></td></tr></table></figure>
<h4 id="2-2-string"><a href="#2-2-string" class="headerlink" title="2.2 string"></a>2.2 string</h4><p>使用sorted()</p>
<p>因为sorted()返回一个list，还需使用join()转换成string</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_str = <span class="string">'cebad'</span></span><br><span class="line"></span><br><span class="line">new_str_list = sorted(org_str)</span><br><span class="line">print(org_str)</span><br><span class="line">print(new_str_list)</span><br><span class="line"><span class="comment"># cebad</span></span><br><span class="line"><span class="comment"># ['a', 'b', 'c', 'd', 'e']</span></span><br><span class="line"></span><br><span class="line">new_str = <span class="string">''</span>.join(new_str_list)</span><br><span class="line">print(new_str)</span><br><span class="line"><span class="comment"># abcde</span></span><br><span class="line"></span><br><span class="line">new_str_reverse = <span class="string">''</span>.join(sorted(org_str, reverse=<span class="literal">True</span>))</span><br><span class="line">print(new_str_reverse)</span><br><span class="line"><span class="comment"># edcba</span></span><br></pre></td></tr></table></figure>
<p>The order of the characters is determined by their Unicode code point.</p>
<h4 id="2-2-tuple"><a href="#2-2-tuple" class="headerlink" title="2.2 tuple"></a>2.2 tuple</h4><p>使用sorted()</p>
<p>需要使用tuple()将结果转换成tuple</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">org_tuple = (<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">new_tuple_list = sorted(org_tuple)</span><br><span class="line">print(org_tuple)</span><br><span class="line">print(new_tuple_list)</span><br><span class="line"><span class="comment"># (3, 1, 4, 5, 2)</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line">new_tuple = tuple(new_tuple_list)</span><br><span class="line">print(new_tuple)</span><br><span class="line"><span class="comment"># (1, 2, 3, 4, 5)</span></span><br><span class="line"></span><br><span class="line">new_tuple_reverse = tuple(sorted(new_tuple_list, reverse=<span class="literal">True</span>))</span><br><span class="line">print(new_tuple_reverse)</span><br><span class="line"><span class="comment"># (5, 4, 3, 2, 1)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据仓库简介</title>
    <url>/2020/10/27/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考《Hadoop构建数据仓库实践》</p>
</blockquote>
<h3 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h3><p><a href="#jump_zhutiyu">主题域</a><br><a href="#jump_RDS">RDS</a><br><a href="#jump_TDS">TDS</a><br><a href="#jump_ODS">ODS</a></p>
<h3 id="1-什么是数据仓库"><a href="#1-什么是数据仓库" class="headerlink" title="1. 什么是数据仓库"></a>1. 什么是数据仓库</h3><h4 id="1-1-数据仓库的定义"><a href="#1-1-数据仓库的定义" class="headerlink" title="1.1 数据仓库的定义"></a>1.1 数据仓库的定义</h4><p>数据仓库之父Bill Inmon将数据仓库描述 为一个<strong><span style="color:red">面向主题的、集成的、随时间变化的、非易失的</span></strong>数据集合，用于支持管理者的决策过程。</p>
<ul>
<li>面向主题</li>
</ul>
<p>数据仓库被设计成辅助人们分析数据。例如，一个公司要分析销售数据，就可以建立一个专注于销售的数据仓库，使用这个数据仓库，就可以回答类似于”去年谁是我们这款产品的最佳用户“这样的问题。<strong><span id="jump_zhutiyu">主题域</span></strong>是对某个主题进行分析后确定的主题的边界，如客户、销售、产品都是主题域的例子。</p>
<ul>
<li>集成</li>
</ul>
<p>还用销售的例子，假设公司有多条产品线和多种产品销售渠道，而每个产品线都有自己独立的销售数据库。此时要想从公司层面整体分析销售数据，必须将多个分散的数据源统一成一致的、无歧义的数据格式后，再放置到数据仓库中。因此数据仓库必须能解决诸如产品命名冲突、计量单位不一致等问题。当完成了这些数据整合工作后，该数据仓库可称为是集成的。</p>
<ul>
<li>随时间变化</li>
</ul>
<p>为了发现业务变化的趋势、存在的问题，或者新的机会，需要分析大量的历史数据。这与联机事务处理（OLTP）系统形成鲜明的对比。联机事务处理反应的是当前时间点的数据情况，要求高性能、高并发和极短的响应时间。而数据仓库关注的是数据随时间变化的情况，并且能反映再过去某个时间点的数据是怎样的。</p>
<ul>
<li>非易失</li>
</ul>
<p>一旦进入到数据仓库中，数据就不应该再有改变。在数据仓库环境中，一般不进行数据更新。数据仓库中的数据基本是静态的。数据仓库的目的就是根据曾经发生的事件进行分析，如果数据是可修改的，将使历史分析变得没有意义。</p>
<p>除了以上四个特性以外，数据仓库还有一个重要的概念是<strong>粒度</strong>。数据仓库中的粒度是指数据的细节或汇总程度，细节程度越高，粒度级别越低。例如，单个事务是低粒度级别，而全部一个月事务的汇总就是高粒度级别。粒度级别越低，数据量越大，查询的细节程度越高，查询范围越广泛。</p>
<h4 id="1-2-数据仓库里的数据从哪里来"><a href="#1-2-数据仓库里的数据从哪里来" class="headerlink" title="1.2 数据仓库里的数据从哪里来"></a>1.2 数据仓库里的数据从哪里来</h4><p><strong>通常数据仓库的数据来自各个业务应用系统。</strong></p>
<ul>
<li>Oracle、MySQL、SQL Server等关系数据库里的结构化数据；</li>
<li>文本、CSV等平面文件或Word、Excel文档中的非结构化数据；</li>
<li>HTML、XML等自描述的半结构化数据。</li>
</ul>
<p>这些业务数据经过一系列的数据抽取、转换、清洗，最终以一种统一的格式装载进数据仓库。数据仓库里的数据作为分析用的数据源，提供给后面的即席(ad hoc)查询、分析系统、数据集市、报表系统、数据挖掘系统等。</p>
<h4 id="1-3-建立数据仓库的原因，数据仓库的好处"><a href="#1-3-建立数据仓库的原因，数据仓库的好处" class="headerlink" title="1.3 建立数据仓库的原因，数据仓库的好处"></a>1.3 建立数据仓库的原因，数据仓库的好处</h4><p>为什么不直接操作业务系统中的数据用于分析，而要使用数据仓库呢？很多因素导致直接访问业务系统无法进行全局数据分析的工作：</p>
<ul>
<li>某些业务数据由于安全或其他因素不能直接访问。</li>
<li>业务系统的版本变更很频繁，每次变更都需要重写分析系统并重新测试。</li>
<li>很难建立和维护汇总数据来源于多个业务系统版本的报表。</li>
<li>业务系统的数据格式，如日期、数字的格式不统一。</li>
<li>业务系统的表结构为事务处理性能而优化，有时并不适合查询与分析。</li>
<li>…</li>
</ul>
<p>使用数据仓库的好处：</p>
<ul>
<li>将多个数据源集成到单一数据存储，因此可以使用单一数据查询引擎展示数据。</li>
<li>缓解在事务处理数据库上因执行大查询而产生的资源竞争问题。</li>
<li>维护历史数据</li>
<li>通过提供一致的编码和描述，减少或修正坏数据问题，提高数据质量。</li>
<li>重构数据，使数据对业务用户更有意义。</li>
<li>向复杂分析查询交付优秀的查询性能，同时不影响操作型系统。</li>
<li>…</li>
</ul>
<h3 id="2-操作型系统与分析型系统"><a href="#2-操作型系统与分析型系统" class="headerlink" title="2. 操作型系统与分析型系统"></a>2. 操作型系统与分析型系统</h3><h4 id="2-1-操作型系统"><a href="#2-1-操作型系统" class="headerlink" title="2.1 操作型系统"></a>2.1 操作型系统</h4><p>操作型系统是一类专门用于管理面向事务的应用的信息系统。事务在这里指计算机或数据库的术语。</p>
<h5 id="2-1-1-操作型系统的数据库操作"><a href="#2-1-1-操作型系统的数据库操作" class="headerlink" title="2.1.1 操作型系统的数据库操作"></a>2.1.1 操作型系统的数据库操作</h5><p>常用操作：<strong>增、改、查</strong>。通常是插入与更新密集型的，同时会对数据库进行大量并发查询，而删除操作相对较少。</p>
<h5 id="2-1-2-操作型系统的数据库设计"><a href="#2-1-2-操作型系统的数据库设计" class="headerlink" title="2.1.2 操作型系统的数据库设计"></a>2.1.2 操作型系统的数据库设计</h5><p>操作型系统的特征是大量短的事务，并强调快速处理查询。每秒事务数是操作型系统的一个有效度量指标。</p>
<p>在数据库<strong>逻辑设计</strong>上，操作型系统的应用数据库大都使用规范化设计方法，通常要满足第三范式。这是因为规范化设计能最大限度地数据冗余，提供更快更高效的方式执行数据库写操作。</p>
<p>在数据库<strong>物理设计</strong>上，以Oracle数据库为例，简要说明在设计操作型系统数据库时应考虑的问题：</p>
<ul>
<li>合理使用聚簇。聚簇是一种数据库模式，其中包含有共用一列或多列的多个表。数据库中的聚簇表用于提高连接操作的性能。</li>
<li>适当调整数据块大小。数据块大小应该是操作系统块大小的倍数，并且设置上限以避免不必要的I/O。</li>
<li>动态分配表空间。</li>
<li>合理划分数据库分区。分区最大的作用是能在可用性和安全性维护期间保持事务处理的性能。</li>
<li>SQL优化。有效利用数据库管理系统的优化器，使用最佳的数据访问路径。</li>
<li>避免过度使用索引。大量的数据修改会给索引维护带来压力，从而对整个系统的性能产生负面影响。</li>
</ul>
<p>以上所讲的操作型系统都是以数据据系统为核心，而数据库系统为了保持ACID特性，本质上是单一集中式系统。在当今这个信息爆炸的时代，集中式数据库往往已无法支撑业务的需要。分布式事务、去中心化、CAP与最终一致性等一些列新的理论和技术为解决系统扩展问题应运而生。这里不做展开。</p>
<h4 id="2-2-分析型系统"><a href="#2-2-分析型系统" class="headerlink" title="2.2 分析型系统"></a>2.2 分析型系统</h4><p>分析型系统是一种快速回答多维分析查询的实现方式。</p>
<h5 id="2-2-1-分析型系统的数据库操作"><a href="#2-2-1-分析型系统的数据库操作" class="headerlink" title="2.2.1 分析型系统的数据库操作"></a>2.2.1 分析型系统的数据库操作</h5><p>在数据库层面，分析型系统操作被定义为少量的事务，复杂的查询，处理归档和历史数据。这些数据很少被修改，从数据库抽取数据是最多的操作。分析型数据库基本上都是<strong>读操作</strong>。</p>
<h5 id="2-2-2-分析型系统的数据库设计"><a href="#2-2-2-分析型系统的数据库设计" class="headerlink" title="2.2.2 分析型系统的数据库设计"></a>2.2.2 分析型系统的数据库设计</h5><p>分析型系统的特征是相对少量的事务，但查询通常非常复杂且会包含聚合计算。吞吐量是一个有效的性能度量指标。</p>
<p>在数据库<strong>逻辑设计</strong>上，分析型数据库使用多维数据模型，通常是设计成<span style="color:blue">星型模式</span>或<span style="color:blue">雪花模式</span>。</p>
<p>在数据库物理设计上，依然以Oracle数据库为例，简要说明在设计分析型系统数据库时应该考虑的一些问题。</p>
<ul>
<li>表分区。可以独立定义表分区的物理存储属性，将不同分区的数据存放到多个物理文件上，这样做一方面可以分散I/O；另一方面，当数据量非常大时，方便数据维护；再有就是利用分区消除查询数据时，不用扫描整张表，从而提高查询性能。</li>
<li>位图索引。当查询条件中包含低基数（不同值很少，例如性别）的列，尤其是包含有这些列上的or、and或not这样的逻辑运算时，或者从有大量行的表中返回大量的行时，应考虑位图索引。</li>
<li>物化视图。物化视图物理存储查询所定义的数据，能够自动增量刷新数据，并且可以利用查询重写特性极大地提高查询速度。</li>
<li>并行化操作。可以在查询大量数据时执行并行化操作，这样会导致多个服务器进程为同一个查询语句工作，使用该查询可以快速完成，但会耗费更多的资源。</li>
</ul>
<blockquote>
<p>分析型系统更加注重数据分析和报表，而操作型系统的目标时一个伴有大量数据改变的事务优化系统。</p>
</blockquote>
<h3 id="3-数据仓库架构"><a href="#3-数据仓库架构" class="headerlink" title="3. 数据仓库架构"></a>3. 数据仓库架构</h3><h4 id="3-1-基本架构"><a href="#3-1-基本架构" class="headerlink" title="3.1 基本架构"></a>3.1 基本架构</h4><p><img src="/2020/10/27/数据仓库简介/1603782098335.png" alt="1603782098335"></p>
<p>整个数据仓库环境包括操作型系统和数据仓库系统两大部分。操作型系统的数据由各种形式的业务数据组成（数据可能是结构化、半结构化、非结构化的）。<span style="color:red">这些数据经过抽取、转换和装载（ETL）过程进入数据仓库系统。</span></p>
<p>这里把ETL过程分成了抽取和转换装载两个部分。<strong>抽取</strong>过程负责从操作型系统获取数据，该过程一般不做数据聚合和汇总，但是会按照主题进行集成，物理上是将操作型系统的数据全量或增量复制到数据仓库系统的RDS中。</p>
<blockquote>
<p>抽取过程指的是把数据从操作型数据源抽取到RDS的过程，这个过程可能会有一些数据集成的操作，但不会做数据转换、清洗、格式化等工作。<br>Hadoop生态圈中的主要数据源抽取工具是 <strong>Sqoop</strong> 和 <strong>Flume</strong>。Sqoop被设计成支持在关系数据库和 Hadoop 之间传输数据，而 Flume 被设计成基于流的数据捕获，主要是从日志文件中获取数据。使用这两个工具可以完成数据仓库的抽取。<br>如果数据源是普通的文本和CSV文件，抽取过程将更加简单，只需用操作系统的<code>scp</code>或<code>ftp</code>命令将文件拉取到Hadoop集群的任一节点，然后使用HDFS的<code>put</code>命令将已在本地的文件上传到HDFS，或者使用Hive的<code>load data</code>将文件装载进表里就可以了。</p>
</blockquote>
<p><strong>转换装载</strong>过程将数据进行清洗、过滤、汇总、统一格式化等一系列转换操作后，使数据转换为适合查询的格式，然后装载进数据仓库系统的TDS中。</p>
<blockquote>
<p>转换与装载过程是将数据从RDS迁移到TDS的过程，期间会对数据进行一系列的转换和处理。经过了数据抽取步骤，此时数据已经在Hive表中了，因此<strong>Hive</strong>可以用于转换和装载。<br>Hive实际上是在MapReduce之上封装了一层SQL解释器，这样可以用类SQL语言书写复杂的MapReduce作业。Hive不但提供了丰富的数据查询功能和分析函数，还可以在某些限制下进行数据的更新，因此支持SCD1(渐变维的一种处理类型)。</p>
</blockquote>
<p>（关于ETL的更详细内容见 <a href="#jump4">4. 抽取-转换-装载（ETL）</a>）</p>
<p><strong><span id="jump_RDS">RDS</span></strong> (RAW DATA STORES) 是原始数据存储的意思。将原始数据保存到数据仓库是个不错的想法。ETL过程的bug或系统中的其他错误是不可避免的，保留原始数据使得追踪并修改这些错误成为可能。有时数据仓库的用户会有查询细节数据的需求，这些细节数据的粒度与操作型系统的相同。有了RDS，这种需求很容易实现，用户可以查询RDS里的数据而不必影响业务系统的正常运行。这里的RDS实际上是起到了操作型数据存储（<a href="#jump_ODS">ODS</a>）的作用。</p>
<blockquote>
<p>RDS 是原始数据存储，其数据是从操作型系统抽取而来。它有两个作用，一是充当操作型系统和数据仓库之间的过渡区，二是作为细节数据查询的数据源。</p>
</blockquote>
<p><strong><span id="jump_TDS">TDS</span></strong> (TRANSFORMED DATA STORES) 意为转换后的数据存储。这是真正的数据仓库中的数据。大量的用户会在经过转换的数据集上处理他们的日常查询。这些数据将被以保证最重要的和最频繁的查询能够快速执行的方式构建。</p>
<blockquote>
<p>TDS 是转换后的数据存储，也就是数据仓库，用于后续的多维分析或即席查询。</p>
</blockquote>
<p><strong>自动化调度</strong>组件的作用是自动定期重复执行ETL过程。</p>
<blockquote>
<p>ETL过程自动化是数据仓库成功的重要衡量标准，也是系统易用性的关键。<br>Hadoop生态圈中的主要管理工具是 <strong>Falcon</strong>。Falcon把自己看作是数据治理工具，能让用户建立定义好的ETL流水线。还有一个叫做 <strong>Oozie</strong> 的工具，它是一个Hadoop的工作流程调度系统，可以使用它将ETL过程封装进工作流自动执行。</p>
</blockquote>
<p><strong>数据目录</strong>有时也被称为元数据存储，它存储的是数据仓库的元数据，可以提供一份数据仓库中数据的清单，主要是描述数据属性的信息，用来支持如指示存储位置、历史数据、资源查找、文件记录等功能。用户通过它应该可以快速解决这些问题：什么类型的数据被存储在哪里，数据集的构建有何区别，数据最后的访问或更新时间等。</p>
<blockquote>
<p>Hadoop 生态圈中主要的数据目录工具是 <strong>HCatalog</strong>。HCatalog 是 Hadoop 上的一个表和存储管理层。使用不同的数据处理工具（如 Pig、MapReduce）的用户，通过 HCatalog 可以更加容易地读写集群中的数据。HCatalog 引入”表“的抽象，把文件看作数据集。它展现给用户的是一个 HDFS 上数据的关系视图，这样用户不必关心数据存放在哪里或者数据格式是什么等问题，就可以轻松知道系统中有哪些表，表中都包含什么。<br>HCatalog 默认支持多种文件格式的读写，如 RCFile、SequenceFile、ORC files、text files、CSV、JSON等。</p>
</blockquote>
<p><strong>查询引擎</strong>组件负责实际执行用户查询。</p>
<blockquote>
<p>由于最终用户经常需要进行交互式的即席查询，并随时动态改变和组合他们的查询条件，因此要求查询引擎具有很高的查询性能和较短的响应时间。<br>Hadoop生态圈中的主要SQL查询引擎有基于 MapReduce 的 <strong>Hive</strong>、基于 RDD 的 <strong>SparkSQL</strong> 和 Cloudera 公司的 <strong>Impala</strong>。<br>Hive可以在四种主流计算框架的三种，分别是 Tez、MapReduce 和 Spark（还有一种是Storm）上执行类SQL查询。<br>SparkSQL是Hadoop中另一个著名的SQL引擎，它实际上是一个Scala程序语言的子集。正如SparkSQL这个名字所暗示的，它以 Spark 作为底层的计算框架。<br>Impala 是 Cloudera 公司的查询系统，它提供 SQL 语言，最大的特点是速度快，主要用于 OLAP。</p>
</blockquote>
<p><strong>用户界面</strong>指的是最终用户所使用的接口程序。可能是一个GUI软件，如BI套件中的客户端软件，也可能是一个浏览器。</p>
<blockquote>
<p>数据分析的结果最终要以业务语言和形象化的方式展现给用户。数据仓库的最终用户界面通常是一个BI仪表盘或类似的一个数据可视化工具提供的浏览器页面。<br>Hadoop 生态圈中比较知名的数据可视化工具是 <strong>Hue</strong> 和 <strong>Zeppelin</strong>。<br>Hue 是一个开源的 Hadoop UI 系统，最早是由 Cloudera Desktop 演化而来，它是基于 Python Web 框架 Django 实现的。通过使用 Hue 我们可以在浏览器端的 Web 控制台上与 Hadoop 集群进行交互来分析处理数据，还可以用图形化的方式定义工作流。Hue 默认支持的数据源有 Hive 和 Impala。<br>Zeppelin 提供了 Web 版的 notebook，用于做数据分析和可视化。Zeppelin 默认只支持 SparkSQL。</p>
</blockquote>
<p><span style="color:blue">可以看到，普通数据仓库的8个组成部分都有相对应的 Hadoop 组件作为支撑。Hadoop 生态圈中众多更具提供的功能，完全可以满足创建传统数据仓库的需要。使用 Hadoop 建立数据仓库不仅是必要，而且是充分的。</span></p>
<h4 id="3-2-操作数据存储（ODS）"><a href="#3-2-操作数据存储（ODS）" class="headerlink" title="3.2 操作数据存储（ODS）"></a><span id="jump_ODS">3.2 操作数据存储（ODS）</span></h4><p>操作数据存储又称为ODS (Operational Data Sore)，定义：一个<strong><span style="color:red">面向主题的、集成的、可变的、当前的</span></strong>细节数据集合，用于支持企业对于即时性的、操作性的、集成的全体信息的需求。ODS在某些方面具有类似于数据仓库的特点，在另一些方面又显著不同。</p>
<ul>
<li>像数据仓库一样，是面向主题的</li>
<li>像数据仓库一样，其数据是完全集成的</li>
<li>数据是当前的，这与数据仓库存储历史数据的性质明显不同。ODS具有最少的历史数据（一般是30天到60天），而尽可能接近实时地展示数据的状态。</li>
<li>数据是可更新的，ODS就如同一个事务处理系统，当新的数据流进ODS时，受其影响的字段被新信息覆盖。</li>
<li>数据几乎完全是细节数据，仅具有少量的动态聚集或汇总数据。通常将ODS设计成包含事务级的数据，即包含该主题域中最低粒度级别的数据。</li>
<li>在数据仓库中，几乎没有针对其本身的报表，报表均放到数据级市中完成；在ODS中，业务用户频繁地直接访问ODS。</li>
</ul>
<p>在一个数据仓库环境中，ODS具有如下几个作用：</p>
<ul>
<li>充当业务系统与数据仓库之间的过渡区。ODS中存放的数据从数据结构、数据粒度、数据之间的逻辑关系上都与业务系统基本保持一致，因此抽取过程只需简单的数据复制而基本不再需要做数据转换，大大降低了复杂性，同时最小化对业务系统的侵入。</li>
<li>转移部分业务系统细节查询的功能。某些原来由业务系统产生的报表、细节数据的查询能够在ODS中进行，从而降低业务系统的查询压力。</li>
<li>完成数据仓库中不能完成的一些功能。用户有时会要求数据仓库查询最低粒度级别的细节数据，而数据仓库中存储的一般是聚合或汇总过的数据，并不存储每笔交易产生的细节数据，这时就需要转移到ODS来完成，而且ODS的数据模型是按照面向主题的方式组织的，可以方便地支持多维分析。</li>
</ul>
<h3 id="4-抽取-转换-装载（ETL）"><a href="#4-抽取-转换-装载（ETL）" class="headerlink" title="4. 抽取-转换-装载（ETL）"></a><span id="jump4">4. 抽取-转换-装载（ETL）</span></h3><p>ETL（Extract、Transform、Load）是建立数据仓库最重要的处理过程。</p>
<ul>
<li>抽取：从操作型数据源获取数据。</li>
<li>转换：转换数据，使之转变为适用于查询和分析的形式和结构。</li>
<li>装载：将转换后的数据导入道最终的目标数据仓库。</li>
</ul>
<p>建立一个数据仓库就是要把来自于多个异构的源系统的数据集成在一起，放置于一个集中的位置用于数据分析。ETL系统的工作就是把异构的数据转换成同构的。</p>
<h4 id="4-1-数据抽取"><a href="#4-1-数据抽取" class="headerlink" title="4.1 数据抽取"></a>4.1 数据抽取</h4><p>设计和建立数据抽取过程，在ETL处理乃至整个数据仓库处理过程中，一般是较为耗时的任务。需要决定抽取哪些数据。通常数据都不是只抽取一次，而是需要以一定的时间间隔反复抽取。对抽取方法的选择高度依赖于源系统和目标数据仓库环境的业务需要。一般情况下，不可能因为需要提升数据抽取的性能，而在源系统中添加额外的逻辑，也不能增加这些源系统的工作负载。</p>
<h5 id="4-1-1-逻辑抽取"><a href="#4-1-1-逻辑抽取" class="headerlink" title="4.1.1 逻辑抽取"></a>4.1.1 逻辑抽取</h5><p>两种逻辑抽取类型：<span style="color:red">全量抽取</span>和<span style="color:red">增量抽取</span>。</p>
<h6 id="（1）全量抽取"><a href="#（1）全量抽取" class="headerlink" title="（1）全量抽取"></a>（1）全量抽取</h6><p>源系统的数据全部被抽取。因为这种抽取类型影响源系统上当前所有有效的数据，所以不需要跟踪自上次成功抽取以来的数据变化。源系统只需要原样提供现有的数据而不需要为附加的逻辑信息（比如时间戳等）。一个全表导出的数据文件或者一个查询源表所有数据的SQL语句，都是全量抽取的例子。</p>
<h6 id="（2）增量抽取"><a href="#（2）增量抽取" class="headerlink" title="（2）增量抽取"></a>（2）增量抽取</h6><p>只抽取某个事件发生的特定时间点之后的数据。通过该事件发生的时间顺序能够反映数据的历史变化，它可能是最后一次成功抽取，也可能是一个复杂的业务事件，如最后一次财务结算等。必须能够标识出特定时间点之后所有的数据变化。这些发生变化的数据可以由源系统自身来提供，例如能够反映数据最后发生变化的时间戳列，或者是一个原始事务处理之外的，只用于跟踪数据变化的变更日志表。大多数情况下，使用后者意味着需要在源系统上增加抽取逻辑。</p>
<p>在许多数据仓库中，抽取过程不含任何变化数据捕获技术。取而代之的是，把源系统中的整个表抽取到数据仓厍过渡区，然后用这个表的数据和上次从源系统抽取得到的表数据作比对，从而找出发生变化的数据。虽然这种方法不会对源系统造成很大的影响，但显然需要考虑给数据仓库处理增加的负担，尤其是当数据量很大的时候。</p>
<h5 id="4-1-2-物理抽取"><a href="#4-1-2-物理抽取" class="headerlink" title="4.1.2 物理抽取"></a>4.1.2 物理抽取</h5><p>依赖于选择的逻辑抽取方法和能够对源系统所做的操作和所受的限制，存在两种物理数据抽取机制：直接从源系统联机抽取或者间接从一个脱机结构抽取数据。这个脱机结构有可能已经存在，也可能需要由抽取程序生成。</p>
<h6 id="（1）联机抽取"><a href="#（1）联机抽取" class="headerlink" title="（1）联机抽取"></a>（1）联机抽取</h6><p>数据直接从源系统抽取。抽取进程或者直连源系统数据库，访问它们的数据表，或者连接到一个存储快照日志或变更记录表的中间层系统。注意这个中间层系统并不需要必须和源系统物理分离。</p>
<h6 id="（2）脱机抽取"><a href="#（2）脱机抽取" class="headerlink" title="（2）脱机抽取"></a>（2）脱机抽取</h6><p>数据不从源系统直接抽取，而是从一个源系统以外的过渡区抽取。过渡区可能己经存在（例如数据库备份文件、关系数据库系统的重做日志、归档日志等），或者抽取程序自己建立。</p>
<h5 id="4-1-3-变化数据捕获"><a href="#4-1-3-变化数据捕获" class="headerlink" title="4.1.3 变化数据捕获"></a>4.1.3 变化数据捕获</h5><p>抽取处理需要重点考虑增量抽取，也被称为变化数据捕获，简称CDC。假设一个数据仓库系统，在每天夜里的业务低峰时间从操作型源系统抽取数据，那么增量抽取只需要过去24小时内发生变化的数据。变化数据捕获也是建立准实时数据仓库的关键技术。</p>
<p>常用的变化数据捕获方法有<strong>时间戳、快照、触发器和日志</strong>四种。时间戳方法需要源系统有相应的数据列表示最后的数据变化。快照方法可以使用数据库系统自带的机制实现，如Oracle的物化视图技术，也可以自己实现相关逻辑，但会比较复杂。触发器是关系数据库系统具有的特性，源表上建立的触发器会在对该表执行insert、update、delete等语句时被触发，触发器中的逻辑用于捕获数据的变化。日志可以使用应用日志或系统日志，这种方式对源系统不具有侵入性，但需要额外的日志解析工作。</p>
<h4 id="4-2-数据转换"><a href="#4-2-数据转换" class="headerlink" title="4.2 数据转换"></a>4.2 数据转换</h4><p>转换操作：如统一数据类型、处理拼写错误、消除数据歧义、解析为标准格式等。数据转换一个最重要的功能是清洗数据，只有”合规“的数据才能进入目标数据仓库。</p>
<ul>
<li>只装载特定的数据列。例如，某列为空的数据不装载。</li>
<li>统一数据编码。例如，性别字段，有些系统使用的是1和0，有些是’M，和’F’，有些是’男’，和’女’，统一成’M’和’F’</li>
<li>自由值编码。例如，将’Male’改成’M’</li>
<li>预计算。例如，产品单价*购买数量=金额。</li>
<li>基于某些规则重新排序以提高查询性能。</li>
<li>合并多个数据源的数据并去重。</li>
<li>预聚合。例如，汇总销售数据。</li>
<li>行列转置</li>
<li>将一列转为多列。例如，某列存储的数据是以逗号作为分隔符的字符串，将其分割成多列的单个值</li>
<li>合并重复列</li>
<li>预连接。例如，查询多个关联表的数据。</li>
<li>数据验证。针对验证的结果采取不同的处理，通过验证的数据交给装载步骤，验证失败的数据或直接丢弄，或记录下来做进一步检查。</li>
</ul>
<h4 id="4-3-数据装载"><a href="#4-3-数据装载" class="headerlink" title="4.3 数据装载"></a>4.3 数据装载</h4><p>把转换后的数据装载进目标数据仓库。需要考虑的两个问题：</p>
<ul>
<li>数据装载的效率问题</li>
<li>一旦装载过程中途失败了，如何再次重复执行装载过程</li>
</ul>
<p>即使经过了转换、过滤和清洗，去掉了部分噪声数据，但需要装载的数据量还是很大的。执行一次数据装载可能需要几个小时的时间，同时需要占用大量的系统资源，要提高装载的效率，加快装载速度，可以从以下几方面入手。</p>
<ul>
<li>首先保证足够的系统资源。数据仓厍存储的都是海量数据，所以要配置高性能的服务器，并且要独占资源，不要与别的系统共用。</li>
<li>在进行数据装载时，要禁用数据库约束（唯一性、非空性，检查约束等）和索引，当装载过程完全结束后，再启用这些约束，重建索引，这种方法会很大的提高装载速度。在数据仓库环境中，一般不使用数据库来保证数据的参考完整性，即不使用数据库的外键约束，它应该由ETL工具或程序来维护。</li>
</ul>
<p>数据装载过程可能由于多种原因而失败，比如装载过程中某些源表和目标表的结构不一致而导致失败，而这时己经有部分表装载成功了。在数据量很大的情况下，如何能在重新执行装致过程时只装载失败的部分是一个不小的挑战。对于这种情况，实现可重复装载的关键是要<strong>记录下失败点，并在装载程序中处理相关的逻辑</strong>。还有一种情况，就是<strong>装载成功，数据又发生了改变</strong>（比如有些滞后的数据在ETL执行完才进入系统，就会带来数据的更新或新增），这时需要重新再执行一遍装载过程，己经正确装载的数据可以被覆盖，但相同数据不能重复新增。简单的实现方式是<strong>先删除再插入</strong>，或者用replace into、merge into等类似功能的操作。</p>
<p>装载到数据仓库里的数据，经过汇总、聚合等处理后交付给多维立方体或数据可视化、仪表盘等报表工其、Bl工具做进一步的数据分析。</p>]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>数据仓库</tag>
      </tags>
  </entry>
  <entry>
    <title>熵、条件熵、互信息、相对熵</title>
    <url>/2020/10/19/%E7%86%B5%E3%80%81%E6%9D%A1%E4%BB%B6%E7%86%B5%E3%80%81%E4%BA%92%E4%BF%A1%E6%81%AF%E3%80%81%E7%9B%B8%E5%AF%B9%E7%86%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来自《数学之美》</p>
</blockquote>
<h4 id="1-信息熵"><a href="#1-信息熵" class="headerlink" title="1.信息熵"></a>1.信息熵</h4><p>香农在他著名的论文”通信的数学原理“（A Mathematic Theory of Communication）中提出了”信息熵“的概念，解决了信息的度量问题，并且量化出信息的作用。</p>
<p>一条信息的信息量与其不确定性有着直接的关系。比如说，我们要搞清楚一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。相反，如果已对某件事了解较多，则不需要太多的信息就能把它弄清楚。从这个角度来看，<span style="color:red">可以认为，信息量就等于不确定性的多少。</span></p>
<blockquote>
<p>那么如何量化信息量的度量呢？来看一个例子。2014年举行了世界杯足球赛，大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛结果的观众“哪支球队是冠军”？他不愿意直接告诉我，而让我猜，并且我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我要掏多少钱才能知道谁是冠军呢？我可以把球队编上号，从1到32，然后提问：“冠军球队在1一16号中吗？”假如他告诉我猜对了，我会接着问：“冠军在1一8号中吗？”假如他告诉我猜错了，我自然知道冠军队在9一16号中。这样只需要五次，我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只值5块钱。</p>
</blockquote>
<p>当然，香农不是用钱，而是用“比特”（Bit）这个概念来度量信息量。一个比特是一位二进制数，在计算机中，一个字节就是8比特。在上面的例子中，这条消息的信息量是5比特。（如果有朝一日有64支球队进入决赛阶段的比赛，那么“谁是世界杯冠军”的信息量就是6比特，因为要多猜一次。）读者可能已经发现，信息量的比特数和所有可能情况的对数函数log有关。（$log32=5,log 64=6$）</p>
<p>有些读者会发现实际上可能不需要猜五次就能猜出谁是冠军，因为像西班牙、巴西、德国、意大利这样的球队夺得冠车的可能性比日本、南非、韩国等球队大得多。因此，第一次猜测时不需要把32支球队等分成两个组，而可以把少数几支最可能的球队分成一组，把其他球队分成另一组。然后猜冠军球队是否在那几支热门队中。重复这样的过程，根据夺冠概率对余下候选球队分组，直至找到冠军队。这样，也许三次或四次就猜出结果。因此，当每支球队夺冠的可能性（概率）不等时，“谁是世界杯冠军”的信息量比5比特少。香农指出，它的准确信息量应该是</p>
<script type="math/tex; mode=display">
H=-(p_1logp_1+p_2logp_2+...+p_{32}logp_{32})</script><p>其中，$p_1,p_2,…,p_{32}$分别是这32支球队夺冠的概率。香农把它称为<strong>“信息熵”（Entropy）</strong>，一般用符号 $H$ 表示，单位是比特。当32支球队夺冠概率相同时，对应的信息熵等于5比特。可以证明上面公式的值不可能大于5，即</p>
<script type="math/tex; mode=display">
0 \leq H \leq logn</script><p>对于任意一个随机变量 $X$（比如得冠军的球队），它的熵定义如下：</p>
<script type="math/tex; mode=display">
H(X)=-\sum _{x\in X}P(x)logP(x)</script><p><span style="color:Red">变量的不确定性越大，熵也就越大，要把它搞清楚，所需信息量也就越大。</span></p>
<h4 id="2-信息的作用，条件熵"><a href="#2-信息的作用，条件熵" class="headerlink" title="2.信息的作用，条件熵"></a>2.信息的作用，条件熵</h4><blockquote>
<p>有些时候，在战争中1比特的信息能抵过干军万马。在第二次世界大战中．当纳粹德国兵临前苏联莫斯科城下时，斯大林在欧湖已经无兵可派，他们在西伯利亚的中苏边界却有60万大军不敢使用，因为苏联人不知道德国的轴心国盟友日本当时的军事策略是北上进攻前苏联，还是南下和美国开战。如果是南下，那么苏联人就可以放心大胆地从亚洲撤回60万大军增援莫斯科会战。事实上日本人选择了南下，其直接行动是后来的偷袭珍珠港，但是苏联人并不知骁。斯大林不能猜，因为猜错了后果是很严重的。这个“猜“既是指扔钢镚儿似的卜卦，也包括主观的臆断。最后传奇间谍佐尔格向莫斯科发去了信息量仅1比特却价值无限的情报（信息）：“日本将南下”，于是前苏联就把西伯利亚所有的军队调往了欧洲战场。后面的故事大家都知道了。</p>
</blockquote>
<p>如果把这个故事背后的信息论原理抽象化、普遍化，可以总结如下：</p>
<p><img src="/2020/10/19/熵、条件熵、互信息、相对熵/1603102832279.png" alt="1603102832279"></p>
<p>一个事物（比如上面讲到的日本内阁的战略决定）内部会存有随机性，也就是不确定性，假定为 $U$，而从外部消除这个不确定性唯一的办法是引入信息 $I$，而需要引入的信息量取决于这个不确定性的大小，即 $I&gt;U$ 才行。当 $I&lt;U$ 时，这些信息可以消除一部分不确定性，也就是说新的不确定性。</p>
<script type="math/tex; mode=display">
U'=U-I</script><p>反之，如果没有信息，任何公式或数字的游戏都无法排除不确定性。这个朴素的结论非常重要，但是在研究工作中经常被一些半瓶子醋的专家忽视，希望做这方面工作的读者谨记。几所有的自然语言处理、信息与信号处理的应用都是一个消除不确定性的过程。</p>
<blockquote>
<p>网页搜索本质上就是要从大量（几十亿个）网页中．找到和用户输入的搜索词最相关的几个网页。几十亿种可能性，当然是很大的不确定性 $U$。如果只剩下几个网页，就几平没有了不确定性了（此时 $U’&lt;&lt;U$），甚至是完全确定了（对于导航类搜索就是如此，第一条结果通常就是要找的网页）。因此，网页搜索本质上也是利用信息消除不确定性的过程。如果提供的信息不够多，比如搜索词是常用的关键词，诸如“中国”、“经济”之类的，那么会有好多相关的结果，用户可能还是无从选择，这时正确的做法是挖掘新的隐含信息，比如网页本身的质量信息。如果这些信息还是不够消除不确定性，不妨再问问用户。这就是相关搜索的理论基础。不正确的做法是在这个关键词上玩数字和公式的游戏，由于没有额外的信息引入，这种做法没有效果，这就是很多做搜索质量的人非常辛苦却很少有收获的原因。最糟糕的做法是引入人为的假设，这和“蒙“没什么差别。其结果是似平满足了个别用户的口味，但是对大部分用户来讲，搜索结果反而变得更糟。合理利用信息，而非玩弄什么公式和机器学习算法，是做好搜索的关键。</p>
</blockquote>
<p>知道的信息越多，随机事件的不确定性就越小。</p>
<p>这些信息，可以是直针对我们要了解的随机事件，也可以是和我们关心的随机事件相关的其他（事件）的信息一一通过获取这些相关信息也能帮助我们了解所关注的对象。比如自然语言的统计模型，其中的一元模型就是通过某个词本身的概率分布来清除不确定因素；而二元及更高阶的语言模型则还使用了上下文的信息，那就能准确预测一个句子中当前的词汇了。在数学上可以严格地证明为什么这些”相关的“信息也能够消除不确定性，为此，需要引入一个<strong>条件熵（Conditional Entropy）</strong>的概念。</p>
<p>假定 $X$ 和 $Y$ 是两个随机变量， $X$ 是我们需要了解的。假定我们现在知道了 $X$ 的随机分布 $P(X)$，那么也就知道了 $X$ 的熵:</p>
<script type="math/tex; mode=display">
H(X)=-\sum_{x\in X}P(x)logP(x)</script><p>那么它的不确定性就是这么大。现在假定我们还知道 $Y$ 的一些情况，包括它和 $X$ 一起出现的概率，在数学上称为联合概率分布，以及在 $Y$ 取不同值的前提下 $X$ 的概率分布，在数学上称为条件概率分布。</p>
<p>定义在 $Y$ 的条件下的条件熵为：</p>
<script type="math/tex; mode=display">
\begin{align*}
H(X|Y) &= -\sum_{x\in X,y\in Y}P(x,y)logP(x,y)\\
&=\sum_{i=1}^n p_iH(X|Y=y_i)
\end{align*}</script><p>这里，$p_i=P(Y=y_i),\quad i=1,2,…,n.$</p>
<p>可以证明， $H(X)\geq H(X|Y)$，也就是说多了 $Y$ 的信息之后，关于 $X$ 的不确定性下降了。在统计语言模型中，如果把 $Y$ 看成前一个字，那么在数学上就证明了二元模型的不确定性小于一元模型。同理，可以定义有两个条件的条件熵</p>
<script type="math/tex; mode=display">
H(X|Y,Z)=-\sum_{x\in X,y\in Y,z\in Z}p(x,y,z)logp(x,y,z)</script><p>还可以证明， $H(X|Y)\geq H(X|Y,Z)$。也就是说，三元模型应该比二元好。</p>
<blockquote>
<p>上述的等号什么时候成立？等号成立说明增加了信息，不确定性却没有降低。如果我们获取的信息与要研究的事物毫无关系，等号就成立。</p>
</blockquote>
<p>用一句话概括这一节：<span style="color:Red">信息的作用在于消除不确定性</span>，自然语言处理的大量问题就是寻找相关的信息。</p>
<h4 id="3-互信息"><a href="#3-互信息" class="headerlink" title="3.互信息"></a>3.互信息</h4><p>在上一节中提到，当获取的信息和要研究的事物“有关系”时，这些信息才能帮助我们消除不确定性。如何量化地度量“相关性”，香农在信息论中提出了一个<strong>“互信息”（Mutual Information）</strong>的概念作为两个随机事件“相关性”的量化度量。</p>
<p>假定有两个随机事件 $X$ 和 $Y$，它们的互信息定义如下：</p>
<script type="math/tex; mode=display">
I(X;Y)=\sum_{x\in X,y\in Y}P(x,y)log\frac{P(x,y)}{P(x)P(y)}</script><p>这个互信息就是上节介绍的随机事件 $X$ 的不确定性（熵 $H(X)$），以及在知道随机事件 $Y$ 的条件下的不确定性（条件熵 $H(X|Y)$）之间的差异，即</p>
<script type="math/tex; mode=display">
I(X;Y)=H(X)-H(X|Y)</script><blockquote>
<p>即决策树中的信息增益</p>
</blockquote>
<p><span style="color:red">所谓两个事件相关的量化度量，就是在了解了其中一个 $Y$ 的前提下，对消除另一个 $X$ 的不确定性所提供的信息量。</span></p>
<p>互信息是一个取值在 $0$ 到 $min(H(X),H(Y))$ 之间的函数，当 $X$ 和 $Y$ 完全相关时，它的取值是 $H(X)$，同时 $H(X)=H(Y)$；当二者完全无关时，它的取值是0。</p>
<p>在自然语言处理中，两个随机事件，或者语言特征的互信息是很容易计算的。只要有足够的语料，就不难估计出互信息公式中的 $P(X,Y),P(X)$ 和 $P(Y)$ 三个概率，进而算出互信息。因此，<span style="color:red">互信息被广泛用于度量一些语言现象的相关性。</span></p>
<p>机器翻译中，最难的两个问题之一是<span style="color:blue">词义的二义性</span>（又称歧义性，Ambiguation）问题。比如 Bush 可以是美国总统布什的名字，也可以是灌木丛。那么如何正确地翻译这些词呢？</p>
<p>法一：用语法，分析语句，等等。-&gt; 迄今为止没有一种语法能很好地解决这个问题，Bush不论翻译成人名还是灌木丛，都是名词，在语法上没有太大问题。</p>
<p>法二：加规则“总统做宾语时，主语得是一个人”。-&gt; 要是这样，语法规则就多得数不清，而且还有许多例外。</p>
<p>真正简单却非常实用的方法是实用互信息：</p>
<p><span style="color:blue">首先从大量文本中找出和总统布什一起出现的互信息量最大的一些词，比如总统、美国、国会、华盛顿，等等。再用同样的方法找出和灌木丛一起出现的互信息量最大的词，比如土壤、植物、野生，等等。有了这两组词，再翻译 Bush 时，看看上下文中哪类相关的词多就可以了。</span></p>
<p>这种方法最初由吉尔（William Gale），丘奇（Kenneth Church）和雅让斯基（David Yarowsky）提出。</p>
<h4 id="4-相对熵"><a href="#4-相对熵" class="headerlink" title="4.相对熵"></a>4.相对熵</h4><p><strong>“相对熵”</strong>，在有些文献中它被称为<strong>“交叉熵”</strong>，在英语中是 $Kullback-Leibler Divergence$（KL散度）。</p>
<p><span style="color:red">相对熵也用来衡量相关性，但和变量的互信息的不同，它用来衡量两个取值为正数的函数的相似性</span>，定义如下：</p>
<script type="math/tex; mode=display">
KL(f(x)||g(x))=\sum_{x\in X} f(x)log\frac{f(x)}{g(x)}</script><p>结论：</p>
<ol>
<li><span style="color:blue">对于两个完全相同的函数，它们的相对熵等于零。</span></li>
<li><span style="color:blue">相对熵越大，两个函数的差异越大；反之，相对熵越小，两个函数的差异越小。</span></li>
<li><span style="color:blue">对于概率分布或概率密度函数，如果取值均大于零，相对熵可以度量两个随机分布的差异性。</span></li>
<li>$KL(f(x)||g(x))&gt;=0$</li>
</ol>
<p><strong>总结</strong>：相对熵可以用来衡量两个概率分布之间的差异。</p>
<p>相对熵是不对称的，即</p>
<script type="math/tex; mode=display">
KL(f(x)||g(x)) \neq KL(g(x)||f(x))</script><p>这样使用起来有时不是很方便，为了让它对称，詹森和香农提出一种新的相对熵的计算方法，将上面的不等式两边取平均，即</p>
<script type="math/tex; mode=display">
JS(f(x)||g(x))=\frac{1}{2}[KL(f(x)||g(x))+KL(g(x)||f(x))]</script><p>相对熵最早是用在信号处理上。如果两个随机信号，它们的相对熵越小，说明这两个信号越接近，否则信号的差异越大。后来研究信息处理的学者们也用它来<span style="color:red">衡量两段信息的相似程度，比如说如果一篇文章是照抄或者改写另一篇，那么这两篇文章中词频分布的相对熵就非常小，接近于零</span>。在Google自动问答系统中，我们采用了上面的詹森-香农度量来衡量两个答案的相似性。</p>
<p>相对熵在自然语言处理中还有很多应用，比如用来衡量两个常用词（在语法和语义上）在不同文本中的概率分布，看它们是否同义。另外，利用相对熵，还可以得到信息检索中最重要的一个概念：词频率-逆向文档频率（TF-IDF）。</p>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Precision, Recall, ROC曲线等</title>
    <url>/2020/08/07/Precision-Recall-ROC%E6%9B%B2%E7%BA%BF%E7%AD%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-Precision-Recall"><a href="#1-Precision-Recall" class="headerlink" title="1.Precision, Recall"></a>1.Precision, Recall</h4><p>准确率 <script type="math/tex">Accuracy = \frac{TP+TN}{TP+TN+FP+FN}</script></p>
<p>精确率 <script type="math/tex">Precision = \frac{TP}{TP+FP}</script>，预测为positive中，实际为positive的比例，反映分类器的准确性</p>
<p>召回率 <script type="math/tex">Recall = \frac{TP}{TP+FN}</script>，实际为positive中，预测为positive的比例，反映分类器的完备性</p>
<p>F值为精确率和召回率的调和平均：</p>
<script type="math/tex; mode=display">
F1\_Score=\frac{2*Precision*Recall}{Precision+Recall}</script><p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20210718110616770.png" alt="image-20210718110616770" style="zoom: 60%;"></p>
<p>什么情况下更注重哪个指标？</p>
<ul>
<li><p>注重 <script type="math/tex">Precision = \frac{TP}{TP+FP}</script>，希望 FP 小 -&gt; 判断为正实际为负的情况少 -&gt; 垃圾邮件 (垃圾邮件为1)</p>
</li>
<li><p>注重 <script type="math/tex">Recall = \frac{TP}{TP+FN}</script>，希望 FN 小 -&gt; 判断为负实际为正的情况少 -&gt; 信贷风控 (坏客户为1)</p>
</li>
</ul>
<h4 id="2-TPR-FPR"><a href="#2-TPR-FPR" class="headerlink" title="2.TPR,FPR"></a>2.TPR,FPR</h4><script type="math/tex; mode=display">
TPR (True\ Positive\ Rate) = \frac{TP}{TP+FN}</script><p><strong>TPR 等价于 Recall</strong>，正样本中正确分类的比例（所有真实的1中，有多少被模型成功选出）</p>
<script type="math/tex; mode=display">
FPR(False\ Positive\ Rate) = \frac{FP}{FP+TN}</script><p>FPR，负样本中错分的比例（所有真实的0中，有多少被模型误判为1）</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20210718110748865.png" alt="image-20210718110748865" style="zoom: 50%;"></p>
<h4 id="3-Sensitivity-Specificity"><a href="#3-Sensitivity-Specificity" class="headerlink" title="3. Sensitivity, Specificity"></a>3. Sensitivity, Specificity</h4><p>灵敏度 <script type="math/tex">Sensitivity = \frac{TP}{TP+FN}</script>，<strong>等价于 Recall</strong>，正样本中正确分类的比例 (Accuracy with respect to positive cases, also called <script type="math/tex">True\ Positive\ Rate</script>) </p>
<p>特异度 <script type="math/tex">Specificity = \frac{TN}{TN+FP}</script>，负样本中正确分类的比例 (Accuracy with respect to negative cases)</p>
<script type="math/tex; mode=display">FPR=1-Specificity</script><p><img src="/2020/08/07/Precision-Recall-ROC曲线等/1596783235673.png" alt="1596783235673" style="zoom: 67%;"></p>
<hr>
<h4 id="4-ROC-曲线"><a href="#4-ROC-曲线" class="headerlink" title="4. ROC 曲线"></a>4. ROC 曲线</h4><p>ROC曲线：ROC曲线是一个画在二维平面上的曲线，横坐标是FPR（负样本中错分的比例）,纵坐标是TPR（TPR等价于recall，正样本中正确分类的比例）。对某个分类器而言，根据其在测试样本上的表现可以得到一个(FPR,TPR)点对，调整分类时使用的阈值，可以得到一个曲线，就是ROC曲线。一般情况下，这个曲线应该处于对角线的上方（对角线代表的是一个随机分类器）。</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/1596778766409.png" alt="1596778766409"></p>
<hr>
<blockquote>
<p>参考 <a href="https://www.sohu.com/a/132667664_278472" target="_blank" rel="noopener">【建模基础课】ROC、K-S，教你巧妙使用模型评价指标 (sohu.com)</a></p>
</blockquote>
<p>最理想的模型，当然是TPR尽量高而FPR尽量低啦，然而任何模型在提高正确预测概率的同时，也会难以避免地增加误判率。听起来有点抽象，好在有ROC曲线非常形象地表达了二者之间的关系。</p>
<p>对于一个二分类模型，输出的最初结果是连续的（概率）；假设已经确定一个阈值，那么最初结果大于阈值时，则输出最终结果为1，小于阈值则输出为0。假如阈值取值为0.6，那么FPR和TPR就可以计算出此时的取值，标记为一个点，记为(FPR1,TPR1)；如果阈值取值为0.5，同理可以计算出另一个点，记为(FPR2,TPR2)。设定不同的阈值，就可以计算不同的点(FPR,TPR)，以FPR为横坐标,TPR为纵坐标，把不同的点连成曲线，就得到了<strong>ROC曲线</strong>。那么问题来了，阈值如何确定？</p>
<p>以Logistic模型为例，模型输出的结果其实是概率，我们通过设定阈值，把概率转化为最终的输出结果0和1。首先出现在我们脑中的直观想法，就是把(0,1)区间进行等分，比如等分为十个区间（其实分成多少份都可以，大家可以自由发挥），那么就可以分别以0.1，0.2，0.3，0.4，0.5，0.6，0.7，0.8，0.9为阈值，首先计算出根据阈值判定出的0和1有多少，以及“真实为1判定为1”和“真实为0判断为1”的有多少；然后计算出不同的(FPR,TPR)值；最后把点之间进行连线，画出的曲线即是ROC曲线。</p>
<p>下面，我们以某商业银行某时间段内某支行客户的逾期相关数据为例详细说明：P代表此支行的某客户的逾期率（暂且定义为在此时间段内某客户的逾期可能性），Y代表是否为高逾期客户，X是与逾期有关的相关指标，比如行业、企业规模、客户的五级分类等等。</p>
<p>然而，当把这个直观的想法对案例数据付诸实施的时候，我们发现计算出的概率值都落在[0.0092,0.578]区间范围内。这种情况下，如果还用上面的“直观想法”（即仍然假定P小于阈值时，判定为0），那么设定阈值为0.1到0.5时，能够计算出不同的(FPR,TPR)值；而将阈值取到0.6到0.9时，模型的判定结果为所有的样本就都是0了……so sad！此时计算出的(FPR,TPR)值都是(0,0)，ROC曲线的点由11个变成了6个…….</p>
<p>面对这个特殊案例，我们的直观想法肯定需要改进。最终，我们的实现方法是：</p>
<blockquote>
<ol>
<li>把(0,1)区间升级为(min(P),max(P))；</li>
<li>取值(min(P),max(P))/10，设定阈值为(min(P),max(P))*k/10，其中k=1,2,3,…,9；</li>
<li>根据不同的阀值，计算出不同的(FPR,TPR)值。</li>
</ol>
</blockquote>
<p>这时候再画出ROC曲线，就避免了上面的问题。然而小伙伴又发问了：这样在写代码实现的过程中，每次都要和阈值进行做比较，计算量比较大，不如先对样本计算出的P值从小到大排序（当然从大到小也可以），取前百分之几（比如10%）处的值为阈值，那么排序之后前百分之几（比如前10%）的判定为0，其他则判定为1。这样计算量就少了很多啦！</p>
<p>于是，我们继续改进阈值的设置，<strong>首先把Logistic模型输出的概率从小到大排序，然后取10%的值（也就是概率值）作为阈值，同理把10%*k（k=1,2,3,…,9）处的值作为阈值，计算出不同的(FPR,TPR)值，</strong>就可以画出ROC曲线啦。</p>
<p>可是，从小到大排序之后，每次取前百分之几处的值为阈值呢？总共分成10份还是100还是1000份呢？有选择困难症的小伙伴又纠结了，告诉你个办法，别纠结，<strong>有多少个模型输出的概率值就分成多少份，不再考虑百分之几</strong>！比如Logistic模型输出的概率有214个，那么我们把214个目标变量从小到大进行排序，然后分别以这214个的概率值为阈值，可以计算出214个不同的(FPR,TPR)值，也可以画出ROC曲线。</p>
<p>ROC曲线画好后，就要发挥用处！对于一个模型一组参数可以画出一条ROC曲线，此时最优的阈值是什么呢（即以什么阈值为准，去最终划分为0，1）？TPR和FPR是正相关的，也就是说，正确判定出1的数量增加时，必然要伴随着代价：误判为1的FP也增加。</p>
<p>从ROC曲线上也可以反映出这种变化，从ΔTPR&gt;ΔFPR到ΔTPR&lt;ΔFPR（一开始曲线比较陡，TPR增长得快，FPR增长得慢，即ΔTPR&gt;ΔFPR；到后面，曲线比较平缓，TPR增长得慢，FPR增长得快，有ΔTPR&lt;ΔFPR），最理想的阀值是ΔTPR=ΔFPR时。但是在实际应用中，我们很少能够给出ROC曲线的函数表达式，这时的解决方法包括：</p>
<blockquote>
<ol>
<li>给出ROC曲线的拟合函数表达式，然后计算出最优的阈值，这个目前通过软件实现难度不大：如何给出最优拟合函数，计算数学上有很多方法；计算出 ΔTPR≈ΔFPR 的点即为最优的阀值。</li>
<li>从业务上给出最优的阀值。</li>
</ol>
</blockquote>
<p>对于一个模型多个参数的情况，就可以画出多条ROC曲线，此时哪组参数是最优的呢？我们可以结合<strong>AUC指标</strong>，哪组参数的AUC值越高，说明此组参数下的模型效果越好。另外，在SAS的评分模型输出中，常用来判断收入分配公平程度的gini系数也用来评价模型，此时gini=2*AUC-1.</p>
<hr>
<p>ROC曲线的特性：当测试集中的正负样本的分布（比例）变化的时候，ROC曲线能保持不变。类不平衡现象可以使用ROC曲线来评估模型的性能。</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/1602655652264.png" alt="1602655652264"></p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/1602655688379.png" alt="1602655688379"></p>
<p>AUC (Area Under the ROC Curve) 值：ROC曲线下的面积，取值范围在 0.5 到 1 之间。使用AUC值作为评价标准是因为很多时候ROC曲线并不能清晰的说明哪个分类器的效果更好，而作为一个数值，对应AUC更大的分类器效果更好。</p>
<h4 id="5-KS-曲线"><a href="#5-KS-曲线" class="headerlink" title="5. KS 曲线"></a>5. KS 曲线</h4><blockquote>
<p>参考 <a href="https://www.sohu.com/a/132667664_278472" target="_blank" rel="noopener">【建模基础课】ROC、K-S，教你巧妙使用模型评价指标 (sohu.com)</a></p>
</blockquote>
<p>常用的模型评价还有<strong>K-S曲线</strong>，它和ROC曲线的画法异曲同工。以Logistic模型为例，首先把Logistic模型输出的概率从大到小排序，然后取10%的值（也就是概率值）作为阈值，同理把10%*k（k=1,2,3,…,9）处的值作为阀值，计算出不同的FPR和TPR值，以10%*k（k=1,2,3,…,9）为横坐标<strong>（以阈值为横坐标），分别以TPR和FPR的值为纵坐标，就可以画出两个曲线，这就是K-S曲线。</strong></p>
<p>从K-S曲线就能衍生出<strong>KS值</strong>，<code>KS=max(TPR-FPR)</code>（或者<code>KS=max(|TPR-FPR|)</code>），即是两条曲线之间的最大间隔距离。当(TPR-FPR)最大时，也就是ΔTPR-ΔFPR=0，这和ROC曲线上找最优阈值的条件ΔTPR=ΔFPR是一样的。从这点也可以看出，ROC曲线、K-S曲线、KS值的本质是相同的。</p>
<p>以某模型的评价为例，在K-S曲线的横坐标0.4时取KS=0.53，可以认为最优的阀值是从小到大排序的40%处的值：</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20210718110047789.png" alt="image-20210718110047789"></p>
<p>K-S曲线能直观地找出模型中差异最大的一个分段，比如评分模型就比较适合用KS值进行评估；但同时，KS值只能反映出哪个分段是区分度最大的，不能反映出所有分段的效果。所以，在实际应用中，模型评价一般需要将ROC曲线、K-S曲线、KS值、AUC指标结合起来使用。</p>
<h4 id="6-Lift-提升度"><a href="#6-Lift-提升度" class="headerlink" title="6. Lift 提升度"></a>6. Lift 提升度</h4><blockquote>
<p>参考<br><a href="https://www.jianshu.com/p/ff0eb70d31ec" target="_blank" rel="noopener">模型和策略效果衡量常用指标——LIFT提升度 - 简书 (jianshu.com)</a><br><a href="https://cosx.org/2009/02/measure-classification-model-performance-lift-gain/" target="_blank" rel="noopener">分类模型的性能评估——以 SAS Logistic 回归为例 (3): Lift 和 Gain | 统计之都 (cosx.org)</a><br><a href="https://zhuanlan.zhihu.com/P/94323568" target="_blank" rel="noopener">怎么做模型提升度的曲线？ - 知乎 (zhihu.com)</a><br><a href="https://www.listendata.com/2014/08/excel-template-gain-and-lift-charts.html" target="_blank" rel="noopener">Understand Gain and Lift Charts (listendata.com)</a><br><a href="https://www.datasciencecentral.com/profiles/blogs/comparing-model-evaluation-techniques-part-2" target="_blank" rel="noopener">Comparing Model Evaluation Techniques Part 2: Classification and Clustering - Data Science Central</a><br><a href="https://www.datasciencecentral.com/profiles/blogs/7-important-model-evaluation-error-metrics-everyone-should-know" target="_blank" rel="noopener">11 Important Model Evaluation Techniques Everyone Should Know - Data Science Central</a><br><a href="https://www.analyticsvidhya.com/blog/2019/08/11-important-model-evaluation-error-metrics/" target="_blank" rel="noopener">Evaluation Metrics Machine Learning (analyticsvidhya.com)</a></p>
</blockquote>
<h5 id="6-1-什么是-Lift"><a href="#6-1-什么是-Lift" class="headerlink" title="6.1 什么是 Lift"></a>6.1 什么是 Lift</h5><p>Lift提升度衡量的是，与不利用模型相比，模型的预测能力 “变好” 了多少（how much better one can expect to do with the predictive model comparing without a model. The “lift” is the ratio of results with and without the model; Better models have higher lifts.）。它衡量的是一个模型（或规则）对目标中“响应”的预测能力优于随机选择的倍数，以1为界线，大于1的Lift表示该模型或规则比随机选择捕捉了更多的“响应”，等于1的Lift表示该模型的表现独立于随机选择，小于1则表示该模型或规则比随机选择捕捉了更少的“响应”。维基百科中提升度被解释为“Target response divided by average response”。</p>
<p>显然，lift(提升指数)越大，模型的运行效果越好。如果这个模型的预测能力跟 baseline model 一样（lift 等于 1），这个模型就没有任何 “提升” 了（套一句金融市场的话，它的业绩没有跑过市场）。</p>
<p>以信用评分卡模型为例，LIFT提升度衡量的是评分模型对坏样本的预测能力相比随机选择的倍数，LIFT大于1说明模型表现优于随机选择。我们通常会将打分后的样本按分数从低到高（违约概率从高到低）排序，取10或20等分（有同分数对应多条观测的情况，所以各组观测数未必完全相等），并对组内观测数与坏样本数进行统计。用评分卡模型捕捉到的坏客户的占比，可由该组坏样本数除以总的坏样本数计算得出；而不使用此评分卡，以随机选择的方法覆盖到的坏客户占比，等价于该组观测数占总观测数的比例（分子分母同时乘以样本整体的坏账率）。对两者取累计值，取其比值，则得到提升度Lift，即该评分卡抓取坏客户的能力是随机选择的多少倍。</p>
<h5 id="6-2-为什么要看-Lift"><a href="#6-2-为什么要看-Lift" class="headerlink" title="6.2 为什么要看 Lift"></a>6.2 为什么要看 Lift</h5><p>举个例子，一个贷款产品目标客群有10000个人，其中混合了500个坏客户。如果随机选择1000个人放款，可能会遇到50个坏客户。但是如果运用模型对坏客户加以预测，只选择模型分数最高的1000人放款，如果这1000个客户表现出来最终逾期的只有20户，说明模型在其中是起到作用的，此时的LIFT就是大于1的。如果表现出来逾期客户超过或等于50个，LIFT小于等于1，那么从效果上来看这个模型用了还不如不用。LIFT就是这样一个指标，可以衡量使用这个模型比随机选择对坏样本的预测能力提升了多少倍。</p>
<h5 id="6-3-Lift-如何计算"><a href="#6-3-Lift-如何计算" class="headerlink" title="6.3 Lift 如何计算"></a>6.3 Lift 如何计算</h5><p>通常计算LIFT的时候会把模型的最终得分按照从低到高（违约概率从高到低）排序并等频分为10组或20组（有同分数对应多条观测的情况，所以各组观测数未必完全相等），计算分数最低（违约概率最高）的一组对应的<span style="color:red">累计坏样本占比/累计总样本占比</span>就等于LIFT值了。累计坏样本占比相当于是使用模型的情况下该组能够从所有的坏样本中挑出多少比例的坏样本<span style="color:red">（该组坏样本数/总坏样本数）</span>，而累计总样本占比等于随机抽样的情况下从所有坏样本抽取了多少比例的坏样本<span style="color:red">（该组人数/总人数）</span>（即以随机选择的方法覆盖到的坏客户占比，等价于该组观测数占总观测数的比例（分子分母同时乘以样本整体的坏账率），也即完全随机的情况下，抽取10%的样本也会对应抽到坏样本中的10%，以6.2中的例子：<script type="math/tex">(1000*(500/10000))/(10000*(500/10000))=1000/10000</script>。</p>
<p>注：关于提升度与累计提升度：通常提升度指的就是累计提升度？<br>每组都可以算一个累计提升度：衡量到目前组的情况<br>最大值：到前多少组，两者比值达到最大（一定在第一组？）</p>
<blockquote>
<p>个人理解：累计提升度可以理解为用百分之多少的人数覆盖了百分之多少的目标人群，如果用很少的人数覆盖了很大一部分的目标人群，则累计提升度会比较大。比较两个模型的效果时，以一个模型划分结果去等人数划分另一个模型，哪个模型覆盖的目标人群更多，则其提升度越大。</p>
</blockquote>
<p>下图是一个提升表（Lift Table）的示例：</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20211011151956385.png" alt="image-20211011151956385"></p>
<p> 以分数段为横轴，以提升度为纵轴，可绘制出累计提升图，示例如下：</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20211011152920681.png" alt="image-20211011152920681" style="zoom:80%;"></p>
<p> 有了累计提升图，我们就能直观地去比较不同模型或策略给我们带来的区分能力增益程度。</p>
<p>对累计提升度的解释：</p>
<blockquote>
<p>(假设分为10份) The Cum Lift of 4.03 for top two deciles, means that when selecting 20% of the records based on the model, one can expect 4.03 times the total number of targets (events) found by randomly selecting 20%-of-file without a model.</p>
</blockquote>
<p>另一个例子：</p>
<p>（来自 <a href="http://www2.cs.uregina.ca/~dbd/cs831/notes/lift_chart/lift_chart.html" target="_blank" rel="noopener">Lift Charts (uregina.ca)</a>）</p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20211011165053284.png" alt="image-20211011165053284" style="zoom:150%;"></p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20211011165146743.png" alt="image-20211011165146743" style="zoom:150%;"></p>
<p><img src="/2020/08/07/Precision-Recall-ROC曲线等/image-20211011165243837.png" alt="image-20211011165243837" style="zoom:150%;"></p>
<h5 id="6-4-关于提升度与混淆矩阵"><a href="#6-4-关于提升度与混淆矩阵" class="headerlink" title="6.4  关于提升度与混淆矩阵"></a>6.4  关于提升度与混淆矩阵</h5><p>While the confusion matrix gives proportions between all negatives and positives, <strong>Gain and lift charts focus on the true positives.</strong> One of their most common uses is in marketing, to decide if a prospective client is worth calling.</p>
<p><strong>Gain and lift charts work with a sample</strong> (a fraction of the population). In comparison, a confusion matrix uses the whole population to evaluate a model.</p>
<p>注：Gain 和提升度类似（其实就是Lift的分子部分）</p>
<h4 id="7-在-Python-中的实现"><a href="#7-在-Python-中的实现" class="headerlink" title="7. 在 Python 中的实现"></a>7. 在 Python 中的实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> precision_score, recall_score, f1_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_curve</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluation_metric</span><span class="params">(y_true, y_pred, y_pred_prob)</span>:</span></span><br><span class="line">    print(<span class="string">"precision: "</span>, precision_score(y_true, y_pred))</span><br><span class="line">    print(<span class="string">"recall: "</span>, recall_score(y_true, y_pred))</span><br><span class="line">    print(<span class="string">"f1_score: "</span>, f1_score(y_true,  y_pred))</span><br><span class="line">    print(<span class="string">"========="</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"confusion matrix: "</span>)</span><br><span class="line">    cm = confusion_matrix(y_true, y_pred)</span><br><span class="line">    print(cm)</span><br><span class="line">    print(<span class="string">"========="</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"auc: "</span>, roc_auc_score(y_true, y_pred_prob)) <span class="comment"># auc用预测概率进行计算</span></span><br><span class="line">    </span><br><span class="line">    fpr, tpr, thresholds = roc_curve(y_true, y_pred_prob)</span><br><span class="line">    ks = max(tpr-fpr)</span><br><span class="line">    print(<span class="string">"ks: "</span>, ks)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统冷启动问题</title>
    <url>/2020/07/30/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%90%AF%E5%8A%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来源于</p>
<p><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
</blockquote>
<p>冷启动（ cold start ）在推荐系统中表示该系统积累数据量过少，无法给新用户作个性化推荐的问题，这是产品推荐的一大难题。每个有推荐功能的产品都会遇到冷启动的问题。一方面，当新商品时上架 会遇到冷启动的问题，没有收集到任何一个用户对其浏览、点击或者购买的行为，也无从判断如何将商品进行推荐；另一方面，新用户到来的时候，如果没有他在应用上的行为数据，也无法预测其兴趣，如果给用户的推荐千篇律，没有亮点，会使用户在一开始就对产品失去兴趣，从而放弃使用。所以在冷启动的时候要同时<strong>考虑用户的冷启动和物品的冷启动。</strong></p>
<h3 id="8-1-用户冷启动"><a href="#8-1-用户冷启动" class="headerlink" title="8.1 用户冷启动"></a>8.1 用户冷启动</h3><p>用户冷启动主要解决如何给新用户作个性化推荐的问题。当新用户到来时，我 没有他的行为数据，所以也无法根据他的历史行为预 其兴趣，从而无法借此给他做个性化推荐。解决方法参考以下：</p>
<ol>
<li>利用用户的账号信息。</li>
<li>利用用户的手机 IMEI 号进行冷启动。</li>
<li>制造选工页，让用户选择自己感兴趣的点后，即时生成粗粒度的推荐。</li>
</ol>
<h3 id="8-2-物品冷启动"><a href="#8-2-物品冷启动" class="headerlink" title="8.2 物品冷启动"></a>8.2 物品冷启动</h3><p>物品冷启动主要解决如何将新的物品推荐给可能对它感兴趣的用户这一问题。解决方法参考以下：</p>
<ol>
<li>利用物品的内容、分类信息。</li>
<li>利用专家标注的数据。</li>
</ol>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统总体架构及特征数据</title>
    <url>/2020/07/29/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%E5%8F%8A%E7%89%B9%E5%BE%81%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来源于</p>
<p><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
</blockquote>
<p><strong>个性化推荐系统是建立在海量数据挖掘基础上的一种高级商务智能平台，以帮助电子商务网站为其顾客购物提供完全个性化的决策支持和信息服务。</strong></p>
<p>常见的推荐栏位例如：淘宝的猜你喜欢、看了又看、推荐商品，美团的首页推荐、附近推荐等。</p>
<p>推荐系统是比较偏向于工程类的系统，要做得更加的精确，需要的不仅仅是推荐算法，还有用户意图识别、文本分析、行为分析等，是一个综合性很强的系统。</p>
<h2 id="1-总体架构"><a href="#1-总体架构" class="headerlink" title="1. 总体架构"></a>1. 总体架构</h2><p>本节介绍的几种推荐系统架构，并不是互相独立的关系，实际的推荐系统可能会用到其中一种或者几种的架构。在实际设计的过程中，读者可以把本文介绍的架构作为一个设计的起点，更多地结合自身业务特点进行独立思 考，从而设计出适合自身业务的系统。</p>
<p>根据响应用户行为的速度不同，推荐系统可以大致分为基于<strong>离线训练和在线训练</strong>的推荐系统。</p>
<h3 id="1-1-离线推荐"><a href="#1-1-离线推荐" class="headerlink" title="1.1 离线推荐"></a>1.1 离线推荐</h3><p>基于离线训练的推荐系统架构是最常见的一种推荐系统架构。这里的“离线”训练指的是使用历史一段时间（ 比如周或者几周 ）的数据进行训练，模型迭代的周期较长（一般以小时为单位 ）。模型拟合的是用户的中长期兴趣。</p>
<p>如下图所示， 一个典型的基于离线训练的推荐系统架构由<strong>数据上报、离线训练、在线存储、实时计算和 A/B 测试</strong>这几个模块组成。其中，数据上报和离线训练组成了监督学习中的学习系统，而实时计算和 A/B 测试组成了预测系统。另外，除了模型之外，还有一个在线存储模块，用于存储模型和模型需要的特征信息供实时计算模块调用。图中的各个模块组成了训练和预测两条数据流，训练的数据流搜集业务的数据最后生成模型存储于在线存储模块；预测的数据流接受业务的预测请求，通过 A/B 测试模块访问实时计算模块获取预测结果。</p>
<p><img src="https://camo.githubusercontent.com/256d4abf6809d771af7205fd18eadae4e12936c2/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31302d32322d302e706e67" alt="img"></p>
<a id="more"></a>
<ol>
<li><p><strong>数据上报</strong>：数据上报模块的作用是搜集业务数据组成训练样本。一般分为收集、验证、清洗和转换几个步骤。将收集的数据转化为训练所需要的样本格式，保存到离线存储模块。</p>
<p><a href="https://camo.githubusercontent.com/04a5b6b6717428ef7ffd4e9e139239bbf0072422/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31302d33332d34362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/04a5b6b6717428ef7ffd4e9e139239bbf0072422/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31302d33332d34362e706e67" alt="img"></a></p>
</li>
<li><p><strong>离线训练</strong>：离线训练模块又细分为<strong>离线存储</strong>和<strong>离线计算</strong>。实际业务中使用的推荐系统一般都需要处理海量的用户行为数据，所以离线存储模块需要有一个分布式的文件系统或者存储平台来存储这些数据。离线计算常见的操作有：样本抽样、特征工程、模型训练、相似度计算等。</p>
</li>
<li><p><strong>在线存储</strong>：因为线上的服务对于时延都有严格的要求。比如，某个用户打开手机 APP ，他肯定希望APP 能够快速响应，如果耗时过长，就会影响用户的体验。一般来说，这就要求推荐系统在几十毫秒以内处理完用户请求返回推荐结果，所以，针对线上的服务，需要有一个专门的在线存储模块，负责存储用于线上的模型和特征数据 。</p>
</li>
<li><p><strong>实时推荐</strong>：实时推荐模块的功能是对来自业务的新请求进行预测。1.获取用户特征；2.调用推荐模型；3.结果排序。</p>
<p>在实际应用中，因为业务的物品列表太大，如果实时计算对每个物品使用复杂的模型进行打分，就有可能耗时过长而影响用户满意度。所以，一种常见的做法是将推荐列表生成分为<strong>召回</strong>和<strong>排序</strong>两步。召回的作用是从大量的候选物品中（例如上百万）筛选出一批用户较可能喜欢的候选集 （一般是几百）。排序的作用是对召回得到的相对较小的候选集使用排序模型进行打分。更进一步，在排序得到推荐列表后，为了多样性和运营的一些考虑，还会加上第三步重排过滤，用于对精排后的推荐列表进行处理。</p>
</li>
<li><p><strong>A/B测试</strong>：对于互联网产品来说， A/B 测试基本上是一个必备的模块，对于推荐系统来说也不例外，它可以帮助开发人员评估新算法对客户行为的影响。除了 离线的指标外，一个新的推荐算法上线之前一般都会经过 A/B 测试来测试新算法的有效性。</p>
</li>
</ol>
<p>下图是与之对应的实际系统中各个组件的流转过程。<strong>需要注意的是生成推荐列表就已经做完了召回和排序的操作，业务层直接调用API就可以得到这个推荐列表。</strong></p>
<p><img src="https://camo.githubusercontent.com/e00fb75f81bd5377bcfd1de0cdb3891a7790b134/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31302d32352d32372e706e67" alt="img"></p>
<h3 id="2-2-在线训练"><a href="#2-2-在线训练" class="headerlink" title="2.2 在线训练"></a>2.2 在线训练</h3><p>对于业务来说，我们希望用户对于上个广告的反馈 （喜欢或者不喜欢，有没有点击），可以很快地用于下 一个广告的推荐中。这就要求我们用另一种方法来解决这个问题，这个方法就是在线训练。</p>
<p>基于在线训练的推荐系统架构适合于广告和电商等高维度大数据量且对实时性要求很高的场景，相比较基于离线训练的推荐系统，基于在线训练的推荐系统不区分训练和测试阶段，每个回合都在学习，通过实时的反馈来调整策略。 一方面，在线训练要求其样本、特征和模型的处理都是实时的，以便推荐的内容更快地反映用户实时的喜好；另一方面，因为在线训练井不需要将所有的训练数据都存储下来，所以不需要巨大的离线存储开销，使得系统具有很好的伸缩性，可以支持超大的数据量和模型。</p>
<p><img src="https://camo.githubusercontent.com/6d0bf23d50bf62aaf218595a74437800ae143d01/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31312d31312d31312e706e67" alt="img"></p>
<ol>
<li><strong>样本处理</strong>：和基于离线训练的推荐系统相比，在线训练在数据上报阶段的主要不同体现在样本处理上。对于离线训练来说，上报后的数据先是被存储到一个分布式文件系统，然后等待离线计算任务来对样本进行处理；对于在线训练来说，对样本的去重、过滤和采样等计算都需要实时进行。</li>
<li><strong>实时特性</strong>：实时特征模块通过实时处理样本数据拼接训练需要的特征构造训练样本，输入流式训练模块用于更新模型。该模块的主要的功能是特征拼接和特征工程。</li>
<li><strong>流式训练</strong>：流式训练模块的主要作用是使用实时训练样本来更新模型。推荐算法中增量更新部分的计算，通过流式计算的方式来进行更新。在线训练的优势之一，是可以支持模型的稀疏存储。训练方面，在线模型不一定都是从零开始训练，而是可以将离线训练得到的模型参数作为基础，在这个基础上进行增量训练。</li>
<li><strong>模型存储和加载</strong>：模型一般存储在参数服务器中。模型更新后，将模型文件推送到线上存储，并由线上服务模块动态加载。</li>
</ol>
<h2 id="2-特征数据"><a href="#2-特征数据" class="headerlink" title="2. 特征数据"></a>2. 特征数据</h2><p>要训练推荐模型，就需要先收集用户的行为数据生成特征向量以后才能进行训练，而一个特征向量由特征以及特征的权重组成，在利用用户行为计算特征向量时需要考虑以下因素。</p>
<ol>
<li><strong>用户行为的种类</strong>：在一个网站中，用户可以对物品产生很多不同种类的行为。用户可以浏览物品、单击物品的链接、收藏物品、给物品打分、购买物品、评论物品、给物品打上不同的标签、和好友分享物品、搜索不同的关键词等。这些行为都会对物品特征的权重产生影响，但不同行为的影响不同，大多时候很难确定什么行为更加重要，一般的标准就是用户付出代价越大的行为权重越高。</li>
<li><strong>用户行为产生的时间</strong>：一般来说，用户近期的行为比较重要，而用户很久之前的行为相对比较次要。因此，如果用户最近购买过某一个物品，那么这个物品对应的特征将会具有比较高的权重。</li>
<li><strong>用户行为的次数</strong>：有时用户对一个物品会产生很多次行为。比如用户会听一首歌很多次，看一部电视剧的很多集等。因此用户对同一个物品的同一种行为发生的次数也反映了用户对物品的兴趣，行为次数多的物品对应的特征权重越高。</li>
<li><strong>物品的热门程度</strong>：如果用户对一个很热门的物品产生了行为，往往不能代表用户的个性，因为用户可能是在跟风，可能对该物品并没有太大兴趣，特别是在用户对一个热门物品产生了偶尔几次不重要的行为（比如浏览行为）时，就更说明用户对这个物品可能没有什么兴趣，可能只是因为这个物品的链接到处都是，很容易点到而已。反之，如果用户对一个不热门的物品产生了行为，就说明了用户的个性需求。因此，推荐引擎在生成用户特征时会加重不热门物品对应的特征的权重。</li>
<li><strong>数据去燥</strong>：对样本做去噪。对于数据中混杂的刷单等类作弊行为的数据，要将其排除出训练数据,否则它会直接影响模型的效果；样本中的缺失值也要做处理。</li>
<li><strong>正负样本均衡</strong>：一般我们收集用户的行为数据都是属于正样本，造成了严重的不平衡。所以对于一个用户，从他没有过行为的物品中采样出一些物品作为负样本，但采样时，保证每个用户的正负样本数目相当。</li>
<li><strong>特征组合</strong>：我们需要考虑特征与特征之间的关系。例如在美团酒店搜索排序中，酒店的销量、价格、用户的消费水平等是强相关的因素，用户的年龄、位置可能是弱相关的因素，用户的ID是完全无关的因素。在确定了哪些因素可能与预测目标相关后，我们需要将此信息表示为数值类型,即为特征抽取的过程。除此之外，用户在App上的浏览、交易等行为记录中包含了大量的信息，特征抽取则主要是从这些信息抽取出相关因素，用数值变量进行表示。常用的统计特征有计数特征,如浏览次数、下单次数等;比率特征，如点击率、转化率等;统计量特征，如价格均值、标准差、分位数、偏度、峰度等。</li>
</ol>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>隐语义模型</title>
    <url>/2020/07/29/%E9%9A%90%E8%AF%AD%E4%B9%89%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来源于:</p>
<p> <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
</blockquote>
<h3 id="1-基本思想"><a href="#1-基本思想" class="headerlink" title="1. 基本思想"></a>1. 基本思想</h3><p>推荐系统中一个重要的分支，隐语义建模。隐语义模型<strong>LFM</strong>：Latent Factor Model，其核心思想就是<span style="color:red">通过隐含特征联系用户兴趣和物品</span>。</p>
<p><strong>过程分为三个部分，将物品映射到隐含分类，确定用户对隐含分类的兴趣，然后选择用户感兴趣的分类中的物品推荐给用户。它是基于用户行为统计的自动聚类。</strong></p>
<p>隐语义模型在Top-N推荐中的应用十分广泛。常用的隐语义模型，LSA(Latent Semantic Analysis)，LDA(Latent Dirichlet Allocation)，主题模型(Topic Model)，矩阵分解(Matrix Factorization)等等。</p>
<p>首先通过一个例子来理解一下这个模型，比如说有两个用户A和B，目前有用户的阅读列表，用户A的兴趣涉及侦探小说，科普图书以及一些计算机技术书，而用户B的兴趣比较集中在数学和机器学习方面。那么如何给A和B推荐图书呢？</p>
<p>对于UserCF，首先需要找到和他们看了同样书的其他用户(兴趣相似的用户)，然后在给他们推荐那些用户喜欢的其他书。 对于ItemCF, 需要给他们推荐和他们已经看的书相似的书，比如用户B 看了很多数据挖掘方面的书，那么可以给他推荐机器学习或者模式识别方面的书。</p>
<p>还有一种方法就是使用隐语义模型，可以对书和物品的兴趣进行分类。对于某个用户，首先得到他的兴趣分类，然后从分类中挑选他可能喜欢的物品。</p>
<a id="more"></a>
<h3 id="2-模型理解"><a href="#2-模型理解" class="headerlink" title="2 模型理解"></a>2 模型理解</h3><ol>
<li>如何给物品进行分类？</li>
<li>如何确定用户对哪些类的物品感兴趣，以及感兴趣的程度？</li>
<li>对于一个给定的类，选择哪些属于这个类的物品推荐给用户，以及如何确定这些物品在一个类中的权重？</li>
</ol>
<p>为了解决上面的问题，研究人员提出：为什么我们不从数据出发，自动地找到那些类，然后进行个性化推荐，隐语义分析技术因为采取基于用户行为统计的自动聚类，较好地解决了上面的问题。隐语义分析技术从诞生到今天产生了很多著名的模型和方法，其中和推荐技术相关的有pLSA，LDA，隐含类别模型（latent class model）, 隐含主题模型（latent topic model）, 矩阵分解（matrix factorization）。</p>
<p>LFM通过如下公式计算用户 u 对物品 i 的兴趣：</p>
<p><img src="https://camo.githubusercontent.com/7f94ca282d949c428b6c6021803daa14f88d61fb/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f707265666572656e636528752c69293d725f25374275692537443d705f7525354554715f693d25354373756d5f253742663d3125374425354546705f253742752c6b253744715f253742692c6b253744" alt="img"></p>
<p>这个公式中 $p_{u,k}$ 和 $q_{i,k}$ 是模型的参数，其中 $p_{u,k}$  度量了用户 u 的兴趣和第 k 个隐类的关系，而 $q_{i,k}$  度量了第 k 个隐类和物品 i 之间的关系。那么，下面的问题就是如何计算这两个参数。</p>
<p>对最优化理论或者机器学习有所了解的读者，可能对如何计算这两个参数都比较清楚。这两个参数是从数据集中计算出来的。要计算这两个参数，需要一个训练集，对于每个用户u，训练集里都包含了用户u喜欢的物品和不感兴趣的物品，通过学习这个数据集，就可以获得上面的模型参数。</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习相关资料</title>
    <url>/2020/07/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://createmomo.github.io/2018/01/23/Super-Machine-Learning-Revision-Notes/" target="_blank" rel="noopener">Super Machine Learning Revision Notes</a></p>
<p>总结了机器学习的一系列基本概念，算法等。</p>
<p>分为激活函数，梯度下降，参数，正则化，模型，实用窍门等几大板块。</p>
<hr>
<p><a href="https://yuanxiaosc.github.io/2019/08/16/机器学习中的常识性问题/" target="_blank" rel="noopener">机器学习中的常识性问题</a></p>
<p><img src="/2020/07/28/机器学习相关资料/1595861323230.png" alt="1595861323230"></p>
<a id="more"></a>
<hr>
<p>ds-cheatsheets</p>
<p><a href="https://github.com/FavioVazquez/ds-cheatsheets" target="_blank" rel="noopener">https://github.com/FavioVazquez/ds-cheatsheets</a></p>
<p>各种cheatsheet，关于python, R, big data, machine learning, deep learning, SQL, data visulization等等。</p>
<hr>
<p><a href="https://github.com/MachineLP/CodeFun" target="_blank" rel="noopener">https://github.com/MachineLP/CodeFun</a></p>
<p>包含编程语言（python, scala, c++）, 深度学习（tensorflow, keras, pytorch），机器学习（pyspark, feature engineering），AutoML/DL， 模型部署，sql等内容。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习相关资料</title>
    <url>/2020/07/28/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>吴恩达深度学习coursera课程笔记：</p>
<p><a href="https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng" target="_blank" rel="noopener">https://www.slideshare.net/TessFerrandez/notes-from-coursera-deep-learning-courses-by-andrew-ng</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/152362317" target="_blank" rel="noopener">22张深度学习精炼图笔记总结</a></p>
<p>内容包含深度学习基础、卷积网络和循环网络等。</p>
<hr>
<p>ML-NLP</p>
<p><a href="https://github.com/NLP-LOVE/ML-NLP" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP</a></p>
<p>包含机器学习，深度学习，NLP等内容及代码实现。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>深度学习</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树</title>
    <url>/2020/07/25/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>（关于决策树与集成学习也可参考我的OneNote笔记 -&gt; preparation）</p>
<h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><p><a href="#jump_entropy">熵</a><br><a href="#jump_conditional_entropy">条件熵</a><br><a href="#jump_IG">信息增益的定义</a><br><a href="#jump_MI">互信息</a><br><a href="#jump_IGR">信息增益率</a><br><a href="#jump_Gini">基尼指数</a></p>
<p><a href="#jump_C4.5advantage">C4.5对于ID3所做的改进</a><br><a href="#jump_CARTadvantage">CART对于CR.4所做的改进</a></p>
<p><a href="#jump_algo1.1">算法1.1 (信息增益的算法)</a><br><a href="#jump_algo1.2">算法1.2 (ID3算法)</a><br><a href="#jump_algo2.1">算法2.1 (C4.5的生成算法)</a><br><a href="#jump_algo3.1">算法3.1 (CART生成算法)</a><br><a href="#jump_algo3.2">算法3.2 (CART剪枝算法)</a><br><a href="#jump_algo3.3">算法3.3 (最小二乘回归树生成算法)</a><br><a href="#jump_GBDT">GBDT算法步骤</a></p>
<p><a href="#jump3.1.2.1">XGBoost并行化</a><br><a href="#jump3.1.4">XGBoost与GBDT的比较</a></p>
<h2 id="篇零：决策树的分类"><a href="#篇零：决策树的分类" class="headerlink" title="篇零：决策树的分类"></a>篇零：决策树的分类</h2><blockquote>
<p>本部分内容来自 <a href="https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A</a></p>
</blockquote>
<p>决策树分为两大类：分类树和回归树。前者用于预测离散的具体类别：是否晴天/好坏/网页是否是垃圾网页等等，后者预测的是连续的具体的值：年龄/身高等等。前者的累加是没有意义的比如‘男+男+女=？’，而后者结果的加减是有意义的，‘10+3-6=7’。</p>
<p><strong>1.分类树</strong></p>
<p>决策树的分类算法有很多，以具有最大熵的特征进行分类，以信息增益特征进行分类（ID3），以增益率特征进行分类（C4.5），以基尼系数特征进行分类（CART分类与回归树）等等。这一类决策树的特点就是最后的结果都是离散的具体的类别，比如苹果的好/坏，性别男/女。</p>
<p><strong>2.回归树</strong></p>
<p>回归树与分类树的流程大致一样，不同的是回归树在每个节点都会有一个预测值，以年龄为例，该节点的预测值就是所有属于该节点的样本的年龄的均值。</p>
<p>那回归树是根据什么来划分特征的呢？</p>
<p>分类树的最大熵、信息增益、增益率在回归树这都不适用了，回归树用的是<strong>均方误差</strong>。遍<strong>历每个特征，穷举每个特征的划分阈值</strong>，而这里不再使用最大熵，使用的是最小化均方差——(每个人的年龄-预测年龄)^2/N，N 代表节点内样本数。这很好理解，和预测年龄差距越大，均方差也就越大。因此要<strong>找到均方差最小的阈值作为划分点</strong>。</p>
<p>划分的结束条件一般有两个：第一是划分到每一个节点都只包含一个年龄值，但是这太难了；第二就是划分到一定的深度就停止，取节点内数据的<strong>均值</strong>作为最终的预测值。</p>
<hr>
<h2 id="篇一：决策树-（ID3-C4-5-CART）"><a href="#篇一：决策树-（ID3-C4-5-CART）" class="headerlink" title="篇一：决策树 （ID3, C4.5, CART）"></a>篇一：决策树 （ID3, C4.5, CART）</h2><blockquote>
<p>本部分内容参考<br>公众号Datawhale <a href="https://mp.weixin.qq.com/s/jj3BtmnWRAwCS56ZU3ZXZA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/jj3BtmnWRAwCS56ZU3ZXZA</a><br>以及《统计学习方法》和西瓜书</p>
</blockquote>
<h3 id="1-ID3"><a href="#1-ID3" class="headerlink" title="1. ID3"></a>1. ID3</h3><p>ID3 算法是建立在奥卡姆剃刀（用较少的东西，同样可以做好事情）的基础上：越是小型的决策树越优于大的决策树。</p>
<blockquote>
<p>Occam’s Razor: Given two models of similar generalization errors,  one should prefer the simpler model over the more complex model. For complex models, there is a greater chance that it was fitted accidentally by errors in data.<br>来自 <a href="https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf" target="_blank" rel="noopener">https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf</a></p>
</blockquote>
<h4 id="1-1-思想"><a href="#1-1-思想" class="headerlink" title="1.1 思想"></a>1.1 思想</h4><p>从信息论的知识中我们知道：期望信息越小，信息熵越大，从而样本纯度越低。ID3 算法的核心思想就是以信息增益来度量特征选择，<strong>选择<span style="color:red">信息增益</span>最大的特征进行分裂</strong>。算法采用自顶向下的贪婪搜索遍历可能的决策树空间（C4.5 也是贪婪搜索 ).</p>
<p>其大致步骤为：</p>
<ol>
<li>初始化特征集合和数据集合；</li>
<li>计算数据集合信息熵和所有特征的条件熵，选择信息增益最大的特征作为当前决策节点；</li>
<li>更新数据集合和特征集合（删除上一步使用的特征，并按照特征值来划分不同分支的数据集合）；</li>
<li>重复 2，3 两步，若子集值包含单一特征，则为分支叶子节点。</li>
</ol>
<p>更详细步骤见 <a href="#jump1.2.2">1.2.2 ID3算法</a>.</p>
<h4 id="1-2-划分标准"><a href="#1-2-划分标准" class="headerlink" title="1.2 划分标准"></a>1.2 划分标准</h4><p>ID3 使用的分类标准是信息增益，它表示得知特征 A 的信息而使得样本集合不确定性减少的程度。</p>
<p><strong>一般而言，信息增益越大，意味着使用特征 A 来划分所获得的“纯度提升“越大。</strong></p>
<p>最优划分属性 $a^*=argmax _{a ∈ A}\ Gain(D,a)$.</p>
<h5 id="1-2-1-信息增益"><a href="#1-2-1-信息增益" class="headerlink" title="1.2.1 信息增益"></a>1.2.1 信息增益</h5><blockquote>
<p>以下内容来自《统计学习方法》和《数学之美》</p>
</blockquote>
<p>在信息论与概率统计中，<strong><span id="jump_entropy">熵</span></strong>（entropy）是表示随机变量不确定性的度量，设 $X$ 是一个取有限个值的离散随机变量，其概率分布为</p>
<script type="math/tex; mode=display">
P(X=x_i)=p_i,i=1,2,...,n</script><p>则随机变量 $X$ 的熵定义为</p>
<script type="math/tex; mode=display">
H(X)=-\sum_{i=1}^n p_ilog p_i</script><p>若 $p_i=0$，则定义 $0log0=0$。通常对数以2为底或以e为底，这时熵的单位分别称作比特(bit)或纳特(nat)。由定义可知，熵只依赖于 $X$ 的分布，而与 $X$ 的取值无关，所以也可将 $X$ 的熵记作 $H(p)$，即</p>
<script type="math/tex; mode=display">
H(p)=-\sum_{i=1}^n p_ilog p_i</script><p><span style="color:red">熵越大，随机变量的不确定性就越大，要把它搞清楚，所需要的信息量也就越大。</span>从定义可验证</p>
<script type="math/tex; mode=display">
0 \leq H(p) \leq logn</script><p>当随机变量只取两个值，例如1，0时，即 $X$ 的分布为</p>
<script type="math/tex; mode=display">
P(X=1)=p, \ P(X=0)=1-p, \quad 0\leq p\leq 1</script><p>熵为</p>
<script type="math/tex; mode=display">
H(p)=-plog_2p-(1-p)log_2(1-p)</script><p>这时，熵 $H(p)$ 随概率 $p$ 变化的曲线如下图所示（单位为比特）</p>
<p><img src="/2020/07/25/决策树/1602345214652.png" alt="1602345214652"></p>
<p>当 $p=0$ 或 $p=1$ 时 $H(p)=0$，随机变量完全没有不确定性。当 $p=0.5$ 时，$H(p)=1$，熵取值最大，随机变量不确定性最大。</p>
<p>设有随机变量 $(X,Y)$，其联合概率分布为</p>
<script type="math/tex; mode=display">
P(X=x_i,Y=y_i)=p_{ij}，\quad i=1,2,...,n；j=1,2,...,m</script><p>条件熵 $H(Y|X)$ 表示在已知随机变量 $X$ 的条件下随机变量 $Y$ 的不确定性。随机变量 $X$ 给定条件下随机变量 $Y$ 的<strong><span id="jump_conditional_entropy">条件熵</span></strong>（conditional entropy）$H(Y|X)$，定义为 $X$ 给定条件下 $Y$ 的条件概率分布的熵对 $X$ 的数学期望</p>
<script type="math/tex; mode=display">
\begin{align*}
H(Y|X) &= -\sum_{x\in X,y\in Y}p(x,y)logp(x,y)\\
&=\sum_{i=1}^n p_iH(Y|X=x_i)
\end{align*}</script><p>这里，$p_i=P(X=x_i),\quad i=1,2,…,n.$</p>
<p>可以证明， $H(Y)\geq H(Y|X)$，也就是说多了 $X$ 的信息之后，关于 $Y$ 的不确定性下降了。在统计语言模型中，如果把 $X$ 看成前一个字，那么在数学上就证明了二元模型的不确定性小于一元模型。同理，可以定义有两个条件的条件熵</p>
<script type="math/tex; mode=display">
H(X|Y,Z)=-\sum_{x\in X,y\in Y,z\in Z}p(x,y,z)logp(x,y,z)</script><p>还可以证明， $H(X|Y)\geq H(X|Y,Z)$。也就是说，三元模型应该比二元好。</p>
<blockquote>
<p>上述的等号什么时候成立？等号成立说明增加了信息，不确定性却没有降低。如果我们获取的信息与要研究的事物毫无关系，等号就成立。</p>
</blockquote>
<p>当熵和条件熵中的概率由数据估计（特别时极大似然估计）得到时，所对应的熵与条件熵分别称为<strong>经验熵</strong>（empirical entropy）和<strong>经验条件熵</strong>（empirical conditional entropy）. 此时，如果有概率0，令0log0=0 .</p>
<p><strong><span id="jump_IG">信息增益</span>（information gain）表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度。</strong></p>
<blockquote>
<p><strong>定义（信息增益）</strong>  特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$ ，定义为集合 $D$ 的经验熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的经验条件熵 $H(D|A)$ 之差，即</p>
<script type="math/tex; mode=display">
g(D,A)=H(D)-H(D|A)</script></blockquote>
<p>一般地，熵 $H(Y)$ 与条件熵 $H(Y|X)$ 之差称为<strong><span id="jump_MI">互信息</span>（mutual information）</strong>. 决策树学习中的信息增益等价于训练数据集中类与特征的互信息。</p>
<p>决策树学习应用信息增益准则选择特征。给定训练数据集 $D$ 和特征 $A$，经验熵 $H(D)$ 表示对数据集 $D$ 进行分类的不确定性。而经验条件熵 $H(D|A)$ 表示在特征 $A$ 给定的条件下对数据集 $D$ 进行分类的不确定性。它们的差，即信息增益，就表示由于特征 $A$ 而使得对数据集 $D$ 的分类的不确定性减少的程度。显然，对于数据集 $D$ 而言，信息增益依赖于特征，不同的特征往往具有不同的信息增益。信息增益大的特征具有更强的分类能力。</p>
<p>根据信息增益准则的特征选择方法是：对训练数据集（或子集）$D$，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。</p>
<p>设训练数据集为 $D$，$|D|$ 表示其样本容量，即样本个数。设有 $K$ 个类 $C_k，k=1,2,…,K$，$|C_k|$ 为属于类$C_k$的样本个数，$\sum_{k=1}^K |C_k|=|D|.$ 设特征 $A$ 有 $n$ 个不同的取值 $\{a_1,a_2,…,a_n\}$，根据特征 $A$ 的取值将 $D$ 划分为 $n$ 个 $D_1,D_2,…,D_n，|D_i|$ 为 $D_i$ 的样本个数，$\sum_{i=1}^n|D_i|=|D|.$ 记子集 $D_i$ 中属于类 $C_k$ 的样本的集合 $D_{ik}$，即 $D_{ik}=D_i∩C_k, |D_{ik}|$ 为 $D_{ik}$ 的样本个数。于是信息增益的算法如下：</p>
<p><strong><span id="jump_algo1.1" style="color:blue">算法 1.1（信息增益的算法）</span></strong></p>
<p>输入：训练数据集 $D$ 和特征 $A$<br>输出：特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$</p>
<p> （1）计算数据集 $D$ 的经验熵 $H(D)$</p>
<script type="math/tex; mode=display">
H(D)=-\sum_{k=1}^K \frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}</script><p>（2）计算特征 $A$ 对数据集 $D$ 的经验条件熵 $H(D|A)$</p>
<script type="math/tex; mode=display">
H(D|A) = \sum_{i=1}^n \frac{|D_i|}{|D|}H(D_i)=- \sum_{i=1}^n \frac{|D_i|}{|D|} \sum_{k=1}^K \frac{|D_{ik}|}{|D_i|}log_2 \frac{|D_{ik}|}{|D_i|}</script><p>（3）计算信息增益</p>
<script type="math/tex; mode=display">
g(D,A)=H(D)-H(D|A)</script><h5 id="1-2-2-ID3算法"><a href="#1-2-2-ID3算法" class="headerlink" title="1.2.2 ID3算法"></a><span id="jump1.2.2">1.2.2 ID3算法</span></h5><blockquote>
<p>以下内容来自《统计学习方法》</p>
</blockquote>
<p>ID3算法的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。具体方法是：从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子结点；再对子结点递归地调用以上方法，构建决策树；直到所有特征的信息增益均很小或没有特征可以选择为止。最后得到一个决策树。ID3相当于用极大似然法进行概率模型的选择。</p>
<p><strong><span id="jump_algo1.2" style="color:blue">算法 1.2 （ID3算法）</span></strong></p>
<p>输入：训练数据集 $D$，特征集 $A$，阈值 $\varepsilon$<br>输出：决策树 $T$.</p>
<p>（1）若 $D$ 中所有实例属于同一类 $C_k$，则 $T$ 为单结点树，并将类 $C_k$ 作为该结点的类标记，返回 $T$<br>（2）若 $A=\varnothing$，则 $T$ 为单结点树，并将 $D$  中实例数最大的类 $C_k$ 作为该结点的类标记，返回 $T$<br>（3）否则，按算法1.1计算 $A$ 中各特征对 $D$ 的信息增益，选择信息增益最大的特征 $A_g$<br>（4）若 $A_g$ 的信息增益小于阈值 $\varepsilon$，则置  $ T$ 为单结点树，并将 $D$ 中实例数最大的类 $C_k$ 作为该结点的类标记，返回 $T$<br>（5）否则，对 $A_g$ 的每一可能值 $a_i$，依 $A_g=a_i$ 将 $D$ 分割为若干非空子集 $D_i$，将 $D_i$ 中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树 $T$，返回 $T$<br>（6）对第 $i$ 个子结点，以 $D_i$ 为训练集，以 $A-\{A_g\}$ 为特征集递归地调用步(1) ~ 步(5)，得到子树 $T_i$，返回 $T_i$.</p>
<p>例：对表5.1的训练数据集，利用ID3算法建立决策树</p>
<p><img src="/2020/07/25/决策树/1602388750606.png" alt="1602388750606"></p>
<p><img src="/2020/07/25/决策树/1602388794784.png" alt="1602388794784"></p>
<p><img src="/2020/07/25/决策树/1602388824685.png" alt="1602388824685"></p>
<h4 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h4><ul>
<li>ID3 没有剪枝策略，该算法生成的树容易过拟合；</li>
<li>信息增益准则对可取值数目较多的特征有所偏好，类似“编号”的特征其信息增益接近于 1（但实际上这并不是一个好的特征选择）；</li>
<li><span style="color:red">只能用于处理离散分布的特征</span>；</li>
<li>没有考虑缺失值。</li>
</ul>
<h3 id="2-C4-5"><a href="#2-C4-5" class="headerlink" title="2. C4.5"></a>2. C4.5</h3><p>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题。<br><strong>C4.5 算法最大的特点是克服了 ID3 对特征数目的偏重这一缺点</strong>，引入<strong><span style="color:red">信息增益率</span></strong>来作为分类标准。</p>
<h4 id="2-1-思想"><a href="#2-1-思想" class="headerlink" title="2.1 思想"></a>2.1 思想</h4><p><span id="jump_C4.5advantage">C4.5 相对于 ID3 的缺点对应有以下改进方式</span>：</p>
<ul>
<li><p>引入悲观剪枝策略进行后剪枝；</p>
</li>
<li><p>引入信息增益率作为划分标准；</p>
</li>
<li><p>将连续特征离散化，假设 n 个样本的连续特征 A 有 m 个取值，C4.5 将其排序并取相邻两样本值的平均数共 m-1 个划分点，分别计算以该划分点作为二元分类点时的信息增益，并选择信息增益最大的点作为该连续特征的二元离散分类点；（具体内容见 <a href="#jump2.4">2.4 连续值处理</a>）</p>
</li>
<li><p>对于缺失值的处理可以分为两个子问题：1. 在特征值缺失的情况下如何进行划分特征的选择？（即如何计算特征的信息增益率）2. 选定该划分特征，对于缺失该特征值的样本如何处理？（即到底把这个样本划分到哪个结点里）(具体内容见 <a href="#jump2.5">2.5 缺失值处理</a>)</p>
<ul>
<li><p>针对问题一，C4.5 的做法是：对于具有缺失值特征，用没有缺失的样本子集所占比重来折算；</p>
</li>
<li><p>针对问题二，C4.5 的做法是：将样本同时划分到所有子节点，不过要调整样本的权重值，其实也就是以不同概率划分到不同节点中。</p>
</li>
</ul>
</li>
</ul>
<h4 id="2-2-划分标准"><a href="#2-2-划分标准" class="headerlink" title="2.2 划分标准"></a>2.2 划分标准</h4><h5 id="2-2-1-信息增益率"><a href="#2-2-1-信息增益率" class="headerlink" title="2.2.1 信息增益率"></a><span id="jump_IGR">2.2.1 信息增益率</span></h5><p><img src="/2020/07/25/决策树/1595650023450.png" alt="1595650023450"></p>
<p>👆(intrinsic value)</p>
<p>$H_A(D)$表示训练数据集 $D$ 关于特征 $A$ 的值的熵，$n$ 是特征 $A$ 取值的个数。特征 $A$ 的可能取值数目越大（即n越大），则 $H_A(D)$ 的值通常会越大。</p>
<p>这里需要注意，信息增益率对可取值较少的特征有所偏好（分母越小，整体越大），因此 C4.5 并不是直接用增益率最大的特征进行划分，而是使用一个<em>启发式方法</em>：先从候选划分特征中找到信息增益高于平均值的特征，再从中选择增益率最高的。</p>
<h5 id="2-2-2-C4-5算法"><a href="#2-2-2-C4-5算法" class="headerlink" title="2.2.2 C4.5算法"></a>2.2.2 C4.5算法</h5><p><strong><span id="jump_algo2.1" style="color:blue">算法 2.1 （C4.5的生成算法）</span></strong></p>
<p>输入：训练数据集 $D$，特征集 $A$，阈值 $\varepsilon$<br>输出：决策树 $T$</p>
<p>（1）如果 $D$ 中所有实例属于同一类 $C_k$，则置 $T$ 为单结点树，并将 $C_k$作为该结点的类，返回 $T$<br>（2）如果 $A=\varnothing$，则直 $T$ 为单结点树，并将 $D$ 中实例数最大的类 $C_k$ 作为该结点的类，返回 $T$<br>（3）否则，计算 $A$ 中各特征对 $D$ 的信息增益率，选择信息增益率最大的特征 $A_g$<br>（4）若 $A_g$ 的信息增益率小于阈值 $\varepsilon$，则置  $ T$ 为单结点树，并将 $D$ 中实例数最大的类 $C_k$ 作为该结点的类标记，返回 $T$<br>（5）否则，对 $A_g$ 的每一可能值 $a_i$，依 $A_g=a_i$ 将 $D$ 分割为若干非空子集 $D_i$，将 $D_i$ 中实例数最大的类作为标记，构建子结点，由结点及其子结点构成树 $T$，返回 $T$<br>（6）对第 $i$ 个子结点，以 $D_i$ 为训练集，以 $A-\{A_g\}$ 为特征集递归地调用步(1) ~ 步(5)，得到子树 $T_i$，返回 $T_i$.</p>
<h4 id="2-3-剪枝策略"><a href="#2-3-剪枝策略" class="headerlink" title="2.3 剪枝策略"></a>2.3 剪枝策略</h4><p>为什么要剪枝：过拟合的树泛化能力表现非常差。</p>
<blockquote>
<p>以下内容来自西瓜书</p>
</blockquote>
<p>剪枝（pruning）是决策树学习算法对付过拟合的主要手段。在决策树学习中，为例尽可能正确分类训练样本，结点划分过程将不断重复，有时会造成决策树分支过多，这时就可能因训练样本学得“太好”了，以致于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。因此，可通过主动去掉一些分支来降低过拟合的风险。</p>
<p>剪枝的基本策略有<strong>“预剪枝”（pre-pruning）</strong>和<strong>“后剪枝”（post-pruning）</strong>.  预剪枝是指在决策树生成过程中，对每个结点在划分前先进行估计，若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。后剪枝则是先从训练集生成一棵完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</p>
<p>如何判断决策树泛化性能是否提升呢？可采用留出法，即预留一部分数据用作“验证集”以进行性能评估。</p>
<h5 id="2-3-1-预剪枝"><a href="#2-3-1-预剪枝" class="headerlink" title="2.3.1 预剪枝"></a>2.3.1 预剪枝</h5><p>在节点划分前来确定是否继续增长，及早停止增长的主要方法有：</p>
<ul>
<li>节点内数据样本低于某一阈值；</li>
<li>所有节点特征都已分裂；</li>
<li>节点划分前准确率比划分后准确率高。</li>
</ul>
<p>预剪枝不仅可以降低过拟合的风险而且还可以减少训练时间，但另一方面它是基于“贪心”策略，会带来欠拟合风险。</p>
<p><img src="/2020/07/25/决策树/1605848197047.png" alt="1605848197047"></p>
<p>(👆 <a href="https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf" target="_blank" rel="noopener">https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf</a>)</p>
<hr>
<blockquote>
<p>以下内容来自西瓜书</p>
</blockquote>
<p>例子：</p>
<p><img src="/2020/07/25/决策树/1602343114032.png" alt="1602343114032"></p>
<p>假定采用信息增益准则进行划分属性选择，则从表4.2的训练集将会生成一棵如图4.5所示的决策树。</p>
<p><img src="/2020/07/25/决策树/1602343198091.png" alt="1602343198091"></p>
<p>基于信息增益准则，我们会选取属性“脐部”来对训练集进行划分，并产生3个分支，如图4.6所示。然而，是否应该进行这个划分呢？预剪枝要对划分前后的泛化性能进行评估。</p>
<p><img src="/2020/07/25/决策树/1602342904256.png" alt="1602342904256"></p>
<p>在划分之前，所有样例集中在根结点。若不进行划分，该结点将被标记为叶结点，其类别标记为训练样例数最多的类别，假设我们将这个叶结点标记为“好瓜”（当样例最多的类不唯一时，可任选其中一类）.  用表4.2的验证集对这个单结点决策树进行评估，编号为{4,5,8}的样例被分类正确，另外4个样例分类错误，于是验证集的<strong>精度</strong>为 $\frac{3}{7}\times 100\%=42.9\%$.</p>
<p>在用属性“脐部”划分之后，图4.6中的结点②、③、④分别包含编号为 {1,2,3,14}, {6,7,15,17}, {10,16}的训练样例，因此这3个结点分别被标记为叶结点“好瓜”，“好瓜”，“坏瓜”。此时，验证集中编号为 {4,5,8,11,12}的样例被分类正确，验证集精度为 $\frac{5}{7}\times 100\%=71.4\% &gt; 42.9\%$. 于是，用“脐部”进行划分得以确定。</p>
<p>然后，决策树算法对结点②进行划分，基于信息增益准则将挑选出属性“色泽”。然而，在使用“色泽”划分后，编号为 {5} 的验证集样本分类结果会由正确转为错误，（其余样本分类结果不变）使得验证集精度下降为 57.1%. 于是，预剪枝策略将禁止结点②被划分。</p>
<p>对结点③，最优划分属性为“根蒂”，划分后验证集精度仍为71.4%. 这个划分不能提升验证集精度，于是，预剪枝策略禁止结点③被划分。</p>
<p>对结点④，其所含训练样例已属于同一类，不再进行划分。</p>
<p>于是，基于预剪枝策略从表4.2数据所生成的决策树如图4.6所示，其验证集精度为71.4%.</p>
<p>对比图4.6和图4.5可以看出，预剪枝使得决策树的很多分支都没有“展开”，这不仅降低了过拟合的风险，还显著减少了决策树的训练时间开销和测试时间开销。但另一方面，有些分支的当前划分虽不能提升泛化性能，甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致性能显著提高；预剪枝基于“贪心”本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。</p>
<h5 id="2-3-2-后剪枝"><a href="#2-3-2-后剪枝" class="headerlink" title="2.3.2 后剪枝"></a>2.3.2 后剪枝</h5><p>后剪枝是人们普遍关注的决策树剪枝策略，与预剪枝恰好相反，后剪枝的执行步骤是先构造完成完整的决策树，再通过某些条件遍历树进行剪枝，其主要思路是通过删除节点的分支并用叶节点替换，剪去完全成长的树的子树，这个节点所标识的类别通过大多数原则（majority class criterion）确定（既将一些子树删除而用叶子节点代替，这个叶节点所表示的类别用这棵子树中的大多数训练样本所属类别来进行标识）。</p>
<p><img src="/2020/07/25/决策树/1605848257068.png" alt="1605848257068"></p>
<p>(👆 <a href="https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf" target="_blank" rel="noopener">https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf</a>)</p>
<p>目前主要应用的后剪枝方法有四种：</p>
<ul>
<li>悲观错误剪枝（Pessimistic Error Pruning，PEP）</li>
<li>最小错误剪枝（Minimum Error Pruning，MEP）</li>
<li>代价复杂度剪枝（Cost-Complexity Pruning，CCP）</li>
<li>基于错误的剪枝（Error-Based Pruning，EBP），也叫错误率降低剪枝（Reduced Error Pruning, REP）</li>
</ul>
<p>(👆 来自 <a href="https://zhuanlan.zhihu.com/p/165647069" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/165647069</a>)</p>
<p><img src="/2020/07/25/决策树/1605860334434.png" alt="1605860334434"></p>
<blockquote>
<p>C4.5 采用的悲观错误剪枝，CART采用的代价复杂度剪枝</p>
</blockquote>
<h6 id="2-3-2-1-基于错误的剪枝"><a href="#2-3-2-1-基于错误的剪枝" class="headerlink" title="2.3.2.1 基于错误的剪枝"></a>2.3.2.1 基于错误的剪枝</h6><blockquote>
<p>参考  <a href="https://www.cnblogs.com/zhangchaoyang/articles/2842490.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangchaoyang/articles/2842490.html</a></p>
</blockquote>
<p>这个思路很直接，完全的决策树不是过度拟合么，我再搞一个测试数据集来纠正它。对于完全决策树中的每一个非叶子节点的子树，我们尝试着把它替换成一个叶子节点，该叶子节点的类别我们用子树所覆盖训练样本中存在最多的那个类来代替，这样就产生了一个简化决策树，然后比较这两个决策树在测试数据集中的表现，如果简化决策树在测试数据集中的错误比较少，并且该子树里面没有包含另外一个具有类似特性的子树（所谓类似的特性，指的就是把子树替换成叶子节点后，其测试数据集误判率降低的特性），那么该子树就可以替换成叶子节点。该算法以bottom-up的方式遍历所有的子树，直至没有任何子树可以替换使得测试数据集的表现得以改进时，算法就可以终止。</p>
<blockquote>
<p>以下内容来自西瓜书</p>
</blockquote>
<p>基于表4.2的数据得到如图4.5的决策树。易知，该决策树的验证集精度为 42.9%.<br>如下展示的后剪枝为基于错误的后剪枝(EBP)？</p>
<p><img src="/2020/07/25/决策树/1602344727944.png" alt="1602344727944"></p>
<p><img src="/2020/07/25/决策树/1602344969446.png" alt="1602344969446"></p>
<h6 id="2-3-2-2-悲观错误剪枝"><a href="#2-3-2-2-悲观错误剪枝" class="headerlink" title="2.3.2.2 悲观错误剪枝"></a>2.3.2.2 悲观错误剪枝</h6><blockquote>
<p>参考<br><a href="https://www.cnblogs.com/zhangchaoyang/articles/2842490.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangchaoyang/articles/2842490.html</a><br><a href="https://blog.csdn.net/weixin_41647586/article/details/89052754" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41647586/article/details/89052754</a><br><a href="https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf" target="_blank" rel="noopener">https://www.ismll.uni-hildesheim.de/lehre//////ml-08w/skript/decision_trees2.pdf</a></p>
</blockquote>
<p>基于错误的剪枝方法很直接，但是需要一个额外的测试数据集，能不能不要这个额外的数据集呢？为了解决这个问题，于是就提出了悲观剪枝。该方法和基于错误的剪枝思路是一致的，不同之处在于如何估计泛化误差。</p>
<p>把一颗子树（具有多个叶子节点）的分类用一个叶子节点来替代的话，在训练集上的误判率肯定是上升的（这是显然的，同样的样本子集，如果用子树分类可以分成多个类，而用单颗叶子节点来分的话只能分成一个类，多个类肯定要准确一些），但是在新数据上不一定。于是我们需要对子树的误判数加上一个经验性的惩罚因子。对于一颗叶子节点，假设它覆盖了N个样本，其中有E个错误，那么该叶子节点的错误率为（E+0.5）/N。这个0.5就是惩罚因子。那么一颗子树，它有L个叶子节点，那么该子树的误判率估计为 $\frac{\sum_{i=1}^L E_i+0.5*L}{\sum_{i=1}^L N_i}$。剪枝后内部节点变成了叶子节点，其误判个数 J 也需要加上一个惩罚因子，变成 J+0.5。</p>
<p><img src="/2020/07/25/决策树/1605847883769.png" alt="1605847883769"></p>
<blockquote>
<p>一句话概括，基于错误的剪枝利用额外的测试集去估计泛化误差，悲观剪枝直接利用训练集估计泛化误差</p>
</blockquote>
<p>子树是否可以被剪枝取决于剪枝后的错误 J+0.5 是否在 $\sum_{i=1}^L E_i+0.5*L$ 的标准差内。对于样本的误差率 e，我们可以根据经验把它估计成各种各样的分布模型，比如是二项式分布、正态分布。</p>
<p>那么一棵树错误分类一个样本值为1，正确分类一个样本值为0，该树错误分类的概率（误判率）为e（e为分布的固有属性,可以通过 $\frac{\sum_{i=1}^L E_i+0.5*L}{\sum_{i=1}^L N_i}$ 统计出来），那么树的误判次数就是伯努利分布，我们可以估计出该树的误判次数均值和标准差：</p>
<script type="math/tex; mode=display">
E(subtree\_err\_count)=N∗e\\

std(subtree\_err\_count)=N∗e∗(1−e)</script><p>把子树替换成叶子节点后，该叶子的误判次数也是一个伯努利分布，其概率误判率e为(E+0.5)/N，因此叶子节点的误判次数均值为 </p>
<script type="math/tex; mode=display">
E(leaf\_err\_count)=N∗e</script><p>这里我们采用一种保守的分裂方案，即有足够大的置信度保证分裂后准确率比不分裂时的准确率高时才分裂，否则就不分裂，也就是应该剪枝。如果要分裂（即不剪枝），至少要保证分裂后的误判数E(subtree_err_count)要小于不分裂的误判数E(leaf_err_count)，而且为了保证足够高的置信度，这里甚至要是</p>
<script type="math/tex; mode=display">
E(subtree\_err\_count)+std(subtree\_err\_count)<E(leaf\_err\_count)</script><p>这里加了一个标准差可以有95%的置信度。</p>
<p>反之就是不分裂，即剪枝的条件：</p>
<script type="math/tex; mode=display">
E(subtree\_err\_count)+std(subtree\_err\_count)>E(leaf\_err\_count)</script><p><span style="color:red">（此处公式存疑，看到许多不同的说法）</span></p>
<p>例：<br><img src="/2020/07/25/决策树/1605857635104.png" alt="1605857635104"></p>
<p>T4这棵子树的误差率：（即分裂后的误差率）</p>
<script type="math/tex; mode=display">
\frac{(2+3)+0.5∗3}{16}=0.40625</script><p>子树误差率的标准差：</p>
<script type="math/tex; mode=display">
\sqrt{16*0.40625*(1-0.40625)}=1.96</script><p>子树替换为一个叶节点后，其误差率为：（即分裂前的误差率）</p>
<script type="math/tex; mode=display">
\frac{7+0.5}{16}=0.46875</script><p>因为 $16∗0.40625+1.96=8.46&gt;16∗0.46875=7.5$，所以应该把T4的所有子节点全部剪掉，T4变成一个叶子节点。</p>
<hr>
<p><strong>C4.5 采用悲观剪枝方法</strong>，用递归的方式从底往上针对每一个非叶子节点，评估用一个最佳叶子节点去代替这课子树是否有益。如果剪枝后与剪枝前相比其错误率是保持或者下降，则这棵子树就可以被替换掉。C4.5 通过训练数据集上的错误分类数量来估算未知样本上的错误率。</p>
<p>后剪枝决策树的欠拟合风险很小，泛化性能往往优于预剪枝决策树。但同时其训练时间会大的多。</p>
<h4 id="2-4-连续值处理"><a href="#2-4-连续值处理" class="headerlink" title=" 2.4 连续值处理"></a><span id="jump2.4"> 2.4 连续值处理</span></h4><blockquote>
<p>以下内容来自西瓜书</p>
</blockquote>
<p>到目前为止我们仅讨论了基于离散属性来生成决策树。现实学习任务中常会遇到连续属性，有必要讨论如何在决策树学习中使用连续属性。</p>
<p>由于连续属性的可取值数目不再有限，因此不能直接根据连续属性的可取值来对结点进行划分。此时，<strong>连续属性离散化</strong>技术可派上用场。最简单的策略是采用<strong>二分法</strong>（bi-partition）对连续属性进行处理，这正是C4.5决策树算法中采用的机制。</p>
<p>给定样本集 $D$ 和连续属性 $a$，假定 $a$ 在 $D$ 上出现了 <span style="color:blue">$n$</span> 个不同的取值，将这些值从小到大进行排序，记为 $\{a^1,a^2,…,a^n \}$.  基于划分点 $t$ 可将 $D$ 分为子集 $D_t^-$ 和 $D_t^+$，其中 $D_t^-$ 包含那些在属性 $a$ 上取值不大于 $t$ 的样本，而 $D_t^+$ 则包含那些在属性 $a$ 上取值大于 $t$ 的样本。显然，对相邻的属性取值 $a^i$与 $a^{i+1}$ 来说，$t$ 在区间 $[a^i,a^{i+1})$ 中取任意值所产生的划分结果相同。因此，对连续属性 $a$，我们可考察包含 <span style="color:blue">$n-1$</span> 个元素的候选划分点集合</p>
<script type="math/tex; mode=display">
T_a=\{\frac{a^i+a^{i+1}}{2}|1\leq i \leq n-1 \}.</script><p>即把区间 $[a^i,a^{i+1})$ 的中位点 $\frac{a^i+a^{i+1}}{2}$作为候选划分点。</p>
<blockquote>
<p>可将划分点设为该属性在训练集中出现的不大于中位点的最大值，从而使得最终决策树使用的划分点都在训练集中出现过</p>
</blockquote>
<p>然后就可以像离散属性值一样来考察这些划分点，选取最优的划分点进行样本集合的划分。例如：</p>
<script type="math/tex; mode=display">
Gain(D,a)=max_{t∈T_a} Gain(D,a,t)=max_{t∈T_a} Ent(D) - 
\sum_{\lambda∈\{-,+\}} \frac{|D_t^\lambda|}{|D|}Ent(D_t^\lambda)</script><p>其中 $Gain(D,a,t)$ 是样本集 $D$ 基于划分点 $t$ 二分后的信息增益。于是，我们就可选择使 $Gain(D,a,t)$ 最大化的划分点。</p>
<p>例：</p>
<p><img src="/2020/07/25/决策树/1602392020465.png" alt="1602392020465"></p>
<p><img src="/2020/07/25/决策树/1602392050284.png" alt="1602392050284"></p>
<p><img src="/2020/07/25/决策树/1605845780129.png" alt="1605845780129"></p>
<p>(👆 来自 <a href="https://www.cnblogs.com/zhangchaoyang/articles/2842490.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangchaoyang/articles/2842490.html</a>)</p>
<h4 id="2-5-缺失值处理"><a href="#2-5-缺失值处理" class="headerlink" title="2.5 缺失值处理"></a><span id="jump2.5">2.5 缺失值处理</span></h4><blockquote>
<p>以下内容来自西瓜书</p>
</blockquote>
<p>现实任务中常会遇到不完整样本，即样本的某些属性值缺失。若简单地放弃不完整样本，仅使用无缺失值的样本来进行学习，显然是对数据信息极大的浪费。例如，表4.4中，若放弃不完整样本，则仅有编号 {4,7,14,16} 的4个样本能被使用。显然，有必要考虑利用缺失属性值的训练样例来进行学习。</p>
<p>我们需解决两个问题：</p>
<p>（1）如何在属性值缺失的情况下进行划分属性选择？<br>（2）给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分？</p>
<p>给定训练集 $D$ 和属性 $a$，令 $\tilde D$ 表示 $D$ 中在属性 $a$ 上没有缺失值的样本子集。对问题（1），显然我们仅可根据 $\tilde D$ 来判断属性 $a$ 的优劣．假定属性 $a$ 有 $V$ 个可取值 $\{ a^1,a^2,…,a^V\}$，令 $\tilde D^v$ 表示 $\tilde D$ 中在属性 $a$上取值为 $a^v$ 的样本子集，$\tilde D_k$ 表示 $\tilde D$ 中属于第 $k$ 类 ($k=1,2,…,K$)，则显然有 $\tilde D = \cup _{k=1}^K \tilde D_k, \tilde D = \cup _{v=1}^V \tilde D^v$.  假定我们为每个样本 $x$ 赋予一个权重 $w_x$（在决树学习开始阶段，根结点中各样本的权重初始化为1），并定义</p>
<script type="math/tex; mode=display">
\begin{align*}
\rho &= \frac{\sum_{x\in \tilde D} w_x}{\sum_{x \in D}w_x},\\
\tilde p_k &= \frac{\sum_{x\in \tilde D_k} w_x}{\sum_{x\in \tilde D} w_x} \quad (1\leq k \leq K),\\
\tilde r_v &=\frac{\sum_{x\in \tilde D^v} w_x}{\sum_{x\in \tilde D} w_x} \quad (1\leq v \leq V).
\end{align*}</script><p>直观地看，对属性 $a$，$\rho$ 表示无缺失值样本所占的比例，$\tilde p_k$表示无缺失值样本中第 $k$ 类所占的比例，$\tilde r_v$ 则表示无缺失值样本中在属性 $a$ 上取值 $a^v$ 的样本所占的比例。显然 $\sum_{k=1}^K\tilde p_k=1, \sum_{v=1}^V\tilde r_v=1.$ </p>
<p><img src="/2020/07/25/决策树/1602422558525.png" alt="1602422558525"></p>
<p>C4.5算法使用了上述解决方案。下面以表4.4的数据集为例来生成一棵决策树。</p>
<p><img src="/2020/07/25/决策树/1602422851775.png" alt="1602422851775"></p>
<p><img src="/2020/07/25/决策树/1602422915383.png" alt="1602422915383"></p>
<p><img src="/2020/07/25/决策树/1602422970229.png" alt="1602422970229"></p>
<p><img src="/2020/07/25/决策树/1602423017458.png" alt="1602423017458"></p>
<h4 id="2-6-缺点"><a href="#2-6-缺点" class="headerlink" title="2.6 缺点"></a>2.6 缺点</h4><ul>
<li>剪枝策略可以再优化；</li>
<li>C4.5 用的是多叉树，用二叉树效率更高；</li>
<li><span style="color:red">C4.5 只能用于分类</span>；</li>
<li>C4.5 使用的熵模型拥有大量耗时的对数运算，连续值还有排序运算；</li>
<li>C4.5 在构造树的过程中，对数值属性值需要按照其大小进行排序，从中选择一个分割点，所以只适合于能够驻留于内存的数据集，当训练集大得无法在内存容纳时，程序无法运行。</li>
</ul>
<h3 id="3-CART"><a href="#3-CART" class="headerlink" title="3. CART"></a>3. CART</h3><p>ID3 和 C4.5 虽然在对训练样本集的学习中可以尽可能多地挖掘信息，但是其生成的决策树分支、规模都比较大，CART 算法的二分法可以简化决策树的规模，提高生成决策树的效率。</p>
<h4 id="3-1-思想"><a href="#3-1-思想" class="headerlink" title="3.1 思想"></a>3.1 思想</h4><p>CART 是在给定输入随机变量 $X$ 条件下输出随机变量 $Y$ 的条件概率分布的学习方法。CART 假设决策树是二叉树，内部结点特征的取值为 ”是“ 和 ”否“，左分支是取值为”是“的分支，右分支是取值为”否“的分支。这样的决策树等价于递归地二分每个特征，将输入空间即特征空间划分为有限个单元，并在这些单元上确定预测的概率分布，也就是在输入给定的条件下输出的条件概率分布。（《统计学习方法》）</p>
<p>CART 包含的基本过程有分裂，剪枝和树选择。</p>
<ul>
<li><strong>分裂</strong>：分裂过程是一个二叉递归划分过程，其输入和预测特征既可以是连续型的也可以是离散型的，CART 没有停止准则，会一直生长下去；</li>
<li><strong>剪枝</strong>：<strong>采用<em>代价复杂度剪枝</em></strong>，从最大树开始，每次选择训练数据熵对整体性能贡献最小的那个分裂节点作为下一个剪枝对象，直到只剩下根节点。CART 会产生一系列嵌套的剪枝树，需要从中选出一颗最优的决策树；</li>
<li><strong>树选择</strong>：用单独的测试集评估每棵剪枝树的预测性能（也可以用交叉验证）。</li>
</ul>
<p><span id="jump_CARTadvantage">CART 在 C4.5 的基础上进行了很多提升。</span></p>
<ul>
<li>C4.5 为多叉树，运算速度慢，CART 为二叉树，运算速度快；</li>
<li>C4.5 只能分类，<span style="color:red">CART 既可以分类也可以回归</span>；</li>
<li>CART 使用 <strong><span style="color:red">Gini 系数</span></strong> 作为变量的不纯度量，减少了大量的对数运算；</li>
<li>CART 采用代理测试来估计缺失值，而 C4.5 以不同概率划分到不同节点中；</li>
<li>CART 采用“基于代价复杂度剪枝”方法进行剪枝，而 C4.5 采用悲观剪枝方法。</li>
</ul>
<h4 id="3-2-划分标准"><a href="#3-2-划分标准" class="headerlink" title="3.2 划分标准"></a>3.2 划分标准</h4><p>最优划分属性 $a^*=argmin_{a∈A}Gini$_$index (D,a)$.</p>
<p>对回归树用平方误差最小化准则，对分类树用基尼指数（Gini index）最小化准则，进行特征选择，生成二叉树。关于回归树，见后面 <a href="#jump3.6">3.6 回归树</a>.</p>
<p>熵模型拥有大量耗时的对数运算，基尼指数在简化模型的同时还保留了熵模型的优点。<strong><span id="jump_Gini">基尼指数代表了模型的不纯度，基尼系数越小，不纯度越低，特征越好。这和信息增益（率）正好相反。</span></strong></p>
<hr>
<h5 id="3-2-1-基尼指数"><a href="#3-2-1-基尼指数" class="headerlink" title="3.2.1 基尼指数"></a>3.2.1 基尼指数</h5><blockquote>
<p>以下内容来自《统计学习方法》</p>
</blockquote>
<p>分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。</p>
<blockquote>
<p><strong>定义 （基尼指数）</strong> 分类问题中，假设有 $K$ 个类，样本点属于第 $k$ 类的概率为 $p_k$，则概率分布的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(p)=\sum_{k=1}^K p_k(1-p_k)=1-\sum_{k=1}^K p_k^2</script><p>对于二分类问题，若样本点属于第1个类的概率是 $p$，则概率分布的基尼指数为</p>
<script type="math/tex; mode=display">
Gini(p)=2p(1-p)</script></blockquote>
<p>对于给定的样本集合 $D$，其基尼指数为</p>
<script type="math/tex; mode=display">
Gini(D)=1-\sum_{k=1}^K (\frac{|C_k|}{|D|})^2</script><p>这里， $C_k$ 是 $D$ 中属于第 $k$ 类的样本子集，$K$ 是类的个数。</p>
<p>直观来说，$Gini(D)$ 反映了从数据集 $D$ 中随机抽取两个样本，其类别标记不一致的概率。因此 $Gini(D)$ 越小，则数据集 $D$ 的纯度越高。</p>
<p>如果样本集合 $D$ 根据特征 $A$ 是否取某一可能值 $a$ 被分割成 $D_1$ 和 $D_2$ 两部分，即</p>
<script type="math/tex; mode=display">
D_1=\{(x,y)∈D|A(x)=a\},\quad D_2=D-D_1</script><p>则在特征 $A$ 的条件下，集合 $D$ 的基尼指数定义为</p>
<script type="math/tex; mode=display">
Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)</script><p>基尼指数 $Gini(D)$ 表示集合 $D$ 的不确定性（不纯度），基尼指数 $Gini(D,A)$ 表示经 $A=a$ 分割后集合 $D$ 的不确定性。<span style="color:red">基尼指数越大，样本集合的不确定性也就越大，这一点与熵相似。</span></p>
<p> <img src="/2020/07/25/决策树/1602387260925.png" alt="1602387260925"></p>
<h5 id="3-2-2-CART算法"><a href="#3-2-2-CART算法" class="headerlink" title="3.2.2 CART算法"></a>3.2.2 CART算法</h5><p><strong><span id="jump_algo3.1" style="color:blue"> 算法3.1（CART生成算法）</span></strong></p>
<p>输入：训练数据集 $D$，停止计算的条件<br>输出：CART决策树</p>
<p>根据训练数据集，从根结点开始，递归地对每个结点进行以下操作，构建二叉决策树<br>（1）设结点的训练数据集为 $D$，计算现有特征对该数据集的基尼指数。此时，对每一个特征 $A$，对其可能取值的每个值 $a$，根据样本点对 $A=a$ 的测试为”是“或”否“将 $D$ 分割成 $D_1$ 和 $D_2$ 两部分，计算 $A=a$ 时的基尼指数<br>（2）在所有可能的特征 $A$ 以及它们所有可能的切分点 $a$ 中，选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去<br>（3）对两个子结点递归地调用(1), (2)，直至满足停止条件<br>（4）生成CART决策树<br>算法停止计算的条件是结点中的样本个数小于预定阈值，或样本的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。</p>
<p>例：根据表5.1所给训练数据集，应用CART算法生成决策树。（表5.1见<a href="#jump1.2.2">1.2.2 ID3算法</a>）</p>
<p><img src="/2020/07/25/决策树/1602388389187.png" alt="1602388389187"></p>
<hr>
<p>基尼指数偏向于特征值较多的特征，类似信息增益。基尼指数可以用来度量任何不均匀分布，是介于0~1之间的数，0是完全相等，1是完全不相等。</p>
<h4 id="3-3-缺失值处理"><a href="#3-3-缺失值处理" class="headerlink" title="3.3 缺失值处理"></a>3.3 缺失值处理</h4><p>上文说到，模型对于缺失值的处理会分为两个子问题：</p>
<p>1.在特征值缺失的情况下进行划分特征的选择？<br>2.选定该划分特征，对于缺失该特征值的样本如何处理？</p>
<p>对于问题 1，CART 一开始严格要求分裂特征评估时只能使用在该特征上没有缺失值的那部分数据，在后续版本中，CART 算法使用了一种惩罚机制来抑制提升值，从而反映出缺失值的影响（例如，如果一个特征在节点的 20% 的记录是缺失的，那么这个特征就会减少 20% 或者其他数值）。</p>
<p>对于问题 2，CART 算法的机制是为树的每个节点都找到代理分裂器，无论在训练数据上得到的树是否有缺失值都会这样做。在代理分裂器中，特征的分值必须超过默认规则的性能才有资格作为代理（即代理就是代替缺失值特征作为划分特征的特征），当 CART 树中遇到缺失值时，这个实例划分到左边还是右边是决定于其排名最高的代理，如果这个代理的值也缺失了，那么就使用排名第二的代理，以此类推，如果所有代理值都缺失，那么默认规则就是把样本划分到较大的那个子节点。代理分裂器可以确保无缺失训练数据上得到的树可以用来处理包含确实值的新数据。</p>
<h4 id="3-4-剪枝策略"><a href="#3-4-剪枝策略" class="headerlink" title="3.4 剪枝策略"></a>3.4 剪枝策略</h4><p>采用一种“基于代价复杂度的剪枝”方法进行后剪枝，这种方法会生成一系列树，每个树都是通过将前面的树的某个或某些子树替换成一个叶节点而得到的，这一系列树中的最后一棵树仅含一个用来预测类别的叶节点。然后用一种成本复杂度的度量准则来判断哪棵子树应该被一个预测类别值的叶节点所代替。这种方法需要使用一个单独的测试数据集来评估所有的树，根据它们在测试数据集熵的分类性能选出最佳的树。</p>
<p>我们来看具体看一下代价复杂度剪枝算法：</p>
<p><img src="/2020/07/25/决策树/1595650752017.png" alt="1595650752017"></p>
<p><img src="/2020/07/25/决策树/1595650778439.png" alt="1595650778439"></p>
<hr>
<blockquote>
<p>以下内容来自《统计学习方法》</p>
</blockquote>
<p>CART 剪枝算法从”完全生长“的决策树的底端剪去一些子树，使决策树变小（模型变简单）。CART 剪枝算法由两步组成：<span style="color:blue">首先从生成算法产生的决策树 $T_0$ 底端开始不断剪枝，直到 $T_0$ 的根结点，形成一个子树序列 $\{ T_0,T_1, …,T_n\}$；然后通过交叉验证法在独立的验证数据集上对字数序列进行测试，从中选择最优子树。</span></p>
<p>1.剪枝，形成一个子树序列</p>
<p><img src="/2020/07/25/决策树/1602424688613.png" alt="1602424688613"></p>
<p><img src="/2020/07/25/决策树/1602424717026.png" alt="1602424717026"></p>
<p>2.在剪枝得到的字数序列 $ T_0,T_1, …,T_n$ 中通过交叉验证选取最优子树 $T_\alpha$</p>
<p><img src="/2020/07/25/决策树/1602424810650.png" alt="1602424810650"></p>
<p><strong><span id="jump_algo3.2" style="color:blue">算法3.2 （CART剪枝算法）</span></strong></p>
<p>输入：CART 算法生成的决策树 $T_0$<br>输出：最优决策树 $T_\alpha$</p>
<p>（1）设 $k=0，T=T_0$<br>（2）设 $\alpha=+\infty$<br>（3）自下而上地对各内部结点 $t$ 计算 $C(T_t)，|T_t|$以及</p>
<script type="math/tex; mode=display">
g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}\\
\alpha=min(\alpha,g(t))</script><p>这里，$T_t$ 表示以 $t$ 为根结点的子树，$C(T_t)$ 是对训练数据的预测误差，$|T_t|$ 是 $T_t$ 的叶结点个数。<br>（4）对 $g(t)=\alpha$ 的内部结点 $t$ 进行剪枝，并对叶结点 $t$ 以多数表决法决定其类，得到树 $T$<br>（5）设 $k=k+1，\alpha_k=\alpha，T_k=T$.<br>（6）如果 $T_k$ 不是由根结点及两个叶结点构成的树，则回到不再(3)；否则令 $T_k=T_n$<br>（7）采用交叉验证法在子树序列 $ T_0,T_1, …,T_n$ 中选取最优子树 $T_\alpha$.</p>
<h4 id="3-5-类别不平衡"><a href="#3-5-类别不平衡" class="headerlink" title="3.5 类别不平衡"></a>3.5 类别不平衡</h4><p>CART 的一大优势在于：无论训练数据集有多失衡，它都可以将其自动消除不需要建模人员采取其他操作。</p>
<p>CART 使用了一种先验机制，其作用相当于对类别进行加权。这种先验机制嵌入于 CART 算法判断分裂优劣的运算里，在 CART 默认的分类模式中，总是要计算每个节点关于根节点的类别频率的比值，这就相当于对数据自动重加权，对类别进行均衡。</p>
<p><img src="/2020/07/25/决策树/1595650963697.png" alt="1595650963697"></p>
<p>通过这种计算方式就无需管理数据真实的类别分布。假设有 K 个目标类别，就可以确保根节点中每个类别的概率都是 1/K。这种默认的模式被称为“先验相等”。</p>
<p>先验设置和加权不同之处在于先验不影响每个节点中的各类别样本的数量或者份额。先验影响的是每个节点的类别赋值和树生长过程中分裂的选择。</p>
<h4 id="3-6-回归树"><a href="#3-6-回归树" class="headerlink" title="3.6 回归树"></a><span id="jump3.6">3.6 回归树</span></h4><p>CART(Classification and Regression Tree，分类回归树)，从名字就可以看出其不仅可以用于分类，也可以应用于回归。其回归树的建立算法上与分类树部分相似，这里简单介绍下不同之处。</p>
<h5 id="3-6-1-连续值处理"><a href="#3-6-1-连续值处理" class="headerlink" title="3.6.1 连续值处理"></a>3.6.1 连续值处理</h5><p>对于连续值的处理，CART 分类树采用基尼系数的大小来度量特征的各个划分点。在回归模型中，我们使用常见的和方差度量方式，对于任意划分特征 $A$，对应的任意划分点 $s$ 两边划分成的数据集$D_1$和 $D_2$，求出使$D_1$和$D_2$ 各自集合的均方差最小，同时$D_1$和$D_2$ 的均方差之和最小所对应的特征和特征值划分点。表达式为：</p>
<p><img src="/2020/07/25/决策树/1595651148743.png" alt="1595651148743"></p>
<p>其中，$c_1$表示 $D_1$ 的输出值，$c_2$表示 $D_2$ 的输出值。$D_1$上的最优值输出值 $\hat c_1$ 是 $D_1$ 数据集的样本输出均值，即 $\hat c_1 = ave(y_i|x_i\in D_1)$，同理，$\hat c_2 = ave(y_i|x_i\in D_2)$.</p>
<h5 id="3-6-2-预测方式"><a href="#3-6-2-预测方式" class="headerlink" title="3.6.2 预测方式"></a>3.6.2 预测方式</h5><p>对于决策树建立后做预测的方式，上面讲到了 CART 分类树采用叶子节点里概率最大的类别作为当前节点的预测类别。而回归树输出不是类别，它采用的是用最终叶子的均值或者中位数来预测输出结果。</p>
<h5 id="3-6-3-回归树的生成"><a href="#3-6-3-回归树的生成" class="headerlink" title="3.6.3 回归树的生成"></a>3.6.3 回归树的生成</h5><blockquote>
<p>以下内容来自《统计学习方法》</p>
</blockquote>
<p><img src="/2020/07/25/决策树/1602423716567.png" alt="1602423716567"></p>
<p><img src="/2020/07/25/决策树/1602423679709.png" alt="1602423679709"></p>
<p><strong><span id="jump_algo3.3" style="color:blue">算法3.3 （最小二乘回归树生成算法）</span></strong></p>
<p><img src="/2020/07/25/决策树/1602423808005.png" alt="1602423808005"></p>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h3><p>最后通过总结的方式对比下 ID3、C4.5 和 CART 三者之间的差异。</p>
<ul>
<li><strong>划分标准的差异</strong>：ID3 使用信息增益，偏向特征值多的特征，C4.5 使用信息增益率克服信息增益的缺点，偏向于可取值较少的特征，CART 使用基尼指数克服 C4.5 需要求 log 的巨大计算量，偏向于特征值较多的特征。</li>
<li><strong>使用场景的差异</strong>：ID3 和 C4.5 都只能用于分类问题，CART 可以用于分类和回归问题；ID3 和 C4.5 是多叉树，速度较慢，CART 是二叉树，计算速度很快；</li>
<li><strong>样本数据的差异</strong>：ID3 只能处理离散数据且对缺失值敏感，C4.5 和 CART 可以处理连续型数据且有多种方式处理缺失值；从样本量考虑的话，小样本建议 C4.5，大样本建议 CART。C4.5 处理过程中需对数据集进行多次扫描排序，处理成本耗时较高，而 CART 本身是一种大样本的统计方法，小样本处理下泛化误差较大 ；</li>
<li><strong>样本特征的差异</strong>：ID3 和 C4.5 层级之间只使用一次特征，CART 可多次重复使用特征；</li>
<li><strong>剪枝策略的差异</strong>：ID3 没有剪枝策略，C4.5 是通过悲观剪枝策略来修正树的准确性（后剪枝），而 CART 是通过代价复杂度剪枝（后剪枝）。</li>
</ul>
<hr>
<p><img src="/2020/07/25/决策树/1595649034648.png" alt="1595649034648"></p>
<p><img src="/2020/07/25/决策树/1595649090585.png" alt="1595649090585"></p>
<p><img src="/2020/07/25/决策树/1595649112772.png" alt="1595649112772"></p>
<p><img src="/2020/07/25/决策树/1595649135709.png" alt="1595649135709"></p>
<p>信息增益，信息增益率 -&gt; 选最大</p>
<p>基尼系数 -&gt; 选最小</p>
<hr>
<h2 id="篇二：Random-Forest-Adaboost-GBDT算法"><a href="#篇二：Random-Forest-Adaboost-GBDT算法" class="headerlink" title="篇二：Random Forest, Adaboost, GBDT算法"></a>篇二：Random Forest, Adaboost, GBDT算法</h2><blockquote>
<p>本部分内容主要参考公众号Datawhale<br><a href="https://mp.weixin.qq.com/s/Nl_-PdF0nHBq8yGp6AdI-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nl_-PdF0nHBq8yGp6AdI-Q</a></p>
</blockquote>
<p>主要介绍基于集成学习的决策树，其主要通过不同学习框架生产基学习器（base learners），并综合所有基学习器的预测结果来改善单个基学习器的识别率和泛化性。</p>
<h3 id="1-集成学习"><a href="#1-集成学习" class="headerlink" title="1.集成学习"></a>1.集成学习</h3><p>常见的集成学习框架有三种：Bagging，Boosting 和 Stacking。</p>
<blockquote>
<ul>
<li><p>In <strong>averaging methods</strong>, the driving principle is to build several estimators independently and then to average their predictions. On average, the combined estimator is usually better than any of the single base estimator because its variance is reduced.</p>
<p><strong>Examples:</strong> <a href="https://scikit-learn.org/stable/modules/ensemble.html#bagging" target="_blank" rel="noopener">Bagging methods</a>, <a href="https://scikit-learn.org/stable/modules/ensemble.html#forest" target="_blank" rel="noopener">Forests of randomized trees</a>, …</p>
</li>
<li><p>By contrast, in <strong>boosting methods</strong>, base estimators are built sequentially and one tries to reduce the bias of the combined estimator. The motivation is to combine several weak models to produce a powerful ensemble.</p>
<p><strong>Examples:</strong> <a href="https://scikit-learn.org/stable/modules/ensemble.html#adaboost" target="_blank" rel="noopener">AdaBoost</a>, <a href="https://scikit-learn.org/stable/modules/ensemble.html#gradient-boosting" target="_blank" rel="noopener">Gradient Tree Boosting</a>, …</p>
<p>(来自 <a href="https://scikit-learn.org/stable/modules/ensemble.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/ensemble.html</a>)</p>
</li>
</ul>
</blockquote>
<h4 id="1-1-Bagging"><a href="#1-1-Bagging" class="headerlink" title="1.1 Bagging"></a>1.1 Bagging</h4><p>Bagging 全称叫 Bootstrap aggregating，每个基学习器都会对训练集进行<strong>有放回抽样</strong>得到子训练集，比较著名的采样法为 0.632 自助法。每个基学习器基于不同子训练集进行训练，并综合所有基学习器的预测值得到最终的预测结果。Bagging 常用的综合方法是投票法，票数最多的类别为预测类别。</p>
<p><img src="/2020/07/25/决策树/1595652338160.png" alt="1595652338160"></p>
<p><img src="/2020/07/25/决策树/1601797615594.png" alt="1601797615594"></p>
<p>每个基础分类器（可以是树形结构、神经网络等等任何分类模型）的特点是<strong>低偏差、高方差</strong>，框架通过(加权)投票方式降低方差，使得整体趋于<strong>低偏差、低方差</strong>。</p>
<h4 id="1-2-Boosting"><a href="#1-2-Boosting" class="headerlink" title="1.2 Boosting"></a>1.2 Boosting</h4><p>Boosting 训练过程为阶梯状，<strong>基模型的训练是有顺序的，每个基模型都会在前一个基模型学习的基础上进行学习</strong>，最终综合所有基模型的预测值产生最终的预测结果，用的比较多的综合方式为加权法。</p>
<p><img src="/2020/07/25/决策树/1595652444294.png" alt="1595652444294"></p>
<p><img src="/2020/07/25/决策树/1601797938878.png" alt="1601797938878"></p>
<p>Boosting 通过迭代方式训练若干基础分类器，每个分类器依据上一轮分类器产生的残差做权重调整，每轮的分类器需要够“简单”（弱分类器），具有<strong>高偏差、低方差</strong>的特点，框架再辅以(加权)投票方式降低偏差，使得整体趋于<strong>低偏差、低方差</strong>。</p>
<h4 id="1-3-Stacking"><a href="#1-3-Stacking" class="headerlink" title="1.3 Stacking"></a>1.3 Stacking</h4><p>Stacking 是先用全部数据训练好基模型，然后每个基模型都对每个训练样本进行预测，其预测值将作为训练样本的特征值，最终会得到新的训练样本，然后基于新的训练样本进行训练得到模型，然后得到最终预测结果。</p>
<blockquote>
<p>为什么集成学习会好于单个学习器呢？原因可能有三：</p>
<ol>
<li>训练样本可能无法选择出最好的单个学习器，由于没法选择出最好的学习器，所以干脆结合起来一起用；</li>
<li>假设能找到最好的学习器，但由于算法运算的限制无法找到最优解，只能找到次优解，采用集成学习可以弥补算法的不足；</li>
<li>可能算法无法得到最优解，而集成学习能够得到近似解。比如说最优解是一条对角线，而单个决策树得到的结果只能是平行于坐标轴的，但是集成学习可以去拟合这条对角线。</li>
</ol>
</blockquote>
<h3 id="2-偏差与方差"><a href="#2-偏差与方差" class="headerlink" title="2.偏差与方差"></a>2.偏差与方差</h3><p>如何从偏差和方差的角度来理解集成学习。</p>
<h4 id="2-1-集成学习的偏差与方差"><a href="#2-1-集成学习的偏差与方差" class="headerlink" title="2.1 集成学习的偏差与方差"></a>2.1 集成学习的偏差与方差</h4><p><strong>偏差（Bias）描述的是预测值和真实值之差；方差（Variance）描述的是预测值作为随机变量的离散程度（不同样本下模型效果的离散程度）。</strong></p>
<p>放一张很经典的图：</p>
<p><img src="/2020/07/25/决策树/1595652870653.png" alt="1595652870653"></p>
<blockquote>
<p>We can create a graphical visualization of bias and variance using a bulls-eye diagram. Imagine that the center of the target is a model that perfectly predicts the correct values. As we move away from the bulls-eye, our predictions get worse and worse. Imagine we can repeat our entire model building process to get a number of separate hits on the target. Each hit represents an individual realization of our model, given the chance variability in the training data we gather. Sometimes we will get a good distribution of training data so we predict very well and we are close to the bulls-eye, while sometimes our training data might be full of outliers or non-standard values resulting in poorer predictions. These different realizations result in a scatter of hits on the target. </p>
<p>(来自 <a href="http://scott.fortmann-roe.com/docs/BiasVariance.html" target="_blank" rel="noopener">http://scott.fortmann-roe.com/docs/BiasVariance.html</a>)</p>
</blockquote>
<p>模型的偏差与方差</p>
<ul>
<li><strong>偏差</strong>：描述样本拟合出的模型的预测结果的期望与样本真实结果的差距，要想偏差表现的好，就需要复杂化模型，增加模型的参数，但这样容易过拟合，过拟合对应上图的 High Variance，点会很分散。低偏差对应的点都打在靶心附近，描得很准，但不一定很稳；</li>
<li><strong>方差</strong>：描述样本上训练出来的模型在测试集上的表现，要想方差表现的好，需要简化模型，减少模型的复杂度，但这样容易欠拟合，欠拟合对应上图 High Bias，点偏离中心。低方差对应就是点都打的很集中，但不一定是靶心附近，手很稳，但不一定瞄的准。</li>
</ul>
<p>我们常说集成学习中的基模型是弱模型，通常来说弱模型是偏差高（在训练集上准确度低）方差小（防止过拟合能力强）的模型。但是，并不是所有集成学习框架中的基模型都是弱模型。<strong><span style="color:red">Bagging 和 Stacking 中的基模型为强模型（偏差低方差高），Boosting 中的基模型为弱模型</span></strong>。</p>
<p><img src="/2020/07/25/决策树/1595653661803.png" alt="1595653661803"></p>
<h4 id="2-2-Bagging-的偏差与方差"><a href="#2-2-Bagging-的偏差与方差" class="headerlink" title="2.2 Bagging 的偏差与方差"></a>2.2 Bagging 的偏差与方差</h4><p><img src="/2020/07/25/决策树/1595653718100.png" alt="1595653718100"></p>
<p>（👆 应为方差公式第二项的改变对整体方差的作用很小？）</p>
<p>在此我们知道了为什么 Bagging 中的基模型一定要为强模型，如果 Bagging 使用弱模型则会导致整体模型的偏差提高，而准确度降低。</p>
<p>Random Forest 是经典的基于 Bagging 框架的模型，并在此基础上通过引入特征采样和样本采样来降低基模型间的相关性，从而在方差公式中，第一项显著减少，第二项稍微增加，整体方差仍是减少。</p>
<h4 id="2-3-Boosting-的偏差与方差"><a href="#2-3-Boosting-的偏差与方差" class="headerlink" title="2.3 Boosting 的偏差与方差"></a>2.3 Boosting 的偏差与方差</h4><p>对于 Boosting 来说，基模型的训练集抽样是强相关的，那么模型的相关系数近似等于1，故我们也可以针对 Boosting 化简公式为：</p>
<script type="math/tex; mode=display">
E(F)=r\sum_i^mE(f_i)\\
Var(F)=m^2r^2\sigma^2\rho+mr^2\sigma^2(1-\rho)=m^2r^2\sigma^2</script><p>通过观察整体方差的表达式，我们容易发现：</p>
<ul>
<li>若基模型不是弱模型，其方差相对较大，这将导致整体模型的方差很大，即无法达到防止过拟合的效果。因此，Boosting框架中的基模型必须为弱模型</li>
<li>因为基模型为弱模型，导致了每个基模型的准确度都不是很高。随着基模型数的增多，整体模型的期望值增加，更接近真实值，因此整体模型的准确度提高。但是准确度一定会无限逼近1吗？仍然并不一定，因为训练过程中准确度的提高的主要功臣是整体模型在训练集行的准确度提高，而随着训练的进行，整体模型的方差变大，导致防止过拟合的能力变弱，最终导致了准确度反而有所下降。</li>
</ul>
<p>基于 Boosting 框架的 Gradient Boosting Decision Tree 模型中基模型也为树模型，同 Random Forest，我们也可以对特征进行随机抽样来使基模型间的相关性降低，从而达到减少方差的效果。</p>
<h4 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4 小结"></a>2.4 小结</h4><ul>
<li>我们可以使用模型的偏差和方差来近似描述模型的准确度；</li>
<li>对于 Bagging 来说，整体模型的偏差与基模型近似，而随着模型的增加可以降低整体模型的方差，故其基模型需要为强模型；</li>
<li>对于 Boosting 来说，整体模型的方差近似等于基模型的方差，而整体模型的偏差由基模型累加而成，故基模型需要为弱模型。</li>
</ul>
<h3 id="3-Random-Forest"><a href="#3-Random-Forest" class="headerlink" title="3.Random Forest"></a>3.Random Forest</h3><p>RF 算法由很多决策树组成，每一棵决策树之间没有关联。建立完森林后，当有新样本进入时，每棵决策树都会分别进行判断，然后基于投票法给出分类结果。<span style="color:red">组成随机森林的树可以是分类树，也可以是回归树。</span>（而GBDT只由回归树组成）</p>
<h4 id="3-1-思想-1"><a href="#3-1-思想-1" class="headerlink" title="3.1 思想"></a>3.1 思想</h4><p>Random Forest（随机森林）是 Bagging 的扩展变体，它在以决策树为基学习器构建 Bagging 集成的基础上，进一步在决策树的训练过程中引入了随机特征选择，因此可以概括 RF 包括四个部分：</p>
<ol>
<li>随机选择样本（有放回抽样）；</li>
<li>随机选择特征；</li>
<li>构建决策树；</li>
<li>随机森林投票（平均）。</li>
</ol>
<p>随机选择样本和 Bagging 相同，采用的是 Bootstrap 自助采样法；随机选择特征是指在每个节点在分裂过程中都是随机选择特征的（区别于每棵树随机选择一批特征）。</p>
<blockquote>
<p>for each split on a tree, you take a random subset of the features but still use the same splitting criteria. </p>
<p><strong>Does random forest select a subset of features for every tree or every node?</strong></p>
<p>That’s a good question, since the earlier random decision forests by Tin Kam Ho used the “random subspace method,” where each tree got a random subset of features.</p>
<blockquote>
<p>“Our method relies on an autonomous, pseudo-random procedure to select a small number of dimensions from a given feature space …”</p>
</blockquote>
<ul>
<li>Ho, Tin Kam. “The random subspace method for constructing decision forests.” IEEE transactions on pattern analysis and machine intelligence 20.8 (1998): 832-844.</li>
</ul>
<p>However, a few years later, Leo Breiman described the procedure of selecting different subsets of features for each node (while a tree was given the full set of features) — Leo Breiman’s formulation has become the “trademark” random forest algorithm that we typically refer to these days when we speak of “random forest”</p>
<blockquote>
<p>“… random forest with random features is formed by selecting at random, at each node, a small group of input variables to split on.”</p>
</blockquote>
<ul>
<li>Breiman, Leo. “Random Forests” Machine learning 45.1 (2001): 5-32.</li>
</ul>
<p>To answer your question: Each tree gets the full set of features, but at each node, only a random subset of features is considered.</p>
<p>(来自 <a href="https://sebastianraschka.com/faq/docs/random-forest-feature-subsets.html" target="_blank" rel="noopener">https://sebastianraschka.com/faq/docs/random-forest-feature-subsets.html</a>)</p>
</blockquote>
<p>这种随机性导致随机森林的偏差会有稍微的增加（相比于单棵不随机树），但是由于随机森林的“平均”特性，会使得它的方差减小，而且方差的减小补偿了偏差的增大，因此总体而言是更好的模型。</p>
<p>随机采样由于引入了两种采样方法保证了随机性，所以每棵树都是最大可能的进行生长就算不剪枝也不会出现过拟合。</p>
<h4 id="3-2-优缺点"><a href="#3-2-优缺点" class="headerlink" title="3.2 优缺点"></a>3.2 优缺点</h4><p>优点</p>
<ol>
<li>在数据集上表现良好，相对于其他算法有较大的优势</li>
<li>易于并行化，在大数据集上有很大的优势；</li>
<li>能够处理高维度数据，不用做特征选择。</li>
</ol>
<h3 id="4-AdaBoost"><a href="#4-AdaBoost" class="headerlink" title="4.AdaBoost"></a>4.AdaBoost</h3><p>AdaBoost（Adaptive Boosting，自适应增强），其自适应在于：前一个基本分类器分错的样本会得到加强，加权后的全体样本再次被用来训练下一个基本分类器。同时，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率或达到预先指定的最大迭代次数。</p>
<h4 id="4-1-思想"><a href="#4-1-思想" class="headerlink" title="4.1 思想"></a>4.1 思想</h4><p>Adaboost 迭代算法有三步：</p>
<ol>
<li>初始化训练样本的权值分布，每个样本具有相同权重；</li>
<li>训练弱分类器，如果样本分类正确，则在构造下一个训练集中，它的权值就会被降低；反之提高。用更新过的样本集去训练下一个分类器；</li>
<li>将所有弱分类组合成强分类器，各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，降低分类误差率大的弱分类器的权重。</li>
</ol>
<h4 id="4-2-细节"><a href="#4-2-细节" class="headerlink" title="4.2 细节"></a>4.2 细节</h4><h5 id="4-2-1-算法过程"><a href="#4-2-1-算法过程" class="headerlink" title="4.2.1 算法过程"></a>4.2.1 算法过程</h5><p>来自 <a href="https://blog.csdn.net/weixin_38629654/article/details/80516045" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38629654/article/details/80516045</a></p>
<p><img src="/2020/07/25/决策树/1601196695960.png" alt="1601196695960"></p>
<p>最后总结一下Adaboost算法，理解它的关键就在于了解权值分布$D_t$是如何影响误差率$e_t$、权值$\alpha_t$以及更新权值分布$D_{t+1}$。具体的例子，可见 <a href="https://blog.csdn.net/guyuealian/article/details/70995333" target="_blank" rel="noopener">https://blog.csdn.net/guyuealian/article/details/70995333</a></p>
<p>AdaBoost 通过训练多个弱分类器来组合得到一个强分类器，每次迭代会生成一棵<strong>高偏差、低方差</strong>的弱分类器，每一轮的训练会更关注上一轮被分类器分错的样本，为其加大权重。</p>
<p>训练过程：</p>
<p><img src="/2020/07/25/决策树/1601799086192.png" alt="1601799086192"></p>
<h5 id="4-2-2-损失函数"><a href="#4-2-2-损失函数" class="headerlink" title="4.2.2 损失函数"></a>4.2.2 损失函数</h5><p><img src="/2020/07/25/决策树/1595663386859.png" alt="1595663386859"></p>
<p><img src="/2020/07/25/决策树/1595663456133.png" alt="1595663456133"></p>
<p><img src="/2020/07/25/决策树/1595663508910.png" alt="1595663508910"></p>
<h5 id="4-2-3-正则化"><a href="#4-2-3-正则化" class="headerlink" title="4.2.3 正则化"></a>4.2.3 正则化</h5><p><img src="/2020/07/25/决策树/1595663617670.png" alt="1595663617670"></p>
<h4 id="4-3-优缺点"><a href="#4-3-优缺点" class="headerlink" title="4.3 优缺点"></a>4.3 优缺点</h4><p><strong>优点</strong></p>
<ol>
<li>分类精度高；</li>
<li>可以用各种回归分类模型来构建弱学习器，非常灵活；</li>
<li>不容易发生过拟合。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>对异常点敏感，异常点会获得较高权重。</li>
</ol>
<p>另：</p>
<p><strong>优点</strong> </p>
<p>（1）Adaboost提供一种框架，在框架内可以使用各种方法构建子分类器。可以使用简单的弱分类器，不用对特征进行筛选，也不存在过拟合的现象。 </p>
<p>（2）Adaboost算法不需要弱分类器的先验知识，最后得到的强分类器的分类精度依赖于所有弱分类器。无论是应用于人造数据还是真实数据，Adaboost都能显著的提高学习精度。 </p>
<p>（3）Adaboost算法不需要预先知道弱分类器的错误率上限，且最后得到的强分类器的分类精度依赖于所有弱分类器的分类精度，可以深挖分类器的能力。Adaboost可以根据弱分类器的反馈，自适应地调整假定的错误率，执行的效率高。 </p>
<p>（4）Adaboost可以在不改变训练数据，只改变数据权值分布，使得数据在不同学习器中产生不同作用，类似于重采样。 </p>
<p><strong>缺点</strong> </p>
<p>​     在Adaboost训练过程中，Adaboost会使得难于分类样本的权值呈指数增长，训练将会过于偏向这类困难的样本，导致Adaboost算法易受噪声干扰。此外，Adaboost依赖于弱分类器，而弱分类器的训练时间往往很长。</p>
<h3 id="5-GBDT"><a href="#5-GBDT" class="headerlink" title="5.GBDT"></a>5.GBDT</h3><blockquote>
<p>参考：<br><a href="https://mp.weixin.qq.com/s/Nl_-PdF0nHBq8yGp6AdI-Q" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Nl_-PdF0nHBq8yGp6AdI-Q</a><br><a href="https://blog.csdn.net/sb19931201/article/details/52506157" target="_blank" rel="noopener">https://blog.csdn.net/sb19931201/article/details/52506157</a><br><a href="https://www.zybuluo.com/vivounicorn/note/446479" target="_blank" rel="noopener">https://www.zybuluo.com/vivounicorn/note/446479</a><br><a href="https://www.cnblogs.com/bnuvincent/p/9693190.html" target="_blank" rel="noopener">https://www.cnblogs.com/bnuvincent/p/9693190.html</a></p>
</blockquote>
<p>GBDT（Gradient Boosting Decision Tree）是一种迭代的决策树算法，该算法由多棵决策树组成，从名字中我们可以看出来它是属于 Boosting 策略。GBDT 是被公认的泛化能力较强的算法。</p>
<p>GBDT 是通过采用加法模型（即基函数的线性组合），以及不断减小训练过程产生的残差来达到将数据分类或者回归的算法。</p>
<p>不同于Adaboost加大误分样本权重的策略，GBDT每次迭代加的是上一轮梯度更新值。其训练过程如下:</p>
<p><img src="/2020/07/25/决策树/1601800623694.png" alt="1601800623694"></p>
<h4 id="5-1-思想"><a href="#5-1-思想" class="headerlink" title="5.1 思想"></a>5.1 思想</h4><p>GBDT 通过多轮迭代，每轮迭代产生一个弱分类器，每个分类器在上一轮分类器的<strong>残差</strong>基础上进行训练。对弱分类器的要求一般是足够简单，并且是低方差和高偏差的。因此训练的过程是通过降低偏差来不断提高最终分类器的精度。</p>
<p>弱分类器一般会选择为CART TREE（也就是分类回归树）。由于上述高偏差和简单的要求，每个分类回归树的深度不会很深。最终的总分类器是将每轮训练得到的弱分类器加权求和得到的（也就是加法模型）。</p>
<p>模型最终可以描述为：</p>
<script type="math/tex; mode=display">
F_M(x)=\sum_{m=1}^MT(x;\theta_m)</script><p> 模型一共训练 $M$ 轮，每轮产生一个弱分类器 $T(x;\theta_m)$。弱分类器的<strong>损失函数</strong></p>
<script type="math/tex; mode=display">
\theta_m = argmin_{\theta_m}\sum_{i=1}^N L(y_i,F_{m-1}(x_i)+T(x_i;\theta_m))</script><p>$F_{m-1}(x)$ 为当前的模型，GBDT 通过经验风险极小化来确定下一个弱分类器的参数。具体到损失函数本身的选择也就是 $L$ 的选择，有平方损失函数，0-1损失函数，对数损失函数等等。如果我们选择平方损失函数，那么这个差值其实就是我们平常所说的残差。</p>
<p>如何让损失函数尽可能快的减小：让损失函数沿着梯度方向下降。这个就是 GBDT 的 GB 的核心了。 <strong>利用损失函数的负梯度在当前模型的值</strong></p>
<script type="math/tex; mode=display">
-[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}</script><p><strong>作为回归问题提升树算法中的残差的近似值去拟合一个回归树。gbdt 每轮迭代的时候，都去拟合损失函数在当前模型下的负梯度。</strong>这样每轮训练的时候都能够让损失函数尽可能快的减小，尽快的收敛达到局部最优解或者全局最优解。</p>
<h5 id="5-1-1-Boosting"><a href="#5-1-1-Boosting" class="headerlink" title="5.1.1 Boosting"></a>5.1.1 Boosting</h5><p>GBDT 的全称是 Gradient Boosting Decision Tree，Gradient Boosting 和 Decision Tree是两个独立的概念。因此我们先说说Boosting。Boosting的概念很好理解，意思是用一些弱分类器的组合来构造一个强分类器。因此，它不是某个具体的算法，它说的是一种理念。和这个理念相对应的是一次性构造一个强分类器。像支持向量机，逻辑回归等都属于后者。通常，我们<strong>通过相加来组合弱分类器</strong>，形式如下：</p>
<script type="math/tex; mode=display">
F_m(x) = f_0 + \alpha_1f_1(x) +\alpha_2f_2(x) + ... + \alpha_m f_m(x)</script><h5 id="5-1-2-Gradient-Boosting-Modeling-GBM"><a href="#5-1-2-Gradient-Boosting-Modeling-GBM" class="headerlink" title="5.1.2 Gradient Boosting Modeling (GBM)"></a>5.1.2 Gradient Boosting Modeling (GBM)</h5><p>给定一个问题，我们如何构造这些弱分类器呢？Gradient Boosting Modeling (GBM) 就是构造这些弱分类器的一种方法。同样，它指的不是某个具体的算法，仍然只是一个理念。</p>
<h6 id="5-1-2-1-最深梯度下降法（Steepest-Gradient-Descent）"><a href="#5-1-2-1-最深梯度下降法（Steepest-Gradient-Descent）" class="headerlink" title="5.1.2.1 最深梯度下降法（Steepest Gradient Descent）"></a>5.1.2.1 最深梯度下降法（Steepest Gradient Descent）</h6><p>在理解 Gradient Boosting Modeling 之前，我们先看看一个典型的优化问题：</p>
<script type="math/tex; mode=display">
find\ \hat x = \mathop{\arg\min}_x f(x)</script><p>针对这种优化问题，有一个经典的算法叫 Steepest Gradient Descent（最深梯度下降法）。 这个算法的过程大致如下: </p>
<p>1.给定一个起始点  $x_0$</p>
<p>2.对 $i = 1, 2, …, K$ 分别做如下迭代：</p>
<script type="math/tex; mode=display">
x_i = x_{i-1} + \gamma_{i-1}*g_{i-1}，这里g_{i-1}=-\frac{\partial f}{\partial x}|_{x=x_{i-1}}表示 f 在 x_{i-1}处的梯度</script><p>直到 $g_{i-1}$ 足够小，或者 $|x_i-x_{i-1}|$ 足够小。</p>
<p>以上迭代过程可以这么理解：整个寻优的过程就是个小步快跑的过程，每跑一小步，都往函数当前下降最快的那个方向走一点。</p>
<p>这样寻优得到的结果可以表示成加和形式，即：</p>
<script type="math/tex; mode=display">
x_k = x_0 + \gamma_1*g_1 +\gamma_2*g_2 + ... + \gamma_k*g_k</script><h6 id="5-1-2-2-Gradient-Boosting"><a href="#5-1-2-2-Gradient-Boosting" class="headerlink" title="5.1.2.2 Gradient Boosting"></a>5.1.2.2 Gradient Boosting</h6><p>Gradient Boosting 正是由此启发而来。 构造 $F_m(x)$ 本身也是一个寻优的过程，只不过我们寻找的不是一个最优点，而是一个最优的函数。优化的目标通常都是通过一个损失函数来定义，即：</p>
<script type="math/tex; mode=display">
find\ F_m = \mathop{\arg \min_F} L(F)= \mathop{\arg \min_F} \sum_{i=0}^N Loss(F(x_i),y_i)</script><p>其中 $Loss(F(x_i),y_i)$ 表示损失函数 Loss 在第 i 个样本上的损失值。常见的损失函数如平方差函数：</p>
<script type="math/tex; mode=display">
Loss(F(x_i),y_i)=(F(x_i)-y_i)^2</script><p>类似最深梯度下降法，可以通过梯度下降法来构造弱分类器 $f_1,f_2,…,f_m$，只不过每次迭代时，令</p>
<script type="math/tex; mode=display">
g_i=-\frac{\partial L}{\partial F}|_{F=F_{i-1}}</script><p>即对损失函数L，以 F 为参考求取梯度。这里有个小问题，一个函数对函数的求导不好理解，而且通常都无法通过上述公式直接求解到梯度函数 $g_i$。为此，采取一个近似的方法，把函数 $F_{i−1}$ 理解成在所有样本上的离散的函数值，即：$[F_{i-1}(x_1),F_{i-1}(x_2),…F_{i-1}(x_N)]$，不难理解，这是一个 N 维向量。然后计算</p>
<script type="math/tex; mode=display">
\hat g_i(x_k)=-\frac{\partial L}{\partial F(x_k)}|_{F=F_{i-1}} \quad for\ k = 1,2,3,...,N</script><p>严格来说 $\hat g_i(x_k) \quad for\ k = 1,2, … , N$ 只是描述了 $g_i$ 在某些个别点上的值，并不足以表达 $g_i$，但我们可以通过函数拟合的方法从 $\hat g_i(x_k) \quad for\ k = 1,2, … , N$ 构造 $g_i$，这样我们就通过近似的方法得到了函数对函数的梯度求导。 </p>
<h6 id="5-1-2-3-GBM-的过程总结"><a href="#5-1-2-3-GBM-的过程总结" class="headerlink" title="5.1.2.3 GBM 的过程总结"></a>5.1.2.3 GBM 的过程总结</h6><blockquote>
<p>1.选择一个起始常量函数 $f_0$（常量函数 $f_0$ 通常取样本目标值的均值，即 $f_0 = \frac{1}{N}\sum_{i=0}^Ny_i$.）</p>
<p>2.对 $i=1,2,…,K$ 分别做如下迭代：</p>
<p>a) 计算离散梯度值 $\hat g_i(x_j)=-\frac{\partial L}{\partial F(x_j)}|_{F=F_{i-1}}, \quad for\ j = 1,2,3,…,N$<br>b) 对 $\hat g_{i-1}(x_j) \quad for\ j = 1,2,3,…,N$ 做函数拟合得到 $g_i-1$<br>c) 通过 line search 得到 $\gamma_{i-1}=\arg \min L(F_{i-1}+\gamma_{i-1}<em>g_{i-1})$<br>d) 令 $F_i = F_{i-1}+\gamma_{i-1}</em>g_{i-1}$</p>
<p>3.直到 $|\hat g_{i-1}|$ 足够小，或者迭代次数完毕</p>
</blockquote>
<h5 id="5-1-3-Gradient-Boosting-Decision-Tree"><a href="#5-1-3-Gradient-Boosting-Decision-Tree" class="headerlink" title="5.1.3 Gradient Boosting Decision Tree"></a>5.1.3 Gradient Boosting Decision Tree</h5><p>以上 Gradient Boosting Modeling 的过程中，还没有说清楚如何通过离散值 $\hat g_{i−1}(x_j) \quad for\ j = 1,2,3,…N$ 构造拟合函数 $g_{i−1}$。函数拟合是个比较熟知的概念，有很多现成的方法，不过有一种拟合方法广为应用，那就是决策树 Decision Tree。GBDT 是 Gradient Boosting 的一种具体实例，只不过这里的弱分类器是决策树。如果你改用其他弱分类器 XYZ，也可以称之为 Gradient Boosting XYZ。只不过 Decision Tree 很好用，GBDT 才如此引人注目。 </p>
<p>GBDT 无论用于分类还是回归一直都是使用的CART 回归树。对于分类树而言，其值加减无意义（如性别），而对于回归树而言，其值加减才是有意义的（如说年龄）。<strong>GBDT 的核心在于累加所有树的结果作为最终结果</strong>，所以 <strong><span style="color:red">GBDT 中的树都是回归树</span></strong>，不是分类树，这一点相当重要。</p>
<p>回归树在分枝时会穷举每一个特征的每个阈值以找到最好的分割点，衡量标准是最小化均方误差。</p>
<h5 id="5-1-4-梯度迭代（Gradient-Boosting）"><a href="#5-1-4-梯度迭代（Gradient-Boosting）" class="headerlink" title="5.1.4 梯度迭代（Gradient Boosting）"></a>5.1.4 梯度迭代（Gradient Boosting）</h5><p>上面说到 GBDT 的核心在于累加所有树的结果作为最终结果，<strong>GBDT 的每一棵树都是以之前树得到的残差来更新目标值，这样每一棵树的值加起来即为 GBDT 的预测值</strong>。</p>
<blockquote>
<p>举个例子：比如说 A 用户年龄 20 岁，第一棵树预测 12 岁，那么残差就是 8，第二棵树用 8 来学习，假设其预测为 5，那么其残差即为 3，如此继续学习即可。</p>
</blockquote>
<p>那么Gradient 从何体现？其实很简单，其残差其实是最小均方损失函数关于预测值的反向梯度。</p>
<script type="math/tex; mode=display">
F_i(x) = F_{i-1}(x) + (-\frac{\partial(\frac{1}{2}(y-F_{i-1}(x))^2)}{\partial F(x)} )</script><p><img src="/2020/07/25/决策树/1595667123278.png" alt="1595667123278"></p>
<p><img src="/2020/07/25/决策树/1595667175530.png" alt="1595667175530"></p>
<p>GBDT 的 Boosting 不同于 Adaboost 的 Boosting，GBDT 的每一步残差计算其实变相地增大了被分错样本的权重，而对于分对样本的权重趋于 0，这样后面的树就能专注于那些被分错的样本。</p>
<hr>
<blockquote>
<p>参考 <a href="https://blog.csdn.net/sb19931201/article/details/52506157" target="_blank" rel="noopener">https://blog.csdn.net/sb19931201/article/details/52506157</a></p>
</blockquote>
<p><span id="jump_GBDT">GBDT算法步骤：</span></p>
<p><img src="/2020/07/25/决策树/1601189631302.png" alt="1601189631302"></p>
<p>算法第 1 步初始化 ，估计使损失函数极小化的常数值，它是只有一个根结点的树。第 2 (a) 步计算损失函数的负梯度在当前模型的值，将它作为残差的估计。对于平方损失函数，它就是通常所说的残差；对于一般损失函数，它就是残差的近似值。第 2 (b) 步估计回归树叶结点区域，以拟合残差的近似值。第 2(c) 步利用线性搜索估计叶结点区域的值，使损失函数极小化。第 2(d) 步更新回归树，第 3 步得到输出的最终模型。</p>
<hr>
<blockquote>
<p>维基百科 <a href="https://en.wikipedia.org/wiki/Gradient_boosting" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gradient_boosting</a></p>
</blockquote>
<p>In pseudocode, the generic gradient boosting method is:</p>
<p><img src="/2020/07/25/决策树/1601190228458.png" alt="1601190228458"></p>
<p><img src="/2020/07/25/决策树/1601190289236.png" alt="1601190289236"></p>
<p><img src="/2020/07/25/决策树/1601190443051.png" alt="1601190443051"></p>
<h5 id="5-1-5-避免过拟合-缩减（Shrinkage）"><a href="#5-1-5-避免过拟合-缩减（Shrinkage）" class="headerlink" title="5.1.5 避免过拟合 - 缩减（Shrinkage）"></a>5.1.5 避免过拟合 - 缩减（Shrinkage）</h5><p>Shrinkage 的思想认为，每走一小步逐渐逼近结果的效果要比每次迈一大步很快逼近结果的方式更容易避免过拟合。即它并不是完全信任每一棵残差树。</p>
<p>更新规则：</p>
<script type="math/tex; mode=display">
F_m(x)=F_{m-1}(x)+\nu \cdot \gamma_m h_m(x), (0< v \leq 1)</script><p>Shrinkage 不直接用残差修复误差，而是只修复一点点，把大步切成小步。本质上 Shrinkage 为每棵树设置了一个 weight，累加时要乘以这个 weight，当 weight 降低时，基模型数会配合增大。</p>
<blockquote>
<p>Empirically it has been found that using small <a href="https://en.wikipedia.org/wiki/Learning_rate" target="_blank" rel="noopener">learning rates</a> (such as  $\nu$ &lt;0.1) yields dramatic improvements in models’ generalization ability over gradient boosting without shrinking ($\nu$ =1). However, it comes at the price of increasing <a href="https://en.wikipedia.org/wiki/Computational_time" target="_blank" rel="noopener">computational time</a> both during training and <a href="https://en.wikipedia.org/wiki/Information_retrieval" target="_blank" rel="noopener">querying</a>: lower learning rate requires more iterations.</p>
<p>（来自 <a href="https://en.wikipedia.org/wiki/Gradient_boosting）" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Gradient_boosting）</a></p>
</blockquote>
<h5 id="5-1-6-对GBDT损失函数的理解"><a href="#5-1-6-对GBDT损失函数的理解" class="headerlink" title="5.1.6 对GBDT损失函数的理解"></a>5.1.6 对GBDT损失函数的理解</h5><p>谈到 GBDT，常听到一种简单的描述方式：“先构造一个(决策)树，然后不断在已有模型和实际样本输出的残差上再构造一颗树，依次迭代”。其实这个说法不全面，它只是 GBDT 的一种特殊情况，为了看清这个问题，需要对损失函数的选择做一些解释。 </p>
<p>从对 GBM 的描述里可以看到 Gradient Boosting 过程和具体用什么样的弱分类器是完全独立的，可以任意组合，因此这里不再刻意强调用决策树来构造弱分类器，转而我们来仔细看看弱分类器拟合的目标值，即梯度$\hat g_{i−1}(x_j)$。</p>
<p>以<strong>平方差损失函数</strong>为例</p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial F(x_k)}|_{F=F_{i-1}}=2(F_{i-1}(x_k)-y_k)</script><p> 忽略倍数2，这正好是当前已经构造好的函数 $F_{i-1}$ 在样本上和目标值 $y_k$ 之间的差值。</p>
<p>对于<strong>绝对差值损失函数</strong>，梯度是个符号函数：</p>
<script type="math/tex; mode=display">
Loss(F(x_i),y_i)=|F(x_i)-y_i|</script><script type="math/tex; mode=display">
\frac{\partial L}{\partial F(x_k)}|_{F=F_{i-1}}=sign(F_{i-1}(x_k)-y_k)</script><p>由此可以看到，<strong>只有当损失函数为平方差函数时，才能说 GBDT 是通过拟合残差来构造弱分类器的</strong>。</p>
<h5 id="5-1-7-利用-GBDT-构建特征组合"><a href="#5-1-7-利用-GBDT-构建特征组合" class="headerlink" title="5.1.7 利用 GBDT 构建特征组合"></a>5.1.7 利用 GBDT 构建特征组合</h5><blockquote>
<p>参考 <a href="https://www.cnblogs.com/bnuvincent/p/9693190.html" target="_blank" rel="noopener">https://www.cnblogs.com/bnuvincent/p/9693190.html</a></p>
</blockquote>
<p> 其实说 GBDT 能够构建特征并非很准确，GBDT 本身是不能产生特征的，但是我们可以利用 GBDT 去产生特征的组合。在CTR预估中，工业界一般会采用<a href="http://www.cnblogs.com/ModifyRong/p/7739955.html#3825035" target="_blank" rel="noopener">逻辑回归</a>去进行处理，<strong>逻辑回归本身是适合处理线性可分的数据，如果我们想让逻辑回归处理非线性的数据，其中一种方式便是组合不同特征，增强逻辑回归对非线性分布的拟合能力</strong>。</p>
<p>长久以来，我们都是通过人工的先验知识或者实验来获得有效的组合特征，但是很多时候，使用人工经验知识来组合特征过于耗费人力，造成了机器学习当中一个很奇特的现象：有多少人工就有多少智能。关键是这样通过人工去组合特征并不一定能够提升模型的效果。所以我们的从业者或者学界一直都有一个趋势便是通过算法自动、高效的寻找到有效的特征组合。Facebook 在2014年 发表的一篇论文便是这种尝试下的产物，利<strong>用 GBDT 去产生有效的特征组合，以便用于逻辑回归的训练，提升模型最终的效果</strong>。</p>
<p><img src="/2020/07/25/决策树/1606036242199.png" alt="1606036242199"></p>
<p>如上图所示，我们使用 GBDT 生成了两棵树，两棵树一共有五个叶子节点。我们将样本 X 输入到两棵树当中去，样本 X 落在了第一棵树的第二个叶子节点，第二棵树的第一个叶子节点，于是我们便可以依次构建一个五维的特征向量，每一个维度代表一个叶子节点，样本落在这个叶子节点上面的话那么值为1，没有落在该叶子节点的话，那么值为 0。于是对于该样本，我们可以得到一个向量 [0,1,0,1,0] 作为该样本的组合特征，和原来的特征一起输入到逻辑回归当中进行训练。实验证明这样会得到比较显著的效果提升。</p>
<p>（具体例子见原网页）</p>
<h5 id="5-1-8-GBDT-如何用于分类"><a href="#5-1-8-GBDT-如何用于分类" class="headerlink" title="5.1.8 GBDT 如何用于分类"></a>5.1.8 GBDT 如何用于分类</h5><blockquote>
<p>参考 <a href="https://www.cnblogs.com/bnuvincent/p/9693190.html" target="_blank" rel="noopener">https://www.cnblogs.com/bnuvincent/p/9693190.html</a></p>
</blockquote>
<p> 首先明确一点，GBDT 无论用于分类还是回归一直都是使用的CART 回归树。这里面的核心是因为 GBDT 每轮的训练是在上一轮训练的残差基础之上进行训练的。这里的残差就是当前模型的负梯度值 。这个要求每轮迭代的时候，弱分类器的输出的结果相减是有意义的。残差相减是有意义的。如果选用的弱分类器是分类树，类别相减是没有意义的。</p>
<p>具体到分类这个任务上面来，假设样本 $X$ 总共有 $K$ 类。来了一个样本 $x$，我们需要使用 GBDT 来判断 $x$ 属于哪一类。</p>
<p><img src="/2020/07/25/决策树/1606040985704.png" alt="1606040985704"></p>
<p>第一步，我们在训练的时候，是针对样本 $X$ 每个可能的类都训练一个分类回归树。举例说明，目前样本有三类（ K = 3）。样本 $x$ 属于 第二类，那么针对该样本 $x$ 的分类结果，我们可以用一个三维向量 [0,1,0] 来表示。</p>
<p>针对样本有三类的情况，我们实质上是在每轮训练时，同时训练三棵树。第一棵树针对样本 $x$ 的第一类，输入为 $(x,0)$。第二棵树输入针对样本 $x$ 的第二类，输入为 $(x,1)$。第三棵树针对样本 $x$ 的第三类，输入为 $(x, 0)$。</p>
<p>在这里每棵树的训练过程，其实就是之前提到过的 CART TREE 的生成过程。参照之前的生成树的程序可以解出三棵树，以及三棵树对 $x$ 类别的预测值 $f_1(x),f_2(x),f_3(x)$。在此类训练中，我们仿照多分类的逻辑回归 ，使用 softmax 来产生概率，则属于类别 1 的概率 </p>
<script type="math/tex; mode=display">
p_1=\frac{exp(f_1(x))}{∑_{k=1}^3 exp(f_k(x))}</script><p>并且我们可以针对类别 1 求出残差 $y_1(x)=0−p_1(x)$; 类别 2 求出残差 $y_2(x)=1−p_2(x)$; 类别 3 求出残差 $y_3(x)=0−p_3(x)$.</p>
<p>然后开始第二轮训练。针对第一类输入为 $(x,y_1(x))$, 针对第二类输入为 $(x,y_2(x))$, 针对第三类输入为 $(x,y_3(x))$. 继续训练出三棵树。一直迭代 M 轮，每轮构建 3 棵树。</p>
<p>所以当 K = 3 时，我们应该有三个式子</p>
<script type="math/tex; mode=display">
F_{1M}(x)=∑_{m=1}^M C_{1m}I(x\in R_{1m})\\
F_{2M}(x)=∑_{m=1}^M C_{2m} I(x\in R_{2m})\\
F_{3M}(x)=∑_{m=1}^M C_{3m} I(x\in R_{3m})</script><p>当训练完毕以后，新来一个样本 $x_1$ ，我们需要预测该样本的类别的时候，便可以用这三个式子产生三个值，$f1(x_1),f2(x_1),f3(x_1)$。样本属于某个类别 $c$ 的概率为 </p>
<script type="math/tex; mode=display">
p_c=\frac{exp(f_c(x_1))}{∑_{k=1}^3exp(f_k(x_1))}</script><p>(GBDT 多分类举例说明 Iris 数据集见原网页.)</p>
<h5 id="5-1-9-GBDT总结"><a href="#5-1-9-GBDT总结" class="headerlink" title="5.1.9 GBDT总结"></a>5.1.9 GBDT总结</h5><blockquote>
<p> 来自 <a href="https://blog.csdn.net/sb19931201/article/details/52506157" target="_blank" rel="noopener">https://blog.csdn.net/sb19931201/article/details/52506157</a> </p>
</blockquote>
<ol>
<li><p>Gradient Boosting：每一次的计算是为了减少上一次的残差(residual)，而为了消除残差，我们可以在残差减少的梯度(Gradient)方向上建立一个新的模型。所以说，在Gradient Boost中，每个新的模型的建立是为了使得之前模型的残差往梯度方向减少（当然也可以变向理解成每个新建的模型都给予上一模型的误差更多的关注），与传统Boost对正确、错误的样本进行直接加权还是有区别的。</p>
</li>
<li><p>Size of trees(J)：模型叶结点的数量J需要根据现有数据调整，它控制着模型变量之间的相互作用，一般情况下都选择J的大小在4到8之间，J=2一般不能满足需要，J&gt;10的情况也不太可能需要。</p>
<p><img src="/2020/07/25/决策树/1601191484592.png" alt="1601191484592"></p>
</li>
</ol>
<h4 id="5-2-优缺点"><a href="#5-2-优缺点" class="headerlink" title="5.2 优缺点"></a>5.2 优缺点</h4><p><strong>优点</strong></p>
<ol>
<li>可以自动进行特征组合，拟合非线性数据；</li>
<li>可以灵活处理各种类型的数据。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>对异常点敏感。</li>
</ol>
<p>另：</p>
<p><img src="/2020/07/25/决策树/1595669502617.png" alt="1595669502617"></p>
<p><img src="/2020/07/25/决策树/1595669541744.png" alt="1595669541744"></p>
<h4 id="5-3-与-Adaboost-的对比"><a href="#5-3-与-Adaboost-的对比" class="headerlink" title="5.3 与 Adaboost 的对比"></a>5.3 与 Adaboost 的对比</h4><p>相同：</p>
<ol>
<li>都是 Boosting 家族成员，使用弱分类器；</li>
<li>都使用前向分布算法；</li>
</ol>
<p>不同：</p>
<ol>
<li>迭代思路不同：Adaboost 是通过提升错分数据点的权重来弥补模型的不足（利用错分样本），而 GBDT 是通过算梯度来弥补模型的不足（利用残差）；</li>
<li>损失函数不同：AdaBoost 采用的是指数损失，GBDT 使用的是绝对损失或者 Huber 损失函数；</li>
</ol>
<h4 id="5-4-随机森林与GBDT的比较"><a href="#5-4-随机森林与GBDT的比较" class="headerlink" title="5.4 随机森林与GBDT的比较"></a>5.4 随机森林与GBDT的比较</h4><ul>
<li><p>随机森林采用的bagging思想，GBDT采用的boosting思想，组成随机森林的树可以并行生成，GBDT只能串行生成，因为每个学习器是在之前的学习器的基础上进行训练的</p>
</li>
<li><p>组成随机森林的树可以是分类树，也可以是回归树；而GBDT只能由回归树组成。</p>
</li>
<li><p>对于最终的输出结果而言，随机森林采用多数投票等；而GBDT则是将所有结果累加起来，或者加权累加起来。</p>
</li>
<li><p>随机森林对异常值不敏感；GBDT对异常值非常敏感。</p>
</li>
<li><p>随机森林是通过减少模型方差提高性能；GBDT是通过减少模型偏差提高性能。</p>
</li>
<li><p>Random Forest and Gradient Boosted Decision Trees have vastly different optimal max_depth： Random Forest usually have <em>max_depth</em> ≥ 15, while for GBDT it is typically 4 ≤ <em>max_depth</em> ≤ 8.</p>
<p>(<a href="https://towardsdatascience.com/why-do-random-forest-and-gradient-boosted-decision-trees-have-vastly-different-optimal-max-depth-a64c2f63e127" target="_blank" rel="noopener">https://towardsdatascience.com/why-do-random-forest-and-gradient-boosted-decision-trees-have-vastly-different-optimal-max-depth-a64c2f63e127</a>)</p>
</li>
</ul>
<ul>
<li><p>When would one use Random Forests over Gradient Boosted Machines (GBMs)?</p>
<p>There are two main reasons why you would use Random Forests over Gradient Boosted Decision Trees, and they are both pretty related:</p>
<ol>
<li>RF are much easier to tune than GBM</li>
<li>RF are harder to overfit than GBM</li>
</ol>
<p>Related to (1), RF basically has only one hyperparameter to set: the number of features to randomly select at each node. However there is a rule-of-thumb to use the square root of the number of total features which works pretty well in most cases<a href="https://www.quora.com/When-would-one-use-Random-Forests-over-Gradient-Boosted-Machines-GBMs#pvZHI" target="_blank" rel="noopener">[1]</a>. On the other hand, GBMs have several hyperparameters that include the number of trees, the depth (or number of leaves), and the shrinkage (or learning rate).</p>
<p>And, regarding (2), while it is not true that RF do not overfit (as opposed as many are led to believe by Breiman’s strong assertions<a href="https://www.quora.com/When-would-one-use-Random-Forests-over-Gradient-Boosted-Machines-GBMs#DVkbR" target="_blank" rel="noopener">[2]</a>), it is true that they are more robust to overfitting and require less tuning to avoid it.</p>
<p>随机森林更不容易过拟合？</p>
<blockquote>
<p>GBMs are more sensitive to overfitting if the data is noisy.<br>(<a href="https://medium.com/@aravanshad/gradient-boosting-versus-random-forest-cfa3fa8f0d80" target="_blank" rel="noopener">https://medium.com/@aravanshad/gradient-boosting-versus-random-forest-cfa3fa8f0d80</a>)</p>
</blockquote>
<p>In some sense, RF is a tree ensemble that is more “plug’n’play” than GBM. However, it is generally true that a well-tuned GBM can outperform a RF.</p>
<p>Also, as <a href="https://www.quora.com/profile/Tianqi-Chen-1" target="_blank" rel="noopener">Tianqi Chen</a> mentioned, RF has traditionally been easier to parallelism. However, that is not a good reason anymore given there are efficient ways to do it with GBMs also.</p>
<p>(<a href="https://www.quora.com/When-would-one-use-Random-Forests-over-Gradient-Boosted-Machines-GBMs" target="_blank" rel="noopener">https://www.quora.com/When-would-one-use-Random-Forests-over-Gradient-Boosted-Machines-GBMs</a>)</p>
</li>
</ul>
<hr>
<h2 id="篇三：XGBoost"><a href="#篇三：XGBoost" class="headerlink" title="篇三：XGBoost"></a>篇三：XGBoost</h2><p><img src="/2020/07/25/决策树/1595667573239.png" alt="1595667573239"></p>
<blockquote>
<p>本部分内容参考公众号Datawhale<br><a href="https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/LoX987dypDg8jbeTJMpEPQ</a></p>
<p>以及文章：<br><a href="https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A</a></p>
<p>XGBoost原论文：<br><a href="https://arxiv.org/pdf/1603.02754.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/1603.02754.pdf</a></p>
</blockquote>
<p>（注：以下内容只包含XGBoost部分，LightGBM部分可见原文链接）</p>
<h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p>XGBoost 是大规模并行 boosting tree 的工具，它是目前最快最好的开源 boosting tree 工具包，比常见的工具包快 10 倍以上。Xgboost 和 GBDT 两者都是 boosting 方法，除了工程实现、解决问题上的一些差异外，最大的不同就是目标函数的定义。</p>
<h4 id="1-1-数学原理"><a href="#1-1-数学原理" class="headerlink" title="1.1 数学原理"></a>1.1 数学原理</h4><h5 id="1-1-1-目标函数"><a href="#1-1-1-目标函数" class="headerlink" title="1.1.1 目标函数"></a>1.1.1 目标函数</h5><p><img src="/2020/07/25/决策树/1595667719081.png" alt="1595667719081"></p>
<p><img src="/2020/07/25/决策树/1595667791401.png" alt="1595667791401"></p>
<p>👆 <span style="color:blue">以基模型为回归树为例，我们的目标其实就是训练一群回归树，使这群树的预测值尽量接近真实值，并且有尽可能强大的泛化能力。前一项表示的是预测误差，后一项表示的是树的复杂度函数，$f_t$表示第t棵树，一共有k棵树。</span></p>
<p>我们要做的就是使<strong>预测误差尽量小，叶子节点数尽量少，预测值尽量不极端</strong>（什么叫预测值尽量不极端?举个栗子，一个人的真实年龄是4岁，有两个模型，第一个模型的第一棵回归树预测值是3岁，第二棵回归树预测值是1岁，第二个模型的第一棵回归树预测值是2岁，第二棵预测值也是2岁，那我们更倾向于选择第二个模型，因为第一个模型学习的太多，有过拟合的风险）</p>
<p><img src="/2020/07/25/决策树/1595667837751.png" alt="1595667837751"></p>
<p><img src="/2020/07/25/决策树/1595667861205.png" alt="1595667861205"></p>
<blockquote>
<script type="math/tex; mode=display">
g_i=\frac{\partial\ l(y_i,\hat{y_i}^{t-1})}{\partial\,\hat{y_i}^{t-1}}</script><script type="math/tex; mode=display">
h_i=\frac{\partial^2 l(y_i,\hat{y_i}^{t-1})}{\partial (\hat{y_i}^{t-1})^2}</script></blockquote>
<p><img src="/2020/07/25/决策树/1595667888425.png" alt="1595667888425"></p>
<p>又因为有 </p>
<script type="math/tex; mode=display">
\sum_{i=1}^{t} \Omega(f_i)=\Omega(f_t)+\sum_{i=1}^{t-1}\Omega(f_i)</script><p>并且$\sum_{i=1}^{t-1}\Omega(f_i)$在前t-1棵树已知下为常数，所以目标函数可写为：</p>
<script type="math/tex; mode=display">
Obj^{(t)}≈\sum_{i=1}^{n}[g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)</script><p><span style="color:red">（最优化目标函数，就相当于求解$f_{t}$）</span></p>
<h5 id="1-1-2-基于决策树的目标函数"><a href="#1-1-2-基于决策树的目标函数" class="headerlink" title="1.1.2 基于决策树的目标函数"></a>1.1.2 基于决策树的目标函数</h5><p>我们知道 <span style="color:red">Xgboost 的基模型不仅支持决策树，还支持线性模型</span>，这里我们主要介绍基于决策树的目标函数。</p>
<p>下面讨论基于决策树时，$\Omega(f_t)$ 的表达式。</p>
<p><img src="/2020/07/25/决策树/1595667950419.png" alt="1595667950419"></p>
<p>(注：这里的节点权重$w_{j}$指的就是该叶子节点的预测值)</p>
<hr>
<p>另一种描述：</p>
<blockquote>
<p>参考 <a href="https://mp.weixin.qq.com/s/AAKPSIHk1iUqCeUibrORqQ" target="_blank" rel="noopener">我的XGBoost学习经历及动手实践</a></p>
</blockquote>
<p>现在定义$\Omega(f_t)$：假设我们待训练的第t棵树有T个叶子结点，叶子结点的输出向量表示如下：</p>
<script type="math/tex; mode=display">
[w_1,w_2,...,w_T]</script><p>假设 $q(x):R^d \rightarrow \{1,2,3,…,T\}$ 表示样本到叶子结点的映射，那么$f_t(x)=w_{q(x)},w∈R^T$.那么我们定义：</p>
<script type="math/tex; mode=display">
\Omega(f_t)=\gamma T+\frac{1}{2}\lambda\sum_{j=1}^Tw_j^2</script><p>其中$T$为叶子结点数，$w_j$为叶子结点$j$的输出，$\gamma$为系数。</p>
<hr>
<p><img src="/2020/07/25/决策树/1595667972342.png" alt="1595667972342"></p>
<p><img src="/2020/07/25/决策树/1595667995025.png" alt="1595667995025"></p>
<p><img src="/2020/07/25/决策树/1595668020156.png" alt="1595668020156"></p>
<hr>
<p>另一种描述：</p>
<blockquote>
<p>参考 <a href="https://mp.weixin.qq.com/s/AAKPSIHk1iUqCeUibrORqQ" target="_blank" rel="noopener">我的XGBoost学习经历及动手实践</a></p>
</blockquote>
<p><img src="/2020/07/25/决策树/1595822346216.png" alt="1595822346216"></p>
<hr>
<p><img src="/2020/07/25/决策树/1595668057942.png" alt="1595668057942"></p>
<h5 id="1-1-3-最优切分点划分算法"><a href="#1-1-3-最优切分点划分算法" class="headerlink" title="1.1.3 最优切分点划分算法"></a>1.1.3 最优切分点划分算法</h5><p>我们刚刚的假设前提是已知前t-1棵树，现在我们讨论怎么生成树。根据决策树的生成策略，在每次分裂节点的时候我们需要考虑能使得损失函数减小最快的节点，将分裂前损失函数减去分裂后损失函数称之为Gain：</p>
<p>对于某个节点，有</p>
<script type="math/tex; mode=display">
Gain = \frac{1}{2}[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}]-\gamma</script><p>其中</p>
<script type="math/tex; mode=display">
G_L=\sum_{i\in I_L} g_i, \quad G_R = \sum_{i\in I_R}g_i, \quad H_L = \sum_{i\in I_L} h_i, \quad H_R=\sum_{i\in I_R}h_i</script><p>$I_L$，$I_R$ 分别表示分裂后左右子节点的样本集合， $I=I_L \cup L_R$ .</p>
<p>Gain越大越能说明分裂后目标函数值减小越多。</p>
<p>如何找到叶子的节点的最优切分点：Xgboost 支持两种分裂节点的方法——贪心算法和近似算法。</p>
<h6 id="1）贪心算法-精确贪心算法-Basic-Exact-Greedy-Algorithm"><a href="#1）贪心算法-精确贪心算法-Basic-Exact-Greedy-Algorithm" class="headerlink" title="1）贪心算法 (精确贪心算法 Basic Exact Greedy Algorithm)"></a>1）贪心算法 (精确贪心算法 Basic Exact Greedy Algorithm)</h6><p>在决策树（CART）里面，我们使用的是精确贪心算法，也就是将所有特征的所有取值排序（耗时耗内存巨大），然后比较每一个点的Gini，找出变化最大的节点。当特征是连续特征时，我们对连续值离散化，取两点的平均值为分割节点。可以看到，这里的排序算法需要花费大量的时间，因为要遍历整个样本所有特征，而且还要排序。</p>
<p>步骤：</p>
<ol>
<li>从深度为 0 的树开始，对每个叶节点枚举所有的可用特征；</li>
<li>针对每个特征，把属于该节点的训练样本根据该特征值进行升序排列，通过线性扫描的方式来决定该特征的最佳分裂点，并记录该特征的分裂收益；</li>
<li>选择收益最大的特征作为分裂特征，用该特征的最佳分裂点作为分裂位置，在该节点上分裂出左右两个新的叶节点，并为每个新节点关联对应的样本集</li>
<li>回到第 1 步，递归执行到满足特定条件为止</li>
</ol>
<p>那么如何计算每个特征的分裂收益呢？</p>
<p><img src="/2020/07/25/决策树/1595668137245.png" alt="1595668137245"></p>
<p><img src="/2020/07/25/决策树/1595668154967.png" alt="1595668154967"></p>
<p><img src="/2020/07/25/决策树/1595823332714.png" alt="1595823332714"></p>
<h6 id="2）近似算法-Approximate-Algorithm"><a href="#2）近似算法-Approximate-Algorithm" class="headerlink" title="2）近似算法 (Approximate Algorithm)"></a>2）近似算法 (Approximate Algorithm)</h6><p>贪婪算法可以得到最优解，但当数据量太大时则无法读入内存进行计算，近似算法主要针对贪婪算法这一缺点给出了近似最优解。</p>
<p>对于每个特征，只考察分位点可以减少计算复杂度。</p>
<p>该算法会首先根据特征分布的分位数提出候选划分点，然后将连续型特征映射到由这些候选点划分的桶中，然后聚合统计信息找到所有区间的最佳分裂点。</p>
<hr>
<p>另一种描述：</p>
<blockquote>
<p>参考 <a href="https://mp.weixin.qq.com/s/AAKPSIHk1iUqCeUibrORqQ" target="_blank" rel="noopener">我的XGBoost学习经历及动手实践</a></p>
</blockquote>
<p>该算法首先根据特征分布的百分位数(percentiles)提出候选分裂点，将连续特征映射到由这些候选点分割的桶中，汇总统计信息并根据汇总的信息在提案中找到最佳解决方案。对于某个特征k，算法首先根据特征分布的分位数找到特征切割点的候选集合$S_k=\{S_{k_1},S_{k_2},…,S_{k_l}\}$ , 然后将特征k的值根据集合$S_k$ 划分到桶(bucket)中，接着对每个桶内的样本统计值G、H进行累加，最后在这些累计的统计量上寻找最佳分裂点。</p>
<hr>
<p>在提出候选切分点时有两种策略：</p>
<ul>
<li>Global：学习每棵树前就提出候选切分点，并在每次分裂时都采用这种分割；</li>
<li>Local：每次分裂前将重新提出候选切分点。</li>
</ul>
<p>直观上来看，Local 策略需要更多的计算步骤，而 Global 策略因为节点没有划分所以需要更多的候选点。</p>
<p>下图给出不同种分裂策略的 AUC 变换曲线，横坐标为迭代次数，纵坐标为测试集 AUC，eps 为近似算法的精度，其倒数为桶的数量。</p>
<p><img src="/2020/07/25/决策树/1595668243451.png" alt="1595668243451"></p>
<p>我们可以看到 Global 策略在候选点数多时（eps 小）可以和 Local 策略在候选点少时（eps 大）具有相似的精度。此外我们还发现，在 eps 取值合理的情况下，分位数策略可以获得与贪婪算法相同的精度。</p>
<p><img src="/2020/07/25/决策树/1595668320876.png" alt="1595668320876"></p>
<p><img src="/2020/07/25/决策树/1595668340241.png" alt="1595668340241"></p>
<h5 id="1-1-4-加权分位数缩略图（weighted-quantile-sketch）"><a href="#1-1-4-加权分位数缩略图（weighted-quantile-sketch）" class="headerlink" title="1.1.4 加权分位数缩略图（weighted quantile sketch）"></a>1.1.4 加权分位数缩略图（weighted quantile sketch）</h5><p><img src="/2020/07/25/决策树/1595668403168.png" alt="1595668403168"></p>
<p><img src="/2020/07/25/决策树/1595668446774.png" alt="1595668446774"></p>
<h5 id="1-1-5-稀疏感知算法（缺失值处理）"><a href="#1-1-5-稀疏感知算法（缺失值处理）" class="headerlink" title="1.1.5 稀疏感知算法（缺失值处理）"></a>1.1.5 稀疏感知算法（缺失值处理）</h5><p>实际应用中，稀疏数据无法避免，产生稀疏数据的原因：（1）数据缺失；（2）统计上的0；（3）特征表示中的one-hot形式。</p>
<p>在决策树的第一篇文章中我们介绍 CART 树在应对数据缺失时的分裂策略，XGBoost 也给出了其解决方案。</p>
<p>XGBoost 在构建树的节点过程中只考虑非缺失值的数据遍历，而为每个节点增加了一个缺省方向，当样本相应的特征值缺失时，可以被归类到缺省方向上，最优的缺省方向可以从数据中学到。至于如何学到缺省值的分支，其实很简单，分别枚举特征缺省的样本归为左右分支后的增益，选择增益最大的枚举项即为最优缺省方向。</p>
<blockquote>
<p>假设样本的第i个特征缺失，无法使用该特征进行样本划分，那我们就把缺失样本默认的分到某个节点，具体分到哪个节点还要根据算法：</p>
<p>算法思想：分别假设缺失属于左节点和右节点，而且只在不缺失的样本上迭代，分别计算样本属于左子树和右子树的增益，选择增益最大的方向作为缺失数据的默认方向。</p>
</blockquote>
<p>在构建树的过程中需要枚举特征缺失的样本，乍一看该算法的计算量增加了一倍，但其实该算法在构建树的过程中只考虑了特征未缺失的样本遍历，而特征值缺失的样本无需遍历只需直接分配到左右节点，故算法所需遍历的样本量减少，下图可以看到稀疏感知算法比 basic 算法速度块了超过 50 倍。</p>
<p><img src="/2020/07/25/决策树/1595668537184.png" alt="1595668537184"></p>
<h5 id="1-1-6-避免过拟合-正则化、shrinkage与采样技术"><a href="#1-1-6-避免过拟合-正则化、shrinkage与采样技术" class="headerlink" title="1.1.6 避免过拟合(正则化、shrinkage与采样技术)"></a>1.1.6 避免过拟合(正则化、shrinkage与采样技术)</h5><h6 id="1-正则化"><a href="#1-正则化" class="headerlink" title="1) 正则化"></a>1) 正则化</h6><p>一说起过拟合，我们的第一反应就是正则化。XGBoost也是这样做的。</p>
<p>我们在loss_function里看到了正则化项（树的复杂度函数），正则化的目的就是防止过拟合。我们再看看这个函数:</p>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjMAAACzCAIAAADzHwpkAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAAEnQAABJ0Ad5mH3gAAFwiSURBVHhe7d15vJdVtT9wKnNGIBAR1HBIvSYOYdcUbqJeTG+iKQ4vSAU19abQIJqFN4GuoCJoKTmQKVpKKpiC9+dQlDmAGKiJA+CEA6AMoiIq5r3+3t/venh8+J6BAxzgHNyfPzb7Wc/aa6+99tpr7fU933P43CeffNIkISEhISGhweDz2b8JCQkJCQkNAykzJSQkJCQ0LKTMlJCQkJDQsJB+zpSQ0KARJ/Rzn/tcPBaRH95q3yYkNF6kmikhISEhoWEhZaaEhAYKJVFeFf1fGfmjTjwGUP75z39qEcvvExIaN9KneQkJDRTFs1lOTKWskxM/97nPfeELX4g+fP7zn1+6dOkGG2xQJCYkNFKkzJSQ0EARZ7PYFrNOFEkSkvbZZ5/deOON27Rpo/3iF79Yfp+Q0IiRPs1LSGjoiPQD/1tAEKOQko3efffdzTbb7MMPPywzJiQ0bqSaKSGhEWDx4sUbbLCB9LPRRhu9//772rlz53q87777Pv7446effnrzzTcfMWKEomqLLbbIxiQkNFqkmikhoUEjyiBV0cYbb/zRRx/985//VDAplZYsWdKqVSuVk1ebbrrpggUL0OMjvoSExo5UMyUkNAIojz73uc9deumlktPrr7+ubdmyJfqYMWO23HLL/fffX666/vrr58+f7zGGJCQ0XqSaKSGhQSPKoA022CCvmT7++GN5SIWE3rp1a4/xMydpKf+JVEJCo0aqmRISGiiKZzP6CxYs2GijjTbZZJMNN9xw0aJF8lO3bt3Q/+Vf/uULX/jC0KFDZalWrVqVRyQkNGKkG1ZCQqOBtPTFL36xlr9FlC6aCesHUmZKSGgckHU23XRTmUl5VJGB5CoUSH9AL2H9QMpMCQmNA/E1vKiZKjIToMTvNiUkrAdImSkhoYFCBsproOiU66JSTopXclV0iq8SEtYDpMyUkJCQUM+IiwJkzwkriZSZEhIaJUS9/1v258bjsaKTsG6RtmN1kDJTQsL6gPxjvYSGgEhIkD9GJ6GOSJkpIaFBI1JOVWSva0CExUBGSlhbKJo9+qrbjz76SAtLly7V9+rtt98OnoSqSJkpIWF9QF3SVcJaQyShPD/BhhtuKCfBRhttFPTmzZunvw1fE1JmSkholIjAlyOI2UOqkxoAYhfy7fjggw82KUNHcoqCaeONNy6xJlRBykwJCY0eEfuKnYaPcsReDtmL9QKxIreHeFTO5jWTDnqzZs3Q09+Grwnp7+YlJDRKLFy40OGNv5u3yy67fOELX7jkkkv+93//t/i3xouf7zWoz/oi7GirarV+fCb59NNPL1my5Iknnnjvvfd0rLRp06bSUt++fT/88MPNN9/8448/jv/pcdNNN83GJBSQaqaEhEYPgS9HRmrwyNQtIHvRyJH/6EhHbfT+++9/9NFH6iQZN/7vx/hYLyjBmVAVqWZKSGiUKP6t8a985St5zdS6detggGLsa1BxMFIRVNWwscfr55577q233nryyScVRl27dt1iiy1s09tvv33DDTdIUQ8//LD21ltvxWmn7NoXv/jFGJhQxDqomTKXLCB70XhQ1Dn6VVeRf8ScUHeUvGF5ZC9WhIy7OmQcjRbZMsrISFUQryoY6hjiy4IzZKQqyF6XkZFWFVUlrL7Mekd5oRkyUp2xdOlSlgcdw1VO//znPzfaaCOvJKFizVT1L/Mm5Firmam80dXsRE30QLytHRlrFUQ1rcNLtPHzRm02rIwSXw0wHLM7DmfyuHjx4vgPrfOBkX6K/WjDKTHHq4S6IGxVYTGPdUG1zEVi9BsXiprrcK0igp4jPHzjjTeOsAgxvFrEkGr777zzjpbDZ9OUEW+rojy0GngVH2oZGxTqoThKITCIEELQ4eOPP65F5lpD6KCtimCoHU888cTf//73SZMmPfjgg5tttpkM1LJly6ZNm5544ondu3d/6aWXpk2b9thjj02cOBGzJceohAo0gpqJT+fISLUiE7oMcTFxUN977z2dyDF1AU5+45rDt+LLnfwsqu/Pf/7zXjlpxKLnUSDuRxKYKxIinrpPlwBhxiKyFytCxr0McScIZByNFrEKK4K4J1U9C7HMaONtBPqwQ5mlRpSkF8DDEXl49lxAkT/6tYAEGYjC8ehEOESOUpydUC9eOSleYYijWhfhaxRxqHOsrEpvvvkms+sIOBbFAsKCIomQzTffXEDYoAymEEnS1x9qQiP4BgSvzVHhNEWEAzkM0UKcTB7gGHB6xdPbb7/tbX4kagdn4jrGcizgZ5yMEL6l41XoQ6BHE82dO3fevHl8jjsGc/K8tQkbER1bH531CRw4whnv4pmQvSgj93yIk4KN+xlSy5EpItgIMUobA2UR0FlZk1KDBKfAwXFRcy4cEB3HJ85F5KGceeHChWo1/BjqqHC9gwI5wpjZi5VE165d99tvv912223bbbfN449FWTWZe+655+677269ixYtisCSDUtYHusmM9XF+ewicBGwwTmCDhnfMpAJDhI/wJZfGBF10B2J+fPnO9J18QYD8ZvaAXPOjdKJ0x59MjGATjam/G0cs7/77rsSEh46VNxtE9YObJ+9yx7WF1gUj+JyfAzC28teX0Lej7fYMDNCHIFMxIqAn4fH1S2kQbwCorQVxGoRh8JxoEZkIK0Y7ezomAUdkRx9zG57Wm+bNm1aGr8uEOsKZKQ6gE3CLDkc+QULFrgEs6REa0U6sV59NhEZwhpxh4hRCRVYN9/N444Okqk5gVO0ZMkS9ymPXNOj1kZiaN68eX6xMiQ6OaWIojOR42jFumKKKVOmaCdMmEDyOeecw3XQ+YSOZBOjKlAcrhOf7MVvIaiN6EYUD+Ne3C5U+vOf/4z++OOPezzllFNatGjhDmhISVxCzWAlFrMdFZuYG7+OwGyb7Is+b7G54U72KBgaKdghby2Hj3E8rcUiHn744ejt27fnh7/61a/0I9gFf10MWJSPn+lIjs+dHMwvfelLWsfEK5NqoTyuhGK/CHpScsaMGdpHH33URhxyyCEUs9GGSELo2Eyqb8Y777xTEO/QoYO5DjjggBCylnH77bdHttB+85vfRKFqaKhP81g+PZ9++mntv/7rv6IwOyKUZZTA8WILJCEdKUoc8/jSSy9h3mWXXTBMnDhRu/feexMebxMqsA5qJpHIfoDtjKsEKDJsVVzWeK1TYV+5CIcI2FR0Hb4SiIFVYaC3+OM4aaU9RwUxPi5ACdehA+YYVYFwtdzhTL3FFltgJtZBohhpiNRG4aA0NwVOnfBXy/HWFCEhoSbYU/aMrY+d4hUsz8JMXXcYztpGQXxUgkJyaY7GDwYBi2IoC8yoy1A+IqVaxFvWy70ut0xdEFOQ45jYCA5sOs6Mwozh5xlrHUAUCZFKKSw5xV7oBwVyTqfSo/PSsmXLIK59WKATHa3HsjFK1oi1M6ygxLaURKRnOGr4bRFiC7tBBJlIPPITznfffbdZs2akeRt31pSWakI91ExVJdjRrFcDbEz8jvQDDzxguNuEdrfddjPQFmpfe+01Z2P77bfX9u7d28WtTZs22uIxq/acxNTY4nw+//zz3Gjw4MG87brrrps3b167du24FC/ZbLPN8NQSuYrrmjNnDpm/+93vyOReZM6ePZsCJ554ogrd3SfkkHzVVVc5Zq1ateJ5PXv2NKqW85xPsUKLrcdgBFayU2z74osvujcsWLBAGwGi7nDgeYvAoW+4UMh/tPYiGBopin743HPP8bGI+O+8845XRxxxBPquu+7KhS666CIuvdVWWzFFGDBqKc4ZTlitvxXlh+QnnniC3YYNG+aVWgf9sMMOE2e5tLbIX5PfEmLShx56yClTM6GcfPLJWlqV32cf94GjRMhll12m7dy5M4paJF6tZdx00010tkAWs958aRJS5KegSNuDBg166623fvGLX2C2wHxRAWzim463ecEEP/jBD1jVW3s0fPhwYcRll8euww8wGzLWRs1UdGUQuCUGvssD4q6EKKA4FeGv/KB05SgXKBwiLjK5Z9QO0kgm36g4RfyGMxH+xhtvOLTOs1NqOtK8zU9I7aCAW1KoZBThWn2+Fbp5jKxpavIJl3fNW5e09BkHW9lxG6HjJNu+8A32XCnEFmjBLtssAiuiRmOHRXEwC2SxWGnQw83Y0FuBD5jC8rm9fjh5zlwL4rgJl+KmsabzSHjE31qcuQKm1sbscRwEZecx3gZCH6/AeQz5dVFyDcFKA3wvI5VBc0QLsRyP8QVdt+SIMxSmf3AGGM1KQScvmLQk6ETE8Eqaty8pLdWE1aqZahmb75YTouVztsHtw17++te/trUXXHCBrVLH2KEDDzyw4mJLsrB+7733GnjcccehDBkyZP78+e4pJHAUo4qz59OFo5hUzuNJp5xyCqc/44wz8Ktsck5tsNV+2AhxYGj705/+lA9FhvvGN76hf9RRR+mrxhxmVV2uPx5tr169OO65556r7dSpE+cOf6WeSSNSWEUoU4Fqiesx3BhatGhx/PHHL1q06O9//zt79unTx67pMH7ELFU1o9l9/OWt+1z0VUW8iJGjRbnxxhtxvvrqq5KTytsO7rzzzqVpVhvE8oToUMCG6tvT2l1oNcFhOLyOqU109dVX87rwbfZBEeaizel0428CKNN973vfC5fT1uRvNWHcuHHNmjU79NBDyef/1Ojfvz81yMk4avZV20GlyZMnm/epp56iwH/+53+i6wQDeGV44JprrvFq3333Zdt1VTONGTOGSlxRe/DBB9Mq6Hknh9iFeNppp7HM1ltvXZWB7zGdcIeB9955550LFy6cPXu2lH/xxRdzVGaMDa06NiGwpg6V3XXtclQ4NOs7xnbCVjktjk2EEhsD8+bNa9269SuvvJKNLMMoPJzb8fNoiFbFQ4Jdt9kRhqqFV+bVMaM+n4g/61sBGpo9e6gODjlttfo6VIooSSYdIm5yNSq5QMUQaUkK1FmwYEFYwBJCeWCEyM35uhKANcKeselMqjyNrRGnUGyBsMXaNpQxGdZjnh70jWV2cvTFTQwExpkv/nnT1QSVTEoZanjkDBCv1hyswrqAceL4WCxiLL8IWjERBnrq60hO7GOgxxiVCa0byDHKem2BqVmYHBbOXtcKY2vnDJ0he25g4EKQPawkRDYBh91Yz46ww1tvvaVUYkbeO3fuXDxeMablr85E6zfqoWaqKiEcLlpv42zYsKFDhzpRqh+Pv/vd79S2aho8Iriyt+jKEZgUSaqTu+++2wE78cQTUX7+859rBw0aFKe0xFoD3ICc57vuuotP/Pd//zc5Ib94GGo/GBEQXeTj3i3k3Xbbbc4nryKzY8eObdq0GT16NJ4uXbqIp6R5G8npnnvuQcdv+SNHjiTN5TrEojMFO+QUqLtW6x+ef/55DqBO4g8TJkxgWyZyhvkAU4QnqIFY+IgjjmDerl272oJLLrlEKwSwZNQKBuJ89NFHDb/++uvx/+Y3v+E522yzTXme1YWt5HWqN/O6Kcf2kb+mP5AxaaQWfZ4TRMoA+3DycBiPFg4oHnGCM4KiU4u/1YQlS5bw+b59+1LgueeeY2Rnyr6oUzOOmuWY1CsVMK3+8Y9/eIyayWMwQOivo21oNdNBBx1Eq1AvUOznNZO2Xbt2GXUZDJeE5CRmF39EthdeeIENv//979tEQ9DVTywpUMRNIhuZUMAaNIpDa4c4HNPr2yqt/QB0ju68cURbZcPEpmxYGUbF7sbBs4WIaiYFEGIFcwUEL2N1zMsJlC+rFjuENqoKeVrXzzjnoXzc8R11XqjgsxYLMaRYM2npGWwlcWWDkIbTgS+GiUYE661A9mI14OLCSkxqrwl0FZBjmMi+e2R2Bo/Aik0qYkbEiH3oOujMbrh+tOzPuwyvx5qJP9CBWPrwqNLiy/+1QfZ6jYHLsUbYweogYpk2rKTPDpRB8VaHBeJxdfwt0qGQal4eHj9fITl7XStCw/UejJz1CmAuMYq32IuddtrJxnnkJ7aAWcQEW4ZiUwz3NhuWsDxWq2YKVCshiPmrhx9+mHP/x3/8h2PWuXPnli1b/vKXv7RP8dsSIpEDUDw8TpRHgV4yiE9mTj/9dGnJjVhguvXWW72N3+TIkc9FlP0++OCDRav4zs9XvvIVdEcrGCDOc+1wCM01ffp0xfi3v/1tAfR//ud/+NM+++zDsSjvzFNPJHXP4o7hahEj6M8v/+Vf/oUOF198MWnWrvWK2Di3RR1q6jcohIW1VTVcHZ1vvPFGW7bDDjuwNjsHMRcY9nzwwQf1v/Wtb+lfccUViO7y+jrBBhzMFrzxxhvMO2rUKPb/4Q9/WLwZrD644vnnn29SFRtPRtGvR/nVIsxeFUWbF3kq+iv0t5qAx46MHTtWVD322GN5+L333iuwHnPMMTmDNp+uqswpU6aY/cknn9Q2xpop6FXX9fOf/5xJzzjjDDpvu+22xUWBQCH+qPJ59eTJk0WAww47TMsVvVU/8Rx04Uj1T3jsTkIF1pJRhAkXLgHdtkUesp22SgT3KLhXHO94tHm2TWsvZSlOI/rwBhRnhhMTkiMGAk7TgY6DBPh5Rva6zjC1rGkimscHktttt50lUBgxvkVmIeHKQDds5sVjam8jY5kakTQIsSG/MSJWWkT2YiWRDS6D3Zo3bz5//nwWzl4v+0Fj2DP8hEltPX6PLGwLGD/jLsMtgakNwUMUO+Ovxzvp66+/TqW4lPBPKpFPvex1Q8Xq+JvFWqkTFPZkcDVoedM+Rcb6mUQsv8IIbAUuMTyWQzKaizg/4TDyEP988803xRCj+E+jjgZrFGvJLrfffvukSZMcbLfa3XbbzeXIljRr1syjDbN/IkhxgyMSIdpXJYtXe+21l1Px5S9/2eX6/vvvdyXxFuw0RMyKse5oOTp06OAK5miZmlvkCM7aQQczTp061QWnffv2W221VZRH0pXWo3gaGVSWcoYjA5mI5m3btrU6d/xTTjnlpptuuvvuuxV8XoXkQKZKGRmpMWA1tY0DCXYtdnDChAmuq6ql+HWWAEuybdhT6po2bdqLL75oamnJ/cB2RB4qGy8DTpeVuXPnKpvYv3Xr1jaoHj9tM11ckuw1NehPPTNmr9c7WBpX32mnnQ499FDH0Jb9+c9/vu6668oHrpT+UbSQDagCm7LKkbcWsQ0H1So5c+ZMl5hTTz31rLPOEqZeeumlq6666tJLL73llluGDx8+aNCgyy+/nAE5J//h/9mwhOVR/5mp7KuVGyYDgSMd4cPBFjK4O9/FzH11MtYycOLHBu4XgpTwJB/YyDlz5shPkoGBedlkSH4G7Lfc4E6tUy6Z3hVTyAnOQHAGMlIZGamM0Na8JPMkrXkRaY5OfjmulhxLEtKRyehDbfErFIuaSQylidZNKiQ3HMSqi8herDFEtGIuJipnqFJ0YyWvog0wOB4U9mS6uKkEpy0AlCI/2GUWJhbCGQiPDaoXuAUr7Ox7+KEpgA9nr9c7MKY0zPhOUL7YVq1ahYWBEexmxcldfdg17Uq5YgypCSsUlTPULqeOYChyhCkey4ZxYY0PitiK0bzyyIHN61U2LGF51ENmCu8E/XyPdSAiRURk/m1XPHJumQZRfLEx0dfJpJRhrLda22ysGKRGkQBs9pe+9KVHH33UrQRbCMcWLiWcIT700EMzZsz4Xhnbb7+9PIHHwJJay1BSbtnlvUih4eLyF8GVRyAYEeXiQ84+++xDGRmOKAz6kpZHuunTRN9EobCOEPa1r31tjz32uO++++655x5sij+veCQeE5WnzVBedIaMtOZhvXmbo2yG6k9yrl50rIKJdCxNyGa3BWU4eB4J8TZEqRcjgrNJ2NzmGmUTH3/88ZNOOqlnz56ukC0Lf5mGcC6BU4fk+A9vOnbsuOeeezrVfMC8DO5tDqNYVYentWnTZueddzZFPZ58GvIlPvbmm29STMq06RaSvV5jKBu7GmSvy8hItSJjrTNsmcUqT13IfvKTn5x77rmjRo361a9+9dprr82ePZtAJ7fsLNUgJOgwVPTrjpAQiPBtH9E5lf3Vvvzyy8RyMwcQJXjsBSIEhadp9Y1F9FYHxeFVUgMK5NPhtF4dFDubm2sV7Pbcc88JQf369fvOd74jgKg7KcxovH3evHk77LCDsMCBFaOUzMYkVEE9ZKYKxE7r8AN7r+UTNlvIiDY8hrsEf11AYDicekXQFw4MJwo9kgFgc5DMaNflAHPhyROSm0tZrwxBDGSkMgQ10cco/C6M/FIcpL9XhFPARCRHvPOWVuKjE5JTyiJLoJj7ZpRTxmrpFspjc6ozvnWKWHUR2Ys6QL5haufZuiKpGG5dTBR2YEOr1lFkxE8KvcXMGjjZQYgX7hkQJxsWrUcInthEtrUvcl4YmUmNCjZDcuB31Fk4+hA8awIUsxATmS4jrV+wNJsVy4wbmB1Et15EJ8IGxW2j3hGRQWsH7XhEDy2HMSOP4mz8gc84X9SLA8Wp7D4fM+Tt8l84Q9cnBE9sk4VgsBByUMjUMdBacIJR2PCX9ChjFbzIFGTSWbDS5gjldagdq8sGJFSHevhuXg6icmk6EaHCLf7rv/7L4/Dhw+3ZeeedJ/r37ds3Qn/wVyCXA/KBxwsvvJCokSNHcqATTzxRO2jQoMhV6OSQzyO13bt3b926dfzlq+9+97sk8BUthyjLKyHmLc4SfZcdnUsvvdStyu2GNAHRMRCC9WUpOk+dOpX+VsTJDjnkEKsLd8cQoiCkPfPMM1rFFp7Jkyc7CR06dKAzTaIt864zUDIQ1ijuRbFfBOast4znH//4h0hxwQUXtG3bdvDgwYggefTq1UvhYq8lMAxu2e3atXOFtF8Yxo0bJ3Dos+2BBx6oKoqvdxeDAqOJNQpW5j322GO96tKlCwXsjkDJetqq+jjzeadMLiW5oKwmKC+yWKP2sssus5uRerlixtEwULRJsV9EXQzC7DyckW3E+PHjeaw91TqD9s6OeJUbGYoyo79q383be++9zRuG9YoafICH3HTTTZKlM45HQezEHXPMMdxGSMEJNhqzgfF3FpxN7ZFHHonCzbwdMmSIsX/7298c5+uuu86FyYmmAAZC7r77bm+5rja+SWv2UDj0zJF/N88oBSXNiwyGACIwVEYtA4VKRvEcjyEcKuQnQP3XTDk4cbR2mnPbSy3YGxSbFPuRb09NCP+wnUTFNcR+G45IWvAQruVheDicmgkFD08NhnCFFSLinbFbbbVVyI8PA/XpTLg+BWJeium4ChHubUjIQQhpxZoJCKe8URUuWwtWaJ96Qd3PRs7pBqplDVFDWpKB7A4Kiy1atMjlQLB48cUX1TeMs/XWW7NeHHvWsHzBwgaJNRBpKQQWwVB4yJEVyGc9RELiLTBODpJZmNnrvpZVQAjXWrhOON56Cd5rjazKw1leJkBEgTh9FR9GoWS9+oPZHa6ogdxsTMHZtGKI2bfddlsHnJ52AScHoypvCX56hsNAbBMHM9xCsPFSQiIWcTPEOPgG5gvRyft1R2RHahTPODkm0uHtKS3VBfVZM0FpJwsC8/7NN9/Mb/r162fbTjjhBPQRI0aIUO4s3MLexPYUx+bgPVzt/PPP50+33HILyu9+9zsb3K1bN84XwSs8z8WczPgBw/333+9Vp06dvNIpS1qxN0hp7lNz587VqnLM0rVrV63ZzaVWI5nb8S0SuHIoYGmRLDMpZfnmmjlzpmAdt6p7770Xs1t/aanlt9qMu1bgtHDz3nbbbRmp/rD77rtbxZ577ukghXHqqBW4C7MSaxtiL8hp37699b7yyiutWrW65JJLrPeqq65SdNp3qcVeM92SJUsEiLPPPlsyUzdrY++AHMYMNcKYXv3hD39AOf300x1sd2EtaQxuU9jEFOWhJStV1TyIufzVRNzW3bvJvOiii6iaz1h16gaCMOYqIAZq43C9/vrrPFwlof3KV76iVTWyAPvnFg4jFNtVq5n22WcfWUe+0c6ZM8cs8VnLr371K/vuTNn3/fbbz0AnlAIdOnSggIHk/P3vf9fuv//+2nvuuceo+A057qc/YMAAvnfrrbdixskbeX4oQBl0c3FpjwcddFBoGMuPBeZYYc2U9ZbZoXbUhecziPo5tCsE6/MhLmXb3Fa4nUsKCIj22AbzwuKOFuGVoBahX4siCBpCprFGxdZ6y+HQCedhOoIgfvNyQVOjlOXVBmPlTt5JFMlOAuEx3B2fNApTBrwNNdBNUfW+H8vJlQwhHiFe1RE5c4ytX1CbVkwXU9QRYWqrVhJZnQ2SO5lCYYTISmyITrjiSccQhjWdtcgo+lIXnm222cYoZgywbQiHGGUfDfFKhwERtehERettwOOqYWXHxtT0yR+Dsr4iNsJR1Vo1b3EoBHp2U3/ErqEDztUxhbGxF+TwCg7GVfiV6ZTU9n3evHk8Klo+ho3j0cQQDhNTcypalcSV+y4T0cfgNonfQLOQRkjOaS4tgUVniL511bKo9Xvr1y1WLkquELm06OSP7lzaHj168AnRipdcf/313OWrX/2qWBYhCapVxqWbOx577LH8lWO1bt3aPXr+/Pm77LILvyEEnQSSX3vtNS2ZiH/6058Qv/71r+NxfsLv0UNmTS6Fh0M3a9aM4z766KNOBZ2148ePJ6Rz585xUMkJaabg1qYIYllGCeR7fP7555s3b+5W5Tz/8Y9/RDnqqKNCk7r7NOaomZ566qmMVH9o164drdyCtbG0FQInZdj5sMMOa9OmzZlnnql/yCGHvPrqq1YaUQPbHXfcIQMdfvjhjDljxgw23G677dDVu1bEYux20kknGWv7yoJLRqODV6FJmCj+pnj8z0N33XWXUeozfduhLepc1aRFSk0Gr/teRM2kbjNk6NChRtVxIBiS9WrVJOvVzLOyKMpcKcTAfLggTiVVglbtzgcmTZrkfrbDDjugBOyFNvj1jV2pv5vn0Wn1qI6Xk3T4jJpbFe6m6BypY9g/Kqfbb79dmrn//vtzvwo4ZeT07NlT++abb3JUdyDyeYv+rFmzBB/1lpjzzDPPUNLYcEV9MnGai5yDDz44VxURoh+Imkkdb10k5JyrhgrhCYE6BaPVB+vzBqHEXnI1ZVO07mL2mGeAVxl3md+j1q4Xaya37LgWGRhvtQK3V/rkk0NsyESPskzs45dF+bVAPMUZKYffo4TaYi6xKBEQCcRDN57tFeYYHqjq1kYZor/Kfhyi6heR8+pomRzWwg4tWrTQzpkzx9Xhrbfeiu/LRW0U2SWMr6a0ffoxixgBsfUeMQhDAVvs0cDSHMvAXEFkYWJNjWgKbQXnqmHVtqNsvPUnoFhLhR0qVhfHLY6w1kbYxChBQN8eraZBDA8PIUqHZ5JsCj4WNVM4gEcM3qKESoghASI4hCY68pBOnE1KxrXJSo3Vx1was8wHivrnFJrU4iHFIQn1i1UPlLUjxObCuQKfcF92gz7++OM53IQJE8TEAw88MHaXhwVnIEI/Z+IZOPmWGzqPvPbaa8W+4447Lpwm4y5P5NHdXGevvfbirEahxP/nH/C4Qk8qWuPGG280o5uRdtq0aYarCbJ3yztl9Itj9UG8NqpLly70v/DCC5csWXLyySejr1CNInJ+naBUoO7SQkKxZWd7Ie5ExCkxlVG7zLFjx7JwfHZ/6qmnolhmvAIyhQ/bLTT85je/MdGee+4pEOy7776S2dlnn+1S8pOf/MSMyt8IN9nI5WGInHfeeeex/80330yOW7Di2/5GlWxsXdZe5KngJxN4murWEggMSva6DMsxl1aZbl2jR4+meXyzVGgL02WsyyO8t2PHjthk4oy6PHJ9YtJ86viM4bHHHtPSqkxbMUJasS2uJS5GdkGb/73wIhtt2Xzz8t/Lp7DWwmPUiBEjbNPDDz/s7d13360/ePBgbe/evVnGSmN4SWIZiGRGzfTEE09ov//972tjOtCH6GO++uqrSYuT+7WvfS3o8MADD3BLOtNk4cKFWhHDHUitxvKXXXYZCjn2hUtQfsiQId5OnjxZO3z4cE5oIVrz8nP5zKJ4IMkqJK3VxRq1Y8aMQYkLVvH/ZwoUH/OaydTxd/OKb/N1QYWQhLpjTdVM4Qo8JsA5ELVvvPGGjn3lCnIMCl+MI1EeV4Kxdhc9HufNmxdftsEc1U/Qi/AWf9EnqmJlvcR5M6NV8ObQk3yaZ69rRa6JSTMTlFG7hmsfRTvXBRF9vlSGgQodpx3iLYSRIzAxIAZsyibZSOXEmChSmmjOAXDWMrtIJJMRIj95JNDs8V9axC6s7IZWi9gRfkWl2GuzBKQE8CoQzOj6WruJYlSZt3rg5K519JkiHAeGkgspYHgdEWPzqYF6OYRydyMbYZnBCeTTEH+cIG91TI1uv0hwSOP7Pni22morErxt1aqVa4d9N6kNih87BTK5Kw9TxPA4KQF5BXTMRTe7YxU8R/4I1/LKKH0M6JbJ2aid//zJ6mK98dYsZcOUGHCWJl7mA17FY6C0mGX0ilc50IMnod6xlizrpLn7qCE4d48ePbiFWxviFVdcEQnAHnOjYKaSR07veHC+AQMGcK+pU6fqq2NUXRgMqap5/P5QTTVTXVZa5HH/0l5zzTVa9z6ur2bi3ISjFJ01+sWxcdTFVn01k8eomU488cTiwJVCTfrXXWBIKLYUc2KZ1+5UXVFVxI4899xzER2cealCaxNzBi1pDj+e+P2wmTNnKndUD6LMrFmz7F38P8UGRmgrD62E3SRht912ExyPOOIItxN7wWe+8pWvkEnDWMIKUcu6SGABe/rXv/5VjLNBVCrWjog0pIZVx9fW77vvPvofcsghRnm03jwlVKBly5ZEde7cGT9k1Br0oUkgHh955BGrHjp0qJjLaEFcIaxFG0KKbSDqsEGDBmnzv+edK2AhVhRBXA7QCtxykurWAu3yokWLevXqxRQoDrIjTLc77rjDFBJVSCgJKsMQ9KiZnnzySe0Kaya22mOPPcgv1kx0MIQFtKqc7bbbLr53p2rHmf9lemnSI5W23nprbqnOdnOKeg7ySVnAY/z/A5deeikKz7eJ4cBkokR46dq1a6iHvzRyeUTNlP//TLn8hHrESt/makfZ30pwSMLX7T04mc62du7cuTaSHwCH4/pcKtiMCiEYoo8eFK4DPC84q7pC8Nevi9DQBY3Tx02Nqoi5krUjYkRAdMtheAUypnWEUKCW8FotHHthVxu/9WUH84XYZTuV72DccMUXF/CKmsnb8ITyuGrAW1RLzM7+0pJwaTrzehUbXY/bLY/yK5ePYu0OLBOeDB4tKh61dhPFQvSrRSR7zFZdFrYC5DYM61m1VrIsnZ+6oaxm9oEkIVXB+KF2jkzX8vdfvM1rEetieWa3QY6AUbabhHK9UfrNQnsqV1ljsJk9k7iqIJzaOrGWAOHFmsnu8CiTKqZ1MHtlFB4M1NanGCPwMX0dQtjfAjF7xKP1iI2FEWNSoEB0IIhFSrXIdU6od9SnZUOUNjqcoEwueU+c+S3Lf0J/8uTJnDu+/fLSSy85e7vvvju28J4A7xHR3HEcjPbt2xuuZsLZqVMnr9xeMbdt2xZnebYSHK3p06cbteuuu5r6L3/5C85/+7d/C4GAJ+vVDEKcybg79+vXL7zf7XXw4MEo9OfNxTtsTb5raqJee+014XWnnXYyavTo0ewQ/zNv1VG1nwGaW6+yw7ocS5I95supy7pyxFkyXEcrErGwJWuLcor65H0MEBI8Mog+lbRUCp4ASljg1VdfZa7LL7/c2kUZAUW1Ifa5g7OM6BDX8xz5XPCHP/xh22235SfUu/baa7VhPXKCAUKTuqMoP8bGioJeIS0nBn3evHk0HzhwoLZ///5Wx9liO8rsmSidaMM+kZ/K7zMUH4t9MdQuOCbkG8vrRHzpnCUzjpVHaB4gn/DWrVsTHlNEa1JvaRL6c346a4cNG8bmrpJ2bciQIZbpOLgrjBkzBt3psPy7777bzsb/MsydYiLATNpK/ZyJtPjtuogGAfzoMfA3v/kNrS644AIG4VfqNu6B7pGtHnvsMR7FW/CorgyJv+MQEHAsSiWqVbVz2vhZtYXoh69G/ZfXTN5CNn555DWTVpWmzV4k1B/WSM2UPZRzkosVimuXM8DJHA+t8+YtnxBllMMiVPBXAN1AHUdIXOB5BBoOXI0ojkV4OJA2omRZhVLw1ZbFlFDs1w4DeSr5rl1xZ+TNAmgExGJaqh2hVWiiQzdqlzRbHmXe2mC4VYsphlMG8s4qwFjGZEnbQSbhTrLHmg5hBcK80RcOhCrrigUWgSeOK81tIktilp5tImbTgbesSmBNU2+33XZvvPEG+djstU0JG2av6wlmpxJHCney75QPrXS80gbYzaKwhcUCucvhjFEQksPOhtA8KCsEOQRquRzTkaClEsV0bNnqwGapOOlPvqtezGiK6CBqrYKfc3uPOK2FPi6CcSL0BW4d0jBEWHddoy1KyKlfsF5MBIypD5Q3nRqOhohcK5hds0Qbr6TSCn24DVXDFS3QEPYk0ysCU2ppgPg00Kw+ym7zqTTOwQPitwrciVDcs5wNdK7g1untXnvt5RZ2+umnc5Ri0HESPD744INOTvwVgKFDhwptfE48PfPMM411j3MkuCZOJ4rM559/nv/tuOOOTpSaCfHAAw8MgaFYHjWKKOoM1Is8Gne3ESNGkHP88cdTyVzWUseaiSZudpLBDjvsYHXxmxbx//AWR0W/JjmGGCsU0ufCCy8k05LjuELwUC86dQTdHE6n1ELiN7RYKSyZcVSnIcSMWhStQ24U4wN6BVuAJYlV68hJhx12mF37wQ9+gNOiWNLmig5RmAaK8w4aNIj8AQMGUPiBBx6gcLdu3cKwGUeVvVshivJjbJGSw6uqVp0zZw5V7YJVxE9fLFwbO1JVDvtg8Ba8zVUtchb7liboc5iImF7lYrXRWR3E513kZ89lV9cWKYyMeMUVV8SnFAL9tGnT7J1Ky7mzELv2+OOP85+vf/3rTGR3OKedYpOixWhuvXWvma655hrCO3TowGLaoAMisXGFOuuss5hIBEBUz9HTdogJhuvceeednO1HP/qRUePHj6fwLrvsEkIAm1bVpVVLmfqrX/2qPoGl12UUayaVfS0GTzXTWsAatKlj4Iwpuu00x+Jz8UMCx0+rj8jFba3zUB7xKWKzuRqX0hoSTomTHGcJRXTThn+HG5WOb7mDGJMGMTp1QUSHaE0NjgEIr3HBF81jitpRMaMhoXb2XGdYBRtaqUhBQoAcyB5Wvn6yFoiLp2XqWNTKni4rckU1sJgnqsIUti9qJpxCjEBmRRTItK+5BvJKbc0C+oREGC0iXq0mSo5SdhWbHtCv2L6A8EelsFjYMMB01bqEGGfVnEe/LqqSY/YQZRZzWbWBNclfWdBfXtGxC5YQxLxmClDAkYzPObxy4twsY49CJW+5kCoq9l271VZbxUkvC1h1sLllVmsoUzsCTO0tDSkPzGIID6QSole8xYHlYDyzwlvoTHnRQzmI375QOKyR0DBRnzUTkJYL5Ey8J3DppZfOnz//5JNP5jfqJJSHHnqII/7tb3/T/6//+i+OEmc4B7e78sorSfvXf/1Xoc1NB+eUKVOktIsvvthbt1fOysm4HTbTEa5130F3q9V+5zvf8SoCTTGG5kpWgBpevfTSS9p9992XQHpydzLzIcUwkfe9dX50zELPXI5+3N3GjRvnbBx66KHOjDNPT2qXh5ZQU+ghJH8lTkWnAjWNrRYEhsywhg4N41EneCpQlG9sdIrE2mMKevzOk1uzuPDtb39bHMnn8tYjCYyjj1+fMvpHHXWUV4yvdZ8VjNq3b29IKFwUUncU1c5RoXl4S1VOcc2kgwcPxhA/d6FzKJNLqIv8InL+4Ik2lhZq6ECJo4xq5deCWqbOQSYj2xon6/TTT5dpbr75ZhvhrDlc8mvRUSHs0LNnT60jhjJixAjttttuW35fEhh6xt/NU2NRY4U1k84+++yDQXwIOnjE5rDIphdccIGzs+WWW4okqh95Jc+1Qoc6T8r56U9/ynkmTJggObVt2xY/Hu306dOta9SoURT+8Y9/HMIrUFEzZdTqkGqmtYA1aFM+wQ84DQ92C7OFc+bMEZR5G3+NRML18dja3E0DIjtitJwyPj5Gj5PA7cQpfWcmIqzhxIoUIU0Qj2uRWZwxPMG2QhBIAnc31ryhVQTNYMiPVgVidjAd3UxHFAtwdNpGh0peBX8sZIXIp6OA6yEJqww6APtD2I2htDaI2vox0SqAkrmeFbD1LBmz058pEIt7YSAFWAMnr/AYcVBrx22EcKNaZVVEbUyEuY4bWhdUKO+xglI7Kly3KlZKGuR7ER3yVzjF6sAZCcd4q/yHPObOncvmsSkco6rylOHMEfQdYR1bbEey16sKYs0VbY54tNc0kRGppFxr3bp11NDxlqtwDG+jvPPIblSim0WFntaFQXKy2Gy+hIaN+s9MZY8qQaHjLsZFeLlHN53u3bsrgA466KAjjjjipJNOOvPMM1988UX+xF3iDOTgc4gzZsx48sknBw4cOHr0aNVPly5d9txzz5122kmM69y5s5anBrN5uaNHRJzHHXecm9ozzzwTp4sOHDTUC8QsgZyiNSm8/vrrkqixQioiCWWWFUDWEUkdDCchzqqa6YUXXmAH/RYtWrjuRQgwRdz11iZisQ45RDaiamxNIOOrAyqY47Eso4QgBtgBrH2L8n9EK6Ygxn7l4AOvvfbaP/7xDxfbZ5999qmnnrrrrrtuu+22v//97y7dNkKstJVTp06dOXOmt4899piWtSvkrE1kS11+4RBvVxMhhz/Xo8xawJLO4IUXXnj55ZdfffXV48eP//Of/3zPPfdwfkeAt2R8y8CBufQPf/jD448/fuLEiZMnT3bWVvOPOkYOjsXGqnOg8FU47LDD3G5/+9vf0lN+EltcZTjwgw8++Oijj9Jh2rRpb7zxhsOr//DDD7vQEOvgY1ZR/eEPf+jUqZPgUJqvZuSTJqxb1H9mCthdFyt5gmeLIFxKYHKLEad4PD9DFK/z7BKfXeTAhih8a41ym1PB8DOnAqeQioEQwhGJAh0U0nR4rRwQpY9ZuK+BmeiaQYjh4ApmoBYFndhgoExQqoUZTWSgeelAN6IYAZ0OxZqJHEuIUWsT5gW6VSB7vfIIa9RiEwtnkLxmYgTM+agAU9gdnEFk7Yg4cUtwf5fVCKGnlv54dDAUhUBpvjWJtTDFOgEj2yBb4JTZI8dNorIpvJeRGTzjWwa7Yx9jlDZqpihqYxPrEbHdOjSZN28eT6Cnk6VmcpSihqYqlaJmwkmrcBX98B+PFJZN27RpU8uNMN/fqktOWPuoLdSuJnLJOn/84x95lbvw9ttvHzUEr4LtttuO9/zkJz+ReIrJgzMZ5QbHwxYtWsRXIpk999xzDkzv3r218XvsiJHVcn9y3XZdOu+887jjX/7yl7ffflsVTz6XDYYKkECHCI6m8zh06FAyH3roIe2tt97qFYE445wUHbfY9yrrLaMPGzZMxw1Oprz99tudqJrGFvs1oSi/iLqMrXfUpEwF1Dpiyg033GD7fvGLX7Bw8TIRPKNGjUJUHKPbiJYtW7r2tmrVKv5yuYgjVnoVzBDXndNOO00b36mpippssjp2Fri1l156KSEXXHABlSyqqNhqIp83OtqittGvi/4ri/hp0AknnCDEjxw50h7tu+++Zi9enqrO+8orr+B0crXbbrut8xjfpYTcJspccsjX1v5zpnxemnTs2DHokPPoxE/CLrroIslGbSQsiB7ykxkxnHLKKdoXXnjBFNdffz2ZO+20k2M7a9Ys7RFHHEHCHnvsoc0vmhWIv6TnAq09+OCDy7TqkX7OtBawNmzKV+L3+7iIoCOgcKZohR4dPBVpgxe+9tpr3E444G2uSDr4nQEZDoP0puVnFWkJRDfMzpXOggUL+A22mtJSEURJQs4YrURD2uobHlMAOdFZIYKTHHc0R47mlq8Tb9cbWGYge64CZmQEywd7FHuBzqQxEBgZJdqIGvqYI/q4K1SEEpYkR8Ziz0xEGdnrNQmz0KeWe3djhAMo2cf1y2a5RdUUu3M4WXbQRtgmQxxJ5zp7t2ZgovhqbpxQB9yJdvUEjzSPnzxhc991raESfrpZGmYbxwO1tSxt7bhQQh2xNmom4MecRijh0648HjmQx03K35zhbVIRJ8u4l31FVWbidhELOCI/k294WESrCHNAMmQjmzSR0rgj78Qzb948frnDDjvw6UhpVUECrehALJW07l/aHXfckbu7zeWZKVCcq9gnJ+uVQWavXr0spE+fPuR069YNc1FUTXJqQoX8HHUZW++oSZkKTJgwQeBTfWr79+8f+16MDiHHEphL6xVOfRudfyhadYFGeWWzCMQQxLrYoS48NS2Ni1Je5acdPnw4BcIJs9dl1EV+TaiLSVdHfi1wOizEPcDNj0k5PzhE2evl57UveBxM7cLy3xJ0h2jXrp2NKN9A6rNmKoKSQoSjhNOkLp2URN9mm21Q4uqJYlNwUmPu3LmmcPbRMegbpZ/PW4FUMzUorCWbijX2L5CRyuDl4ShuPUEJOPzubryfS/FmycztG51vOQDouRxvc3cPmMuB0eGmOt6aoiItocS8FYgbmbkgaiZEysTbusMQ88qsdLAEp2U9u2jXESzAksJEJBhxh9kZJHtdjkqRWiJqRJ/ZMWvZLUbFwEBcjUUoRg7+tYPQxKSNaytZLOvVAIvi6vJubAGPZfliWqoKW6C1uWzinDpcroMoHsvv1wikJXPFCZWWXGrNC9SOayutuJPdQUTBaV2GeMUIfCnkrFDJFVosYS1gDdZMaxqhefhZcRWOFmL8PCASw8CBAwWUimSG4hWGm2++uXnz5mIc199pp514cPv27bVjxozh5fn/QhtjK+BV1ivP65A7NpgnTZqkaPvOd76jve222xAdpHiVcS8/tthvRMiXU9SfVWWj+Mnzueeea+Huwujf/va3mUhHotLGWANXZ+112Zd6hDB3//33C4Vdu3aNdJu9qG8U18WpmNSk8emCRzWK2R999FFeOnv2bEn6m9/85pw5c/bYYw8R2a0/vB2n4TirGnl17JPrFp38kUz9OGUhP36CFZXTmWeeqV/TvNdee623/MRK87+DDrlwWB2d6wLnVNuiRQvtv//7v5dp1SPVTGsB66FNHWAn1q1KXnFQZR0+jaKWCmDg8cKKFh2Pk+zk43dVRAcUSaVly5Z1Pw9EyT2CFzkkiBdiBK9FFB10isdsPYa1u7TOnz+fnS3cZTwurcAI3mZ89YE1Ha2KUCKInvZU8JJiwUZD9nqNoeSO5b/5Ji2xJAqPoozcL46zwJZbbvnyyy9zYE4bdUMcARri9Bj0kFaPMDWQH4jH7F1jxmfknDZwNOKaqRaIFyKjm7u7pOD40EMPOajxn87lwDNjxgynt3Pnzo7ur3/9a63MJFG5E4k+t99+u/OviqrFRMWjKOeRJl7on3322WY01uw9e/aMQ1sRlItji/3Gjkj/gqZqyS1elvqf//kf1o6/DR9GKJq0sazdogR6Nx4Ky09rTW3ZiE+yJ0ybNo0lr7jiClb9xje+wZi0oszIkSN5r7fcfvTo0XQ7+uijZQtveSBXLGrL+KujfC3HIZcc7erXTGsT8RfKXWS16W9ArHOshzbl4u6P8QPSqJm4jpji2pjDAcCjdWjzmskx1pk9e/Yuu+zSrFmzqJkIrOMxJkFaIsS8QkbUTDroUTNlfOs7mDRqpvgJ0zvvvKMT4Wx1AuI6h2pYa095lC3mPDwNLC1Wt4bAPyUnjgQqJxQe5c7k8tS6dWuF1KJFi94q/8Jf/FSVp/Fwu8CZXQ5sAfUoXKFkWesSsuf6QHF/SQ7jZM8NHqGqJTQinddjrIfbEOchAsdtt93mZMZv1VxwwQXeOrdOrE7QHfLdd9/d8f7xj3/sPIuhcljXrl21nTp1whMZpSYrFY+iyyw29Zn2jjvukKX++7//m+R8rE5NobkmemNEWF49Kj/16tWLBcaNG8eM1hjAU7RnUBo4KByIx2prkTUExmS9l19+mWHPP/98Olx00UX807UJPfDKK6+4vP/iF79wH1I/sfl1112nPfzww7mljrESWyZxrdjfFPG3xmfOnCkvnnLKKRZS01wNoWb6wx/+wJJxm+zSpUtGrQ6pZloLWA9t6vLoJAgcDmRUQo6HE8uBvHI2eL8+nmgNiZppxx13xPDmm2+2adNms802c1RCINTl9JIgVGl5tqCMQkL8XvpnCpbvRu+2zrYM4lHKZ1ivwozFsNgYYVsjJ62dhfBSxRA31mfGqMUVT1EPcV1E7qo2lYTch5idbvjpGUFTx46UhX2KXHmdel9IyAzQKu6CtSBjLSMjrXUIC/SkwAq1TVgL+MLAgQOz7voCucGBdB4ExL333nuPPfZ49tlnpQp3t+eff16FJKxE0GzevLkk5DbXo0cPQ9xDjz/++G9+85tf/epX0TmoqBqnpabMVKRPnTpV1Bg6dOj06dMHDx789a9/vUWLFvFjp0CEiWpRk/zGCLYVNN3imzZtuttuux100EFSPtt6Ve0yG9HaqQr2MSCWASfJXq8xbLrppi+VMX78+Hnz5qktqMG8PJO3u4ExOKj4O3bs+Pvf/16u8jhlyhTGtx3yFrZMVgGEZL01swtz5szRvvrqq6xUeyU0efJkPG3btpVE879ZvpbxxBNPaBmTVXfaaacgVou//vWvzMXUsQtrwnQJ61vNxLPlJF4u8TjPnCYum1EzuTlq8aBHTHFu3377be7VunVrV1GciIZIS8FZllqneyWfNmnkRfI9mnSFo9Y/uMhHzcSGDAJ2BOIArx8GiS3W4UVBWXMIJ3z99dcj97z33nstW7ZUM3FvpqYAa3NjPDIQm4N+1ExxtYpDUZJVxlrYAsbJZ6EJ9apOGgYM0NlCIJRfJ4jZV1YH/FkvoV6xXv2cKV9LtYv605/+5KAqZYQVV3gR05GOK1LGsfxpqaAXX+UoEt2khAbpTZ205ZZbxqtim9CowR+KLgEe7Sx3yp7XJG666SZtr169TBe/TTVu3DiUXAfR/5133pGxzjrrLMlApaK95557vNp11121ReWjX3TLendR+lBG9SYpyqlbbLGF01ExCwb0Dz/88OWXX6atSsWo+I2itY+ZM2cKC1TVxqfxVWEt3g4ZMkTc6Nmzp777QUU9Wu+W/GxiPfw5E1TrHE5j1EOukHGeg66TIyiBjLQMGbVm5Ke9LswJjRf5/gr3+vY9tn7NIcoOicd1Sk5Cya/qoQyXxiPQu2zp5ODwwYA/9AyUh65xUDViPdC86rmItTBjcK7b+oOGNNGJIrVa0NAuWI66isLUDgfIXifUH9bPmgmqrotX8Tn+x6u85ViOsTZ7XSuqHqpAkR4JL3drQUEbDDUNT2hEqOpdxW1dc1vMb/nS9OnT+eof//hHDta5c2ftN77xjYyjHNy1L5X/L+Yf/ehHqpBXXnlFZvrLX/5i+Pbbbx+RNJhzrFH9aajCkFBJdugUFhVTYKCVVzpOoiWoP7J3ax10YKi4alToWYQVWUj8wehYERgFGUc67PWE9bNmqooIJRzIceWFQalHH8rDVoWbBvK3CQkrC2lJ0BTE3dZFw7jxoMTbQHxopmaSk3i4PujEpT5yQMa6tmBeWWfj8rczJMWKsxYngnqhmHXhqVjU2oQzm9dMFae1+EjDt99+WwbVoTP986o0oX6xHpai1a7I4QSvcjfihdyrjo5VE0+RLhBog0Ks6SKI5MS6TJTQKFD0sTW6rbyIl5YuO+XrvMcl5b9J+N577xW/9im+c7ZHH30UT6dOnZo1a7bffvuJ9ddddx233GqrrQyvei6KmtfvKupin5wn76w5feqCCn3yR6aLDtBK7pdu1YIyWUZdxrz2dV6P8ZmomXiMcxsfKWgh7pL160kCAcQUJBcdusLXExLqiFJGKv9uuFS0aNEiaSnoxbQEXA6bJARNy384nLOJnjJZ8/JfK1ZCZawND/V7DFcTcXKB0QKhXhxe5rUXjFlRg+IJtoT6wmelZgKXHW34UIDbBaX8flVQHPvBsv9JPYf8F69yIGa9hMaMoo+t0T2NmomjipXxaLr4O0nF5PTuu+969dvf/hbzT3/6UzVT/PW8rl27yk/CKObaT3r9rqIu9lmb+tQFuT4sCfFIjdz4KKFV3klYc/hM1EwBNTgoa6JmirRUX+CsITxqJsLrV37CZxMRGXmXe9X75f9qOegVNZM6CcWNPj5reuedd8RWV3uJyiOH1MlYE2pFGJzFHOT88w/2B5243dqFZM81jc/uVx5XauGrcEWqkL8KEhISoBQUl/2/RzniUq8VOj1OmjRJu//++2tHjhzJ2U444QRDMMhMMpY7U2nYMhirbTg+2dD0SVjn+AzVTBVY08cgHbOEegFHqkhLgBJX+3+W/+q5yP5x+XvhiPjVTx5d+aUlzN5KTjEwIaFR4LNbMyUkNGpINvLTq6++qt1jjz0++OAD1ZL21FNPjR8sRdLCGfkpIaER4bNbMyUkNF64UMZPTON7Yv9X/qJEUNRMm222WXytWU6K2j1+QJKQ0FiQaqaEhMYHeWj27Nk6J5988qabbnrkkUdKSz179kTfcMMN43sQ2vjQD1Grnz5hTmgsSDVTQkIjg0wDrVq1iv9gd9GiRZtssok8pH6SljBIS26c+htssIFyKlqUHCEnIaHBItVMCQmNCXJS/Aptjx49PvjggzPPPHOzzTbbb7/94gdL8pPi6eOPP37iiSckqvgfV7fffvv4ZkQmIn09J6HBI9VMCQmNAy6RUS1JS3JP1ExbbLFF/CW3peW/Rx5fz/MoLel8sfz3UuMDvUxKwqqiXG2us3t8zA7Z8/qOVDMlJDR0xMd0KiS1jpx06aWXejz44IPlm06dOmEonuL33ntPZurTp88mm2xywQUX4G/ZsqWkVfyLJKl+qjsqIqRMHx35PjqBnK3e7VlLiF6P9y7VTAkJDRrSUsQmmUYrIDZr1mzx4sXxY6QPP/xQKsKQQ1rCs2TJkviP+2Qv8St+/pRQR2SmLCMjLSNmD2sdMTtkz+s7Us2UkNAIIP2ofm655RaV0/Tp0zfffPMjjzxS0tpyyy2Xlv/PwIyvSZO5c+e2aNFi5MiR2quuusqo+BFU8beaUs1UO6qNikHMX63lmqla+evx3qWaKSGhQUMq0kowUTMJRsWaSU6Kv5KXQ5H05ptvNm/eXDYyViuGxtiEhMaCVDMlJDRoxFcebrvtto022ujYY4+VY1BUS/nvKslPxd9V8mqzzTY74IAD1FL33ntvpCvHHFu1V+z1+N69OohPQRm2GCHdD5jRtWCLLbbISGUUeerXnvaODmZs2rRp7KNN1+rruHbg0cFDYepxEpT4wWQMD93waPWpt2DBglatWnkMxBSGc5hNN900eNBRYq58Re+//z738+jGYyKjdNbQpSfVTAkJDRoCh2go0Lz99ttf/OIX4/eWxIWIOFoRBAU94FEhpa6Kr+3FH8YWTfL4krBCsCejibzZ8zLEdx0lfgw6ObLX9Yd8c+kgYeRpSUsxr9DtNX3AziLKIrwi3vKWSFpyVSBWFD7wpS99ST84gdgorOMrncQilpf1f/GFT4/BnHudbBT0NVeLp5opIaGhQ7CYPHmyuPDSSy+1bNlSoJFvpCvQ13qVsZbDxzvvvNOmTRujVE4owoo4UuQpImWsqoigzzKRGzJqkybMiK7jVYTmgC3IeqtkT7MUR0VMRqHG2LFjv/vd7wbdjLJFpAc5A0PMS0N9FB3qYYt8Jm1U6B88RuHnFfPnz2/RooUOyjPPPNOuXbvWrVtjy0uiGEUNj8RKeATSYeHChcG55pBqpoSEBo0ILkLDokWLhAZRAyIkiRERKYIYWLBggSCibFIzvffeeygYIp4m1AKWzHrl7K6GkPXfeustjwwolAOi9oYbbkAU0HMUx9YEPHVhC+A0KTXytAT0Of/88++66y79U0899dVXX501a9Y555wzYMAAzFdfffWZZ545YsSIW2+9FcN55533s5/9rE+fPscff/yTTz7JeSZOnNivX7/nn3/+7rvvPvLIIxcvXixRTZkyhW9wEswvv/yytRg7Y8aMvn37msvjUUcdtfHGG1922WX//u//ftBBBz322GMTJky4+eabSwqVLROd+kfYKyEhYX2F+CKCQPacUB2q2ketEJleGxShfNSoUThvuummnF8ntzAEsQLxSmp5//33CZEV7rzzzqeeegol3mrnzp178sknxyOBksEPf/jDq666yuyXXHLJddddpxTu1auXx+eee+7QQw9V8aDMmzdv2rRp+ieccMJ9991nLLGvvfZa165dH3/88ZkzZz777LPxv+/LTBdffLEh2H77299SA3HkyJFaFNNZrz48/PDDv/71r2OUhBREKkXniSeeGDZsWPTXHFLNlJCwnkPJFVf+7DmhOoR9xN94FBxRBHqFSzxqPcoNOtJA/EhGfJcJSgPqABuxySabqHfHjRvXqVOnyZMnK8Kyd8vDdC1btvzWt751xBFHmPShhx7Sp1vz5s1VMAYefPDBrVq1UhaTufvuu1Pm3/7t3zp37kznDh06NGvW7N57791zzz3btWu38847eyRkr732UmAZIrcde+yxKEpqtZfppLEf//jH0hiix3322Uf5pZYyIwmEDxo06Oijjz7mmGOkN7WaoryUPepcAq4CUmZKSEhIyCBYZ70yxH0BWitkQ/ypXJ3Zs2f/6Ec/Ev1FbYkh464ZpXtB+adW+m+88cbzzz8vr+SfnlWE+HhUrFBGYnj66adbt27dtm1bOfJrX/uaVzfffHOXLl10aKJmkqiuvfbaI488ctNNN33hhRdOPPHE008/Xalk+PHHH/+3v/2NQEuYNWvWGWecga44+3//7/8NGDCgf//+FOjRo8d//Md/HHLIIR6xEUvgYYcdJo2RL4/Ceeedd8stt/z+97/v2LHjTjvthCdKLp01hJSZEhISEjIsXrw4L5tApAaVDaJCwVsJ5pJLLtlmm20uv/xyBU3Tpk2XLFmSca/o6w8kCOgvvviifCas77LLLlIUej5jnr2kBKlImeLV17/+9SuvvNIQmrRp02bBggVyg8KIKJRdd92VnO9///tbbbXVjTfeKIf169fvmmuukS9/85vfqLEUQFIUsUTtuOOOu+22m6Qo2Vx44YWWQMLHH3/8u9/97r777rvjjjviAz21l75JLXy//fZDUWMpFuW8Rx555LXXXiPKq1B1DSFlpoSEhIRStSTUfulLX4rsIu5vuOGG+oK4vlgsiMtDDzzwwLnnnosBs2whlG+++eZe4ZROIlhrAyW5y+AtHjJvvfXWvfbay9iDDjroL3/5S158eCvcy15TpkwZOHCgmkZZNnTo0LPOOuvnP/95/HzrtttuI0E5RSsdo+TFZs2ayViDBg2aOHHiSy+9RDjKX//61z//+c8k0FktZSxm6UonPlE0V+DLX/5yzG4VikKdSZMmnXLKKbKdGuvwww9XbHmlUJPq6LzFFlsQssa/UxMWTEhISPiMQ/qJPCHyxmP8JEmn/P4TRYmy6YMPPkA85phjdN5///141b17dy26sTniVQBzyLngggvmz58vM0kq+ojgEfG0004jAf2FF154/PHHpZmZM2e+8sorWpR33nnne9/73ptvvomfJqZ+4oknvI2KR5IzkHwaPvXUU94a5REzmUAB5RGoe6wrJoWScp98gk7Uq6++6hWthg0bFn1QhF199dUkYDPF73//+1/+8pf6XpWHrhGkmikhISGhBAFRIXLHHXfoC9li8UYbbYSijhGF33333R49eqiQUO6///7bb78dm/pDBsI5ZsyYv/3tb1HHVAvliMpDPlAPtWrVylzKjvbt20s/yhSPckOUTUqcHXfcce+9995+++233XZb9VDr1q2bN28eX0nQJ0ceopXySKk3e/bsPfbYo1OnTt6qt9RYd955J4att97aKuQzWhH74IMPHn/88dLVk08+efnllx999NGjR48m85xzzunateuBBx4oA0lalqxc69Onj4kIfOaZZyzwhBNOIGTy5Ml47rnnnn333deKqEGHWF29I/tYMyEhIeEzDsFQbtC5+OKLf/rTn4rIgq/gLijryz3HHXdcPEpUIngwyCgGAoq3xY+5QlpAlJce+vfvL9ZH/fHb3/5WK2EQ65WSRaUyYsQIwiWbc889V4Fi4NChQ6UTyaxLly69evVSIRklx8gu7dq1UyHRh8A5c+bssMMOZpctzKtDvbFjx8qg3/zmN0899VR55fnnn9d59tlnTfHVr36V8uTLYVLgzjvvHI9AfmhOVHE56jA8Ut2WW24ZzOTIuPG2fpFqpoSEhM86xGLQEc3hvPPO+8EPfhDReYNlf2dBOA4GnPElPcRo5RVsck+IMnDevHnCun4OxPj8TUUybty4u+66q23btkqip59+WvQnpEWLFgogbKQZu9NOO6nMxo8fv+eee26zzTYYpIHrr7/eFAsXLsRmlEQYf7joRz/6kRlffPHFo4466ogjjvj2t7994oknGiLrHH744aeffjqFJbbTTjvNQIXa3LlzJT+p9KqrrjrssMP+8Y9/xFpAkiN25MiRRx55pMe+ffueffbZltatWzez0+HMM8/EjGI5aygtQcpMCQkJCSUIxNER63/4wx8K4voLFizQeiUcf/DBB1GUQBC1wRaIpGK4hFGsNsDwadOmbbbZZoqVKLxQpIFdd931zTffRJHbtDiJxSZvkSMBeIwP+jbddNMhQ4b8+Mc/PuOMM7z1GFPIIuR07tx5xx13lOruvPNOKe26666jySabbLLHHnuY6+2335YOzznnnFdffVUhpf5TJ82fP1/ms8B99tlHawpypCuQJk1EH7P36dPHK0JOOumk5s2bU0mhZqUUKK9sjSB9mpeQkPBZR4TBPBiKyFENnHvuuUqKhx9+eObMmQqOAw44QKEgIovgxcRTjKLyjeGCOx7RPKOWv+z33e9+96CDDvrP//xPYR1FnnvnnXdOPvnk7t27f+9731OakHP55ZdHepAAgg1kGkRFj3ypiNliiy0kIXS5Z9asWSgjRozYbrvt5A/pTUsBY2lCZnyh/JlnnpkwYYIsqISaPn26gkzu7N27t7xF5ltvvWWUSRFDbY8KuM0339wspKFEm398J9VRIzdUvSNlpoSEhM86KjKTuKw6EbjbtWsnUgvx8pC3CpFTTz1VPhCji5Gz2BesL7300gsuuEC/SI9YT5RQHtWSt5IButpIVRRpjHBJ5ZFHHrnkkks8YjPj888/v9dee+25556DBg1SIUlamI0y9uijj46MhfjSSy9dfPHFJOhLn+edd94vf/lLOc/Yd999V5rBD6+//jqGwYMHL1myxCytW7eWI1944YXbbrvNkgn505/+ZGo8Sjflkb65DMdGOFWl5++UQX9v1wRSZkpISEhYLosUIZRnvfIPeATlbbfdVtT2GDWNvo4ILuWI9c2bN1dYyD1exc+oihKiX9NcBhJl1Pjx46UBtVSUPjKiKqdZs2YTJ04866yzMu4ybrzxxuOOO26TTTYxVm03efLkE088kSZS12uvvfarX/2qf//+O+ywQ8ZdTpy/+MUv6CnH/PznP1dOIUo8CxYsuPbaa0866STJxisZEdErCtOH8HgMtGjRQtKKT/MqPrSsL6TMlJCQkFBjtihCmH7jjTeeeOKJww47TEKSPFQS4ngenQX0N998U+qSACKmx6h4C7VnJm/j00L9d955R0daAvT4MM3AojSPZpe9ICjBFn9pPigB2spGQZRm8BBLfyktPrWTeFCCOUA46KAbjiFmCWIglCm29YWUmRISEhLqlJnEdKFc8rjmmmv23nvvAw88MKdPmDChU6dOCiaP8pPKQyivGqyDUu1cUZSI/obLHB9//LGEJz8plcgnUNaR6iJR4Qwh+jERfh1sQfeIM3KJ4flPg/CgE0W4UZJT0M3o0dhgAERCUHAW8x+GYIuJDCyNr2+kzJSQkJBQp8wkHEd0BsH99ddf14rabdq02XLLLUX5gQMHnnbaafE3TzFHCikiKDXNFdkoShmSMXvMmWWpyHwBdPz00TEXTsQoblBibHBGkURgJLyackkwmF3+i7Eh2RTW6DHWHkRtaUzKTAkJCQmNCHlorZqf6gXkryHJDQHp95kSEhISGh/W47QEqWZKSEhISGhYSDVTQkJCQkLDQspMCQkJCQkNCykzJSQkJCQ0LKTMlJCQkJDQsJAyU0JCQkJCw0LKTAkJCQkJDQspMyUkJCQkNCykzJSQkJCQ0LCQMlNCQkJCQsNCykwJCQkJCQ0LKTMlJCQkJDQspMyUkJCQkNCwkDJTQkJCQkLDQspMCQkJCQkNCykzJSQkJCQ0LKTMlJCQkJDQsJAyU0JCQkJCw0LKTAkJCQkJDQspMyUkJCQkNCykzJSQkJCQ0LCQMlNCQkJCQsNCykwJCQkJCQ0LKTMlJCQkJDQspMyUkJCQkNCwkDJTQkJCQkLDQspMCQkJCQkNCykzJSQkJCQ0LKTMlJCQkJDQsJAyU0JCQkJCw0LKTAkJCQkJDQspMyUkJCQkNCykzJSQkJCQ0LCQMlNCQkJCQsNCykwJCQkJCQ0LKTMlJCQkJDQspMyUkJCQkNCwkDJTQkJCQkLDQspMCQkJCQkNCykzJSQkJCQ0LKTMlLAusWB8377jF2QPFajybsao3gMfKBLmjD2j99hZ2cPyWPxA/+7Dpy7NnuqCacP3GT4t69cJi6de2bvvqGmLs8cKEFcjCvMsnXZl//FzdLLpF0wcPvC+8vOV+w9ZKf0TEtYjfO6TTz7JugkJax2yz6AmA67cb1LfQwdNymj7Dbj3ym6t8nelbglLpw751tj9xw/p0jSemzSZNbb3wCZDRnVvmz1/ijnj+x4zfE77thtlz0UsnDVz6dY7t+3+s1t6dijlg5NHZy8q0eOGKf06ZP0yamNehiqDMixdMOvpp6fOmNOkZfvdO3TcpaCZ3HTRnO4D247e5/5DxrQfNb79wL4dm5ZWMKrtsP4dq1tBQsJ6j5SZEtYRinF+WTIqU+9v0mP06E8zQPnd3OWTQol2yCtDDjzjjo8ySglZVpjzwMC+59z9Sg05Qr47dObpVV/NGNXtxva3LMt71XKVdDukTNMbufMylYsvAjH63t1HX/be6QO6t9+oKE5RNHLx7hudf3d5fOlFnpKXgea9Zi1P/9RACQmfBaTMlLAOsfiB/geO3U+WWXjL8Jld+ndrK1Kf3+Rn13YrlUH6ec1UjP1l+s/6LOzbv8mQsb13KZFgGcesWxQbvTuOPWP4nJ1rqpkOubaQRkpYOm14z4EbDrylb4dsxKepZOnU4efM6XFlSaPSFMtnzSqIDJKNPr3JqL5njG8/4MqBHaeGuJbj+508uv2wG7rc36mY2RZPvfKMvjfO7E6tjmXCnLG9h29+5fBvSZOzxvYcvuEVKS0lfLaQfs6UsO6wdNrE+8udjXY5pOP95wyfNufpSbP2azqt35CJK/gJy6xJY6d2H5KnpQLa97xyYJcv63QbeEt1uKJPBP9lWDpn6qgzjrioSb9r87RUwobelOuxmRMfKNZlh/SbAjf0KOWgUq8Mj+qcEpbLIE079B41pm+TSVPnZBLmTJ3adtgNy83TZOms8QN795vVvc/hTaZe2fuM0s+tlk68/4GmH723sPx6zoyZ7duntJTwGUPKTAnrDEunPnD3hhsuvntQ//FzWn1rQK9ZfY/pP637fl327/beiNEzMqbq0f6A/ld2Wzik/9hZWQpbMKfymxDjB/asDj8YMTVjKIX9+/r3vOiBrc8ec0u//cvRX1lU/tZFq/179Hi6b+nbCn2ndunVpepPsppMHfGDTGLPngPHZ8SqaLp1xyZ3j50qNS2dOqr/3Tsf0n65tDTjlnOGL+x27QPDu3do2qRjv1EDWo4eeOXYSU1P77H1A9NKX/aYNXPSIR3bB3dCwmcHnyQkrBvMH9fn7Btu6NNn3OzZ4waPefmTT5664pCOgx/50KuXx/zshqdmj/NufvA+NaxjERl9/iODe/S4Ysq7pW6BOfDhU8OOPvqG6dlTHWGeCjEFTBnWcdhTWb9WUKbjsCnvTh83oMcBPQaMm/6upRj64cvjBhy9X48B984mqTjNy2NO73Xz9NLCc5SMc++7n0y/4fCa9UlIWG+Rfs6UsG5Q+tHO+C7DO4wanv0saenEId8a8XTLpYcs++FRrT9nWvadvQUTh182q/uAnpvfv/wX+WaNPafnRZM2/HLlz5qWzpn5yke9bpjYtySq9POgKt8/qIJl3z7AffLCPkMWfreGL+h9+pWLktyp7XstXNy+T79uuzQt/dzojCNm9Sm/nnPfwJEfddhw0AMdSlKtq1LafoPvvfJbrZosvq9fz781bT/xo+7FryMmJHxGEAkqIWFtY/q4cS9/WuqUKhzV07v+6VWqn6BYBqll8nKlankEReL8R4b1OOT0m6dMublPr1LFEtRPPpw95YbTjz79him11CC11UxPXbHfz/5aFjZ73Nm9olQrY/a9A5aVbgHKZOq+PKZHucjbr8cNTxVqosI0yqmjh02Jd2rAo7MpqPvI4I4dj755JYu+hIT1AunnTAnrCLt065b//GTO+HP6zur9s25tm3bo07/DxKmlXzVdOSxcGD9nUiz1O+eBnQeMubZnx449r7yyR5OxfbufMeTKIX2/dcSgaR0Gj722d8esrsqxeMbY/v3vK/4K79I54/v3Hjh+RvG3aGfNnLRzx53L1UvbbsOH7Dy+b99RU2dMHXVG90Fzu11xS+mXkKqiffdbyt+MmHhL7+W+9/Ap2nYbMny/WSP69+vf/4xjRjQdOCAKpKWz7h59/847Nxkxovx7uAkJny2kzJSwzvHRtPvv3/nKYeWvijfZqGO/4fG7s+8tLn87bRlGn1z++wn77PPpB3BLFy/7Ct+cp6fO3bqlmL5R++7DR/XvtkvTpYvnzLhv7Mgbx05d3P7Lu7Rt33TrpdNGX3nZ8LH3TZu1YHE+cMHUK3sfc9ni7md/q5yvsi/RbSRfDOu28LJuXc4YNbWcspZOGzuqZfcDyoqVRM/6qGXLhaNHjRw1elarnVsuXTgnl5ghV7c6FD7BW7pg4ZxZU6dNnbthx6P7dZx50fCJC0qf+PXsPbHLqBtuuXJIy1E9+41dLkUmJHwGkNVOCQnrAtV+MrfsM7ADTs8+16vp07wpn34v4oBe+cdl5e9F9Dh78M3jHpk+u/i1gg/nvzxl3M2Dz+5xyH4dDx/21Icfzr73Z70GjHu5xDP9hsPLcvbrsdznZ7PvHdBnwF/nf/LhUzf0ueGpd6eP6VNV9Iezpz9SFtvj6KNLvHXAsk/zPnxqWI+jzx427qmCnrPvPXuZUmWY9OxeVxQ/C0xIWO+RvgGR0NixdPHiJk2bVv9ZWUJCQmNEykwJCQkJCQ0L6edMCQkJCQkNCykzJSQkJCQ0LKTMlJCQkJDQsJAyU0JCQkJCw0LKTAkJCQkJDQlNmvx/I9b6t5tk6PEAAAAASUVORK5CYII=" alt="Q(f) = TT + —Allw112 "></p>
<p>这里出现了γ和λ，这是XGBoost自己定义的，在使用XGBoost时，你可以设定它们的值，显然，γ越大，表示越希望获得结构简单的树，因为要整体最小化的话就要最小化<em>T</em>。λ越大也是越希望获得结构简单的树。</p>
<h6 id="2-Shrinkage"><a href="#2-Shrinkage" class="headerlink" title="2) Shrinkage"></a>2) Shrinkage</h6><p>除了使用正则化，我们还有shrinkage与采样技术来避免过拟合的出现。</p>
<p>所谓的shrinkage就是在每次的迭代产生的树中，对每个叶子结点乘以一个缩减权重 (learning_rate，也叫eta)，主要的目的就是缩减该次迭代产生的树的影响力，留给后边迭代生成的树更多发挥的空间。</p>
<p>举个栗子：比如第一棵树预测值为3.3，label为4.0，第二棵树才学0.7，那后面的树就没啥可学的了，所以给他打个折扣，比如3折，那么第二棵树训练的残差为4.0-3.3*0.3=3.01，这就可以发挥了啦，以此类推，作用的话，就是防止过拟合。</p>
<h6 id="3-采样技术"><a href="#3-采样技术" class="headerlink" title="3) 采样技术"></a>3) 采样技术</h6><p>采样技术有两种，分别是行采样 (subsample) 和列采样 (colsample_bytree)。</p>
<p>列采样效果比较好的是按层随机的方法：之前提到，每次分裂节点的时候我们都要遍历所有的特征和分割点，来确定最优分割点。如果加入列采样，我们会在同一层的结点分割前先随机选一部分特征，遍历的时候只用遍历这部分特征就行了。</p>
<p>行采样则是采用bagging的思想，每次只抽取部分样本进行训练，不使用全部的样本，可以增加树的多样性。</p>
<h4 id="1-2-工程实现"><a href="#1-2-工程实现" class="headerlink" title="1.2 工程实现"></a>1.2 工程实现</h4><h5 id="1-2-1-块结构设计-支持并行化"><a href="#1-2-1-块结构设计-支持并行化" class="headerlink" title="1.2.1 块结构设计 - 支持并行化"></a><span id="jump3.1.2.1">1.2.1 块结构设计 - 支持并行化</span></h5><p>一直听别人说XGBoost能并行计算，感觉这才是XGBoost最bug的地方，但是直观上并不好理解，明明每次分裂节点都用到了上一次的结果，明明是个串行执行的过程，并行这个小妖精到底在哪？答案就是：选哪个feature进行分裂的时候，就是在枚举，选择最佳分裂点的时候进行。</p>
<p><strong>注意：同层级节点之间可以并行。节点内选择最佳分裂点，候选分裂点计算增益使用并行。</strong></p>
<p>(来自 <a href="https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A</a>)</p>
<hr>
<p>我们知道，决策树的学习最耗时的一个步骤就是在每次寻找最佳分裂点是都需要对特征的值进行排序。而 XGBoost 在训练之前对根据特征对数据进行了排序，然后保存到块结构中，并在每个块结构中都采用了稀疏矩阵存储格式（Compressed Sparse Columns Format，CSC）进行存储，后面的训练过程中会重复地使用块结构，可以大大减小计算量。</p>
<ul>
<li>每一个块结构包括一个或多个已经排序好的特征；</li>
<li>缺失特征值将不进行排序；</li>
<li>每个特征会存储指向样本梯度统计值的索引，方便计算一阶导和二阶导数值；</li>
</ul>
<p><img src="/2020/07/25/决策树/1595668680481.png" alt="1595668680481"></p>
<p>这种块结构存储的特征之间相互独立，方便计算机进行并行计算。在对节点进行分裂时需要选择增益最大的特征作为分裂，这时各个特征的增益计算可以同时进行，这也是 Xgboost 能够实现分布式或者多线程计算的原因。</p>
<h5 id="1-2-2-缓存访问优化算法"><a href="#1-2-2-缓存访问优化算法" class="headerlink" title="1.2.2 缓存访问优化算法"></a>1.2.2 缓存访问优化算法</h5><p>块结构的设计可以减少节点分裂时的计算量，但特征值通过索引访问样本梯度统计值的设计会导致访问操作的内存空间不连续，这样会造成缓存命中率低，从而影响到算法的效率。</p>
<p>为了解决缓存命中率低的问题，XGBoost 提出了缓存访问优化算法：为每个线程分配一个连续的缓存区，将需要的梯度信息存放在缓冲区中，这样就是实现了非连续空间到连续空间的转换，提高了算法效率。</p>
<p>此外适当调整块大小，也可以有助于缓存优化。</p>
<h5 id="1-2-3-“核外”块计算"><a href="#1-2-3-“核外”块计算" class="headerlink" title="1.2.3 “核外”块计算"></a>1.2.3 “核外”块计算</h5><p>当数据量过大时无法将数据全部加载到内存中，只能先将无法加载到内存中的数据暂存到硬盘中，直到需要时再进行加载计算，而这种操作必然涉及到因内存与硬盘速度不同而造成的资源浪费和性能瓶颈。为了解决这个问题，XGBoost 独立一个线程专门用于从硬盘读入数据，以实现处理数据和读入数据同时进行。</p>
<p>此外，XGBoost 还用了两种方法来降低硬盘读写的开销：</p>
<ul>
<li>块压缩：对 Block 进行按列压缩，并在读取时进行解压；</li>
<li>块拆分：将每个块存储到不同的磁盘中，从多个磁盘读取可以增加吞吐量。</li>
</ul>
<h4 id="1-3-优缺点"><a href="#1-3-优缺点" class="headerlink" title="1.3 优缺点"></a>1.3 优缺点</h4><h5 id="1-3-1-优点"><a href="#1-3-1-优点" class="headerlink" title="1.3.1 优点"></a>1.3.1 优点</h5><ol>
<li>精度更高：GBDT 只用到一阶泰勒展开，而 XGBoost  对损失函数进行了二阶泰勒展开。XGBoost 引入二阶导一方面是为了增加精度，另一方面也是为了能够自定义损失函数，二阶泰勒展开可以近似大量损失函数；</li>
<li>灵活性更强：GBDT 以 CART 作为基分类器，XGBoost 不仅支持 CART 还支持线性分类器，（使用线性分类器的 XGBoost 相当于带 L1 和 L2 正则化项的Logistic回归（分类问题）或者线性回归（回归问题））。此外，XGBoost 工具支持自定义损失函数，只需函数支持一阶和二阶求导；</li>
<li>正则化：XGBoost 在目标函数中加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、叶子节点权重的 L2 范式。正则项降低了模型的方差，使学习出来的模型更加简单，有助于防止过拟合；</li>
<li>Shrinkage（缩减）：相当于学习速率。XGBoost 在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间；</li>
<li>列抽样：XGBoost 借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算；</li>
<li>缺失值处理：XGBoost 采用的稀疏感知算法极大的加快了节点分裂的速度；</li>
<li>可以并行化操作：块结构可以很好的支持并行计算。</li>
</ol>
<h5 id="1-3-2-缺点"><a href="#1-3-2-缺点" class="headerlink" title="1.3.2 缺点"></a>1.3.2 缺点</h5><ol>
<li>虽然利用预排序和近似算法可以降低寻找最佳分裂点的计算量，但在节点分裂过程中仍需要遍历数据集；</li>
<li>预排序过程的空间复杂度过高，不仅需要存储特征值，还需要存储特征对应样本的梯度统计值的索引，相当于消耗了两倍的内存。</li>
</ol>
<h4 id="1-4-与GBDT的比较"><a href="#1-4-与GBDT的比较" class="headerlink" title="1.4 与GBDT的比较"></a><span id="jump3.1.4">1.4 与GBDT的比较</span></h4><p>来自 <a href="https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A</a></p>
<h5 id="1-4-1-共同点"><a href="#1-4-1-共同点" class="headerlink" title="1.4.1 共同点"></a>1.4.1 共同点</h5><ul>
<li><p>二者都是由一堆回归树构成的模型（本次训练的模型基于上次训练的模型）。传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的Logistic回归（分类问题）或者线性回归（回归问题）。</p>
</li>
<li><p>二都是最小化损失函数的思想，求最优的决策树。</p>
</li>
</ul>
<h5 id="1-4-2-不同点"><a href="#1-4-2-不同点" class="headerlink" title="1.4.2 不同点"></a>1.4.2 不同点</h5><ul>
<li><p>第一眼的感觉XGBoost更好的地方其实就是<strong>正则化+并行化。</strong></p>
</li>
<li><p>二者最小化损失函数的方法不同。GBDT使用的是Gradient Descent方法，优化时只用到了损失函数的一阶导数信息（有人说残差其实就是这里的梯度，不是很理解），拟合上一个模型产生的残差。而XGBoost使用的则是牛顿法，优化时同时用到了一阶导数和二阶导数信息(−<em>gi</em>(1+<em>hi</em>))，其实这个值就是每个叶子节点的预测值（对推导过程有兴趣的朋友请移步参考博文2）。</p>
</li>
<li><p>GBDT分割点的选择通过枚举训练样本集上的特征值来完成，分割点的选择依据则是减少Loss。 XGBoost使用的则是将最小化的目标函数值作为打分函数，提出了一个Gain的公式来划分样本。</p>
</li>
<li><p>XGBoost还支持自定义损失函数，只要能够二阶泰勒展开的函数都可以作为损失函数。</p>
</li>
<li><p>采样方法（Shrinkage）</p>
</li>
<li><p>分裂结点的算法（Weighted Quantile Sketch）</p>
</li>
</ul>
<h3 id="XGBoost动手实践"><a href="#XGBoost动手实践" class="headerlink" title="XGBoost动手实践"></a>XGBoost动手实践</h3><p>本部分内容来源于 <a href="https://mp.weixin.qq.com/s/AAKPSIHk1iUqCeUibrORqQ" target="_blank" rel="noopener">我的XGBoost学习经历及动手实践</a></p>
<h4 id="1-引入基本工具库"><a href="#1-引入基本工具库" class="headerlink" title="1. 引入基本工具库"></a>1. 引入基本工具库</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入基本工具库</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">"ggplot"</span>)</span><br><span class="line">%matplotlib inline</span><br></pre></td></tr></table></figure>
<h4 id="2-XGBoost原生工具库的上手"><a href="#2-XGBoost原生工具库的上手" class="headerlink" title="2. XGBoost原生工具库的上手"></a>2. XGBoost原生工具库的上手</h4><p>更详细的参数设置见后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb  <span class="comment"># 引入工具库</span></span><br><span class="line"><span class="comment"># read in data</span></span><br><span class="line"><span class="comment"># XGBoost的专属数据格式，但是也可以用dataframe或者ndarray</span></span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'demo/data/agaricus.txt.train'</span>)   </span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'demo/data/agaricus.txt.test'</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># specify parameters via map</span></span><br><span class="line"><span class="comment"># 设置XGB的参数，使用字典形式传入</span></span><br><span class="line">param = &#123;<span class="string">'max_depth'</span>:<span class="number">2</span>, <span class="string">'eta'</span>:<span class="number">1</span>, <span class="string">'objective'</span>:<span class="string">'binary:logistic'</span> &#125;    </span><br><span class="line"></span><br><span class="line">num_round = <span class="number">2</span>     <span class="comment"># 使用线程数</span></span><br><span class="line">bst = xgb.train(param, dtrain, num_round)   <span class="comment"># 训练</span></span><br><span class="line"><span class="comment"># make prediction</span></span><br><span class="line">preds = bst.predict(dtest)   <span class="comment"># 预测</span></span><br></pre></td></tr></table></figure>
<h4 id="3-XGBoost的参数设置"><a href="#3-XGBoost的参数设置" class="headerlink" title="3. XGBoost的参数设置"></a>3. XGBoost的参数设置</h4><p>(括号内的名称为sklearn接口对应的参数名字)</p>
<p><span style="background:yellow">更详细的介绍见 <a href="https://xgboost.readthedocs.io/en/latest/parameter.html" target="_blank" rel="noopener">官方文档</a>.</span></p>
<p>XGBoost的参数分为三种：</p>
<h5 id="3-1-通用参数"><a href="#3-1-通用参数" class="headerlink" title="3.1. 通用参数"></a>3.1. 通用参数</h5><blockquote>
<ul>
<li>booster: 使用哪个弱学习器训练，默认gbtree，可选gbtree，gblinear或 dart<ul>
<li>booster参数：控制每一步的booster (tree/regression). 因为tree的性能比线性回归好得多，因此我们很少用线性回归. <code>gbtree</code> and <code>dart</code> use tree based models while <code>gblinear</code> uses linear functions.</li>
</ul>
</li>
<li>nthread：用于运行XGBoost的并行线程数，默认为最大可用线程数</li>
<li>verbosity：打印消息的详细程度。默认值为1，有效值为0（静默），1（警告），2（信息），3（调试）。</li>
</ul>
</blockquote>
<p>tree booster：</p>
<blockquote>
<ul>
<li><p>Tree Booster的参数：</p>
</li>
<li><ul>
<li><p>eta（learning_rate）：learning_rate，在更新中使用步长收缩以防止过度拟合，默认= 0.3，范围：[0,1]；典型值一般设置为：0.01-0.2</p>
</li>
<li><p>gamma（min_split_loss）：默认= 0，分裂节点时，损失函数减小值只有大于等于gamma节点才分裂，gamma值越大，算法越保守，越不容易过拟合，但性能就不一定能保证，需要平衡。范围：[0，∞]</p>
</li>
<li><p>max_depth：默认= 6，一棵树的最大深度。增加此值将使模型更复杂，并且更可能过度拟合。范围：[0，∞]</p>
</li>
<li><p>min_child_weight：默认值= 1，如果新分裂的节点的样本权重和小于min_child_weight则停止分裂 。这个可以用来减少过拟合，但是也不能太高，会导致欠拟合。范围：[0，∞]</p>
</li>
<li><p>max_delta_step：默认= 0，允许每个叶子输出的最大增量步长。如果将该值设置为0，则表示没有约束。如果将其设置为正值，则可以帮助使更新步骤更加保守。通常不需要此参数，但是当类极度不平衡时，它可能有助于逻辑回归。将其设置为1-10的值可能有助于控制更新。范围：[0，∞]</p>
</li>
<li><p>subsample：默认值= 1，构建每棵树对样本的采样率，如果设置成0.5，XGBoost会随机选择一半的样本作为训练集。范围：（0,1]</p>
</li>
<li><p>sampling_method：默认= uniform，用于对训练实例进行采样的方法。</p>
</li>
<li><ul>
<li>uniform：每个训练实例的选择概率均等。通常将subsample&gt; = 0.5 设置 为良好的效果。</li>
<li>gradient_based：每个训练实例的选择概率与规则化的梯度绝对值成正比，具体来说就是 $\sqrt{g^2+\lambda h^2}$，subsample可以设置为低至0.1，而不会损失模型精度。</li>
</ul>
</li>
<li><p>colsample_bytree：默认= 1，列采样率，也就是特征采样率。范围为（0，1]</p>
</li>
<li><p>lambda（reg_lambda）：默认=1，L2正则化权重项。增加此值将使模型更加保守。</p>
</li>
<li><p>alpha（reg_alpha）：默认= 0，权重的L1正则化项。增加此值将使模型更加保守。</p>
</li>
<li><p>tree_method：默认=auto，XGBoost中使用的树构建算法。可选：<code>auto</code>, <code>exact</code>, <code>approx</code>, <code>hist</code>, <code>gpu_hist</code></p>
</li>
<li><ul>
<li>auto：使用启发式选择最快的方法。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>对于小型数据集，将使用精确贪婪<code>exact</code>。</li>
<li>对于较大的数据集，将选择近似算法<code>approx</code>。建议尝试<code>hist</code>，<code>gpu_hist</code>，对于大量的数据有更高的性能。<code>gpu_hist</code>支持 external memory 外部存储器。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>exact：精确的贪婪算法。枚举所有拆分的候选点。</li>
<li>approx：使用分位数和梯度直方图的近似贪婪算法。</li>
<li>hist：更快的直方图优化的近似贪婪算法。（LightGBM也是使用直方图算法）</li>
<li>gpu_hist：GPU hist算法的实现。</li>
</ul>
</li>
<li><p>scale_pos_weight: 默认值1，控制正负权重的平衡，这对于不平衡的类别很有用。Kaggle竞赛一般设置 sum(negative instances) / sum(positive instances)，在类别高度不平衡的情况下，将参数设置大于0，可以加快收敛。</p>
</li>
<li><p>num_parallel_tree：默认=1，每次迭代期间构造的并行树的数量。此选项用于支持增强型随机森林。</p>
</li>
<li><p>monotone_constraints：可变单调性的约束，在某些情况下，如果有非常强烈的先验信念认为真实的关系具有一定的质量，则可以使用约束条件来提高模型的预测性能。（例如params_constrained[‘monotone_constraints’] = “(1,-1)”，(1,-1)告诉XGBoost对第一个预测变量施加增加的约束，对第二个预测变量施加减小的约束。）</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>linear booster：</p>
<blockquote>
<ul>
<li><p>Linear Booster的参数：</p>
</li>
<li><ul>
<li><p>lambda（reg_lambda）：默认= 0，L2正则化权重项。增加此值将使模型更加保守。归一化为训练示例数。(Normalised to number of training examples.)</p>
</li>
<li><p>alpha（reg_alpha）：默认= 0，权重的L1正则化项。增加此值将使模型更加保守。归一化为训练示例数。</p>
</li>
<li><p>updater：默认= shotgun。</p>
</li>
<li><ul>
<li>shotgun：基于shotgun算法的平行坐标下降算法。使用“ hogwild”并行性，因此每次运行都产生不确定的解决方案。</li>
<li>coord_descent：普通坐标下降算法。同样是多线程的，但仍会产生确定性的解决方案。</li>
</ul>
</li>
<li><p>feature_selector：默认= cyclic。特征选择和排序方法</p>
</li>
<li><ul>
<li>cyclic：通过每次循环一个特征来实现的。</li>
<li>shuffle：类似于cyclic，但是在每次更新之前都有随机的特征变换。</li>
<li>random：一个随机(有放回)特征选择器。</li>
<li>greedy：选择梯度最大的特征。（贪婪选择）</li>
<li>thrifty：近似贪婪特征选择（近似于greedy）</li>
</ul>
</li>
<li><p>top_k：默认值为0，要选择的最重要特征数（在greedy和thrifty内）。The number of top features to select in <code>greedy</code> and <code>thrifty</code> feature selector. The value of 0 means using all the features.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h5 id="3-2-任务参数"><a href="#3-2-任务参数" class="headerlink" title="3.2. 任务参数"></a>3.2. 任务参数</h5><p>学习目标参数。这个参数用来控制理想的优化目标和每一步结果的度量方法。</p>
<blockquote>
<ul>
<li><p>objective：默认=<code>reg:squarederror</code>，表示最小平方误差。</p>
</li>
<li><ul>
<li><p><code>reg:squarederror</code>：最小平方误差。</p>
</li>
<li><p><code>reg:squaredlogerror</code>：对数平方损失。</p>
</li>
<li><p><code>reg:logistic</code>：逻辑回归</p>
</li>
<li><p><code>reg:pseudohubererror</code>： 使用伪Huber损失进行回归，这是绝对损失的两倍可微选择。</p>
</li>
<li><p><code>binary:logistic</code>：logistic regression for binary classification, output probability.</p>
</li>
<li><p><code>binary:logitraw</code>：logistic regression for binary classification, output score before logistic transformation.</p>
</li>
<li><p><code>binary:hinge</code>：二元分类的铰链损失(hinge loss)。这使预测为0或1，而不是产生概率。（SVM就是铰链损失函数）</p>
</li>
<li><p><code>count:poisson</code>：计数数据的泊松回归，输出泊松分布的平均值。</p>
</li>
<li><p><code>survival:cox</code>：针对正确的（right censored）生存时间数据进行Cox回归（负值被视为正确的生存时间）。</p>
</li>
<li><p><code>survival:aft</code>：用于检查生存时间数据的加速故障时间模型。</p>
</li>
<li><p><code>aft_loss_distribution</code>：Probabilty Density Function used by <code>survival:aft</code> objective and <code>aft-nloglik</code> metric.</p>
</li>
<li><p><code>multi:softmax</code>：设置XGBoost以使用softmax目标进行多类分类，还需要设置num_class（类数）</p>
</li>
<li><p><code>multi:softprob</code>：与softmax相同，但输出向量，可以进一步重整为矩阵。结果包含属于每个类别的每个数据点的预测概率。</p>
</li>
<li><p><code>rank:pairwise</code>：使用LambdaMART进行成对排名，从而使成对损失最小化。</p>
</li>
<li><p><code>rank:ndcg</code>：使用LambdaMART进行列表式排名，使标准化折让累积收益（NDCG）最大化。</p>
</li>
<li><p><code>rank:map</code>：使用LambdaMART进行列表平均排名，使平均平均精度（MAP）最大化。</p>
</li>
<li><p><code>reg:gamma</code>：使用对数链接(log-link)进行伽马回归。输出是伽马分布的平均值。</p>
</li>
<li><p><code>reg:tweedie</code>：使用对数链接进行Tweedie回归。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>eval_metric：验证数据的评估指标，将根据objective分配默认指标 (rmse for regression, and error for classification, mean average precision for ranking)，用户可以添加多个评估指标 (Python users: remember to pass the metrics in as list of parameters pairs instead of map)</p>
</li>
<li><ul>
<li><p>rmse，均方根误差；</p>
</li>
<li><p>rmsle：均方根对数误差；Default metric of <code>reg:squaredlogerror</code> objective.</p>
</li>
<li><p>mae：平均绝对误差；</p>
</li>
<li><p>mphe：平均伪Huber错误；</p>
</li>
<li><p>logloss：负对数似然；</p>
</li>
<li><p>error：二元分类错误率； It is calculated as <code>#(wrong cases)/#(all cases)</code></p>
</li>
<li><p>merror：多类分类错误率；</p>
</li>
<li><p>mlogloss：多类logloss；</p>
</li>
<li><p>auc：曲线下面积；</p>
</li>
<li><p>aucpr：PR曲线下的面积；</p>
</li>
<li><p>ndcg：归一化累计折扣；</p>
</li>
<li><p>map：平均精度；</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>seed ：随机数种子，[默认= 0]。</li>
</ul>
</blockquote>
<h5 id="3-3-命令行参数"><a href="#3-3-命令行参数" class="headerlink" title="3.3. 命令行参数"></a>3.3. 命令行参数</h5><p>这里不说了，因为很少用命令行控制台版本。(only used in the console version of XGBoost)</p>
<h4 id="4-XGBoost的调参说明"><a href="#4-XGBoost的调参说明" class="headerlink" title="4. XGBoost的调参说明"></a>4. XGBoost的调参说明</h4><p>参数调优的一般步骤：</p>
<ul>
<li>1.确定（较大）学习速率和提升参数调优的初始值</li>
<li>2.max_depth 和 min_child_weight 参数调优</li>
<li>3.gamma参数调优</li>
<li>4.subsample 和 colsample_bytree 参数调优</li>
<li>5.正则化参数alpha调优</li>
<li>6.降低学习速率和使用更多的决策树</li>
</ul>
<h4 id="5-XGBoost详细攻略"><a href="#5-XGBoost详细攻略" class="headerlink" title="5. XGBoost详细攻略"></a>5. XGBoost详细攻略</h4><p>更详细内容见<a href="https://xgboost.readthedocs.io/en/latest/python/python_intro.html" target="_blank" rel="noopener">官方文档</a></p>
<h5 id="1-安装XGBoost"><a href="#1-安装XGBoost" class="headerlink" title="1). 安装XGBoost"></a>1). 安装XGBoost</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip3 install xgboost</span><br><span class="line">或</span><br><span class="line">pip install xgboost</span><br><span class="line"></span><br><span class="line">更新</span><br><span class="line">pip install --upgrade xgboost</span><br></pre></td></tr></table></figure>
<h5 id="2-数据接口（XGBoost可处理的数据格式DMatrix）"><a href="#2-数据接口（XGBoost可处理的数据格式DMatrix）" class="headerlink" title="2). 数据接口（XGBoost可处理的数据格式DMatrix）"></a>2). 数据接口（XGBoost可处理的数据格式DMatrix）</h5><p>The XGBoost python module is able to load data from:</p>
<ul>
<li>LibSVM text format file</li>
<li>Comma-separated values (CSV) file</li>
<li>NumPy 2D array</li>
<li>SciPy 2D sparse array</li>
<li>cuDF DataFrame</li>
<li>Pandas data frame, and</li>
<li>XGBoost binary buffer file.</li>
</ul>
<p>(See <a href="https://xgboost.readthedocs.io/en/latest/tutorials/input_format.html" target="_blank" rel="noopener">Text Input Format of DMatrix</a> for detailed description of text input format.)</p>
<p>The data is stored in a <a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.DMatrix" target="_blank" rel="noopener"><code>DMatrix</code></a> object.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.LibSVM文本格式文件</span></span><br><span class="line"><span class="comment"># To load a libsvm text file or a XGBoost binary file into DMatrix:</span></span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.svm.buffer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.CSV文件(不能含类别文本变量，如果存在文本变量请做特征处理如one-hot)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Categorical features not supported</span></span><br><span class="line"><span class="string">Note that XGBoost does not provide specialization for categorical features; if your data contains categorical features, load it as a NumPy array first and then perform corresponding preprocessing steps like one-hot encoding.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Use Pandas to load CSV files with headers</span></span><br><span class="line"><span class="string">Currently, the DMLC data parser cannot parse CSV files with headers. Use Pandas (see below) to read CSV files with headers.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.csv?format=csv&amp;label_column=0'</span>)</span><br><span class="line">dtest = xgb.DMatrix(<span class="string">'test.csv?format=csv&amp;label_column=0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.NumPy数组</span></span><br><span class="line">data = np.random.rand(<span class="number">5</span>, <span class="number">10</span>)  <span class="comment"># 5 entities, each contains 10 features</span></span><br><span class="line">label = np.random.randint(<span class="number">2</span>, size=<span class="number">5</span>)  <span class="comment"># binary target</span></span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.scipy.sparse数组</span></span><br><span class="line">csr = scipy.sparse.csr_matrix((dat, (row, col)))</span><br><span class="line">dtrain = xgb.DMatrix(csr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.pandas数据框dataframe</span></span><br><span class="line">data = pandas.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">label = pandas.DataFrame(np.random.randint(<span class="number">2</span>, size=<span class="number">4</span>))</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label)</span><br></pre></td></tr></table></figure>
<p>笔者推荐：先保存到XGBoost二进制文件中将使加载速度更快，然后再加载进来</p>
<p>Saving <a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.DMatrix" target="_blank" rel="noopener"><code>DMatrix</code></a> into a XGBoost binary file will make loading faster:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.保存DMatrix到XGBoost二进制文件中</span></span><br><span class="line">dtrain = xgb.DMatrix(<span class="string">'train.svm.txt'</span>)</span><br><span class="line">dtrain.save_binary(<span class="string">'train.buffer'</span>)</span><br><span class="line"><span class="comment"># 2. 缺失值可以用DMatrix构造函数中的默认值替换：</span></span><br><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=<span class="number">-999.0</span>)</span><br><span class="line"><span class="comment"># 3.可以在需要时设置权重：</span></span><br><span class="line">w = np.random.rand(<span class="number">5</span>, <span class="number">1</span>)</span><br><span class="line">dtrain = xgb.DMatrix(data, label=label, missing=<span class="number">-999.0</span>, weight=w)</span><br></pre></td></tr></table></figure>
<h5 id="3-参数的设置方式"><a href="#3-参数的设置方式" class="headerlink" title="3). 参数的设置方式"></a>3). 参数的设置方式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 加载并处理数据</span></span><br><span class="line">df_wine = pd.read_csv(<span class="string">'https://archive.ics.uci.edu/ml/machine-learning-databases/wine/wine.data'</span>,header=<span class="literal">None</span>)</span><br><span class="line">df_wine.columns = [<span class="string">'Class label'</span>, <span class="string">'Alcohol'</span>,<span class="string">'Malic acid'</span>, <span class="string">'Ash'</span>,<span class="string">'Alcalinity of ash'</span>,<span class="string">'Magnesium'</span>, <span class="string">'Total phenols'</span>,</span><br><span class="line">                   <span class="string">'Flavanoids'</span>, <span class="string">'Nonflavanoid phenols'</span>,<span class="string">'Proanthocyanins'</span>,<span class="string">'Color intensity'</span>, <span class="string">'Hue'</span>,<span class="string">'OD280/OD315 of diluted wines'</span>,<span class="string">'Proline'</span>]</span><br><span class="line">df_wine = df_wine[df_wine[<span class="string">'Class label'</span>] != <span class="number">1</span>]  <span class="comment"># drop 1 class</span></span><br><span class="line">y = df_wine[<span class="string">'Class label'</span>].values</span><br><span class="line">X = df_wine[[<span class="string">'Alcohol'</span>,<span class="string">'OD280/OD315 of diluted wines'</span>]].values</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split  <span class="comment"># 切分训练集与测试集</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder   <span class="comment"># 标签化分类变量</span></span><br><span class="line"></span><br><span class="line">le = LabelEncoder()</span><br><span class="line">y = le.fit_transform(y)</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">1</span>,stratify=y)</span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(X_train, label=y_train)</span><br><span class="line">dtest = xgb.DMatrix(X_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.Booster 参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">    <span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>,  <span class="comment"># 多分类的问题</span></span><br><span class="line">    <span class="string">'num_class'</span>: <span class="number">10</span>,               <span class="comment"># 类别数，与 multisoftmax 并用</span></span><br><span class="line">    <span class="string">'gamma'</span>: <span class="number">0.1</span>,                  <span class="comment"># 用于控制是否后剪枝的参数,越大越保守，一般0.1、0.2这样子。</span></span><br><span class="line">    <span class="string">'max_depth'</span>: <span class="number">12</span>,               <span class="comment"># 构建树的深度，越大越容易过拟合</span></span><br><span class="line">    <span class="string">'lambda'</span>: <span class="number">2</span>,                   <span class="comment"># 控制模型复杂度的权重值的L2正则化项参数，参数越大，模型越不容易过拟合。</span></span><br><span class="line">    <span class="string">'subsample'</span>: <span class="number">0.7</span>,              <span class="comment"># 随机采样训练样本</span></span><br><span class="line">    <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,       <span class="comment"># 生成树时进行的列采样</span></span><br><span class="line">    <span class="string">'min_child_weight'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'silent'</span>: <span class="number">1</span>,                   <span class="comment"># 设置成1则没有运行信息输出，最好是设置为0.? slient还是verbosity?</span></span><br><span class="line">    <span class="string">'eta'</span>: <span class="number">0.007</span>,                  <span class="comment"># 如同学习率</span></span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'nthread'</span>: <span class="number">4</span>,                  <span class="comment"># cpu 线程数</span></span><br><span class="line">    <span class="string">'eval_metric'</span>:<span class="string">'auc'</span></span><br><span class="line">&#125;</span><br><span class="line">plst = params.items()</span><br><span class="line"><span class="comment"># evallist = [(dtest, 'eval'), (dtrain, 'train')]   # 指定验证集</span></span><br></pre></td></tr></table></figure>
<p>XGBoost can use either a list of pairs or a dictionary to set <a href="https://xgboost.readthedocs.io/en/latest/parameter.html" target="_blank" rel="noopener">parameters</a>. For instance:</p>
<ul>
<li><p>Booster parameters</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param = &#123;<span class="string">'max_depth'</span>: <span class="number">2</span>, <span class="string">'eta'</span>: <span class="number">1</span>, <span class="string">'objective'</span>: <span class="string">'binary:logistic'</span>&#125;</span><br><span class="line">param[<span class="string">'nthread'</span>] = <span class="number">4</span></span><br><span class="line">param[<span class="string">'eval_metric'</span>] = <span class="string">'auc'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>You can also specify multiple eval metrics:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">param[<span class="string">'eval_metric'</span>] = [<span class="string">'auc'</span>, <span class="string">'ams@0'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively:</span></span><br><span class="line"><span class="comment"># plst = param.items()</span></span><br><span class="line"><span class="comment"># plst += [('eval_metric', 'ams@0')]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Specify validations set to watch performance</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">evallist = [(dtest, <span class="string">'eval'</span>), (dtrain, <span class="string">'train'</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-训练"><a href="#4-训练" class="headerlink" title="4). 训练"></a>4). 训练</h5><p>注：貌似现在不需要<code>plst = param.items()</code>，直接传 <code>param</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2.训练</span></span><br><span class="line">num_round = <span class="number">10</span></span><br><span class="line">bst = xgb.train(plst, dtrain, num_round)</span><br><span class="line"><span class="comment">#bst = xgb.train(plst, dtrain, num_round, evallist )</span></span><br></pre></td></tr></table></figure>
<h5 id="5-保存模型"><a href="#5-保存模型" class="headerlink" title="5). 保存模型"></a>5). 保存模型</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 3.保存模型</span></span><br><span class="line"><span class="comment"># After training, the model can be saved.</span></span><br><span class="line">bst.save_model(<span class="string">'0001.model'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># The model and its feature map can also be dumped to a text file.</span></span><br><span class="line"><span class="comment"># dump model</span></span><br><span class="line">bst.dump_model(<span class="string">'dump.raw.txt'</span>)</span><br><span class="line"><span class="comment"># dump model with feature map</span></span><br><span class="line"><span class="comment">#bst.dump_model('dump.raw.txt', 'featmap.txt')</span></span><br></pre></td></tr></table></figure>
<h5 id="6-加载保存的模型"><a href="#6-加载保存的模型" class="headerlink" title="6) . 加载保存的模型"></a>6) . 加载保存的模型</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 4.加载保存的模型：</span></span><br><span class="line">bst = xgb.Booster(&#123;<span class="string">'nthread'</span>: <span class="number">4</span>&#125;)  <span class="comment"># init model</span></span><br><span class="line">bst.load_model(<span class="string">'0001.model'</span>)  <span class="comment"># load data</span></span><br></pre></td></tr></table></figure>
<h5 id="7-设置早停机制"><a href="#7-设置早停机制" class="headerlink" title="7). 设置早停机制"></a>7). 设置早停机制</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 5.也可以设置早停机制（需要设置验证集）</span></span><br><span class="line">train(..., evals=evals, early_stopping_rounds=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>The model will train until the validation score stops improving. Validation error needs to decrease at least every <code>early_stopping_rounds</code> to continue training.</p>
<p>If early stopping occurs, the model will have three additional fields: <code>bst.best_score</code>, <code>bst.best_iteration</code> and <code>bst.best_ntree_limit</code>. Note that <a href="https://xgboost.readthedocs.io/en/latest/python/python_api.html#xgboost.train" target="_blank" rel="noopener"><code>xgboost.train()</code></a> will return a model from the last iteration, not the best one.</p>
<p>This works with both metrics to minimize (RMSE, log loss, etc.) and to maximize (MAP, NDCG, AUC). Note that if you specify more than one evaluation metric the last one in <code>param[&#39;eval_metric&#39;]</code> is used for early stopping.</p>
<h5 id="8-预测"><a href="#8-预测" class="headerlink" title="8). 预测"></a>8). 预测</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 6.预测</span></span><br><span class="line">ypred = bst.predict(dtest)</span><br></pre></td></tr></table></figure>
<p>If early stopping is enabled during training, you can get predictions from the best iteration with <code>bst.best_ntree_limit</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ypred = bst.predict(dtest, ntree_limit=bst.best_ntree_limit)</span><br></pre></td></tr></table></figure>
<h5 id="9-绘图"><a href="#9-绘图" class="headerlink" title="9). 绘图"></a>9). 绘图</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.绘制重要性</span></span><br><span class="line"><span class="comment"># This function requires matplotlib to be installed.</span></span><br><span class="line">xgb.plot_importance(bst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.绘制输出树</span></span><br><span class="line"><span class="comment"># This function requires graphviz and matplotlib.</span></span><br><span class="line"><span class="comment">#xgb.plot_tree(bst, num_trees=2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.使用xgboost.to_graphviz()将目标树转换为graphviz</span></span><br><span class="line"><span class="comment"># When you use IPython, you can use the xgboost.to_graphviz() function, which converts the target tree to a graphviz instance. The graphviz instance is automatically rendered in IPython.</span></span><br><span class="line"><span class="comment">#xgb.to_graphviz(bst, num_trees=2)</span></span><br></pre></td></tr></table></figure>
<h4 id="6-实战案例"><a href="#6-实战案例" class="headerlink" title="6. 实战案例"></a>6. 实战案例</h4><h5 id="1-分类案例"><a href="#1-分类案例" class="headerlink" title="1). 分类案例"></a>1). 分类案例</h5><p>a. Iris数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score   <span class="comment"># 准确率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载样本数据集</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X,y = iris.data,iris.target</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1234565</span>) <span class="comment"># 数据集分割</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 算法参数</span></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">    <span class="string">'objective'</span>: <span class="string">'multi:softmax'</span>,</span><br><span class="line">    <span class="string">'num_class'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'gamma'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'max_depth'</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="string">'lambda'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'colsample_bytree'</span>: <span class="number">0.75</span>,</span><br><span class="line">    <span class="string">'min_child_weight'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'silent'</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">'eta'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'nthread'</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plst = params.items()</span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(X_train, y_train) <span class="comment"># 生成数据集格式</span></span><br><span class="line">num_rounds = <span class="number">500</span></span><br><span class="line">model = xgb.train(plst, dtrain, num_rounds) <span class="comment"># xgboost模型训练</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集进行预测</span></span><br><span class="line">dtest = xgb.DMatrix(X_test)</span><br><span class="line">y_pred = model.predict(dtest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算准确率</span></span><br><span class="line">accuracy = accuracy_score(y_test,y_pred)</span><br><span class="line">print(<span class="string">"accuarcy: %.2f%%"</span> % (accuracy*<span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示重要特征</span></span><br><span class="line">plot_importance(model)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">accuarcy: 96.67%</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/决策树/1595830272543.png" alt="1595830272543"></p>
<p>b. Titanic数据集</p>
<p>来自  <a href="https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/qongHAx-X2SWrUxjk8tg0A</a></p>
<p><img src="/2020/07/25/决策树/1601268650680.png" alt="1601268650680"></p>
<p><img src="/2020/07/25/决策树/1601268679265.png" alt="1601268679265"></p>
<h5 id="2-回归案例"><a href="#2-回归案例" class="headerlink" title="2). 回归案例"></a>2). 回归案例</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">from</span> xgboost <span class="keyword">import</span> plot_importance</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据集</span></span><br><span class="line">boston = load_boston()</span><br><span class="line">X,y = boston.data,boston.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># XGBoost训练过程</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">params = &#123;</span><br><span class="line">    <span class="string">'booster'</span>: <span class="string">'gbtree'</span>,</span><br><span class="line">    <span class="string">'objective'</span>: <span class="string">'reg:squarederror'</span>,</span><br><span class="line">    <span class="string">'gamma'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'max_depth'</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="string">'lambda'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'subsample'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'colsample_bytree'</span>: <span class="number">0.7</span>,</span><br><span class="line">    <span class="string">'min_child_weight'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'silent'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'eta'</span>: <span class="number">0.1</span>,</span><br><span class="line">    <span class="string">'seed'</span>: <span class="number">1000</span>,</span><br><span class="line">    <span class="string">'nthread'</span>: <span class="number">4</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dtrain = xgb.DMatrix(X_train, y_train)</span><br><span class="line">num_rounds = <span class="number">300</span></span><br><span class="line">plst = params.items()</span><br><span class="line">model = xgb.train(plst, dtrain, num_rounds)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对测试集进行预测</span></span><br><span class="line">dtest = xgb.DMatrix(X_test)</span><br><span class="line">ans = model.predict(dtest)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示重要特征</span></span><br><span class="line">plot_importance(model)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/25/决策树/1595837055748.png" alt="1595837055748"></p>
<h5 id="3-XGBoost调参（结合sklearn网格搜索）"><a href="#3-XGBoost调参（结合sklearn网格搜索）" class="headerlink" title="3). XGBoost调参（结合sklearn网格搜索）"></a><strong>3). XGBoost调参</strong>（结合sklearn网格搜索）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xgboost <span class="keyword">as</span> xgb</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> roc_auc_score</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"></span><br><span class="line">iris = load_iris()</span><br><span class="line">X,y = iris.data,iris.target</span><br><span class="line">col = iris.target_names</span><br><span class="line">train_x, valid_x, train_y, valid_y = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">1</span>)   <span class="comment"># 分训练集和验证集</span></span><br><span class="line"></span><br><span class="line">parameters = &#123;</span><br><span class="line">              <span class="string">'max_depth'</span>: [<span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">25</span>],</span><br><span class="line">              <span class="string">'learning_rate'</span>: [<span class="number">0.01</span>, <span class="number">0.02</span>, <span class="number">0.05</span>, <span class="number">0.1</span>, <span class="number">0.15</span>],</span><br><span class="line">              <span class="string">'n_estimators'</span>: [<span class="number">500</span>, <span class="number">1000</span>, <span class="number">2000</span>, <span class="number">3000</span>, <span class="number">5000</span>],</span><br><span class="line">              <span class="string">'min_child_weight'</span>: [<span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">              <span class="string">'max_delta_step'</span>: [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              <span class="string">'subsample'</span>: [<span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.85</span>, <span class="number">0.95</span>],</span><br><span class="line">              <span class="string">'colsample_bytree'</span>: [<span class="number">0.5</span>, <span class="number">0.6</span>, <span class="number">0.7</span>, <span class="number">0.8</span>, <span class="number">0.9</span>],</span><br><span class="line">              <span class="string">'reg_alpha'</span>: [<span class="number">0</span>, <span class="number">0.25</span>, <span class="number">0.5</span>, <span class="number">0.75</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'reg_lambda'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>],</span><br><span class="line">              <span class="string">'scale_pos_weight'</span>: [<span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xlf = xgb.XGBClassifier(max_depth=<span class="number">10</span>,</span><br><span class="line">            learning_rate=<span class="number">0.01</span>,</span><br><span class="line">            n_estimators=<span class="number">2000</span>,</span><br><span class="line">            silent=<span class="literal">True</span>,</span><br><span class="line">            objective=<span class="string">'multi:softmax'</span>,</span><br><span class="line">            num_class=<span class="number">3</span> ,</span><br><span class="line">            nthread=<span class="number">-1</span>,</span><br><span class="line">            gamma=<span class="number">0</span>,</span><br><span class="line">            min_child_weight=<span class="number">1</span>,</span><br><span class="line">            max_delta_step=<span class="number">0</span>,</span><br><span class="line">            subsample=<span class="number">0.85</span>,</span><br><span class="line">            colsample_bytree=<span class="number">0.7</span>,</span><br><span class="line">            colsample_bylevel=<span class="number">1</span>,</span><br><span class="line">            reg_alpha=<span class="number">0</span>,</span><br><span class="line">            reg_lambda=<span class="number">1</span>,</span><br><span class="line">            scale_pos_weight=<span class="number">1</span>,</span><br><span class="line">            seed=<span class="number">0</span>,</span><br><span class="line">            missing=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">gs = GridSearchCV(xlf, param_grid=parameters, scoring=<span class="string">'accuracy'</span>, cv=<span class="number">3</span>)</span><br><span class="line">gs.fit(train_x, train_y)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"Best score: %0.3f"</span> % gs.best_score_)</span><br><span class="line">print(<span class="string">"Best parameters set: %s"</span> % gs.best_params_ )</span><br></pre></td></tr></table></figure>
<h2 id="决策树算法十问及经典面试问题"><a href="#决策树算法十问及经典面试问题" class="headerlink" title="决策树算法十问及经典面试问题"></a>决策树算法十问及经典面试问题</h2><blockquote>
<p> 参考 <a href="https://mp.weixin.qq.com/s/vkbZweJ5oRo4IPt-3kg64g" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/vkbZweJ5oRo4IPt-3kg64g</a> </p>
<p><a href="https://blog.csdn.net/jaffe507/article/details/105004324" target="_blank" rel="noopener">https://blog.csdn.net/jaffe507/article/details/105004324</a></p>
</blockquote>
<h3 id="简介和算法"><a href="#简介和算法" class="headerlink" title="简介和算法"></a>简介和算法</h3><blockquote>
<p>决策树是机器学习最常用的算法之一，它将算法组织成一颗树的形式。其实这就是将平时所说的if-then语句构建成了树的形式。这个决策树主要包括三个部分：内部节点、叶节点和边。内部节点是划分的属性，边代表划分的条件，叶节点表示类别。构建决策树就是一个递归的选择内部节点，计算划分条件的边，最后到达叶子节点的过程。</p>
</blockquote>
<p><img src="/2020/07/25/决策树/1595669193083.png" alt="1595669193083"></p>
<p><img src="/2020/07/25/决策树/1603251940059.png" alt="1603251940059"></p>
<h3 id="核心公式"><a href="#核心公式" class="headerlink" title="核心公式"></a>核心公式</h3><p><img src="/2020/07/25/决策树/1595669223727.png" alt="1595669223727"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">model</th>
<th style="text-align:center">feature select</th>
<th style="text-align:center">树的类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ID3</td>
<td style="text-align:center">{分类:信息增益}</td>
<td style="text-align:center">多叉树</td>
</tr>
<tr>
<td style="text-align:center">C4.5</td>
<td style="text-align:center">{分类:信息增益率}</td>
<td style="text-align:center">多叉树</td>
</tr>
<tr>
<td style="text-align:center">CART (分类树)</td>
<td style="text-align:center">{分类:基尼指数}</td>
<td style="text-align:center">二叉树</td>
</tr>
<tr>
<td style="text-align:center">CART (回归树)</td>
<td style="text-align:center">{回归:平方误差}</td>
<td style="text-align:center">二叉树</td>
</tr>
</tbody>
</table>
</div>
<h3 id="算法十问"><a href="#算法十问" class="headerlink" title="算法十问"></a>算法十问</h3><p>1.决策树和条件概率分布的关系？</p>
<blockquote>
<p>决策树可以表示成给定条件下类的条件概率分布. 决策树中的每一条路径都对应是划分的一个条件概率分布. 每一个叶子节点都是通过多个条件之后的划分空间，在叶子节点中计算每个类的条件概率，必然会倾向于某一个类，即这个类的概率最大.</p>
</blockquote>
<p>2.ID3和C4.5算法可以处理实数特征吗？如果可以应该怎么处理？如果不可以请给出理由？</p>
<p><img src="/2020/07/25/决策树/1595669343135.png" alt="1595669343135"></p>
<p>3.既然信息增益可以计算，为什么C4.5还使用信息增益比？</p>
<blockquote>
<p>在使用信息增益的时候，模型偏向于选择取值较多的特征。（可能会导致出现很多分支，将数据划分更细，模型复杂度高，出现过拟合的机率更大。）</p>
<p>使用信息增益比就是为了解决偏向于选择取值较多的特征的问题. 使用信息增益比对取值多的特征加上惩罚，对这个问题进行了校正.</p>
</blockquote>
<p>4.基尼指数可以表示数据不确定性，信息熵也可以表示数据的不确定性. 为什么CART使用基尼指数？</p>
<blockquote>
<p>信息熵、基尼指数都是值越大，数据的不确定性越大. 信息熵需要计算对数，计算量大；信息熵可以处理多个类别，基尼指数就是针对两个类计算的，由于CART树是一个二叉树，每次都是选择yes or no进行划分，从这个角度也是应该选择简单的基尼指数进行计算.</p>
</blockquote>
<p>5.决策树怎么剪枝？</p>
<blockquote>
<p>一般算法在构造决策树时都是尽可能的细分，直到数据不可划分才会到达叶子节点，停止划分. 因为给训练数据巨大的信任，这种形式形式很容易造成过拟合，为了防止过拟合需要进行决策树剪枝. </p>
<p>一般分为预剪枝和后剪枝：</p>
<p>1）预剪枝是在决策树的构建过程中加入限制，比如控制叶子节点最少的样本个数，提前停止. </p>
<p>预剪枝(提前停止)：控制深度、当前的节点数、分裂对测试集的准确度提升大小</p>
<ul>
<li>限制树的高度，可以利用交叉验证选择</li>
<li>利用分类指标，如果下一次切分没有降低误差，则停止切分</li>
<li>限制树的节点个数，比如某个节点小于100个样本，停止对该节点切分</li>
</ul>
<p>2）后剪枝是在决策树构建完成之后，根据加上正则项的结构风险最小化自下向上进行的剪枝操作. 剪枝的目的就是防止过拟合，使模型在测试数据上变现良好，更加鲁棒.</p>
<p>后剪枝(自底而上)：生成决策树、交叉验证剪枝：子树删除，节点代替子树、测试集准确率判断决定剪枝.</p>
</blockquote>
<p>6.ID3算法，为什么不选择具有最高预测精度的属性特征，而是使用信息增益？</p>
<p>7.为什么使用贪心和启发式搜索建立决策树，为什么不直接使用暴力搜索建立最优的决策树？</p>
<blockquote>
<p>决策树目的是构建一个与训练数据拟合很好，并且复杂度小的决策树. 因为<strong>从所有可能的决策树中直接选择最优的决策树是NP完全问题</strong>，在使用中一般使用启发式方法学习相对最优的决策树.</p>
</blockquote>
<p>8.如果特征很多，决策树中最后没有用到的特征一定是无用吗？</p>
<blockquote>
<p>不是无用的，从两个角度考虑，一是特征替代性，如果已经使用的特征A和特征B可以替代特征C，特征C可能就没有被使用，但是如果把特征C单独拿出来进行训练，依然有效. 其二，决策树的每一条路径就是计算条件概率的条件，前面的条件如果包含了后面的条件，只是这个条件在这棵树中是无用的，如果把这个条件拿出来也是可以帮助分析数据。</p>
</blockquote>
<p>9.决策树的优缺点？</p>
<blockquote>
<p>优点: </p>
<ul>
<li><p>决策树模型可读性好，具有描述性，有助于人工分析；</p>
</li>
<li><p>基本不需要预处理，不需要提前归一化，处理缺失值；</p>
</li>
<li><p>对于异常点的容错能力好，健壮性高；</p>
</li>
<li><p>效率高，决策树只需要一次性构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</p>
</li>
</ul>
<p>缺点: </p>
<ul>
<li><p>决策树算法非常容易过拟合，导致泛化能力不强。可以通过设置节点最少样本数量和限制决策树深度来改进；</p>
</li>
<li><p>对中间值的缺失敏感；</p>
</li>
<li><p>决策树会因为样本发生一点点的改动，就会导致树结构的剧烈改变。这个可以通过集成学习之类的方法解决；</p>
</li>
<li><p>寻找最优的决策树是一个NP难的问题，我们一般是通过启发式方法，容易陷入局部最优。可以通过集成学习之类的方法来改善；</p>
</li>
<li><p>有些比较复杂的关系，决策树很难学习，比如异或。这个就没有办法了，一般这种关系可以换神经网络分类方法来解决；</p>
</li>
<li><p>如果某些特征的样本比例过大，生成决策树容易偏向于这些特征。这个可以通过调节样本权重来改善。</p>
</li>
</ul>
</blockquote>
<p>10.基尼系数存在的问题?</p>
<blockquote>
<p>基尼指数偏向于多值属性；当类数较大时，基尼指数求解比较困难；基尼指数倾向于支持在两个分区中生成大小相同的测试。</p>
</blockquote>
<h3 id="面试真题"><a href="#面试真题" class="headerlink" title="面试真题"></a>面试真题</h3><p>1.决策树如何防止过拟合？</p>
<p>2.信息增益比相对信息增益有什么好处？</p>
<p>3.如果有异常值或者数据分布不均匀，会对决策树有什么影响？</p>
<p>4.手动构建CART的回归树的前两个节点，给出公式每一步的公式推到？</p>
<p>5.决策树和其他模型相比有什么优点？</p>
<p>6.决策树的目标函数是什么？</p>
<p>7.树形结构为什么不需要归一化?</p>
<blockquote>
<ul>
<li>数值缩放不影响分裂点位置，对树模型的结构不造成影响。</li>
<li>按照特征值进行排序的，排序的顺序不变，那么所属的分支以及分裂点就不会有不同。</li>
<li>树模型是不能进行梯度下降的，因为构建树模型（回归树）寻找最优点时是通过寻找最优分裂点完成的，因此树模型是阶跃的，阶跃点是不可导的，并且求导没意义，也就不需要归一化。</li>
</ul>
</blockquote>
<p>以下内容来自 <a href="https://www.cnblogs.com/liuyingjun/p/10590095.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuyingjun/p/10590095.html</a></p>
<p>引自知乎——数据取经团：吕洞宾</p>
<p>面试官：小张同学，你好，看了你的简历，对相关算法还是略懂一些，下面开始我们的面试，有这么一个场景，在一个样本集中，其中有100个样本属于A，9900个样本属于B，我想用决策树算法来实现对AB样本进行区分，这时会遇到什么问题：</p>
<p>小张：欠拟合现象，因为在这个样本集中，AB样本属于严重失衡状态，在建立决策树算法的过程中，模型会更多的偏倚到B样本的性质，对A样本的性质训练较差，不能很好的反映样本集的特征。</p>
<p>面试官：看你决策树应该掌握的不错，你说一下自己对于决策树算法的理解？</p>
<p>小张：决策树算法，无论是哪种，其目的都是为了让模型的不确定性降低的越快越好，基于其评价指标的不同，主要是ID3算法，C4.5算法和CART算法，其中ID3算法的评价指标是信息增益，C4.5算法的评价指标是信息增益率，CART算法的评价指标是基尼系数。</p>
<p>面试官：信息增益，好的，这里面有一个信息论的概念，你应该知道的吧，叙述一下</p>
<p>小张：香农熵，随机变量不确定性的度量。利用ID3算法，每一次对决策树进行分叉选取属性的时候，我们会选取信息增益最高的属性来作为分裂属性，只有这样，决策树的不纯度才会降低的越快。</p>
<p>面试官：OK，你也知道，在决策树无限分叉的过程中，会出现一种现象，叫过拟合，和上面说过的欠拟合是不一样的，你说一下过拟合出现的原因以及我们用什么方法来防止过拟合的产生？</p>
<p>小张：对训练数据预测效果很好，但是测试数据预测效果较差，则称出现了过拟合现象。对于过拟合现象产生的原因，有以下几个方面，第一：在决策树构建的过程中，对决策树的生长没有进行合理的限制（剪枝）；第二：在建模过程中使用了较多的输出变量，变量较多也容易产生过拟合；第三：样本中有一些噪声数据，噪声数据对决策树的构建的干扰很多，没有对噪声数据进行有效的剔除。对于过拟合现象的预防措施，有以下一些方法，第一：选择合理的参数进行剪枝，可以分为预剪枝后剪枝，我们一般用后剪枝的方法来做；第二：K-folds交叉验证，将训练集分为K份，然后进行K次的交叉验证，每次使用K-1份作为训练样本数据集，另外的一份作为测试集合（作者说反了，应该是份作为测试集，其余k-1份作为训练集）； 第三：减少特征，计算每一个特征和响应变量的相关性，常见的为皮尔逊相关系数，将相关性较小的变量剔除，当然还有一些其他的方法来进行特征筛选，比如基于决策树的特征筛选，通过正则化的方式来进行特征选取等。</p>
<p>面试官：你刚刚前面有提到预剪枝和后剪枝，当然预剪枝就是在决策树生成初期就已经设置了决策树的参数，后剪枝是在决策树完全建立之后再返回去对决策树进行剪枝，你能否说一下剪枝过程中可以参考的某些参数？</p>
<p>小张：剪枝分为预剪枝和后剪枝，参数有很多，在R和Python中都有专门的参数来进行设置，下面我以Python中的参数来进行叙述，max_depth（树的高度），min_samples_split（叶子结点的数目），max_leaf_nodes（最大叶子节点数），min_impurity_split（限制不纯度），当然R语言里面的rpart包也可以很好的处理这个问题。</p>
<p>面试官：对了，你刚刚还说到了用决策树来进行特征的筛选，现在我们就以ID3算法为例，来说一下决策树算法对特征的筛选？</p>
<p>小张：对于离散变量，计算每一个变量的信息增益，选择信息增益最大的属性来作为结点的分裂属性；对于连续变量，首先将变量的值进行升序排列，每对相邻值的中点作为可能的分离点，对于每一个划分，选择具有最小期望信息要求的点作为分裂点，来进行后续的决策数的分裂。</p>
<p>面试官：你刚刚还说到了正则化，确实可以对过拟合现象来进行很好的调整，基于你自己的理解，来说一下正则化？</p>
<p>小张：这一块的知识掌握的不是很好，我简单说一下自己对这一块的了解。以二维情况为例，在L1正则化中，惩罚项是绝对值之和，因此在坐标轴上会出现一个矩形，但是L2正则化的惩罚项是圆形，因此在L1正则化中增大了系数为0的机会，这样具有稀疏解的特性，在L2正则化中，由于系数为0的机率大大减小，因此不具有稀疏解的特性。但是L1没有选到的特性不代表不重要，因此L1和L2正则化要结合起来使用。</p>
<p>面试官：还可以吧！正则化就是在目标函数后面加上了惩罚项，你也可以将后面的惩罚项理解为范数。分类算法有很多，逻辑回归算法也是我们经常用到的算法，刚刚主要讨论的是决策树算法，现在我们简单聊一下不同分类算法之间的区别吧！讨论一下决策树算法和逻辑回归算法之间的区别？</p>
<p>小张：分为以下几个方面：第一，逻辑回归着眼于对整体数据的拟合，在整体结构上优于决策树； 但是决策树采用分割的方法，深入到数据内部，对局部结构的分析是优于逻辑回归；第二，逻辑回归对线性问题把握较好，因此我们在建立分类算法的时候也是优先选择逻辑回归算法，决策树对非线性问题的把握较好；第三，从本质来考虑，决策树算法假设每一次决策边界都是和特征相互平行或垂直的，因此会将特征空间划分为矩形，因而决策树会产生复杂的方程式，这样会造成过拟合现象；逻辑回归只是一条平滑的边界曲线，不容易出现过拟合现象。</p>]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Time Series</title>
    <url>/2020/04/02/Time-Series/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源：<a href="https://courses.analyticsvidhya.com/courses/creating-time-series-forecast-using-python" target="_blank" rel="noopener">Time Series Forecasting using Python - Analytics Vidhya</a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="What-is-Time-Series-Analysis"><a href="#What-is-Time-Series-Analysis" class="headerlink" title="What is Time Series Analysis?"></a>What is Time Series Analysis?</h3><p> As the name ‘time series forecasting’ suggests, it involves working on time (years, days, hours, minutes) based data, to derive hidden insights to make informed decision making.</p>
<h3 id="Importance-of-Time-Series-Analysis"><a href="#Importance-of-Time-Series-Analysis" class="headerlink" title="Importance of Time Series Analysis"></a>Importance of Time Series Analysis</h3><p>Time series models are very useful models when you have serially correlated data as shown above. Most businesses work on time series data to analyze </p>
<ul>
<li>Sales numbers for the next year </li>
<li>Website Traffic</li>
<li>Competition Position</li>
<li>Demand of products</li>
<li>Stock Market Analysis</li>
<li>Census Analysis</li>
<li>Budgetary Analysis</li>
</ul>
<p>This is just the tip of the iceberg and there are numerous prediction problems that involve a time component and concepts of time series analysis come into picture.</p>
<h3 id="Why-is-Time-Series-Forecasting-Challenging"><a href="#Why-is-Time-Series-Forecasting-Challenging" class="headerlink" title="Why is Time Series Forecasting Challenging?"></a>Why is Time Series Forecasting Challenging?</h3><p>But what makes a time series more challenging than say a regular regression problem? There are 2 things:</p>
<ul>
<li><strong>Time Dependence of a time series -</strong> The basic assumption of a linear regression model that the observations are independent doesn’t hold in this case.</li>
<li><strong>Seasonality in a time series -</strong> Along with an increasing or decreasing trend, most time series have some form of seasonal trends, i.e. variations specific to a particular time frame. </li>
</ul>
<a id="more"></a>
<h2 id="Introduction-to-Time-Series"><a href="#Introduction-to-Time-Series" class="headerlink" title="Introduction to Time Series"></a>Introduction to Time Series</h2><p><em>Time Series is generally data which is collected over time and is dependent on it.</em></p>
<p><img src="/2020/04/02/Time-Series/1585797313470.png" alt="1585797313470"></p>
<p>Here we see that the count of cars is independent of time, hence it is not a time series. While the CO2 level increases with respect to time, hence it is a time series.</p>
<p>Some of the examples of time series are:</p>
<p>Stock Price :</p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/865/5c1/2c7/1549344770403.jpg" alt="img"></p>
<p>Passenger Count of an airlines :</p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/a5d/87f/854/1549344770489.jpg" alt="img"></p>
<p>Temperature over time :</p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/1e6/e15/479/1549344770578.jpg" alt="img"></p>
<p>Number of visitors in a hotel :</p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/8e3/d40/890/1549344770669.jpg" alt="img"></p>
<h3 id="Trend"><a href="#Trend" class="headerlink" title="Trend"></a>Trend</h3><p>Trend is a general direction in which something is developing or changing.</p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/7d7/791/f5e/1549344821475.jpg" alt="Example"></p>
<p>Example</p>
<p>Here the red line represents an increasing trend of the time series.</p>
<h3 id="Seasonality"><a href="#Seasonality" class="headerlink" title="Seasonality"></a><strong>Seasonality</strong></h3><p>Another clear pattern can also be seen in the above time series, i.e., the pattern is repeating at regular time interval which is known as the seasonality. Any predictable change or pattern in a time series that recurs or repeats over a specific time period can be said to be seasonality. </p>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/115/9ee/826/1549344821557.jpg" alt="Example"></p>
<p>Example</p>
<p>We can see that the time series is repeating its pattern after every 12 months i.e there is a peak every year during the month of January and a trough every year in the month of September, hence this time series has a seasonality of 12 months.</p>
<h3 id="Difference-between-a-time-series-and-regression-problem"><a href="#Difference-between-a-time-series-and-regression-problem" class="headerlink" title="Difference between a time series and regression problem"></a><strong>Difference between a time series and regression problem</strong></h3><ul>
<li>The main difference is that a time series is time dependent. So the basic assumption of a linear regression model that the observations are independent doesn’t hold in this case.</li>
<li>Along with an increasing or decreasing trend, most Time Series have some form of seasonality trends,i.e. variations specific to a particular time frame.</li>
</ul>
<p>So, predicting a time series using regression techniques is not a good approach.</p>
<p>Time series analysis comprises methods for analyzing time series data in order to extract meaningful statistics and other characteristics of the data. Time series forecasting is the use of a model to predict future values based on previously observed values.</p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><p> <a href="https://datahack.analyticsvidhya.com/contest/practice-problem-time-series-2/" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-time-series-2/</a></p>
<h3 id="Problem-Statement"><a href="#Problem-Statement" class="headerlink" title="Problem Statement"></a>Problem Statement</h3><p>Unicorn Investors wants to make an investment in a new form of transportation - JetRail. JetRail uses Jet propulsion technology to run rails and move people at a high speed! The investment would only make sense, if they can get more than 1 Million monthly users with in next 18 months. In order to help Unicorn Ventures in their decision, you need to forecast the traffic on JetRail for the next 7 months. You are provided with traffic data of JetRail since inception in the test file.</p>
<h3 id="Exploratory-Analysis"><a href="#Exploratory-Analysis" class="headerlink" title="Exploratory Analysis"></a>Exploratory Analysis</h3><p>原本的datetime: train.Datetime是Object格式，首先change the data type to datetime format</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train[<span class="string">'Datetime'</span>] = pd.to_datetime(train.Datetime,format=<span class="string">'%d-%m-%Y %H:%M'</span>) </span><br><span class="line"><span class="comment"># format是原格式的形式</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train.index = train[<span class="string">'Datetime'</span>] <span class="comment"># indexing the Datetime to get the time period on the x-axis.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line">ts = df[<span class="string">'Count'</span>] </span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">8</span>)) </span><br><span class="line">plt.plot(ts, label=<span class="string">'Passenger Count'</span>) </span><br><span class="line">plt.title(<span class="string">'Time Series'</span>) </span><br><span class="line">plt.xlabel(<span class="string">"Time(year-month)"</span>) </span><br><span class="line">plt.ylabel(<span class="string">"Passenger count"</span>) </span><br><span class="line">plt.legend(loc=<span class="string">'best'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://s3.amazonaws.com/thinkific/file_uploads/118220/images/a58/220/12e/1549346696050.jpg" alt="png"></p>
<h3 id="Split-data"><a href="#Split-data" class="headerlink" title="Split data"></a>Split data</h3><p>将训练数据划分为训练集与验证集</p>
<p>The starting date of the dataset is 25-08-2012 as we have seen in the exploration part and the end date is 25-09-2014.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Train=train.ix[<span class="string">'2012-08-25'</span>:<span class="string">'2014-06-24'</span>] valid=train.ix[<span class="string">'2014-06-25'</span>:<span class="string">'2014-09-25'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>We have done time based validation here by selecting the last 3 months for the validation data and rest in the train data. If we would have done it randomly it may work well for the train dataset but will not work effectively on validation dataset.</li>
<li>Lets understand it in this way: If we choose the split randomly it will take some values from the starting and some from the last years as well. It is similar to predicting the old values based on the future values which is not the case in real scenario. So, this kind of split is used while working with time related problems.</li>
</ul>
<p>划分标准：将最后3个月的数据划分为验证集，而不是随机划分。因为若是随机划分，则存在用future value去预测old value的情况，而这在现实情况中是不可能的。</p>
<h3 id="ARIMA-model"><a href="#ARIMA-model" class="headerlink" title="ARIMA model"></a>ARIMA model</h3><p>ARIMA Model的介绍可见：<a href="https://www.youtube.com/watch?v=0xHf-SJ9Z9U" target="_blank" rel="noopener">https://www.youtube.com/watch?v=0xHf-SJ9Z9U</a></p>
<ul>
<li>ARIMA stands for Auto Regression Integrated Moving Average. It is specified by three ordered parameters (p,d,q).</li>
<li>Here p is the order of the autoregressive model(number of time lags)</li>
<li>d is the degree of differencing(number of times the data have had past values subtracted)</li>
<li>q is the order of moving average model. We will discuss more about these parameters in next section.</li>
</ul>
<p>The ARIMA forecasting for a stationary time series is nothing but a linear (like a linear regression) equation.</p>
<h4 id="What-is-a-stationary-time-series"><a href="#What-is-a-stationary-time-series" class="headerlink" title="What is a stationary time series?"></a>What is a stationary time series?</h4><p>There are three basic criterion for a series to be classified as stationary series :</p>
<ul>
<li>The mean of the time series should not be a function of time. It should be constant.</li>
<li>The variance of the time series should not be a function of time.</li>
<li>THe covariance of the ith term and the (i+m)th term should not be a function of time.</li>
</ul>
<h4 id="Why-do-we-have-to-make-the-time-series-stationary"><a href="#Why-do-we-have-to-make-the-time-series-stationary" class="headerlink" title="Why do we have to make the time series stationary?"></a>Why do we have to make the time series stationary?</h4><p>We make the series stationary to make the variables independent. Variables can be dependent in various ways, but can only be independent in one way. So, we will get more information when they are independent. Hence the time series must be stationary.</p>
<p>If the time series is not stationary, firstly we have to make it stationary. For doing so, we need to remove the trend and seasonality from the data. To learn more about stationarity you can refer this article: <a href="https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2015/12/complete-tutorial-time-series-modeling/</a></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>时间序列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据挖掘</title>
    <url>/2020/04/01/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源：书籍：数据挖掘：R语言实战</p>
<h2 id="1-数据挖掘"><a href="#1-数据挖掘" class="headerlink" title="1. 数据挖掘"></a>1. 数据挖掘</h2><h3 id="数据挖掘的过程"><a href="#数据挖掘的过程" class="headerlink" title="数据挖掘的过程"></a>数据挖掘的过程</h3><p><img src="/2020/04/01/数据挖掘/1585702561613.png" alt="1"></p>
<p><img src="/2020/04/01/数据挖掘/1585702611608.png" alt="1585702611608"></p>
<p><img src="/2020/04/01/数据挖掘/1585702665564.png" alt="1585702665564"></p>
<p><img src="/2020/04/01/数据挖掘/1585702697687.png" alt="1585702697687"></p>
<h3 id="数据挖掘的对象"><a href="#数据挖掘的对象" class="headerlink" title="数据挖掘的对象"></a>数据挖掘的对象</h3><p><img src="/2020/04/01/数据挖掘/1585702748399.png" alt="1585702748399"></p>
<a id="more"></a>
<h3 id="数据挖掘的方法"><a href="#数据挖掘的方法" class="headerlink" title="数据挖掘的方法"></a>数据挖掘的方法</h3><p><img src="/2020/04/01/数据挖掘/1585702952640.png" alt="1585702952640"></p>
<p><img src="/2020/04/01/数据挖掘/1585702973741.png" alt="1585702973741"></p>
<p><img src="/2020/04/01/数据挖掘/1585702996306.png" alt="1585702996306"></p>
<h2 id="2-数据概览"><a href="#2-数据概览" class="headerlink" title="2. 数据概览"></a>2. 数据概览</h2><h3 id="R的数据分类"><a href="#R的数据分类" class="headerlink" title="R的数据分类"></a>R的数据分类</h3><p><img src="/2020/04/01/数据挖掘/1585708306115.png" alt="1585708306115"></p>
<p><img src="/2020/04/01/数据挖掘/1585708352907.png" alt="1585708352907"></p>
<p><img src="/2020/04/01/数据挖掘/1585708426054.png" alt="1585708426054"></p>
<p><img src="/2020/04/01/数据挖掘/1585708478937.png" alt="1585708478937"></p>
<p><img src="/2020/04/01/数据挖掘/1585708516071.png" alt="1585708516071"></p>
<h3 id="用R简单处理数据"><a href="#用R简单处理数据" class="headerlink" title="用R简单处理数据"></a>用R简单处理数据</h3><p>这一部分我们以MASS软件包中的Insurance数据集为例，通过对其基本信息及变量类型等<br>方面的探索，介绍几个常用的R函数。在着手处理每一个数据集时，包括进行数据预处理及后续分析的过程中，这些函数通常会被反复使用，可以说是展开数据挖掘的必经步骤。</p>
<p><img src="/2020/04/01/数据挖掘/1585708954877.png" alt="1585708954877"></p>
<p><img src="/2020/04/01/数据挖掘/1585708983273.png" alt="1585708983273"></p>
<p><img src="/2020/04/01/数据挖掘/1585709046088.png" alt="1585709046088"></p>
<p><img src="/2020/04/01/数据挖掘/1585709085363.png" alt="1585709085363"></p>
<p><img src="/2020/04/01/数据挖掘/1585709217345.png" alt="1585709217345"></p>
<p><img src="/2020/04/01/数据挖掘/1585709257400.png" alt="1585709257400"></p>
<h3 id="数据抽样"><a href="#数据抽样" class="headerlink" title="数据抽样"></a>数据抽样</h3><p>抽样技术是我们在和数据打交道过程中常常需要用到的基本技能之一。</p>
<p>比如：在收集数据过程中，绝大多数情况下，并不采取普查的方式获取总体中所有样本的数据信息，而是以各类抽样方法抽取其中的若干代表性样本来进行数据获取和分析：而在获得待分析数据集后，往往需要再次通过抽样技术选取出训练集与测试集，以便比较选择出最优的挖掘算法。</p>
<p>以下我们主要介绍简单随机抽样、分层抽样及整群抽样这三种基本抽样方法在R中的实现。其中主要用到<code>base</code>软件包中的<code>sample()</code>函数，该软件包是R中使用前不需加载的默认软件包之一，其中含有许多基本统计函数；以及<code>sampling</code>软件包中的<code>strata()</code>、<code>cluster()</code>函数，该软件包专用于实现调查抽样技术，其中含有大量各类抽样方法及相关指标的计算等函数。</p>
<h4 id="简单随机抽样"><a href="#简单随机抽样" class="headerlink" title="简单随机抽样"></a>简单随机抽样</h4><p><img src="/2020/04/01/数据挖掘/1585706632444.png" alt="1585706632444"></p>
<h5 id="有放回的随机抽样"><a href="#有放回的随机抽样" class="headerlink" title="有放回的随机抽样"></a>有放回的随机抽样</h5><p><img src="/2020/04/01/数据挖掘/1585706684055.png" alt="1585706684055"></p>
<p><img src="/2020/04/01/数据挖掘/1585706725890.png" alt="1585706725890"></p>
<p><img src="/2020/04/01/数据挖掘/1585706752383.png" alt="1585706752383"></p>
<h5 id="无放回的随机抽样"><a href="#无放回的随机抽样" class="headerlink" title="无放回的随机抽样"></a>无放回的随机抽样</h5><p><img src="/2020/04/01/数据挖掘/1585706789410.png" alt="1585706789410"></p>
<h4 id="分层抽样"><a href="#分层抽样" class="headerlink" title="分层抽样"></a>分层抽样</h4><p><img src="/2020/04/01/数据挖掘/1585707032237.png" alt="1585707032237"></p>
<p><img src="/2020/04/01/数据挖掘/1585707055590.png" alt="1585707055590"></p>
<p><img src="/2020/04/01/数据挖掘/1585707081081.png" alt="1585707081081"></p>
<p><img src="/2020/04/01/数据挖掘/1585707104352.png" alt="1585707104352"></p>
<p><img src="/2020/04/01/数据挖掘/1585707127382.png" alt="1585707127382"></p>
<p><img src="/2020/04/01/数据挖掘/1585707162805.png" alt="1585707162805"></p>
<p><img src="/2020/04/01/数据挖掘/1585707188396.png" alt="1585707188396"></p>
<h4 id="整群抽样"><a href="#整群抽样" class="headerlink" title="整群抽样"></a>整群抽样</h4><p><img src="/2020/04/01/数据挖掘/1585707442032.png" alt="1585707442032"></p>
<p><img src="/2020/04/01/数据挖掘/1585707564705.png" alt="1585707564705"></p>
<p><img src="/2020/04/01/数据挖掘/1585707593282.png" alt="1585707593282"></p>
<p><img src="/2020/04/01/数据挖掘/1585707615607.png" alt="1585707615607"></p>
<h3 id="训练集与测试集"><a href="#训练集与测试集" class="headerlink" title="训练集与测试集"></a>训练集与测试集</h3><p>一般我们控制两者的比例为3:1左右，这是为了在保证建立模型的训练集样本足够的前提下，尽量使测试集的评价结果可信。</p>
<p><img src="/2020/04/01/数据挖掘/1585709638657.png" alt="1585709638657"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/04/01/数据挖掘/1585709698423.png" alt="1585709698423"></p>
<p><img src="/2020/04/01/数据挖掘/1585709720262.png" alt="1585709720262"></p>
<h2 id="3-用R获取数据"><a href="#3-用R获取数据" class="headerlink" title="3. 用R获取数据"></a>3. 用R获取数据</h2><h3 id="获取内置数据集"><a href="#获取内置数据集" class="headerlink" title="获取内置数据集"></a>获取内置数据集</h3><h4 id="datasets数据集"><a href="#datasets数据集" class="headerlink" title="datasets数据集"></a>datasets数据集</h4><p><img src="/2020/04/01/数据挖掘/1585709889840.png" alt="1585709889840"></p>
<p><img src="/2020/04/01/数据挖掘/1585709919129.png" alt="1585709919129"></p>
<p><img src="/2020/04/01/数据挖掘/1585709942978.png" alt="1585709942978"></p>
<p><img src="/2020/04/01/数据挖掘/1585709978867.png" alt="1585709978867"></p>
<h4 id="包的数据集"><a href="#包的数据集" class="headerlink" title="包的数据集"></a>包的数据集</h4><p>除了datasets软件包外，R中许多其他软件包也自带有少量数据集，我们首先通过如下程序代码，来获得如图3.3所示的所有数据集的列表。</p>
<p><img src="/2020/04/01/数据挖掘/1585710056729.png" alt="1585710056729"></p>
<p>我们要知道，某一软件包中的数据集，往往正是由于适合诠释该软件包内相关函数的功能而收集并添置的，也就是说，某一软件包中的数据集在格式、内容，甚至取值等方面，在某种程度上是迎合于该软件包的功能需要的。</p>
<p><img src="/2020/04/01/数据挖掘/1585710151137.png" alt="1585710151137"></p>
<h3 id="获取其他格式的数据"><a href="#获取其他格式的数据" class="headerlink" title="获取其他格式的数据"></a>获取其他格式的数据</h3><p>这一节我们主要介绍如何用R读取由固定分隔符作为数据间隔的文件，如CSV和TXT;如何读取Excel文件中的数据；如何从SPSS、Minitab、STATA、SYSTAT等统计软件中获取多种格式的数据。为了完成上述任务，我们将用到utlls、RODBC、gdata、foreign及Hmisc加载包中的多种函数。</p>
<h4 id="CSV与TXT格式"><a href="#CSV与TXT格式" class="headerlink" title="CSV与TXT格式"></a>CSV与TXT格式</h4><p>下面我们使用到utils软件包中的read.csv(）和read.table(）函数，utils包中含有大量R中最实<br>用的函数，其中包括帮助函数help()以及安装软件包函数installed.packages()等。</p>
<h5 id="读取CSV格式"><a href="#读取CSV格式" class="headerlink" title="读取CSV格式"></a>读取CSV格式</h5><p><img src="/2020/04/01/数据挖掘/1585710410455.png" alt="1585710410455"></p>
<p><img src="/2020/04/01/数据挖掘/1585710532350.png" alt="1585710532350"></p>
<p><img src="/2020/04/01/数据挖掘/1585710551806.png" alt="1585710551806"></p>
<h5 id="读取TXT格式"><a href="#读取TXT格式" class="headerlink" title="读取TXT格式"></a>读取TXT格式</h5><p><img src="/2020/04/01/数据挖掘/1585710664703.png" alt="1585710664703"></p>
<h4 id="从Excel直接获取数据"><a href="#从Excel直接获取数据" class="headerlink" title="从Excel直接获取数据"></a>从Excel直接获取数据</h4><p><img src="/2020/04/01/数据挖掘/1585710773419.png" alt="1585710773419"></p>
<p><img src="/2020/04/01/数据挖掘/1585710795936.png" alt="1585710795936"></p>
<p><img src="/2020/04/01/数据挖掘/1585710816961.png" alt="1585710816961"></p>
<h4 id="从其他统计软件中获取数据"><a href="#从其他统计软件中获取数据" class="headerlink" title="从其他统计软件中获取数据"></a>从其他统计软件中获取数据</h4><p>我们将使用foreign软件包中的相关函数，该软件包的主要功能即是读写SPSS、SAS、Minitab、<br>Stata、Systat等统计软件中的数据。</p>
<h5 id="从SPSS获取数据"><a href="#从SPSS获取数据" class="headerlink" title="从SPSS获取数据"></a>从SPSS获取数据</h5><p><img src="/2020/04/01/数据挖掘/1585710963416.png" alt="1585710963416"></p>
<p><img src="/2020/04/01/数据挖掘/1585710992751.png" alt="1585710992751"></p>
<p><img src="/2020/04/01/数据挖掘/1585711020984.png" alt="1585711020984"></p>
<p><img src="/2020/04/01/数据挖掘/1585711042365.png" alt="1585711042365"></p>
<h5 id="从SAS、Minitab、STATA、SYSTAT中获取数据"><a href="#从SAS、Minitab、STATA、SYSTAT中获取数据" class="headerlink" title="从SAS、Minitab、STATA、SYSTAT中获取数据"></a>从SAS、Minitab、STATA、SYSTAT中获取数据</h5><p><img src="/2020/04/01/数据挖掘/1585711134273.png" alt="1585711134273"></p>
<h3 id="获取数据库数据"><a href="#获取数据库数据" class="headerlink" title="获取数据库数据"></a>获取数据库数据</h3><p><img src="/2020/04/01/数据挖掘/1585711399514.png" alt="1585711399514"></p>
<p><img src="/2020/04/01/数据挖掘/1585711419648.png" alt="1585711419648"></p>
<p><img src="/2020/04/01/数据挖掘/1585711437360.png" alt="1585711437360"></p>
<p><img src="/2020/04/01/数据挖掘/1585711487670.png" alt="1585711487670"></p>
<p><img src="/2020/04/01/数据挖掘/1585711516518.png" alt="1585711516518"></p>
<p><img src="/2020/04/01/数据挖掘/1585711542616.png" alt="1585711542616"></p>
<h3 id="获取网页数据"><a href="#获取网页数据" class="headerlink" title="获取网页数据"></a>获取网页数据</h3><p><img src="/2020/04/01/数据挖掘/1585711889961.png" alt="1585711889961"></p>
<p><a href="http://stockdata.stock.hexun.com/2008en/zxcwzb.aspx?stockid=000002&amp;type=1&amp;date=2013.06.30" target="_blank" rel="noopener">http://stockdata.stock.hexun.com/2008en/zxcwzb.aspx?stockid=000002&amp;type=1&amp;date=2013.06.30</a></p>
<p><img src="/2020/04/01/数据挖掘/1585711961289.png" alt="1585711961289"></p>
<p><img src="/2020/04/01/数据挖掘/1585712253379.png" alt="1585712253379"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="keyword">library</span>(XML)</span><br><span class="line">ul = <span class="string">"http://stockdata.stock.hexun.com/2008en/zxcwzb.aspx?stockid=000002&amp;type=1&amp;date=2013.06.30"</span></span><br><span class="line">tables1 = readHTMLTable(ul)</span><br><span class="line">names(tables1)</span><br></pre></td></tr></table></figure>
<p>[1] “NULL”  “NULL”  “NULL”  “NULL”</p>
<p>如上我们知道所读取结果共有4个部分，因此，可以分别查看tables1中4个维度中所储存的<br>信息，以下仅输出其中的第2、3维度的数据。</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tables1[[<span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/01/数据挖掘/1585712408039.png" alt="1585712408039"></p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">tables1[[<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>
<p><img src="/2020/04/01/数据挖掘/1585712457342.png" alt="1585712457342"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/04/01/数据挖掘/1585712504471.png" alt="1585712504471"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据挖掘</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表,顺序表与数组</title>
    <url>/2020/03/05/%E7%BA%BF%E6%80%A7%E8%A1%A8-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/foreverhuylee/article/details/37813053?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/foreverhuylee/article/details/37813053?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p>
<ol>
<li><p>数组就是相同数据类型的元素按一定顺序排列的集合。</p>
<p>一句话：就是物理上存储在一组联系的地址上。也称为数据结构中的物理结构。</p>
</li>
<li><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。</p>
<p>一句话：线性表是数据结构中的逻辑结构。可以存储在数组上，也可以存储在链表上。</p>
</li>
<li><p>线性表的结点按逻辑次序依次存放在一组地址连续的存储单元里的方法。用顺序存储方法存储的线性表简称为顺序表。</p>
<p>一句话：用数组来存储的线性表就是顺序表。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>牛客-剑指offer</title>
    <url>/2020/03/05/%E7%89%9B%E5%AE%A2-%E5%89%91%E6%8C%87offer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="二维数组中的查找"><a href="#二维数组中的查找" class="headerlink" title="二维数组中的查找"></a>二维数组中的查找</h4><p><a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><u>方法</u>：</p>
<p>从左下找</p>
<p><a href="https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/abc3fe2ce8e146608e868a70efebf62e?answerType=1&amp;f=discussion</a></p>
<p>对于左下角的值 m，m 是该行最小的数，是该列最大的数<br>每次将 m 和目标值 target 比较：</p>
<ol>
<li>当 m &lt; target，由于 m 已经是该行最大的元素，想要更大只有从列考虑，取值右移一位 </li>
<li>当 m &gt; target，由于 m 已经是该列最小的元素，想要更小只有从行考虑，取值上移一位 </li>
<li>当 m = target，找到该值，返回 true </li>
</ol>
<p>用某行最小或某列最大与 target 比较，每次可剔除一整行或一整列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = array.length;</span><br><span class="line">        <span class="keyword">int</span> c = array[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左下角</span></span><br><span class="line">        <span class="keyword">int</span> cur_r = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cur_c = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur_r &gt;= <span class="number">0</span> &amp;&amp; cur_c &lt;= c-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = array[cur_r][cur_c];</span><br><span class="line">            <span class="keyword">if</span>(target == cur)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &lt; cur)</span><br><span class="line">                cur_r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target &gt; cur)</span><br><span class="line">                cur_c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>复杂度</u>：</p>
<p>时间复杂度：O(行高 + 列宽)<br>空间复杂度：O(1)</p>
<hr>
<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><p><a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p>
<p><u>法一</u>：将链表翻转，再依次加入ArrayList</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr.add(prev.val);</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>法二</u>：利用ArrayList的方法<code>add(int index, E element)</code>,每次将链表中的元素添加至索引0处</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ListNode cur = listNode;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arr.add(<span class="number">0</span>,cur.val);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>复杂度</u>：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<a id="more"></a>
<hr>
<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4><p><a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<p><u>方法</u>：</p>
<p>递归</p>
<p>根据中序遍历和前序遍历可以确定二叉树，具体过程为：</p>
<ol>
<li>根据前序序列第一个结点确定根结点</li>
<li>根据根结点在中序序列中的位置分割出左右两个子序列</li>
<li>对左子树和右子树分别递归使用同样的方法继续分解</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.length==<span class="number">0</span> || in.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i]==pre[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//copyOfRange 函数，左闭右开</span></span><br><span class="line">                root.left = reConstructBinaryTree(Arrays.copyOfRange(pre,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(in,<span class="number">0</span>,i));</span><br><span class="line">                root.right = reConstructBinaryTree(Arrays.copyOfRange(pre,i+<span class="number">1</span>,pre.length),Arrays.copyOfRange(in,i+<span class="number">1</span>,in.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>复杂度</u>：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<hr>
<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h4><p><a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述：</u></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123; </span><br><span class="line">        <span class="comment">// 注意这里有个stack2要是empty的条件，若stack2不是empty却往里push stack1中的元素，会出错</span></span><br><span class="line">            <span class="keyword">while</span>(!stack1.empty())&#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="旋转数组的最小数字"><a href="#旋转数组的最小数字" class="headerlink" title="旋转数组的最小数字"></a>旋转数组的最小数字</h4><p><a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end = array.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(array[start]&lt;array[end])</span><br><span class="line">            <span class="keyword">return</span> array[start];</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start+end)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid&gt;<span class="number">1</span> &amp;&amp; array[mid-<span class="number">1</span>]&gt;array[mid])</span><br><span class="line">                <span class="keyword">return</span> array[mid];</span><br><span class="line">            <span class="keyword">if</span>(array[mid]&gt;array[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">// 往右</span></span><br><span class="line">                start = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[mid]&lt;array[<span class="number">0</span>])</span><br><span class="line">                <span class="comment">// 往左</span></span><br><span class="line">                end = mid-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h4><p><a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p>
<p>n&lt;=39</p>
<p><u>方法</u>：</p>
<p>优化动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> F1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> F2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">int</span> F3 = F1 + F2;</span><br><span class="line">            F1 = F2;</span><br><span class="line">            F2 = F3;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>复杂度</u>：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h4 id="跳台阶"><a href="#跳台阶" class="headerlink" title="跳台阶"></a>跳台阶</h4><p><a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
<p><u>方法</u>：</p>
<p>优化动态规划</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> F1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> F2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> F3 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            F3 = F1 + F2;</span><br><span class="line">            F1 = F2;</span><br><span class="line">            F2 = F3;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> F2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><u>复杂度</u>：</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<hr>
<h4 id="变态跳台阶"><a href="#变态跳台阶" class="headerlink" title="变态跳台阶"></a>变态跳台阶</h4><p><a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><u>方法</u>：</p>
<p>易知 f(n)=f(n-1)+f(n-2)+……f(1)<br>f(n-1)=f(n-2)+……f(1)<br>两式相减得f(n)=2f(n-1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            f2 = <span class="number">2</span>*f1;</span><br><span class="line">            f1 = f2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="矩形覆盖"><a href="#矩形覆盖" class="headerlink" title="矩形覆盖"></a>矩形覆盖</h4><p><a href="https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6?tpId=13&amp;tqId=11163&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>:</p>
<p>我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p>
<p>比如n=3时，2*3的矩形块有3种覆盖方法：</p>
<p><img src="/2020/03/05/牛客-剑指offer/1583470479650.png" alt="1583470479650"></p>
<p><u>方法：迭代</u></p>
<p>类似斐波那契数列</p>
<p>f(n) = f(n-1) + f(n-2)</p>
<p><img src="/2020/03/05/牛客-剑指offer/20200306-162012.jpg" alt="20200306-162012"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> f0=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f1=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> f2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++)&#123;</span><br><span class="line">            f2 = f0 + f1;</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = f2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a>二进制中1的个数</h4><p><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8?tpId=13&amp;tqId=11164&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p>
<p>（注：输入的是二进制表示形式）</p>
<p><u>方法</u>：</p>
<p>一个二进制数减去1，再和原二进制数做<code>与运算</code>，会把该数最右边的1变为0，那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>
<p><a href="https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/8ee967e43c2c4ec193b040ea7fbb10b8?answerType=1&amp;f=discussion</a></p>
<p>举个例子：一个二进制数1100，减去1后，结果为1011。我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n!=<span class="number">0</span>)&#123;</span><br><span class="line">            n = n &amp; (n-<span class="number">1</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h4><p><a href="https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00?tpId=13&amp;tqId=11165&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p>保证base和exponent不同时为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">            exponent = - exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(exponent != <span class="number">0</span>)&#123;</span><br><span class="line">            ans *= base;</span><br><span class="line">            exponent--;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag? <span class="number">1</span>/ans : ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a>调整数组顺序使奇数位于偶数前面</h4><p><u>题目描述</u>：</p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><u>思路</u>：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/beb5aa231adc45b2a5dcc5b62c93f593?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/beb5aa231adc45b2a5dcc5b62c93f593?answerType=1&amp;f=discussion</a></p>
<ul>
<li><code>i++</code>往前走，碰到偶数停下来，<code>j=i+1</code></li>
<li>若 <code>a[j]</code>为偶数，<code>j++</code>前进，直到碰到奇数<ul>
<li><code>a[j]</code>对应的奇数插到<code>a[i]</code>位置，<code>j</code>经过的<code>j-1</code>个偶数依次后移</li>
</ul>
</li>
</ul>
<ul>
<li>如果<code>j==len-1</code>时还没碰到奇数，证明<code>i</code>和<code>j</code>之间都为偶数了，完成整个移动</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; array.length)&#123;</span><br><span class="line">            <span class="comment">// i遇到偶数停下</span></span><br><span class="line">            <span class="keyword">if</span>(array[i]%<span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// j遇到奇数停下</span></span><br><span class="line">                <span class="keyword">while</span>(array[j]%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==array.length-<span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> ;</span><br><span class="line">                    j++;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> temp = array[i];</span><br><span class="line">                array[i] = array[j];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k &lt; count; k++)&#123;</span><br><span class="line">                    array[j-k] = array[j-k-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                array[j-count] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="链表中第k个结点"><a href="#链表中第k个结点" class="headerlink" title="链表中第k个结点"></a>链表中第k个结点</h4><p><a href="https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&amp;tqId=11167&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入一个链表，输出该链表中倒数第k个结点。</p>
<p><u>方法</u>：快慢指针</p>
<p>快指针先往前走k步，注意判断边界，然后快慢一起走，当快指针为null的时候，慢指针走到了倒数第k个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><p><a href="https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca?tpId=13&amp;tqId=11168&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入一个链表，反转链表后，输出新链表的表头。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode tmp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h4><p><a href="https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337?tpId=13&amp;tqId=11169&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><u>方法</u>：递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val)&#123;</span><br><span class="line">            list1.next = Merge(list1.next,list2);</span><br><span class="line">            <span class="comment">//不要忘记这个return</span></span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            list2.next = Merge(list1, list2.next);</span><br><span class="line">            <span class="comment">//不要忘记这个return</span></span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><p><a href="https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88?tpId=13&amp;tqId=11170&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span> || root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> judge(root1, root2) || judge(root1.left, root2) ||judge(root2.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1, TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val==root2.val)</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);</span><br><span class="line">        <span class="keyword">return</span> judge(root1.left, root2) || judge(root1.right, root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意与子树的区别：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6e196c44c7004d15b1610b9afca8bd88?answerType=1&amp;f=discussion</a></p>
<hr>
<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><p><a href="https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011?tpId=13&amp;tqId=11171&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>操作给定的二叉树，将其变换为源二叉树的镜像。</p>
<p><u>输入描述</u>:</p>
<blockquote>
<p>二叉树的镜像定义：</p>
<p>​        源二叉树<br>​            8<br>​           /  \<br>​          6   10<br>​         / \  / \<br>​        5  7 9 11<br>​        镜像二叉树<br>​            8<br>​           /  \<br>​          10   6<br>​         / \  / \<br>​        11 9 7  5</p>
</blockquote>
<p><u>思路</u>：</p>
<p>交换左右子树的节点，然后递归调用该方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h4><p><a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&amp;tqId=11172&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>:</p>
<p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p>
<p><u>思路</u>：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/9b4c81a02cd34f76be2659fa0d54342a?answerType=1&amp;f=discussion</a></p>
<ol>
<li>向右走存入整行的值，当存入后，该行再也不会被遍历，代表上边界的 up 加一，同时判断是否和代表下边界的 down 交错 </li>
<li>向下走存入整列的值，当存入后，该列再也不会被遍历，代表右边界的 right 减一，同时判断是否和代表左边界的 left 交错 </li>
<li>向左走存入整行的值，当存入后，该行再也不会被遍历，代表下边界的 down 减一，同时判断是否和代表上边界的 up 交错 </li>
<li>向上走存入整列的值，当存入后，该列再也不会被遍历，代表左边界的 left 加一，同时判断是否和代表右边界的 right 交错</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span> || matrix[<span class="number">0</span>].length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> up = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> down = matrix.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++)</span><br><span class="line">                res.add(matrix[up][i]);</span><br><span class="line">            up++;</span><br><span class="line">            <span class="comment">// 判断是否出界</span></span><br><span class="line">            <span class="keyword">if</span>(up&gt;down)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = up; i &lt;= down; i++)</span><br><span class="line">                res.add(matrix[i][right]);</span><br><span class="line">            right--;</span><br><span class="line">            <span class="comment">// 判断是否出界</span></span><br><span class="line">            <span class="keyword">if</span>(right&lt;left)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = right; i &gt;= left; i--)</span><br><span class="line">                res.add(matrix[down][i]);</span><br><span class="line">            down--;</span><br><span class="line">            <span class="comment">// 判断是否出界</span></span><br><span class="line">            <span class="keyword">if</span>(down&lt;up)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = down; i&gt;=up; i--)</span><br><span class="line">                res.add(matrix[i][left]);</span><br><span class="line">            left++;</span><br><span class="line">            <span class="comment">// 判断是否出界</span></span><br><span class="line">            <span class="keyword">if</span>(left&gt;right)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h4><p><a href="https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=13&amp;tqId=11173&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）。</p>
<p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。</p>
<p><u>思路</u>：</p>
<p>关键在于若用一个int来保存最小值，被pop出去了后怎么办：</p>
<p>使用两个栈，一个保存所有的元素，另一个用来保存历史最小值。</p>
<p>当pop()时，检查stack与minStack的栈顶元素是否相同，若相同则都pop()，否则只需pop stack.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty() || node &lt;= stack.peek())</span><br><span class="line">            minStack.push(node);</span><br><span class="line">        stack.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.peek()==minStack.peek())</span><br><span class="line">            minStack.pop();</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h4><p><a href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;tqId=11174&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><u>思路</u>：</p>
<p>新建一个栈，将数组A压入栈中，只要栈顶元素等于数组B时，就将其出栈，当循环结束时，判断栈是否为空，若为空则返回true.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pushA.length==<span class="number">0</span> || popA.length==<span class="number">0</span> || pushA.length != popA.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pushA.length; i++)&#123;</span><br><span class="line">            stack.push(pushA[i]);</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek()==popA[j])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="从上往下打印二叉树"><a href="#从上往下打印二叉树" class="headerlink" title="从上往下打印二叉树"></a>从上往下打印二叉树</h4><p><a href="https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701?tpId=13&amp;tqId=11175&amp;tPage=2&amp;rp=2&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking</a></p>
<p><u>题目描述</u>：</p>
<p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p>
<p><u>思路</u>：</p>
<p><a href="https://www.nowcoder.com/questionTerminal/7fe2212963db4790b57431d9ed259701?answerType=1&amp;f=discussion" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/7fe2212963db4790b57431d9ed259701?answerType=1&amp;f=discussion</a></p>
<p>每一次打印一个节点的时候，如果该节点有子节点，则把该节点的子节点放到一个队列的尾部。接下来到对队列的头部取出最早进入队列的节点放到ArrayList 中，重复前面的操作，直至队列为空。  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = queue.poll();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>)</span><br><span class="line">                queue.offer(cur.right);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>pip命令</title>
    <url>/2020/02/25/pip%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install package-name</span><br></pre></td></tr></table></figure>
<p>若安装过程中出现[WinError 5]错误，可尝试使用<code>pip install --user package-name</code></p>
<p>参考<a href="https://www.lizenghai.com/archives/585.html" target="_blank" rel="noopener">https://www.lizenghai.com/archives/585.html</a></p>
<p>指定源：</p>
<blockquote>
<p>参考 <a href="https://blog.csdn.net/dss875914213/article/details/86500146" target="_blank" rel="noopener">https://blog.csdn.net/dss875914213/article/details/86500146</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install package-name -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/ </span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure>
<h4 id="所有已安装的包"><a href="#所有已安装的包" class="headerlink" title="所有已安装的包"></a>所有已安装的包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip list</span><br></pre></td></tr></table></figure>
<h4 id="查看某个已安装包"><a href="#查看某个已安装包" class="headerlink" title="查看某个已安装包"></a>查看某个已安装包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip show package_name</span><br></pre></td></tr></table></figure>
<h4 id="检查哪些包需要更新"><a href="#检查哪些包需要更新" class="headerlink" title="检查哪些包需要更新"></a>检查哪些包需要更新</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip list --outdated</span><br></pre></td></tr></table></figure>
<h4 id="升级包"><a href="#升级包" class="headerlink" title="升级包"></a>升级包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install --upgrade package_name</span><br></pre></td></tr></table></figure>
<h4 id="安装某个版本的包"><a href="#安装某个版本的包" class="headerlink" title="安装某个版本的包"></a>安装某个版本的包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install numpy==1.18</span><br></pre></td></tr></table></figure>
<h4 id="卸载包"><a href="#卸载包" class="headerlink" title="卸载包"></a>卸载包</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip uninstall package_name</span><br></pre></td></tr></table></figure>
<p>使用pip –help命令可以查看pip帮助手册</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Vision</title>
    <url>/2020/02/18/Computer-Vision/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>来源于<a href="https://www.analyticsvidhya.com/blog/2020/01/computer-vision-learning-path-2020/?utm_source=feedburner&amp;utm_medium=email&amp;utm_campaign=Feed%3A+AnalyticsVidhya+(Analytics+Vidhya" target="_blank" rel="noopener">Here’s your Learning Path to Master Computer Vision in 2020</a>)</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><h3 id="Face-Recognition"><a href="#Face-Recognition" class="headerlink" title="Face Recognition"></a>Face Recognition</h3><p><img src="/2020/02/18/Computer-Vision/1581936373011.png" alt="1581936373011"></p>
<h3 id="Types-of-computer-vision"><a href="#Types-of-computer-vision" class="headerlink" title="Types of computer vision"></a>Types of computer vision</h3><p><img src="/2020/02/18/Computer-Vision/1581936472914.png" alt="1581936472914"></p>
<h2 id="2-Image-Preprocessing"><a href="#2-Image-Preprocessing" class="headerlink" title="2. Image Preprocessing"></a>2. Image Preprocessing</h2><h3 id="2-1-Three-Beginner-Friendly-Techniques-to-Extract-Features-from-Images"><a href="#2-1-Three-Beginner-Friendly-Techniques-to-Extract-Features-from-Images" class="headerlink" title="2.1 Three Beginner-Friendly Techniques to Extract Features from Images"></a>2.1 Three Beginner-Friendly Techniques to Extract Features from Images</h3><p><a href="https://www.analyticsvidhya.com/blog/2019/08/3-techniques-extract-features-from-image-data-machine-learning-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2019/08/3-techniques-extract-features-from-image-data-machine-learning-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<h4 id="2-1-1-How-do-Machines-Store-Images"><a href="#2-1-1-How-do-Machines-Store-Images" class="headerlink" title="2.1.1 How do Machines Store Images?"></a>2.1.1 How do Machines Store Images?</h4><p>Machines store images in the form of a matrix of numbers. The size of this matrix depends on the number of pixels we have in any given image.</p>
<blockquote>
<p><em>Let’s say the dimensions of an image are 180 x 200 or n x m. These dimensions are basically the number of pixels in the image (height x width).</em></p>
</blockquote>
<p><strong>These numbers, or the pixel values, denote the intensity or brightness of the pixel.</strong> <span style="color:red">Smaller numbers (closer to zero) represent black, and larger numbers (closer to 255) denote white. </span>You’ll understand whatever we have learned so far by analyzing the below image.</p>
<p>The dimensions of the below image are 22 x 16, which you can verify by counting the number of pixels:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-16.png" alt="reading image data machine learning"></p>
<blockquote>
<p><em>A colored image is typically composed of multiple colors and almost all colors can be generated from three primary colors – red, green and blue.</em></p>
</blockquote>
<p>In the case of a colored image, there are three Matrices (or channels) – Red, Green, and Blue. <strong>Each matrix has values between 0-255 representing the intensity of the color for that pixel.</strong> Consider the below image to understand this concept:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-41.png" alt="Channels in Images"></p>
<p>The three channels are superimposed (叠加) to form a colored image.</p>
<p><em>Note that these are not the original pixel values for the given image as the original matrix would be very large and difficult to visualize. Also, there are various other formats in which the images are stored. RGB is the most popular one and hence I have addressed it here. You can read more about the other popular formats <a href="https://www.w3schools.com/cssref/css_colors_legal.asp" target="_blank" rel="noopener">here</a>.</em></p>
<h4 id="2-1-2-Reading-Image-Data-in-Python"><a href="#2-1-2-Reading-Image-Data-in-Python" class="headerlink" title="2.1.2 Reading Image Data in Python"></a>2.1.2 Reading Image Data in Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"></span><br><span class="line">image = imread(<span class="string">'image_8_original.png'</span>, as_gray=<span class="literal">True</span>)</span><br><span class="line">imshow(image)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_1.png" alt="image data machine learning"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#checking image shape </span></span><br><span class="line">image.shape, image</span><br></pre></td></tr></table></figure>
<p>(28,28)</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_2-300x289.png" alt="image data machine learning"></p>
<p>Let’s now explore various methods of using pixel values as features.</p>
<h4 id="2-1-3-Method-1-Grayscale-Pixel-Values-as-Features"><a href="#2-1-3-Method-1-Grayscale-Pixel-Values-as-Features" class="headerlink" title="2.1.3 Method #1: Grayscale Pixel Values as Features"></a>2.1.3 Method #1: Grayscale Pixel Values as Features</h4><blockquote>
<p><em>The simplest way to create features from an image is to use these raw pixel values as separate features.</em></p>
</blockquote>
<p>The number of features will be the same as the number of pixels.</p>
<p>How do we arrange these pixels as features? Well, we can simply append every pixel value one after the other to generate a feature vector. This is illustrated in the image below:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-52.png" alt="pixel features machine learning"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = imread(<span class="string">'puppy.jpeg'</span>, as_gray=<span class="literal">True</span>) </span><br><span class="line">image.shape, imshow(image)</span><br></pre></td></tr></table></figure>
<p>(660, 450)</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_3.png" alt="image data machine learning"></p>
<p>The image shape here is 660 x 450. Hence, the number of features should be 297,000. We can generate this using the <code>reshape</code> function from NumPy where we specify the dimension of the image:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#pixel features</span></span><br><span class="line">features = np.reshape(image, (<span class="number">660</span>*<span class="number">450</span>))</span><br><span class="line">features.shape, features</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(297000,)</span><br><span class="line">array([0.96470588, 0.96470588, 0.96470588, ..., 0.96862745, 0.96470588,</span><br><span class="line">       0.96470588])</span><br></pre></td></tr></table></figure>
<p>But here, we only had a single channel or a grayscale image. Can we do the same for a colored image? Let’s find out!</p>
<h4 id="2-1-4-Method-2-Mean-Pixel-Value-of-Channels-Colored-Image"><a href="#2-1-4-Method-2-Mean-Pixel-Value-of-Channels-Colored-Image" class="headerlink" title="2.1.4 Method #2: Mean Pixel Value of Channels (Colored Image)"></a>2.1.4 Method #2: Mean Pixel Value of Channels (Colored Image)</h4><p>While reading the image in the previous section, we had set the parameter <em>‘as_gray = True’</em>. So we only had one channel in the image and we could easily append the pixel values. Let us remove the parameter and load the image again:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = imread(<span class="string">'puppy.jpeg'</span>) </span><br><span class="line">image.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(660, 450, 3)</span><br></pre></td></tr></table></figure>
<p>This time, the image has a dimension (660, 450, 3), where 3 is the number of channels. We can go ahead and create the features as we did previously. The number of features, in this case, will be 660*450*3 = 891,000.</p>
<p>Alternatively, here is another approach we can use:</p>
<blockquote>
<p><em>Instead of using the pixel values from the three channels separately, we can generate a new matrix that has the mean value of pixels from all three channels.</em></p>
</blockquote>
<p>The image below will give you even more clarity around this idea:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-6.png" alt="image pixel features"></p>
<p>By doing so, the number of features remains the same and we also take into account the pixel values from all three channels of the image. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">image = imread(<span class="string">'puppy.jpeg'</span>)</span><br><span class="line">feature_matrix = np.zeros((<span class="number">660</span>,<span class="number">450</span>)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,image.shape[<span class="number">0</span>]):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,image.shape[<span class="number">1</span>]):</span><br><span class="line">        feature_matrix[i][j] = ((int(image[i,j,<span class="number">0</span>]) + int(image[i,j,<span class="number">1</span>]) + int(image[i,j,<span class="number">2</span>]))/<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>The new matrix will have the same height and width but only 1 channel. Now we can follow the same steps that we did in the previous section. We append the pixel values one after the other to get a 1D array:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">features = np.reshape(feature_matrix, (<span class="number">660</span>*<span class="number">450</span>)) </span><br><span class="line">features.shape</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(297000,)</span><br></pre></td></tr></table></figure>
<h4 id="2-1-5-Method-3-Extracting-Edge-Features"><a href="#2-1-5-Method-3-Extracting-Edge-Features" class="headerlink" title="2.1.5 Method #3: Extracting Edge Features"></a>2.1.5 Method #3: Extracting Edge Features</h4><p>Consider that we are given the below image and we need to identify the objects present in it:</p>
<p><img src="/2020/02/18/Computer-Vision/article-image-71.webp" alt="article-image-71"></p>
<p>You must have recognized the objects in an instant – a dog, a car and a cat. What are the features that you considered while differentiating each of these images? The shape could be one important factor, followed by color, or size. What if the machine could also identify the shape as we do?</p>
<p>A similar idea is to <strong>extract edges as features and use that as the input for the model.</strong> I want you to think about this for a moment – how can we identify edges in an image? <strong>Edge is basically where there is a sharp change in color</strong>. Look at the below image:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-81.png" alt="edge features"></p>
<p>And as we know, an image is represented in the form of numbers. So, we will look for pixels around which there is a drastic change in the pixel values.</p>
<p>Let’s say we have the following matrix for the image:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-9.png" alt="img"></p>
<p>To identify if a pixel is an edge or not, we will simply subtract the values on either side of the pixel. For this example, we have the highlighted value of 85. We will find the difference between the values 89 and 78. Since this difference is not very large, we can say that there is no edge around this pixel.</p>
<p>Now consider the pixel 125 highlighted in the below image:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-101.png" alt="img"></p>
<p>Since the difference between the values on either side of this pixel is large, we can conclude that there is a significant transition at this pixel and hence it is an edge. Now the question is, do we have to do this step manually?</p>
<p>No! <strong>There are various kernels that can be used to highlight the edges in an image.</strong> The method we just discussed can also be achieved using the Prewitt kernel (in the x-direction). Given below is the Prewitt kernel:</p>
<p><img src="/2020/02/18/Computer-Vision/article-image-132-300x159.webp" alt="article-image-132-300x159"></p>
<p>We take the values surrounding the selected pixel and multiply it with the selected kernel (Prewitt kernel). We can then add the resulting values to get a final value. Since we already have -1 in one column and 1 in the other column, adding the values is equivalent to taking the difference.</p>
<p><img src="/2020/02/18/Computer-Vision/article-image-111.webp" alt="article-image-111"></p>
<p>There are various other kernels and I have mentioned four most popularly used ones below:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-121.png" alt="kernels"></p>
<p>Let’s now go back to the notebook and generate edge features for the same image:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#importing the required libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"><span class="keyword">from</span> skimage.filters <span class="keyword">import</span> prewitt_h,prewitt_v</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#reading the image </span></span><br><span class="line">image = imread(<span class="string">'puppy.jpeg'</span>,as_gray=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#calculating horizontal edges using prewitt kernel</span></span><br><span class="line">edges_prewitt_horizontal = prewitt_h(image)</span><br><span class="line"><span class="comment">#calculating vertical edges using prewitt kernel</span></span><br><span class="line">edges_prewitt_vertical = prewitt_v(image)</span><br><span class="line"></span><br><span class="line">imshow(edges_prewitt_vertical, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_61.png" alt="edge features"></p>
<h3 id="2-2-HOG-Histogram-of-Oriented-Gradients-features"><a href="#2-2-HOG-Histogram-of-Oriented-Gradients-features" class="headerlink" title="2.2 HOG (Histogram of Oriented Gradients) features"></a>2.2 HOG (Histogram of Oriented Gradients) features</h3><p><a href="https://www.analyticsvidhya.com/blog/2019/09/feature-engineering-images-introduction-hog-feature-descriptor/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2019/09/feature-engineering-images-introduction-hog-feature-descriptor/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<h4 id="2-2-1-What-is-a-Feature-Descriptor"><a href="#2-2-1-What-is-a-Feature-Descriptor" class="headerlink" title="2.2.1 What is a Feature Descriptor?"></a>2.2.1 What is a Feature Descriptor?</h4><p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-1.png" alt="HOG feature"></p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/article-image-2.png" alt="HOG feature"></p>
<p>The first pair of images had a lot of information, like the shape of the object, its color, the edges, background, etc.</p>
<p>On the other hand, the second pair had much less information (only the shape and the edges) but it was still enough to differentiate the two images.</p>
<p>We were easily able to differentiate the objects in the second case because it had the necessary information we would need to identify the object. And that is exactly what a <strong>feature descriptor</strong> does:</p>
<blockquote>
<p><em>It is a simplified representation of the image that contains only the most important information about the image.</em></p>
</blockquote>
<p>There are a number of feature descriptors out there. Here are a few of the most popular ones:</p>
<ul>
<li><a href="#jumpHOG">HOG: Histogram of Oriented Gradients</a></li>
<li><a href="#jumpSIFT">SIFT: Scale Invariant Feature Transform</a></li>
<li>SURF: Speeded-Up Robust Feature</li>
</ul>
<h4 id="2-2-2-Introduction-to-the-HOG-Feature-Descriptor"><a href="#2-2-2-Introduction-to-the-HOG-Feature-Descriptor" class="headerlink" title="2.2.2 Introduction to the HOG Feature Descriptor"></a><span id="jumpHOG">2.2.2 Introduction to the HOG Feature Descriptor</span></h4><p>HOG, or Histogram of Oriented Gradients, is a feature descriptor that is often used to extract features from image data. It is widely used in <a href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" target="_blank" rel="noopener">computer vision</a> tasks for <a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=understand-math-HOG-feature-descriptor" target="_blank" rel="noopener">object detection</a>.</p>
<p>Let’s look at some important aspects of HOG that makes it different from other feature descriptors:</p>
<ul>
<li>The HOG descriptor focuses on the <strong>structure or the shape</strong> of an object. Now you might ask, how is this different from the edge features we extract for images? In the case of edge features, we only identify if the pixel is an edge or not. HOG is able to provide the edge direction as well. This is done by extracting the <strong>gradient and orientation</strong> (or you can say magnitude and direction) of the edges</li>
<li>Additionally, these orientations are calculated in <strong>‘localized’ portions</strong>. This means that the complete image is broken down into smaller regions and for each region, the gradients and orientation are calculated. We will discuss this in much more detail in the upcoming sections</li>
<li>Finally the HOG would generate a <strong>Histogram</strong> for each of these regions separately. The histograms are created using the gradients and orientations of the pixel values, hence the name ‘Histogram of Oriented Gradients’</li>
</ul>
<p>To put a formal definition to this:</p>
<blockquote>
<p>The HOG feature descriptor counts the occurrences of gradient orientation in localized portions of an image.</p>
</blockquote>
<p>Implementing HOG using tools like OpenCV is extremely simple. It’s just a few lines of code since we have a predefined function called <strong>hog</strong> in the <strong>skimage.feature</strong> library. Our focus in this article, however, is on how these features are actually calculated.</p>
<h4 id="2-2-3-Process-of-Calculating-the-Histogram-of-Oriented-Gradients-HOG"><a href="#2-2-3-Process-of-Calculating-the-Histogram-of-Oriented-Gradients-HOG" class="headerlink" title="2.2.3 Process of Calculating the Histogram of Oriented Gradients (HOG)"></a>2.2.3 Process of Calculating the Histogram of Oriented Gradients (HOG)</h4><p>HOG具体是怎么计算的：详细内容见<a href="https://www.analyticsvidhya.com/blog/2019/09/feature-engineering-images-introduction-hog-feature-descriptor/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</p>
<h4 id="2-2-4-Implementing-HOG-Feature-Descriptor-in-Python"><a href="#2-2-4-Implementing-HOG-Feature-Descriptor-in-Python" class="headerlink" title="2.2.4 Implementing HOG Feature Descriptor in Python"></a>2.2.4 Implementing HOG Feature Descriptor in Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#importing required libraries</span></span><br><span class="line"><span class="keyword">from</span> skimage.io <span class="keyword">import</span> imread, imshow</span><br><span class="line"><span class="keyword">from</span> skimage.transform <span class="keyword">import</span> resize</span><br><span class="line"><span class="keyword">from</span> skimage.feature <span class="keyword">import</span> hog</span><br><span class="line"><span class="keyword">from</span> skimage <span class="keyword">import</span> exposure</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#reading the image</span></span><br><span class="line">img = imread(<span class="string">'puppy.jpeg'</span>)</span><br><span class="line">imshow(img)</span><br><span class="line">print(img.shape)</span><br></pre></td></tr></table></figure>
<p>(663, 459, 3)</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_7.png" alt="hog_feature"></p>
<p>We can see that the shape of the image is 663 x 459. We will have to resize this image into 64 x 128. Note that we are using <code>skimage</code> which takes the input as height x width.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#resizing image </span></span><br><span class="line">resized_img = resize(img, (<span class="number">128</span>,<span class="number">64</span>)) </span><br><span class="line">imshow(resized_img) </span><br><span class="line">print(resized_img.shape)</span><br></pre></td></tr></table></figure>
<p>(128, 64, 3)</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_8.png" alt="hog_feature"></p>
<p>Here, I am going to use the hog function from <code>skimage.feature</code> directly. So we don’t have to calculate the gradients, magnitude (total gradient) and orientation individually. The hog function would internally calculate it and return the feature matrix.</p>
<p>Also, if you set the parameter <code>visualize = True</code>, it will return an image of the HOG.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#creating hog features </span></span><br><span class="line">fd, hog_image = hog(resized_img, orientations=<span class="number">9</span>, pixels_per_cell=(<span class="number">8</span>, <span class="number">8</span>), </span><br><span class="line">                    cells_per_block=(<span class="number">2</span>, <span class="number">2</span>), visualize=<span class="literal">True</span>, multichannel=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>Before going ahead, let me give you a basic idea of what each of these hyperparameters represents. Alternatively, you can check the definitions from the official documentation <a href="https://scikit-image.org/docs/dev/api/skimage.feature.html#skimage.feature.hog" target="_blank" rel="noopener">here</a>.</p>
<ul>
<li>The <code>orientations</code> are the number of buckets we want to create. Since I want to have a 9 x 1 matrix, I will set the orientations to 9</li>
<li><code>pixels_per_cell</code> defines the size of the cell for which we create the histograms. In the example we covered in this article, we used 8 x 8 cells and here I will set the same value. As mentioned previously, you can choose to change this value</li>
<li>We have another hyperparameter <code>cells_per_block</code> which is the size of the block over which we normalize the histogram. Here, we mention the cells per blocks and not the number of pixels. So, instead of writing 16 x 16, we will use 2 x 2 here</li>
</ul>
<p>The feature matrix from the function is stored in the variable <code>fd</code>, and the image is stored in <code>hog_image</code>. Let us check the shape of the feature matrix:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fd.shape</span><br></pre></td></tr></table></figure>
<p>(3780,)</p>
<p>As expected, we have 3,780 features for the image and this verifies the calculations we did in step 7 earlier. You can choose to change the values of the hyperparameters and that will give you a feature matrix of different sizes.</p>
<p>Let’s finally look at the HOG image:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig, (ax1, ax2) = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">8</span>), sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>) </span><br><span class="line"></span><br><span class="line">ax1.imshow(resized_img, cmap=plt.cm.gray) </span><br><span class="line">ax1.set_title(<span class="string">'Input image'</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># Rescale histogram for better display </span></span><br><span class="line">hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="number">0</span>, <span class="number">10</span>)) </span><br><span class="line"></span><br><span class="line">ax2.imshow(hog_image_rescaled, cmap=plt.cm.gray) </span><br><span class="line">ax2.set_title(<span class="string">'Histogram of Oriented Gradients'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/08/index_9.png" alt="hog_features"></p>
<h3 id="2-3-SIFT-Scale-Invariant-Feature-Transform-features"><a href="#2-3-SIFT-Scale-Invariant-Feature-Transform-features" class="headerlink" title="2.3 SIFT (Scale Invariant Feature Transform) features"></a><span id="jumpSIFT">2.3 SIFT (Scale Invariant Feature Transform) features</span></h3><p><a href="https://www.analyticsvidhya.com/blog/2019/10/detailed-guide-powerful-sift-technique-image-matching-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2019/10/detailed-guide-powerful-sift-technique-image-matching-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p>Take a look at the below collection of images and think of the common element between them:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/09/Screenshot-from-2019-09-20-17-49-55.png" alt="SIFT"></p>
<p>The resplendent Eiffel Tower, of course! We naturally understand that the scale or angle of the image may change but the object remains the same.</p>
<p>But machines have an almighty struggle with the same idea. It’s a challenge for them to identify the object in an image if we change certain things (like the angle or the scale). Here’s the good news – machines are super flexible and we can teach them to identify images at an almost human-level.</p>
<p>So, in this article, we will talk about an <span style="color:red">image matching algorithm</span> that <strong>identifies the key features from the images and is able to match these features to a new image of the same object.</strong></p>
<h4 id="2-3-1-Introduciton-to-SIFT"><a href="#2-3-1-Introduciton-to-SIFT" class="headerlink" title="2.3.1 Introduciton to SIFT"></a>2.3.1 Introduciton to SIFT</h4><blockquote>
<p><em>SIFT, or Scale Invariant Feature Transform, is a feature detection algorithm in Computer Vision.</em></p>
</blockquote>
<p>SIFT helps locate the local features in an image, commonly known as the <span style="color:red">‘<em>keypoints</em>‘ </span>of the image. These keypoints are <strong>scale &amp; rotation invariant</strong> that can be used for various computer vision applications, like image matching, object detection, scene detection, etc.</p>
<p>在模型训练过程中，我们也可以使用SIFT生成的关键点作为图像的特征。<strong>The major advantage of SIFT features, over edge features or hog features, is that they are not affected by the size or orientation of the image.</strong></p>
<p>For example, here is another image of the Eiffel Tower along with its smaller version. The keypoints of the object in the first image are matched with the keypoints found in the second image. The same goes for two images when the object in the other image is slightly rotated. Amazing, right?</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/10/Screenshot-from-2019-10-01-16-08-16-300x282.png" alt="SIFT"></p>
<p>Let’s understand how these keypoints are identified and what are the techniques used to ensure the scale and rotation invariance. Broadly speaking, the entire process can be divided into 4 parts:</p>
<ul>
<li><strong><a href="#jump2.3.2">Constructing a Scale Space:</a></strong> To make sure that features are scale-independent</li>
<li><strong><a href="#jump2.3.3">Keypoint Localisation (关键点定位):</a></strong> Identifying the suitable features or keypoints</li>
<li><strong><a href="#jump2.3.4">Orientation Assignment:</a></strong> Ensure the keypoints are rotation invariant</li>
<li><strong><a href="#jump2.3.5">Keypoint Descriptor:</a></strong> Assign a unique fingerprint to each keypoint</li>
</ul>
<p>Finally, we can use these keypoints for feature matching!</p>
<p><em>This article is based on the original paper by David G. Lowe. Here is the link: <a href="https://people.eecs.berkeley.edu/~malik/cs294/lowe-ijcv04.pdf" target="_blank" rel="noopener">Distinctive Image Features from Scale-Invariant Keypoints.</a></em></p>
<h4 id="2-3-2-Constructing-the-Scale-Space"><a href="#2-3-2-Constructing-the-Scale-Space" class="headerlink" title="2.3.2 Constructing the Scale Space"></a><span id="jump2.3.2">2.3.2 Constructing the Scale Space</span></h4><p>We need to identify the most distinct features in a given image while ignoring any noise. Additionally, we need to ensure that the features are not scale-dependent.</p>
<p>1.reduce the noise</p>
<blockquote>
<p><em>We use the</em> <strong>Gaussian Blurring technique</strong> <em>to reduce the noise in an image.</em></p>
</blockquote>
<p>So, for every pixel in an image, the Gaussian Blur calculates a value based on its neighboring pixels. Below is an example of image before and after applying the Gaussian Blur. As you can see, the texture and minor details are removed from the image and only the relevant information like the shape and edges remain:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/09/index_110.png" alt="gaussian blur"></p>
<p>2.ensure the features are not scale-dependent</p>
<p>Gaussian Blur successfully removed the noise from the images and we have highlighted the important features of the image. Now, <em>we need to ensure that these features must not be scale-dependent.</em> This means we will be searching for these features on multiple scales, by creating a ‘scale space’.</p>
<blockquote>
<p><em>Scale space is a collection of images having different scales, generated from a single image.</em></p>
</blockquote>
<p>To create a new set of images of different scales, we will take the original image and <strong>reduce the scale by half</strong>. For each new image, we will create blur versions as we saw above.</p>
<p>例：We have the original image of size (275, 183) and a scaled image of dimension (138, 92). For both the images, two blur images are created:</p>
<p><img src="/2020/02/18/Computer-Vision/1582017369109.png" alt="1582017369109"></p>
<p>How many times do we need to scale the image and how many subsequent blur images need to be created for each scaled image? <strong>The ideal number of octaves should be four</strong>, and for each octave, the number of blur images should be five.</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/09/Screenshot-from-2019-09-24-18-27-46.png" alt="sift octave"></p>
<h5 id="Difference-of-Gaussian"><a href="#Difference-of-Gaussian" class="headerlink" title="Difference of Gaussian"></a>Difference of Gaussian</h5><p>So far we have created images of multiple scales (often represented by σ) and used Gaussian blur for each of them to reduce the noise in the image. Next, we will try to enhance the features using a technique called Difference of Gaussians or DoG.</p>
<blockquote>
<p><em>Difference of Gaussian is a <span style="color:red">feature enhancement</span> algorithm that involves the subtraction of one blurred version of an original image from another, less blurred version of the original.</em></p>
</blockquote>
<p>DoG creates another set of images, for each octave, by subtracting every image from the previous image in the same scale. </p>
<p>Let us create the DoG for the images in scale space. 如下图所示，On the left, we have 5 images, all from the first octave (thus having the same scale). Each subsequent image is created by applying the Gaussian blur over the previous image. On the right, we have four images generated by subtracting the consecutive Gaussians. The results are jaw-dropping (让人吃惊)!</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/09/Screenshot-from-2019-09-25-14-18-26.png" alt="difference of gaussian"></p>
<p>Now that we have a new set of images, we are going to use this to find the important keypoints.</p>
<h4 id="2-3-3-Keypoint-Localization-关键点定位"><a href="#2-3-3-Keypoint-Localization-关键点定位" class="headerlink" title="2.3.3 Keypoint Localization (关键点定位)"></a><span id="jump2.3.3">2.3.3 Keypoint Localization (关键点定位)</span></h4><p>Once the images have been created, the next step is to find the important keypoints from the image that can be used for feature matching. <strong>The idea is to find the local maxima and minima for the images.</strong> This part is divided into two steps:</p>
<ol>
<li><a href="#jump2.3.3.1">Find the local maxima and minima</a></li>
<li><a href="#jump2.3.3.2">Remove low contrast keypoints (keypoint selection)</a></li>
</ol>
<h5 id="Local-Maxima-and-Local-Minima"><a href="#Local-Maxima-and-Local-Minima" class="headerlink" title="Local Maxima and Local Minima"></a><span id="jump2.3.3.1">Local Maxima and Local Minima</span></h5><blockquote>
<p><em>To locate the local maxima and minima, we go through every pixel in the image and compare it with its neighboring pixels.</em></p>
</blockquote>
<p>When I say ‘neighboring’, this not only includes the surrounding pixels of that image (in which the pixel lies), but also the nine pixels for the previous and next image in the octave.</p>
<p>This means that every pixel value is compared with 26 other pixel values to find whether it is the local maxima/minima. For example, in the below diagram, we have three images from the first octave. The pixel marked <em>x</em> is compared with the neighboring pixels (in green) and is selected as a keypoint if it is the highest or lowest among the neighbors:</p>
<p><img src="/2020/02/18/Computer-Vision/Screenshot-from-2019-09-25-16-50-01-300x207.webp" alt="Screenshot-from-2019-09-25-16-50-01-300x207"></p>
<p>We now have potential keypoints that represent the images and are scale-invariant. We will apply the last check over the selected keypoints to ensure that these are the most accurate keypoints to represent the image. ( 因为some of these keypoints may not be robust to noise. )</p>
<h5 id="Keypoint-Selection"><a href="#Keypoint-Selection" class="headerlink" title="Keypoint Selection"></a><span id="jump2.3.3.2">Keypoint Selection</span></h5><p><strong>we will eliminate the keypoints that have low contrast, or lie very close to the edge.</strong></p>
<p>To deal with the low contrast keypoints, <strong>a second-order Taylor expansion</strong> is computed for each keypoint. If the resulting value is less than 0.03 (in magnitude), we reject the keypoint.</p>
<p>So what do we do about the remaining keypoints? Well, we perform a check to identify the poorly located keypoints. 这些是接近边缘的关键点，具有高边缘响应，但可能对少量噪声不够稳健。<strong>A second-order Hessian matrix</strong> is used to identify such keypoints. </p>
<p>Now that we have performed both the <span style="color:red">contrast test</span> and the <span style="color:red">edge test</span> to reject the unstable keypoints, we will now assign an orientation value for each keypoint to make the rotation invariant.</p>
<h4 id="2-3-4-Orientation-Assignment"><a href="#2-3-4-Orientation-Assignment" class="headerlink" title="2.3.4 Orientation Assignment"></a><span id="jump2.3.4">2.3.4 Orientation Assignment</span></h4><p>At this stage, we have a set of stable keypoints for the images. We will now assign an orientation to each of these keypoints so that they are invariant to rotation. We can again divide this step into two smaller steps:</p>
<ol>
<li>Calculate the magnitude and orientation</li>
<li>Create a histogram for magnitude and orientation</li>
</ol>
<p>计算magnitude和orientation的方法与 HOG中的计算方法类似，具体计算过程见<a href="https://www.analyticsvidhya.com/blog/2019/10/detailed-guide-powerful-sift-technique-image-matching-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</p>
<blockquote>
<p><em>The magnitude represents the intensity of the pixel and the orientation gives the direction for the same.</em></p>
</blockquote>
<h5 id="Creating-a-Histogram-for-Magnitude-and-Orientation"><a href="#Creating-a-Histogram-for-Magnitude-and-Orientation" class="headerlink" title="Creating a Histogram for Magnitude and Orientation"></a>Creating a Histogram for Magnitude and Orientation</h5><p>On the x-axis, we will have bins for angle values, like 0-9, 10 – 19, 20-29, up to 360. Since our angle value is 57, it will fall in the 6th bin. The 6th bin value will be in proportion to the magnitude of the pixel, i.e. 16.64.  We will do this for all the pixels around the keypoint.</p>
<p>This is how we get the below histogram:</p>
<p><img src="/2020/02/18/Computer-Vision/Screenshot-from-2019-09-26-18-53-12.webp" alt="Screenshot-from-2019-09-26-18-53-12"></p>
<p><em>You can refer to this article for a much detailed explanation for calculating the gradient, magnitude, orientation and plotting histogram – <a href="https://www.analyticsvidhya.com/blog/2019/09/feature-engineering-images-introduction-hog-feature-descriptor/" target="_blank" rel="noopener">A Valuable Introduction to the Histogram of Oriented Gradients.</a></em></p>
<p>This histogram would peak at some point. <strong>The bin at which we see the peak will be the orientation for the keypoint.</strong> Additionally, if there is another significant peak (seen between 80 – 100%), then another keypoint is generated with the magnitude and scale the same as the keypoint used to generate the histogram. And the angle or orientation will be equal to the new bin that has the peak.</p>
<p>Effectively at this point, we can say that there can be a small increase in the number of keypoints.</p>
<h4 id="2-3-5-Keypoint-Descriptor"><a href="#2-3-5-Keypoint-Descriptor" class="headerlink" title="2.3.5 Keypoint Descriptor"></a><span id="jump2.3.5">2.3.5 Keypoint Descriptor</span></h4><p>This is the final step for SIFT. So far, we have stable keypoints that are scale-invariant and rotation invariant. In this section, we will use the neighboring pixels, their orientations, and magnitude, to generate a unique fingerprint for this keypoint called a ‘descriptor’.</p>
<p>Additionally, since we use the surrounding pixels, the descriptors will be partially invariant to illumination or brightness of the images.</p>
<p>We will first take a 16×16 neighborhood around the keypoint. This 16×16 block is further divided into 4×4 sub-blocks and for each of these sub-blocks, we generate the histogram using magnitude and orientation.</p>
<p><img src="/2020/02/18/Computer-Vision/Screenshot-from-2019-09-26-20-10-52.webp" alt="Screenshot-from-2019-09-26-20-10-52"></p>
<p>At this stage, the bin size is increased and we take only 8 bins (not 36). Each of these arrows represents the 8 bins and the length of the arrows define the magnitude. So, we will have a total of 128 bin values for every keypoint.</p>
<p>Here is an example:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment">#reading image</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'eiffel_2.jpeg'</span>)  </span><br><span class="line">gray1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#keypoints</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line">keypoints_1, descriptors_1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">img_1 = cv2.drawKeypoints(gray1,keypoints_1,img1)</span><br><span class="line">plt.imshow(img_1)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/Computer-Vision/index_41.webp" alt="index_41"></p>
<h4 id="2-3-6-Feature-Matching-代码"><a href="#2-3-6-Feature-Matching-代码" class="headerlink" title="2.3.6 Feature Matching (代码)"></a>2.3.6 Feature Matching (代码)</h4><p>We will now use the SIFT features for feature matching. For this purpose, I have downloaded two images of the Eiffel Tower, taken from different positions. You can try it with any two images that you want. <br>Here are the two images that I have used:</p>
<p><span style="background:yellow">reading_image_eiffel.py</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># read images</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'eiffel_2.jpeg'</span>)  </span><br><span class="line">img2 = cv2.imread(<span class="string">'eiffel_1.jpg'</span>) </span><br><span class="line"></span><br><span class="line">img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">figure, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">ax[<span class="number">0</span>].imshow(img1, cmap=<span class="string">'gray'</span>)</span><br><span class="line">ax[<span class="number">1</span>].imshow(img2, cmap=<span class="string">'gray'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/Computer-Vision/index_71.png" alt="index_71"></p>
<p>Now, for both these images, we are going to generate the SIFT features. First, we have to construct a SIFT object and then use the function <em>detectAndCompute</em> to get the keypoints. It will return two values – the keypoints and the descriptors.</p>
<p>Let’s determine the keypoints and print the total number of keypoints found in each image:</p>
<p><span style="background:yellow">keypoints_shape.py</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># read images</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'eiffel_2.jpeg'</span>)  </span><br><span class="line">img2 = cv2.imread(<span class="string">'eiffel_1.jpg'</span>) </span><br><span class="line"></span><br><span class="line">img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sift</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line"></span><br><span class="line">keypoints_1, descriptors_1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">keypoints_2, descriptors_2 = sift.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">len(keypoints_1), len(keypoints_2)</span><br></pre></td></tr></table></figure>
<p>283, 540</p>
<p>Next, let’s try and match the features from image 1 with features from image 2. We will be using the function <em>match()</em> from the <em>BFmatcher</em> (brute force match) module. Also, we will draw lines between the features that match in both the images. This can be done using the <em>drawMatches</em> function in OpenCV.</p>
<p><span style="background:yellow">feature_matching.py</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">%matplotlib inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># read images</span></span><br><span class="line">img1 = cv2.imread(<span class="string">'eiffel_2.jpeg'</span>)  </span><br><span class="line">img2 = cv2.imread(<span class="string">'eiffel_1.jpg'</span>) </span><br><span class="line"></span><br><span class="line">img1 = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)</span><br><span class="line">img2 = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment">#sift</span></span><br><span class="line">sift = cv2.xfeatures2d.SIFT_create()</span><br><span class="line"></span><br><span class="line">keypoints_1, descriptors_1 = sift.detectAndCompute(img1,<span class="literal">None</span>)</span><br><span class="line">keypoints_2, descriptors_2 = sift.detectAndCompute(img2,<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#feature matching</span></span><br><span class="line">bf = cv2.BFMatcher(cv2.NORM_L1, crossCheck=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">matches = bf.match(descriptors_1,descriptors_2)</span><br><span class="line">matches = sorted(matches, key = <span class="keyword">lambda</span> x:x.distance)</span><br><span class="line"></span><br><span class="line">img3 = cv2.drawMatches(img1, keypoints_1, img2, keypoints_2, matches[:<span class="number">50</span>], img2, flags=<span class="number">2</span>)</span><br><span class="line">plt.imshow(img3),plt.show()</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/18/Computer-Vision/index_61.webp" alt="index_61"></p>
<p>I have plotted only 50 matches here for clarity’s sake. You can increase the number according to what you prefer. To find out how many keypoints are matched, we can print the length of the variable <em>matches</em>. In this case, the answer would be 190.</p>
<h4 id="2-3-7-End-Notes"><a href="#2-3-7-End-Notes" class="headerlink" title="2.3.7 End Notes"></a>2.3.7 End Notes</h4><p>In this article, we discussed the SIFT feature matching algorithm in detail. Here is a site that provides excellent visualization for each step of SIFT. You can add your own image and it will create the keypoints for that image as well. Check it out <a href="http://weitz.de/sift/" target="_blank" rel="noopener">here</a>.</p>
<p>Another popular feature matching algorithm is SURF (Speeded Up Robust Feature), which is simply a faster version of SIFT. I would encourage you to go ahead and explore it as well.</p>
<p>And if you’re new to the world of computer vision and image data, I recommend checking out the below course:</p>
<ul>
<li><a href="https://courses.analyticsvidhya.com/courses/computer-vision-using-deep-learning-version2?utm_source=blog&amp;utm_medium=detailed-guide-powerful-sift-technique-image-matching-python" target="_blank" rel="noopener">Computer Vision using Deep Learning 2.0</a></li>
</ul>
<h2 id="3-Image-Classification-using-Logistic-Regression"><a href="#3-Image-Classification-using-Logistic-Regression" class="headerlink" title="3. Image Classification using Logistic Regression"></a>3. Image Classification using Logistic Regression</h2><ul>
<li><p>Python:</p>
<p>kaggle kernel: used grid search method in logistic regression to classify rooms as messy or clean.</p>
</li>
</ul>
<p>完整代码见：<a href="https://www.kaggle.com/gulsahdemiryurek/image-classification-with-logistic-regression/notebook" target="_blank" rel="noopener">https://www.kaggle.com/gulsahdemiryurek/image-classification-with-logistic-regression/notebook</a></p>
<p>对图片的大致处理：（在这里，先不纠结train/val/test等）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np <span class="comment"># linear algebra</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment"># data processing, CSV file I/O (e.g. pd.read_csv)</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2 </span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle </span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm </span><br><span class="line"></span><br><span class="line">train_messy = <span class="string">"../input/images/images/train/messy"</span></span><br><span class="line">train_clean= <span class="string">"../input/images/images/train/clean"</span></span><br><span class="line">test_messy= <span class="string">"../input/images/images/val/messy"</span></span><br><span class="line">test_clean= <span class="string">"../input/images/images/val/clean"</span></span><br><span class="line">image_size = <span class="number">128</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_data</span><span class="params">()</span>:</span></span><br><span class="line">    train_data_messy = [] </span><br><span class="line">    train_data_clean=[]</span><br><span class="line">    <span class="keyword">for</span> image1 <span class="keyword">in</span> tqdm(os.listdir(train_messy)): </span><br><span class="line">        path = os.path.join(train_messy, image)</span><br><span class="line">        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) </span><br><span class="line">        img1 = cv2.resize(img1, (image_size, image_size))</span><br><span class="line">        train_data_messy.append(img1) </span><br><span class="line">    <span class="keyword">for</span> image2 <span class="keyword">in</span> tqdm(os.listdir(train_clean)): </span><br><span class="line">        path = os.path.join(train_clean, image)</span><br><span class="line">        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) </span><br><span class="line">        img2 = cv2.resize(img2, (image_size, image_size))</span><br><span class="line">        train_data_clean.append(img2) </span><br><span class="line">    </span><br><span class="line">    train_data= np.concatenate((np.asarray(train_data_messy),np.asarray(train_data_clean)),axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> train_data </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_data</span><span class="params">()</span>:</span></span><br><span class="line">    test_data_messy = [] </span><br><span class="line">    test_data_clean=[]</span><br><span class="line">    <span class="keyword">for</span> image1 <span class="keyword">in</span> tqdm(os.listdir(test_messy)): </span><br><span class="line">        path = os.path.join(test_messy, image1)</span><br><span class="line">        img1 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) </span><br><span class="line">        img1 = cv2.resize(img1, (image_size, image_size))</span><br><span class="line">        test_data_messy.append(img1) </span><br><span class="line">    <span class="keyword">for</span> image2 <span class="keyword">in</span> tqdm(os.listdir(test_clean)): </span><br><span class="line">        path = os.path.join(test_clean, image2)</span><br><span class="line">        img2 = cv2.imread(path, cv2.IMREAD_GRAYSCALE) </span><br><span class="line">        img2 = cv2.resize(img2, (image_size, image_size))</span><br><span class="line">        test_data_clean.append(img2) </span><br><span class="line">    </span><br><span class="line">    test_data= np.concatenate((np.asarray(test_data_messy),np.asarray(test_data_clean)),axis=<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">return</span> test_data</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">train_data = train_data() </span><br><span class="line">test_data = test_data()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x_train_flatten = train_data.reshape(train_data.shape[<span class="number">0</span>],train_data.shape[<span class="number">1</span>]*train_data.shape[<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>Grid search:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">grid=&#123;<span class="string">"C"</span>:np.logspace(<span class="number">-3</span>,<span class="number">3</span>,<span class="number">7</span>),<span class="string">"penalty"</span>:[<span class="string">"l1"</span>,<span class="string">"l2"</span>]&#125;,</span><br><span class="line">logistic_regression=LogisticRegression(random_state=<span class="number">42</span>)</span><br><span class="line">log_reg_cv=GridSearchCV(logistic_regression,grid,cv=<span class="number">10</span>)</span><br><span class="line">log_reg_cv.fit(x_train_flatten, y_train)</span><br></pre></td></tr></table></figure>
<ul>
<li>C: <a href="https://mmlind.github.io/Using_Logistic_Regression_to_solve_MNIST/" target="_blank" rel="noopener">Using Logistic regression to classify images</a> (MNIST data)</li>
</ul>
<h2 id="4-Project-1-Identify-the-Apparels-服装"><a href="#4-Project-1-Identify-the-Apparels-服装" class="headerlink" title="4. Project 1- Identify the Apparels (服装)"></a>4. Project 1- Identify the Apparels (服装)</h2><p><a href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-apparels/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-apparels/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p><img src="/2020/02/18/Computer-Vision/1582027636102.png" alt="1582027636102"></p>
<p>More than 25% of entire revenue in E-Commerce is attributed to apparels &amp; accessories. A major problem they face is categorizing these apparels from just the images especially when the categories provided by the brands are inconsistent. This poses an interesting computer vision problem which has caught the eyes of several deep learning researchers.</p>
<p>Fashion MNIST is a drop-in replacement for the very well known, machine learning hello world - MNIST dataset which can be checked out at <a href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/" target="_blank" rel="noopener">‘Identify the digits’</a> practice problem. Instead of digits, the images show a type of apparel e.g. T-shirt, trousers, bag, etc. The dataset used in this problem was created by Zalando Research. More details can be found at this <a href="https://github.com/zalandoresearch/fashion-mnist" target="_blank" rel="noopener">link</a>.</p>
<h2 id="5-Introduction-to-Keras-amp-Neural-Networks"><a href="#5-Introduction-to-Keras-amp-Neural-Networks" class="headerlink" title="5. Introduction to Keras &amp; Neural Networks"></a>5. Introduction to Keras &amp; Neural Networks</h2><h3 id="5-1-Keras"><a href="#5-1-Keras" class="headerlink" title="5.1 Keras"></a>5.1 Keras</h3><p>Keras is one of the most commonly used deep learning tools.</p>
<ul>
<li><a href="https://keras.io/" target="_blank" rel="noopener">Keras Documentation</a> (Keras官方文档)</li>
<li><a href="https://www.analyticsvidhya.com/blog/2016/10/tutorial-optimizing-neural-networks-using-keras-with-image-recognition-case-study/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Neural Networks using Keras</a> (MNIST)</li>
</ul>
<h3 id="5-2-Neural-Network"><a href="#5-2-Neural-Network" class="headerlink" title="5.2 Neural Network"></a>5.2 Neural Network</h3><ul>
<li><p><a href="https://www.analyticsvidhya.com/blog/2017/05/neural-network-from-scratch-in-python-and-r/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Neural Networks from Scratch</a></p>
</li>
<li><p>Introduction to Neural Networks by Stanford:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/d14TUNcbn1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</li>
</ul>
<ul>
<li><p>Neural Networks by 3Blue1Brown:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/aircAruvnKk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

</li>
</ul>
<h2 id="6-Project-1-Identify-the-Apparels"><a href="#6-Project-1-Identify-the-Apparels" class="headerlink" title="6. Project 1 - Identify the Apparels"></a>6. Project 1 - Identify the Apparels</h2><p>同第4部分</p>
<h2 id="7-Understanding-Convolutional-Neural-Networks-CNNs-Transfer-Learning"><a href="#7-Understanding-Convolutional-Neural-Networks-CNNs-Transfer-Learning" class="headerlink" title="7. Understanding Convolutional Neural Networks (CNNs), Transfer Learning"></a>7. Understanding Convolutional Neural Networks (CNNs), Transfer Learning</h2><h3 id="7-1-Introduction-to-Convolutional-Neural-Networks-CNNs"><a href="#7-1-Introduction-to-Convolutional-Neural-Networks-CNNs" class="headerlink" title="7.1 Introduction to Convolutional Neural Networks (CNNs):"></a>7.1 <strong>Introduction to Convolutional Neural Networks (CNNs):</strong></h3><ul>
<li><p><a href="https://www.analyticsvidhya.com/blog/2017/06/architecture-of-convolutional-neural-networks-simplified-demystified/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Convolutional Neural Networks (CNNs) Simplified</a></p>
</li>
<li><p>Convolutional Neural Networks by Stanford:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/bNb2fEVKeEo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


</li>
</ul>
<h3 id="7-2-Introduction-to-Transfer-Learning"><a href="#7-2-Introduction-to-Transfer-Learning" class="headerlink" title="7.2 Introduction to Transfer Learning:"></a>7.2 <strong>Introduction to Transfer Learning:</strong></h3><h4 id="7-2-1-Master-Transfer-Learning"><a href="#7-2-1-Master-Transfer-Learning" class="headerlink" title="7.2.1 Master Transfer Learning"></a>7.2.1 Master Transfer Learning</h4><p><a href="https://www.analyticsvidhya.com/blog/2017/06/transfer-learning-the-art-of-fine-tuning-a-pre-trained-model/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2017/06/transfer-learning-the-art-of-fine-tuning-a-pre-trained-model/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p>训练神经网络有时需要很多的资源（RAM, GPUs）, RAM on a machine is cheap and is available in plenty, but access to GPUs is not that cheap. </p>
<p>Now, that may change in future. But for now, it means that we have to be smarter about the way we use our resources in solving Deep Learning problems. Especially so, when we try to solve complex real life problems on areas like image and voice recognition. Once you have a few hidden layers in your model, adding another layer of hidden layer would need immense resources.</p>
<p>Thankfully, there is something called “Transfer Learning” which enables us to <strong>use pre-trained models from other people by making small changes.</strong> In this article, I am going to tell how we can use pre-trained models to accelerate our solutions.</p>
<ul>
<li><strong>What is transfer learning?</strong></li>
</ul>
<p>A neural network is trained on a data. This network gains knowledge from this data, which is compiled as “weights” of the network. <span style="color:red">These weights can be extracted and then transferred to any other neural network.</span> Instead of training the other neural network from scratch, we <strong>“transfer”</strong> the learned features.</p>
<ul>
<li><strong>What is a Pre-trained Model?</strong></li>
</ul>
<p>Simply put, a pre-trained model is a model created by some one else to solve a similar problem. Instead of building a model from scratch to solve a similar problem, you use the model trained on other problem as a starting point.<br>For example, if you want to build a self learning car. You can spend years to build a decent image recognition algorithm from scratch or you can take inception model (a pre-trained model) from Google which was built on ImageNet data to identify images in those pictures.<br>A pre-trained model may not be 100% accurate in your application, but it saves huge efforts required to re-invent the wheel. </p>
<p>使用pre-trained model不仅能节约训练时间，还能得到更高的准确率</p>
<ul>
<li><strong>How can I use Pre-trained Models?</strong></li>
</ul>
<p> By using pre-trained models which have been previously trained on large datasets, we can directly use the weights and architecture obtained and apply the learning on our problem statement. This is known as transfer learning. We “transfer the learning” of the pre-trained model to our specific problem statement.</p>
<p>You should be very careful while choosing what pre-trained model you should use in your case. If the problem statement we have at hand is very different from the one on which the pre-trained model was trained – the prediction we would get would be very inaccurate. For example, a model previously trained for speech recognition would work horribly if we try to use it to identify objects using it.</p>
<p>We are lucky that many pre-trained architectures are directly available for us in the Keras library. <strong>Imagenet</strong> data set has been widely used to build various architectures since it is large enough (1.2M images) to create a generalized model. The problem statement is to train a model that can correctly classify the images into 1,000 separate object categories. These 1,000 image categories represent object classes that we come across in our day-to-day lives, such as species of dogs, cats, various household objects, vehicle types etc.</p>
<p>These pre-trained networks demonstrate a strong ability to generalize to images outside the ImageNet dataset via transfer learning. <strong>We make modifications in the pre-existing model by fine-tuning the model. </strong>Since we assume that the pre-trained network has been trained quite well, we would not want to modify the weights too soon and too much. While modifying we generally use a learning rate smaller than the one used for initially training the model.</p>
<ul>
<li><p><strong>Ways to Fine tune the model</strong></p>
<ol>
<li><strong>Feature extraction</strong> – We can use a pre-trained model as a feature extraction mechanism. What we can do is that we can remove the output layer( the one which gives the probabilities for being in each of the 1000 classes) and then use the entire network as a fixed feature extractor for the new data set.</li>
<li><strong>Use the Architecture of the pre-trained model –</strong> What we can do is that we use architecture of the model while we initialize all the weights randomly and train the model according to our dataset again.</li>
<li><strong>Train some layers while freeze others</strong> – Another way to use a pre-trained model is to train is partially. What we can do is we keep the weights of initial layers of the model frozen while we retrain only the higher layers. We can try and test as to how many layers to be frozen and how many to be trained.</li>
</ol>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2017/05/31112715/finetune1-300x270.jpg"></p>
</li>
</ul>
<p><strong>Scenario 1 – Size of the Data set is small while the Data similarity is very high –</strong> In this case, since the data similarity is very high, we do not need to retrain the model. All we need to do is to customize and modify the output layers according to our problem statement. We use the pretrained model as a feature extractor. Suppose we decide to use models trained on Imagenet to identify if the new set of images have cats or dogs. Here the images we need to identify would be similar to imagenet, however we just need two categories as my output – cats or dogs. In this case all we do is just modify the dense layers and the final softmax layer to output 2 categories instead of a 1000.</p>
<p><strong>Scenario 2 – Size of the data is small as well as data similarity is very low</strong> – In this case we can freeze the initial (let’s say k) layers of the pretrained model and train just the remaining(n-k) layers again. The top layers would then be customized to the new data set. Since the new data set has low similarity it is significant to retrain and customize the higher layers according to the new dataset.  The small size of the data set is compensated by the fact that the initial layers are kept pretrained(which have been trained on a large dataset previously) and the weights for those layers are frozen.</p>
<p><strong>Scenario 3 – Size of the data set is large however the Data similarity is very low</strong> – In this case, since we have a large dataset, our neural network training would be effective. However, since the data we have is very different as compared to the data used for training our pretrained models. The predictions made using pretrained models would not be effective. Hence, its best to train the neural network from scratch according to your data.</p>
<p><strong>Scenario 4 – Size of the data is large as well as there is high data similarity –</strong> This is the ideal situation. In this case the pretrained model should be most effective. The best way to use the model is to retain the architecture of the model and the initial weights of the model. Then we can retrain this model using the weights as initialized in the pre-trained model.</p>
<blockquote>
<p>There are various architectures that have been trained on the imageNet data set. You can go through various architectures <a href="http://www.pyimagesearch.com/2017/03/20/imagenet-vggnet-resnet-inception-xception-keras/" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<p><span style="background:yellow">代码示例</span>： se the pre-trained models to identify handwritten digits. 见<a href="https://www.analyticsvidhya.com/blog/2017/06/transfer-learning-the-art-of-fine-tuning-a-pre-trained-model/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a></p>
<h4 id="7-2-2-ConvNets-in-Practice-by-Stanford"><a href="#7-2-2-ConvNets-in-Practice-by-Stanford" class="headerlink" title="7.2.2 ConvNets in Practice by Stanford:"></a>7.2.2 ConvNets in Practice by Stanford:</h4><iframe width="560" height="315" src="https://www.youtube.com/embed/dUTzeP_HTZg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>


<h2 id="8-Project-2-Idendify-the-Digits"><a href="#8-Project-2-Idendify-the-Digits" class="headerlink" title="8. Project 2 - Idendify the Digits"></a>8. Project 2 - Idendify the Digits</h2><p><a href="https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/practice-problem-identify-the-digits/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p>Automatic digit recognition is of popular interest today. Deep Learning techniques makes it possible for object recognition in image data . This practice problem is meant to give you a kick start in deep learning. As usual, we will not only provide you with the challenge and a solution checker, but also a set of tutorials to get you off the ground!</p>
<p>The data set used for this problem is from the populat MNIST data set. Developed by Yann LeCun, Corina Cortes and Christopher Burger for evaluating machine learning model on the handwritten digit classification problem. It is a widely used data set in the machine learning community. For more details about the data set, read here <a href="http://bit.ly/1REjJgL" target="_blank" rel="noopener">http://bit.ly/1REjJgL</a></p>
<h2 id="9-Build-your-profile-Participate-in-competitions"><a href="#9-Build-your-profile-Participate-in-competitions" class="headerlink" title="9. Build your profile: Participate in competitions"></a>9. <strong>Build your profile: Participate in competitions</strong></h2><ul>
<li><a href="https://datahack.analyticsvidhya.com/contest/all/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">DataHack</a></li>
<li><a href="https://www.kaggle.com/competitions" target="_blank" rel="noopener">Kaggle</a></li>
</ul>
<h2 id="10-Solving-Object-Detection-problems"><a href="#10-Solving-Object-Detection-problems" class="headerlink" title="10. Solving Object Detection problems"></a>10. Solving Object Detection problems</h2><h3 id="10-1-Step-by-Step-Introduction-to-Object-Detection-Techniques"><a href="#10-1-Step-by-Step-Introduction-to-Object-Detection-Techniques" class="headerlink" title="10.1 Step-by-Step Introduction to Object Detection Techniques"></a>10.1 Step-by-Step Introduction to Object Detection Techniques</h3><p><a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p>The below image is a popular example of illustrating how an object detection algorithm works. Each object in the image, from a person to a kite, have been located and identified with a certain level of precision.</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/06/OD.png" alt="img"></p>
<p>Let’s look at how we can solve a general object detection problem using a CNN.</p>
<ol>
<li><p>First, we take an image as input:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/I1_2009_09_08_drive_0012_001351-768x223.png" alt="img"></p>
</li>
<li><p>Then we divide the image into various regions:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-09-14-21-14.png" alt="img"></p>
</li>
<li><p>We will then consider each region as a separate image.</p>
</li>
<li><p>Pass all these regions (images) to the CNN and classify them into various classes.</p>
</li>
<li><p>Once we have divided each region into its corresponding class, we can combine all these regions to get the original image with the detected objects:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/I1_2009_09_08_drive_0012_001351-another-copy-768x223.png" alt="img"></p>
</li>
</ol>
<p>The problem with using this approach is that the objects in the image can have different aspect ratios and spatial locations. For instance, in some cases the object might be covering most of the image, while in others the object might only be covering a small percentage of the image. The shapes of the objects might also be different (happens a lot in real-life use cases).</p>
<p>As a result of these factors, we would require a very large number of regions resulting in a huge amount of computational time. So to solve this problem and reduce the number of regions, we can use region-based CNN, which selects the regions using a proposal method. Let’s understand what this region-based CNN can do for us.</p>
<h4 id="10-1-1-Understanding-Region-Based-Convolutional-Neural-Network-RCNN"><a href="#10-1-1-Understanding-Region-Based-Convolutional-Neural-Network-RCNN" class="headerlink" title="10.1.1 Understanding Region-Based Convolutional Neural Network (RCNN)"></a>10.1.1 Understanding Region-Based Convolutional Neural Network (RCNN)</h4><h5 id="10-1-1-1-Intuition-of-RCNN"><a href="#10-1-1-1-Intuition-of-RCNN" class="headerlink" title="10.1.1.1 Intuition of RCNN"></a>10.1.1.1 Intuition of RCNN</h5><p>Instead of working on a massive number of regions, the RCNN algorithm proposes a bunch of boxes in the image and checks if any of these boxes contain any object. RCNN <strong>uses <span style="color:red">selective search</span> to extract these boxes from an image (these boxes are called regions).</strong></p>
<p>Let’s first understand what selective search is and how it identifies the different regions. There are basically four regions that form an object: varying scales, colors, textures, and enclosure. Selective search identifies these patterns in the image and based on that, proposes various regions. <a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Here is a brief overview of how selective search works.</a></p>
<p>Below is a succint summary of the steps followed in RCNN to detect objects:</p>
<ol>
<li>We first take a pre-trained convolutional neural network.</li>
<li>Then, this model is retrained. We train the last layer of the network based on the number of classes that need to be detected.</li>
<li>The third step is to get the Region of Interest for each image. We then reshape all these regions so that they can match the CNN input size.</li>
<li>After getting the regions, we train SVM to classify objects and background. For each class, we train one binary SVM.</li>
<li>Finally, we train a linear regression model to generate tighter bounding boxes for each identified object in the image.</li>
</ol>
<p>You might get a better idea of the above steps with a visual example:</p>
<ul>
<li><p>First, an image is taken as an input:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-14-59-02.png" alt="img"></p>
</li>
</ul>
<ul>
<li><p>Then, we get the Regions of Interest (ROI) using some proposal method (for example, selective search as seen above):</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-00-09.png" alt="img"></p>
</li>
<li><p>All these regions are then reshaped as per the input of the CNN, and each region is passed to the ConvNet:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-01-56.png" alt="img"></p>
</li>
<li><p>CNN then extracts features for each region and SVMs are used to divide these regions into different classes:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-03-02.png" alt="img"></p>
</li>
<li><p>Finally, a bounding box regression (<em>Bbox reg</em>) is used to predict the bounding boxes for each identified region:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-06-33.png" alt="img"></p>
</li>
</ul>
<p>And this, in a nutshell, is how an RCNN helps us to detect objects.</p>
<h5 id="10-1-1-2-Limitations-of-RCNN"><a href="#10-1-1-2-Limitations-of-RCNN" class="headerlink" title="10.1.1.2  Limitations of RCNN"></a>10.1.1.2  Limitations of RCNN</h5><p>Training an RCNN model is expensive and slow:</p>
<ul>
<li>Extracting 2,000 regions for each image based on selective search</li>
<li>Extracting features using CNN for every image region. Suppose we have N images, then the number of CNN features will be N*2,000</li>
<li>The entire process of object detection using RCNN has three models:<ol>
<li>CNN for feature extraction</li>
<li>Linear SVM classifier for identifying objects</li>
<li>Regression model for tightening the bounding boxes.</li>
</ol>
</li>
</ul>
<p>All these processes combine to make RCNN very slow. It takes around 40-50 seconds to make predictions for each new image, which essentially makes the model cumbersome and practically impossible to build when faced with a gigantic dataset.</p>
<p>Here’s the good news – we have another object detection technique which fixes most of the limitations we saw in RCNN.</p>
<h4 id="10-1-2-Understanding-Fast-RCNN"><a href="#10-1-2-Understanding-Fast-RCNN" class="headerlink" title="10.1.2 Understanding Fast RCNN"></a>10.1.2 Understanding Fast RCNN</h4><h5 id="10-1-2-1-Intuition-of-Fast-RCNN"><a href="#10-1-2-1-Intuition-of-Fast-RCNN" class="headerlink" title="10.1.2.1 Intuition of Fast RCNN"></a>10.1.2.1 Intuition of Fast RCNN</h5><p>What else can we do to reduce the computation time a RCNN algorithm typically takes? Instead of running a CNN 2,000 times per image, we can run it just once per image and get all the regions of interest (regions containing some object).</p>
<p>In Fast RCNN, we feed the input image to the CNN, which in turn generates the convolutional feature maps. Using these maps, the regions of proposals are extracted. We then use a RoI pooling layer to reshape all the proposed regions into a fixed size, so that it can be fed into a fully connected network.</p>
<p>Let’s break this down into steps to simplify the concept:</p>
<ol>
<li>As with the earlier two techniques, we take an image as an input.</li>
<li>This image is passed to a ConvNet which in turns generates the Regions of Interest.</li>
<li>A RoI pooling layer is applied on all of these regions to reshape them as per the input of the ConvNet. Then, each region is passed on to a fully connected network.</li>
<li>A softmax layer is used on top of the fully connected network to output classes. Along with the softmax layer, a linear regression layer is also used parallely to output bounding box coordinates for predicted classes.</li>
</ol>
<p>So, instead of using three different models (like in RCNN), Fast RCNN uses a single model which extracts features from the regions, divides them into different classes, and returns the boundary boxes for the identified classes simultaneously.</p>
<p>图解：</p>
<ul>
<li><p>Taking an image as input:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-14-59-021.png" alt="img"></p>
</li>
<li><p>This image is passed to a ConvNet which returns the region of interests accordingly:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-44-03.png" alt="img"></p>
</li>
<li><p>Then we apply the RoI pooling layer on the extracted regions of interest to make sure all the regions are of the same size:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-45-26.png" alt="img"></p>
</li>
<li><p>Finally, these regions are passed on to a fully connected network which classifies them, as well as returns the bounding boxes using softmax and linear regression layers simultaneously:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-08-15-47-18.png" alt="img"></p>
</li>
</ul>
<p>This is how Fast RCNN resolves two major issues of RCNN, i.e., <span style="color:red">passing one instead of 2,000 regions per image to the ConvNet, and using one instead of three different models for extracting features, classification and generating bounding boxes.</span></p>
<h5 id="10-1-2-2-Limitations-of-Fast-RCNN"><a href="#10-1-2-2-Limitations-of-Fast-RCNN" class="headerlink" title="10.1.2.2 Limitations of Fast RCNN"></a>10.1.2.2 Limitations of Fast RCNN</h5><p>It also uses <strong>selective search</strong> as a proposal method to find the Regions of Interest, which is a slow and time consuming process. It takes around 2 seconds per image to detect objects, which is much better compared to RCNN. But when we consider large real-life datasets, then even a Fast RCNN doesn’t look so fast anymore.</p>
<p>But there’s yet another object detection algorithm that trump Fast RCNN. </p>
<h4 id="10-1-3-Understanding-Faster-RCNN"><a href="#10-1-3-Understanding-Faster-RCNN" class="headerlink" title="10.1.3 Understanding Faster RCNN"></a>10.1.3 Understanding Faster RCNN</h4><h5 id="10-1-3-1-Intuition-of-Faster-RCNN"><a href="#10-1-3-1-Intuition-of-Faster-RCNN" class="headerlink" title="10.1.3.1 Intuition of Faster RCNN"></a>10.1.3.1 Intuition of Faster RCNN</h5><p>Faster RCNN is the modified version of Fast RCNN. The major difference between them is that Fast RCNN uses selective search for generating Regions of Interest, while Faster RCNN uses <strong>“Region Proposal Network”, aka RPN.</strong> RPN takes image feature maps as an input and generates a set of object proposals, each with an objectness score as output.</p>
<p>The  below steps are typically followed in a Faster RCNN approach:</p>
<ol>
<li>We take an image as input and pass it to the ConvNet which returns the feature map for that image.</li>
<li>Region proposal network is applied on these feature maps. This returns the object proposals along with their objectness score.</li>
<li>A RoI pooling layer is applied on these proposals to bring down all the proposals to the same size.</li>
<li>Finally, the proposals are passed to a fully connected layer which has a softmax layer and a linear regression layer at its top, to classify and output the bounding boxes for objects.</li>
</ol>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/10/Screenshot-from-2018-10-09-14-15-36.png" alt="img"></p>
<p><a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">A briefly explain how this Region Proposal Network (RPN) actually works.</a></p>
<h5 id="10-1-3-2-Limitations-of-Faster-RCNN"><a href="#10-1-3-2-Limitations-of-Faster-RCNN" class="headerlink" title="10.1.3.2 Limitations of Faster RCNN"></a>10.1.3.2 Limitations of Faster RCNN</h5><p>All of the object detection algorithms we have discussed so far use regions to identify the objects. The network does not look at the complete image in one go, but focuses on parts of the image sequentially. This creates two complications:</p>
<ul>
<li>The algorithm requires many passes through a single image to extract all the objects</li>
<li>As there are different systems working one after the other, the performance of the systems further ahead depends on how the previous systems performed</li>
</ul>
<h4 id="10-1-4-Summary"><a href="#10-1-4-Summary" class="headerlink" title="10.1.4 Summary"></a>10.1.4 Summary</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Algorithm</strong></th>
<th><strong>Features</strong></th>
<th><strong>Prediction time / image</strong></th>
<th><strong>Limitations</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>CNN</td>
<td>Divides the image into multiple regions and then classify each region into various classes.</td>
<td>–</td>
<td>Needs a lot of regions to predict accurately and hence high computation time.</td>
</tr>
<tr>
<td>RCNN</td>
<td>Uses selective search to generate regions. Extracts around 2000 regions from each image.</td>
<td>40-50 seconds</td>
<td>High computation time as each region is passed to the CNN separately also it uses three different model for making predictions.</td>
</tr>
<tr>
<td>Fast RCNN</td>
<td>Each image is passed only once to the CNN and feature maps are extracted. Selective search is used on these maps to generate predictions. Combines all the three models used in RCNN together.</td>
<td>2 seconds</td>
<td>Selective search is slow and hence computation time is still high.</td>
</tr>
<tr>
<td>Faster RCNN</td>
<td>Replaces the selective search method with region proposal network which made the algorithm much faster.</td>
<td>0.2 seconds</td>
<td>Object proposal takes time and as there are different systems working one after the other, the performance of systems depends on how the previous system has performed.</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-2-Implementing-Faster-RCNN-for-Object-Detection-代码"><a href="#10-2-Implementing-Faster-RCNN-for-Object-Detection-代码" class="headerlink" title="10.2 Implementing Faster RCNN for Object Detection (代码)"></a>10.2 Implementing Faster RCNN for Object Detection (代码)</h3><p><a href="https://www.analyticsvidhya.com/blog/2018/11/implementation-faster-r-cnn-python-object-detection/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/11/implementation-faster-r-cnn-python-object-detection/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a>)</p>
<h3 id="10-3-Object-Detection-using-YOLO-含代码"><a href="#10-3-Object-Detection-using-YOLO-含代码" class="headerlink" title="10.3 Object Detection using YOLO (含代码)"></a>10.3 Object Detection using YOLO (含代码)</h3><p>详细介绍见这里：<a href="https://www.analyticsvidhya.com/blog/2018/12/practical-guide-object-detection-yolo-framewor-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2018/12/practical-guide-object-detection-yolo-framewor-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<p>The R-CNN family of techniques we saw in Part 1 primarily use regions to localize the objects within the image. The network does not look at the entire image, only at the parts of the images which have a higher chance of containing an object.</p>
<p>The YOLO framework (You Only Look Once) on the other hand, deals with object detection in a different way. It takes the entire image in a single instance and predicts the bounding box coordinates and class probabilities for these boxes. <strong>The biggest advantage of using YOLO is its superb speed</strong> – it’s incredibly fast and can process 45 frames per second. YOLO also understands generalized object representation.</p>
<blockquote>
<p>YOLO is a state-of-the-art object detection algorithm that is incredibly fast and accurate</p>
</blockquote>
<p>_<strong>Training</strong>_</p>
<p>The input for training our model will obviously be images and their corresponding y labels. Let’s see an image and make its y label:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2018/12/Screenshot-from-2018-11-17-15-02-11.png" alt="img"></p>
<p>Consider the scenario where we are using a 3 X 3 grid with two anchors per grid, and there are 3 different object classes. So the corresponding y labels will have a shape of 3 X 3 X 16. Now, suppose if we use 5 anchor boxes per grid and the number of classes has been increased to 5. So the target will be 3 X 3 X 10 X 5 = 3 X 3 X 50. This is how the training process is done – taking an image of a particular shape and mapping it with a 3 X 3 X 16 target (this may change as per the grid size, number of anchor boxes and the number of classes).</p>
<p><strong>_Testing_</strong></p>
<p>The new image will be divided into the same number of grids which we have chosen during the training period. For each grid, the model will predict an output of shape 3 X 3 X 16 (assuming this is the shape of the target during training time). The 16 values in this prediction will be in the same format as that of the training label. The first 8 values will correspond to anchor box 1, where the first value will be the probability of an object in that grid. Values 2-5 will be the bounding box coordinates for that object, and the last three values will tell us which class the object belongs to. The next 8 values will be for anchor box 2 and in the same format, i.e., first the probability, then the bounding box coordinates, and finally the classes.</p>
<p>Finally, the Non-Max Suppression technique will be applied on the predicted boxes to obtain a single prediction per object.</p>
<p>That brings us to the end of the theoretical aspect of understanding how the YOLO algorithm works, starting from training the model and then generating prediction boxes for the objects. Below are the exact dimensions and steps that the YOLO algorithm follows:</p>
<ul>
<li>Takes an input image of shape (608, 608, 3)</li>
<li>Passes this image to a convolutional neural network (CNN), which returns a (19, 19, 5, 85) dimensional output</li>
<li>The last two dimensions of the above output are flattened to get an output volume of (19, 19, 425):<ul>
<li>Here, each cell of a 19 X 19 grid returns 425 numbers</li>
<li>425 = 5 * 85, where 5 is the number of anchor boxes per grid</li>
<li>85 = 5 + 80, where 5 is (pc, bx, by, bh, bw) and 80 is the number of classes we want to detect</li>
</ul>
</li>
<li>Finally, we do the IoU and Non-Max Suppression to avoid selecting overlapping boxes</li>
</ul>
<h3 id="10-4-Object-detection-by-Stanford"><a href="#10-4-Object-detection-by-Stanford" class="headerlink" title="10.4 Object detection by Stanford:"></a>10.4 Object detection by Stanford:</h3><p><iframe width="560" height="315" src="https://www.youtube.com/embed/nDPWywWRIRo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<h3 id="10-5-其他Resources"><a href="#10-5-其他Resources" class="headerlink" title="10.5 其他Resources"></a>10.5 其他Resources</h3><ul>
<li><a href="https://arxiv.org/pdf/1506.02640.pdf" target="_blank" rel="noopener">YOLO Paper</a></li>
<li><a href="https://pjreddie.com/darknet/yolo/" target="_blank" rel="noopener">YOLO Pre-Trained Models</a></li>
</ul>
<h2 id="11-Project-3-Face-Counting-Challenge"><a href="#11-Project-3-Face-Counting-Challenge" class="headerlink" title="11. Project 3 - Face Counting Challenge"></a>11. Project 3 - Face Counting Challenge</h2><p><a href="https://datahack.analyticsvidhya.com/contest/vista-codefest-computer-vision-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://datahack.analyticsvidhya.com/contest/vista-codefest-computer-vision-1/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<h2 id="12-Project-4-COCO-Object-Detection-Challenge"><a href="#12-Project-4-COCO-Object-Detection-Challenge" class="headerlink" title="12. Project 4 - COCO Object Detection Challenge"></a>12. Project 4 - COCO Object Detection Challenge</h2><p><a href="http://cocodataset.org/#download" target="_blank" rel="noopener">http://cocodataset.org/#download</a></p>
<h2 id="13-Image-Segmentation"><a href="#13-Image-Segmentation" class="headerlink" title="13. Image Segmentation"></a>13. Image Segmentation</h2><h3 id="13-1-A-Step-by-Step-Introduction-to-Image-Segmentation-Techniques"><a href="#13-1-A-Step-by-Step-Introduction-to-Image-Segmentation-Techniques" class="headerlink" title="13.1 A Step-by-Step Introduction to Image Segmentation Techniques"></a>13.1 A Step-by-Step Introduction to Image Segmentation Techniques</h3><p><a href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<h4 id="13-1-1-What-is-Image-Segmentation"><a href="#13-1-1-What-is-Image-Segmentation" class="headerlink" title="13.1.1 What is Image Segmentation?"></a>13.1.1 What is Image Segmentation?</h4><p>An image is a collection or set of different pixels. We group together the pixels that have similar attributes using image segmentation. Take a moment to go through the below visual (it’ll give you a practical idea of image segmentation):</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/instance_segmentation_example.jpg" alt="object detection and instance segmentation"></p>
<p>Object detection builds a bounding box corresponding to each class in the image. But it tells us nothing about the shape of the object. We only get the set of bounding box coordinates. We want to get more information – this is too vague for our purposes.</p>
<p><span style="color:red">Image segmentation creates a pixel-wise mask for each object in the image.</span> This technique gives us a far more granular understanding of the object(s) in the image.</p>
<h4 id="13-1-2-Why-do-we-need-Image-Segmentation"><a href="#13-1-2-Why-do-we-need-Image-Segmentation" class="headerlink" title="13.1.2 Why do we need Image Segmentation?"></a>13.1.2 Why do we need Image Segmentation?</h4><p>Cancer has long been a deadly illness. Even in today’s age of technological advancements, cancer can be fatal if we don’t identify it at an early stage. Detecting cancerous cell(s) as quickly as possible can potentially save millions of lives.</p>
<p>The shape of the cancerous cells plays a vital role in determining the severity of the cancer. You might have put the pieces together – object detection will not be very useful here. We will only generate bounding boxes which will not help us in identifying the shape of the cells.</p>
<p>Image Segmentation techniques make a MASSIVE impact here. They help us approach this problem in a more granular manner and get more meaningful results. A win-win for everyone in the healthcare industry.</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/cancer-cell-segmentation.png" alt="cancer cell segmentation"></p>
<p>There are many other applications where Image segmentation is transforming industries:</p>
<ul>
<li>Traffic Control Systems</li>
<li>Self Driving Cars</li>
<li>Locating objects in satellite images</li>
</ul>
<h4 id="13-1-3-The-Different-Types-of-Image-Segmentation"><a href="#13-1-3-The-Different-Types-of-Image-Segmentation" class="headerlink" title="13.1.3 The Different Types of Image Segmentation"></a>13.1.3 The Different Types of Image Segmentation</h4><p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/Screenshot-from-2019-03-28-12-08-09.png" alt="semantic and instance segmentation"></p>
<p>If there are 5 people in an image, semantic segmentation will focus on classifying all the people as a single instance. Instance segmentation, on the other hand. will identify each of these people individually.</p>
<h4 id="13-1-4-Region-based-Segmentation-Threshold"><a href="#13-1-4-Region-based-Segmentation-Threshold" class="headerlink" title="13.1.4 Region-based Segmentation (Threshold)"></a>13.1.4 Region-based Segmentation (Threshold)</h4><p>One simple way to segment different objects could be to use their pixel values. An important point to note – the pixel values will be different for the objects and the image’s background if there’s a sharp contrast between them.</p>
<p>In this case, we can set a threshold value. The pixel values falling below or above that threshold can be classified accordingly (as an object or the background). This technique is known as <strong>Threshold Segmentation</strong>.</p>
<blockquote>
<p>If we want to divide the image into two regions (object and background), we define a single threshold value. This is known as the <strong>global threshold</strong>.</p>
<p>If we have multiple objects along with the background, we must define multiple thresholds. These thresholds are collectively known as the <strong>local threshold</strong>.</p>
</blockquote>
<p><span style="background:yellow">代码见<a href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</span></p>
<p>You can set different threshold values and check how the segments are made. Some of the advantages of this method are:</p>
<ul>
<li>Calculations are simpler</li>
<li>Fast operation speed</li>
<li>When the object and background have high contrast, this method performs really well</li>
</ul>
<p>But there are some limitations to this approach. When we don’t have significant grayscale difference, or there is an overlap of the grayscale pixel values, it becomes very difficult to get accurate segments.</p>
<h4 id="13-1-5-Edge-Detection-Segmentation"><a href="#13-1-5-Edge-Detection-Segmentation" class="headerlink" title="13.1.5 Edge Detection Segmentation"></a>13.1.5 Edge Detection Segmentation</h4><p>What divides two objects in an image? There is always an edge between two adjacent regions with different grayscale values (pixel values). The edges can be considered as the discontinuous local features of an image.</p>
<p>We can make use of this discontinuity to detect edges and hence define a boundary of the object. This helps us in detecting the shapes of multiple objects present in a given image. Now the question is how can we detect these edges? This is where we can make use of <span style="color:red">filters and convolutions</span>. Refer to <a href="https://www.analyticsvidhya.com/blog/2017/06/architecture-of-convolutional-neural-networks-simplified-demystified/?utm_source=blog&amp;utm_medium=image-segmentation-article" target="_blank" rel="noopener">this article</a> if you need to learn about these concepts.</p>
<p>Researchers have found that choosing some specific values for these weight matrices (filters) helps us to detect horizontal or vertical edges (or even the combination of horizontal and vertical edges).</p>
<p>One such weight matrix is the sobel operator. It is typically used to detect edges. </p>
<p><img src="/2020/02/18/Computer-Vision/1582182873707.png" alt="1582182873707"></p>
<p>There is one more type of filter that can detect both horizontal and vertical edges at the same time. This is called the laplace operator:</p>
<p><img src="/2020/02/18/Computer-Vision/1582182970901.png" alt="1582182970901"></p>
<p>例：</p>
<p><img src="/2020/02/18/Computer-Vision/1582183125398.png" alt="1582183125398"></p>
<p><span style="background:yellow">代码见<a href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</span></p>
<h4 id="13-1-6-Image-Segmentation-based-on-Clustering"><a href="#13-1-6-Image-Segmentation-based-on-Clustering" class="headerlink" title="13.1.6 Image Segmentation based on Clustering"></a>13.1.6 Image Segmentation based on Clustering</h4><p>Clustering is the task of dividing the population (data points) into a number of groups, such that data points in the same groups are more similar to other data points in that same group than those in other groups. These groups are known as clusters.</p>
<p>One of the most commonly used clustering algorithms is <a href="https://www.analyticsvidhya.com/blog/2016/11/an-introduction-to-clustering-and-different-methods-of-clustering/" target="_blank" rel="noopener">k-means</a>. Here, the k represents the number of clusters (not to be confused with k-nearest neighbor). Let’s understand how k-means works:</p>
<ol>
<li>First, randomly select k initial clusters</li>
<li>Randomly assign each data point to any one of the k clusters</li>
<li>Calculate the centers of these clusters</li>
<li>Calculate the distance of all the points from the center of each cluster</li>
<li>Depending on this distance, the points are reassigned to the nearest cluster</li>
<li>Calculate the center of the newly formed clusters</li>
<li>Finally, repeat steps (4), (5) and (6) until either the center of the clusters does not change or we reach the set number of iterations</li>
</ol>
<p><strong>The key advantage of using k-means algorithm is that it is simple and easy to understand.</strong> We are assigning the points to the clusters which are closest to them.</p>
<p><span style="background:yellow">代码见<a href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</span></p>
<p>选择5 cluster的效果:</p>
<p><img src="/2020/02/18/Computer-Vision/1582183359913.png" alt="1582183359913"></p>
<p>k-means works really well when we have a small dataset. It can segment the objects in the image and give impressive results. But the algorithm hits a roadblock when applied on a large dataset (more number of images).</p>
<p>It looks at all the samples at every iteration, so the time taken is too high. Hence, it’s also too expensive to implement. And since k-means is a distance-based algorithm, it is only applicable to convex datasets and is not suitable for clustering <a href="https://en.wikipedia.org/wiki/Convex_set" target="_blank" rel="noopener">non-convex clusters</a>.</p>
<p>Finally, let’s look at a simple, flexible and general approach for image segmentation.</p>
<h4 id="13-1-7-Mask-R-CNN"><a href="#13-1-7-Mask-R-CNN" class="headerlink" title="13.1.7 Mask R-CNN"></a>13.1.7 Mask R-CNN</h4><p>Mask R-CNN is an extension of the popular <a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=image-segmentation-article" target="_blank" rel="noopener">Faster R-CNN</a> object detection architecture. Mask R-CNN adds a branch to the already existing Faster R-CNN outputs. The Faster R-CNN method generates two things for each object in the image:</p>
<ul>
<li>Its class</li>
<li>The bounding box coordinates</li>
</ul>
<p>Mask R-CNN adds a third branch to this which outputs the object mask as well. Take a look at the below image to get an intuition of how Mask R-CNN works on the inside:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/Mask-R-CNN.png" alt="Mask R-CNN"></p>
<ol>
<li>We take an image as input and pass it to the ConvNet, which returns the feature map for that image</li>
<li>Region proposal network (RPN) is applied on these feature maps. This returns the object proposals along with their objectness score</li>
<li>A RoI pooling layer is applied on these proposals to bring down all the proposals to the same size</li>
<li>Finally, the proposals are passed to a fully connected layer to classify and output the bounding boxes for objects. It also returns the mask for each proposal</li>
</ol>
<blockquote>
<p><strong>Mask R-CNN is the current state-of-the-art for image segmentation and runs at 5 fps.</strong></p>
</blockquote>
<h4 id="13-1-8-Summary"><a href="#13-1-8-Summary" class="headerlink" title="13.1.8 Summary"></a>13.1.8 Summary</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Algorithm</strong></th>
<th><strong>Description</strong></th>
<th><strong>Advantages</strong></th>
<th><strong>Limitations</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Region-Based Segmentation</td>
<td>Separates the objects into different regions based on some threshold value(s).</td>
<td>a. Simple calculationsb. Fast operation speedc. When the object and background have high contrast, this method performs really well</td>
<td>When there is no significant grayscale difference or an overlap of the grayscale pixel values, it becomes very difficult to get accurate segments.</td>
</tr>
<tr>
<td>Edge Detection Segmentation</td>
<td>Makes use of discontinuous local features of an image to detect edges and hence define a boundary of the object.</td>
<td>It is good for images having better contrast between objects.</td>
<td>Not suitable when there are too many edges in the image and if there is less contrast between objects.</td>
</tr>
<tr>
<td>Segmentation based on Clustering</td>
<td>Divides the pixels of the image into homogeneous clusters.</td>
<td>Works really well on small datasets and generates excellent clusters.</td>
<td>a. Computation time is too large and expensive.b. k-means is a distance-based algorithm. It is not suitable for clustering non-convex clusters.</td>
</tr>
<tr>
<td>Mask R-CNN</td>
<td>Gives three outputs for each object in the image: its class, bounding box coordinates, and object mask</td>
<td>a. Simple, flexible and general approachb. It is also the current state-of-the-art for image segmentation</td>
<td>High training time</td>
</tr>
</tbody>
</table>
</div>
<h3 id="13-2-Implementing-Mask-R-CNN-for-Image-Segmentation"><a href="#13-2-Implementing-Mask-R-CNN-for-Image-Segmentation" class="headerlink" title="13.2 Implementing Mask R-CNN for Image Segmentation"></a>13.2 Implementing Mask R-CNN for Image Segmentation</h3><p><a href="https://www.analyticsvidhya.com/blog/2019/07/computer-vision-implementing-mask-r-cnn-image-segmentation/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">https://www.analyticsvidhya.com/blog/2019/07/computer-vision-implementing-mask-r-cnn-image-segmentation/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020</a></p>
<h4 id="13-2-1-Understanding-Mask-R-CNN"><a href="#13-2-1-Understanding-Mask-R-CNN" class="headerlink" title="13.2.1 Understanding Mask R-CNN"></a>13.2.1 Understanding Mask R-CNN</h4><p>Mask R-CNN is basically an extension of <a href="https://www.analyticsvidhya.com/blog/2018/10/a-step-by-step-introduction-to-the-basic-object-detection-algorithms-part-1/?utm_source=blog&amp;utm_medium=computer-vision-implementing-mask-r-cnn-image-segmentation" target="_blank" rel="noopener">Faster R-CNN</a>. Faster R-CNN is widely used for object detection tasks. For a given image, it returns the class label and bounding box coordinates for each object in the image. </p>
<p><strong>The Mask R-CNN framework is built on top of Faster R-CNN.</strong> So, for a given image, Mask R-CNN, in addition to the class label and bounding box coordinates for each object, will also return the object mask.</p>
<p>Let’s first quickly understand how Faster R-CNN works. This will help us grasp the intuition behind Mask R-CNN as well.</p>
<ul>
<li>Faster R-CNN first uses a ConvNet to extract feature maps from the images</li>
<li>These feature maps are then passed through a Region Proposal Network (RPN) which returns the candidate bounding boxes</li>
<li>We then apply an RoI pooling layer on these candidate bounding boxes to bring all the candidates to the same size</li>
<li>And finally, the proposals are passed to a fully connected layer to classify and output the bounding boxes for objects</li>
</ul>
<p>Once you understand how Faster R-CNN works, understanding Mask R-CNN will be very easy. So, let’s understand it step-by-step starting from the input to predicting the class label, bounding box, and object mask.</p>
<p><span style="background:yellow">第一步：<u>Backbone Model</u></span></p>
<p>Similar to the <a href="https://www.analyticsvidhya.com/blog/2018/12/guide-convolutional-neural-network-cnn/?utm_source=blog&amp;utm_medium=computer-vision-implementing-mask-r-cnn-image-segmentation" target="_blank" rel="noopener">ConvNet</a> that we use in Faster R-CNN to extract feature maps from the image, we use the ResNet 101 architecture to extract features from the images in Mask R-CNN. So, the first step is to take an image and extract features using the ResNet 101 architecture. These features act as an input for the next layer.</p>
<p><span style="background:yellow">第二步：<u>Region Proposal Network (RPN)</u></span></p>
<p>Now, we take the feature maps obtained in the previous step and apply a region proposal network (RPM). This basically predicts if an object is present in that region (or not). In this step, we get those regions or feature maps which the model predicts contain some object.</p>
<p><span style="background:yellow">第三步：<u>Region of Interest (RoI)</u></span></p>
<p>The regions obtained from the RPN might be of different shapes, hence, we apply a pooling layer and convert all the regions to the same shape. Next, these regions are passed through a fully connected network so that the class label and bounding boxes are predicted.</p>
<p>Till this point, the steps are almost similar to how Faster R-CNN works. Now comes the difference between the two frameworks. In addition to this, <strong>Mask R-CNN also generates the segmentation mask.</strong></p>
<p>For that, we first compute the region of interest so that the computation time can be reduced. For all the predicted regions, we compute the Intersection over Union (IoU) with the ground truth boxes. We can computer IoU like this:</p>
<p>IoU = Area of the intersection / Area of the union</p>
<p><strong>Now, only if the IoU is greater than or equal to 0.5, we consider that as a region of interest. Otherwise, we neglect that particular region. We do this for all the regions and then select only a set of regions for which the IoU is greater than 0.5.</strong></p>
<p>Let’s understand it using an example. Consider this image:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/07/Screenshot-from-2019-07-19-16-37-49.png" alt="image_bounding_box">Here, the red box is the ground truth box for this image. Now, let’s say we got 4 regions from the RPN as shown below:</p>
<p><a href="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/07/Screenshot-from-2019-07-19-16-46-07.png" target="_blank" rel="noopener"><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/07/Screenshot-from-2019-07-19-16-46-07.png" alt="rpn_predictions"></a></p>
<p>Here, the IoU of Box 1 and Box 2 is possibly less than 0.5, whereas the IoU of Box 3 and Box 4 is approximately greater than 0.5. Hence. we can say that Box 3 and Box 4 are the region of interest for this particular image whereas Box 1 and Box 2 will be neglected.</p>
<p>Next, let’s see the final step of Mask R-CNN.</p>
<p><span style="background:yellow">第四步：<u>Segmentation Mask</u></span></p>
<p>Once we have the RoIs based on the IoU values, we can add a mask branch to the existing architecture. This returns the segmentation mask for each region that contains an object. It returns a mask of size 28 X 28 for each region which is then scaled up for inference.</p>
<p>Again, let’s understand this visually. Consider the following image:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/07/3.jpg" alt="sample image for segmentation"></p>
<p>The segmentation mask for this image would look something like this:</p>
<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/07/Screenshot-from-2019-07-19-16-59-48.png" alt="masks using Mask R-CNN"></p>
<p>Here, our model has segmented all the objects in the image. This is the final step in Mask R-CNN where we predict the masks for all the objects in the image.</p>
<p>Keep in mind that <strong>the training time for Mask R-CNN is quite high.</strong> It took me somewhere around 1 to 2 days to train the Mask R-CNN on the famous <a href="http://cocodataset.org/#home" target="_blank" rel="noopener">COCO dataset</a>. So, for the scope of this article, we will not be training our own Mask R-CNN model.</p>
<p>We will instead use the pretrained weights of the Mask R-CNN model trained on the COCO dataset. We will be using the <a href="https://github.com/matterport/Mask_RCNN" target="_blank" rel="noopener">mask rcnn framework</a> created by the Data scientists and researchers at Facebook AI Research (FAIR).</p>
<h4 id="13-2-2-Implement-Mask-R-CNN"><a href="#13-2-2-Implement-Mask-R-CNN" class="headerlink" title="13.2.2 Implement Mask R-CNN"></a>13.2.2 Implement Mask R-CNN</h4><p><span style="background:yellow">代码见<a href="https://www.analyticsvidhya.com/blog/2019/07/computer-vision-implementing-mask-r-cnn-image-segmentation/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">这里</a>.</span></p>
<h3 id="13-3-其他Resources"><a href="#13-3-其他Resources" class="headerlink" title="13.3 其他Resources"></a>13.3 其他Resources</h3><ul>
<li><a href="https://arxiv.org/pdf/1703.06870.pdf" target="_blank" rel="noopener">Mask R-CNN Paper</a></li>
<li><a href="https://github.com/matterport/Mask_RCNN" target="_blank" rel="noopener">Mask R-CNN GitHub Repository</a></li>
</ul>
<h2 id="14-Project-5-COCO-Segmentation-Challenge"><a href="#14-Project-5-COCO-Segmentation-Challenge" class="headerlink" title="14. Project 5 - COCO Segmentation Challenge"></a>14. Project 5 - COCO Segmentation Challenge</h2><p> <a href="http://cocodataset.org/#download" target="_blank" rel="noopener">COCO Segmentation Challenge</a></p>
<h2 id="15-Attention-Model"><a href="#15-Attention-Model" class="headerlink" title="15. Attention Model"></a>15. Attention Model</h2><ul>
<li><a href="https://www.analyticsvidhya.com/blog/2018/03/essentials-of-deep-learning-sequence-to-sequence-modelling-with-attention-part-i/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Sequence-to-Sequence Modeling with Attention</a></li>
<li><a href="https://nlp.stanford.edu/~johnhew/public/14-seq2seq.pdf" target="_blank" rel="noopener">Sequence-to-Sequence Models</a> by Stanford</li>
</ul>
<h2 id="16-Explore-Deep-Learning-Tools"><a href="#16-Explore-Deep-Learning-Tools" class="headerlink" title="16. Explore Deep Learning Tools"></a>16. Explore Deep Learning Tools</h2><h3 id="16-1-PyTorch"><a href="#16-1-PyTorch" class="headerlink" title="16.1 PyTorch"></a>16.1 PyTorch</h3><ul>
<li><a href="https://pytorch.org/tutorials/" target="_blank" rel="noopener">PyTorch Tutorials</a></li>
<li><a href="https://www.analyticsvidhya.com/blog/2019/09/introduction-to-pytorch-from-scratch/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Beginner-Friendly Guide to PyTorch</a></li>
</ul>
<h3 id="16-2-TensorFlow"><a href="#16-2-TensorFlow" class="headerlink" title="16.2 TensorFlow"></a>16.2 TensorFlow</h3><ul>
<li><a href="https://www.tensorflow.org/tutorials" target="_blank" rel="noopener">TensorFlow Tutorials</a></li>
<li><a href="https://www.analyticsvidhya.com/blog/2016/10/an-introduction-to-implementing-neural-networks-using-tensorflow/?utm_source=blog&amp;utm_medium=computer-vision-learning-path-2020" target="_blank" rel="noopener">Introduction to TensorFlow</a></li>
</ul>]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Computer Vision</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo相关问题</title>
    <url>/2020/02/17/hexo%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="hexo中无法显示数学公式："><a href="#hexo中无法显示数学公式：" class="headerlink" title="hexo中无法显示数学公式："></a>hexo中无法显示数学公式：</h4><p>参考 <a href="https://runninggump.github.io/2018/12/05/成功解决在hexo中无法显示数学公式的问题/" target="_blank" rel="noopener">成功解决在hexo中无法显示数学公式的问题</a></p>
<p><a href="https://blog.csdn.net/yexiaohhjk/article/details/82526604" target="_blank" rel="noopener">hexo next主题解决无法显示数学公式</a></p>
<h4 id="取消对”文章目录”的自动编号"><a href="#取消对”文章目录”的自动编号" class="headerlink" title="取消对”文章目录”的自动编号"></a>取消对”文章目录”的自动编号</h4><p><a href="https://segmentfault.com/q/1010000008494901" target="_blank" rel="noopener">hexo的NexT主题，怎么取消“文章目录”对标题的自动编号？</a></p>
<h4 id="Markdown页面内跳转"><a href="#Markdown页面内跳转" class="headerlink" title="Markdown页面内跳转"></a>Markdown页面内跳转</h4><p><a href="https://www.cnblogs.com/triple-y/p/10780644.html" target="_blank" rel="noopener">markdown页面内跳转</a></p>
<h4 id="设置文章封面"><a href="#设置文章封面" class="headerlink" title="设置文章封面"></a>设置文章封面</h4><p>参考 <a href="https://www.zhihu.com/tardis/sogou/art/60424755" target="_blank" rel="noopener">https://www.zhihu.com/tardis/sogou/art/60424755</a></p>
<p><code>&lt;!-- less --&gt;</code>: 点击阅读全文后不显示<code>&lt;!-- less --&gt;</code> 以上的内容</p>
<p><code>&lt;!-- more --&gt;</code>: 要显示</p>
<h4 id="设置标题样式（为浅蓝色）"><a href="#设置标题样式（为浅蓝色）" class="headerlink" title="设置标题样式（为浅蓝色）"></a>设置标题样式（为浅蓝色）</h4><p>参考<a href="https://juejin.im/post/5a71ab9f518825735300ee6c#heading-24" target="_blank" rel="noopener">篇Ⅱ：NexT主题的配置和优化指南</a></p>
<p><img src="/2020/02/17/hexo相关问题/1595819136654.png" alt="1595819136654"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*添加下面的CSS代码来修改博客标题样式*/</span></span><br><span class="line">.page-post-detail .post-title &#123;</span><br><span class="line">  font-size: <span class="number">26</span>px;</span><br><span class="line">  text-align: center;</span><br><span class="line">  word-<span class="keyword">break</span>: <span class="keyword">break</span>-word;</span><br><span class="line">  font-weight: $posts-expand-title-font-weight</span><br><span class="line">  background-color: #b9d3ee;</span><br><span class="line">  border-radius:<span class="number">.3</span>em;</span><br><span class="line">  line-height:<span class="number">1</span>em;</span><br><span class="line">  padding-bottom:<span class="number">.12</span>em;</span><br><span class="line">  padding-top:<span class="number">.12</span>em;</span><br><span class="line">  box-shadow:2px 2px 7px #9fb6cd;</span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    font-size: <span class="number">22</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*添加上面的CSS代码来修改博客标题样式*/</span></span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"post-expand"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"post-collapse"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"post-type"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"post-title"</span>;</span><br></pre></td></tr></table></figure>
<p><em>注意：如果想把主页标题样式一同修改，可以用把</em> <code>.page-post-detail</code> 去掉。</p>
<h4 id="修改文章内链接文本样式"><a href="#修改文章内链接文本样式" class="headerlink" title="修改文章内链接文本样式"></a>修改文章内链接文本样式</h4><p> 参考<a href="https://www.cnblogs.com/brady-wang/p/8416122.html" target="_blank" rel="noopener">hexo的next主题个性化教程:打造炫酷网站</a></p>
<p>实现效果图</p>
<p><img src="https://upload-images.jianshu.io/upload_images/5308475-8cc4fc18c399af7e.gif" alt="img"></p>
<p>修改文件 <code>themes\next\source\css\_common\components\post\post.styl</code>，在末尾添加如下css样式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 文章内链接文本样式</span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  border-bottom: 1px solid #0593d3;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #fc6423;</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-bottom: 1px solid #fc6423;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中选择<code>.post-body</code> 是为了不影响标题，选择 <code>p</code> 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<h4 id="修改主题页面布局为圆角"><a href="#修改主题页面布局为圆角" class="headerlink" title="修改主题页面布局为圆角"></a>修改主题页面布局为圆角</h4><p>参考<a href="https://wugenqiang.github.io/articles/hexo-do-optimization.html中3.12.2" target="_blank" rel="noopener">https://wugenqiang.github.io/articles/hexo-do-optimization.html中3.12.2</a></p>
<p>对scheme为Mist时无用？</p>
<h4 id="NeXT第三方服务集成"><a href="#NeXT第三方服务集成" class="headerlink" title="NeXT第三方服务集成"></a>NeXT第三方服务集成</h4><p>(评论系统，数据统计与分析，内容分享服务，搜索服务等)</p>
<p><a href="http://theme-next.iissnan.com/third-party-services.html#google-webmaster-tools" target="_blank" rel="noopener">NeXT第三方服务集成</a></p>
<p>文章及网站访问量：</p>
<p><img src="/2020/02/17/hexo相关问题/1595773900727.png" alt="1595773900727"></p>
<p>注：由于原链接已失效，还需修改</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">themes\next\layout\_third_party\analytics\busuanzi-counter.swig 中</span><br><span class="line">src = <span class="string">"https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/17/hexo相关问题/1595774099538.png" alt="1595774099538"></p>
<h4 id="给博客加上萌宠或萌妹子"><a href="#给博客加上萌宠或萌妹子" class="headerlink" title="给博客加上萌宠或萌妹子"></a>给博客加上萌宠或萌妹子</h4><p>参考 <a href="https://www.jianshu.com/p/c59a15d90759" target="_blank" rel="noopener">https://www.jianshu.com/p/c59a15d90759</a></p>
<p>不同的选择效果见 <a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">https://huaji8.top/post/live2d-plugin-2.0/</a></p>
<h4 id="添加背景音乐"><a href="#添加背景音乐" class="headerlink" title="添加背景音乐"></a>添加背景音乐</h4><p><a href="https://www.cnblogs.com/Guhongying/p/10461970.html" target="_blank" rel="noopener">Hexo 的next主题下添加网易云音乐作BGM</a></p>
<p>网易云音乐无法生成外链：</p>
<p><a href="https://www.cnblogs.com/cstdio1/p/11617357.html" target="_blank" rel="noopener">https://www.cnblogs.com/cstdio1/p/11617357.html</a></p>
<p>（<span style="background:yellow">更新</span>：参考以上方法时，无法播放音乐？）</p>
<p>另一个方法参考：<a href="https://blog.csdn.net/qq_35859750/article/details/91452615" target="_blank" rel="noopener">hexo添加音乐</a></p>
<p>安装aplayer: <code>npm install --save hexo-tag-aplayer</code></p>
<p>粘贴以下内容到 \themes\next\layout\_macro\sidebar.swig</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 新增的内容 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- require APlayer --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- require MetingJS --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meting-js</span></span></span><br><span class="line"><span class="tag"><span class="attr">server</span>=<span class="string">"netease"</span> </span></span><br><span class="line"><span class="tag"><span class="attr">type</span>=<span class="string">"song"</span></span></span><br><span class="line"><span class="tag"><span class="attr">id</span>=<span class="string">"188376"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">meting-js</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 新增的内容end --&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/17/hexo相关问题/1582012566416.png" alt="1582012566416"></p>
<p>即可.</p>
<p>其中server, type, id等根据具体情况修改.</p>
<p>例：</p>
<p><img src="/2020/02/17/hexo相关问题/1582014322346.png" alt="1582014322346"></p>
<h4 id="关于目录"><a href="#关于目录" class="headerlink" title="关于目录"></a>关于目录</h4><p>在 themes\next\_config.yml 中设定，不要去安装 hexo-toc，否则会冲突</p>
<p><img src="/2020/02/17/hexo相关问题/1582014793720.png" alt="1582014793720"></p>
<h4 id="嵌入视频"><a href="#嵌入视频" class="headerlink" title="嵌入视频"></a>嵌入视频</h4><p>参考 <a href="https://www.bilibili.com/video/av23207325/" target="_blank" rel="noopener">https://www.bilibili.com/video/av23207325/</a></p>
<h4 id="NexT主题官方文档"><a href="#NexT主题官方文档" class="headerlink" title="NexT主题官方文档"></a>NexT主题官方文档</h4><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a></p>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>B树介绍</title>
    <url>/2020/02/16/B%E6%A0%91%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考：<br><a href="https://blog.csdn.net/A_zhangq/article/details/99662693" target="_blank" rel="noopener">https://blog.csdn.net/A_zhangq/article/details/99662693</a><br><a href="https://blog.csdn.net/qq_35571554/article/details/82759668" target="_blank" rel="noopener">漫画叙述B+树和B-树，很值得看!</a></p>
</blockquote>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B-树就是B树（可能有部分人会习惯上把B-树读为B减树，其实并不存在B减树，只是读法上的不同而已），B就是balanced，平衡的意思。<strong>B-树就是指的B树</strong>。</p>
<p>B-树是一种多路搜索树（并不是二叉的）：    </p>
<ol>
<li><p>定义任意非叶子结点最多只有M个儿子，且M&gt;2；    </p>
</li>
<li><p>根结点的儿子数为 [2, M]；    </p>
</li>
<li><p>除根结点以外的非叶子结点的儿子数为 [M/2, M]；    </p>
</li>
<li><p>每个结点存放至少 M/2-1（取上整）和至多  M-1 个关键字；（至少 2个关键字）    </p>
</li>
<li><p>非叶子结点的关键字个数 = 指向儿子的指针个数 - 1；    </p>
</li>
<li><p>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且 K[i] &lt; K[i+1] ；    </p>
</li>
<li><p>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1] 指向关键字小于 K[1] 的子树，P[M] 指向关键字大于            K[M-1] 的子树，其它 P[i] 指向关键字属于(K[i-1], K[i]) 的子树；    </p>
</li>
<li><p>所有叶子结点位于同一层；    </p>
</li>
</ol>
<p>如 (M = 3)：</p>
<p><img src="https://img-blog.csdnimg.cn/20190815211241789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>B-树的搜索：</strong></p>
<p>从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点.</p>
<p><strong>B-树的特性：</strong></p>
<ul>
<li>关键字集合分布在整颗树中；</li>
<li>任何一个关键字出现且只出现在一个结点中；</li>
<li>搜索有可能在非叶子结点结束；</li>
<li>其搜索性能等价于在关键字全集内做一次二分查找；</li>
<li>自动层次控制；</li>
</ul>
<hr>
<a id="more"></a>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树是B-树的变体，也是一种多路搜索树：</p>
<p>其定义基本与B-树同，除了：</p>
<ol>
<li>非叶子结点的子树指针与关键字个数相同；</li>
<li>非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1]]的子树（B-树是开区间）；</li>
<li>为所有叶子结点增加一个链指针；</li>
<li>所有关键字都在叶子结点出现；</li>
</ol>
<p>如（M=3）:</p>
<p><img src="https://img-blog.csdnimg.cn/20190817142029576.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>B+树的搜索</strong>：</p>
<p>与B-树基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</p>
<p><strong>B+树的特性：</strong></p>
<ul>
<li>所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是<strong>有序</strong>的；</li>
<li>不可能在非叶子结点命中；</li>
<li>非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；</li>
<li>更适合文件索引系统；</li>
</ul>
<blockquote>
<p>关于稠密索引与稀疏索引：<a href="https://blog.csdn.net/Qmen_Crow/article/details/51052160" target="_blank" rel="noopener">https://blog.csdn.net/Qmen_Crow/article/details/51052160</a></p>
</blockquote>
<p><strong>B+树的分裂：</strong></p>
<p>当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</p>
<hr>
<h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h3><p>B*树是B+树的一种变形，它是在B+树的基础上，将索引层以指针连接起来（在B+树的非根和非叶子结点再增加指向兄弟的指针），使搜索取值更加快捷。 </p>
<p>如下图（M = 3）：</p>
<p><img src="https://img-blog.csdnimg.cn/20190817142644325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Ffemhhbmdx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>B*树在B+树的基础上产生了一系列的变化，如下：</p>
<ol>
<li>B*树定义了非叶子结点关键字个数至少为(2/3)M，即块的最低使用率为2/3（代替B+树的1/2）；</li>
<li><strong>B *树的分裂：</strong>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</li>
</ol>
<p>B*树相对于B+树，空间利用率上有所提高，查询速率也有所提高。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>二叉搜索树：二叉树，每个结点只存储一个关键字且值大于左子树，小于右子树。</p>
</li>
<li><p>B（B-）树：多路搜索树，每个结点存储 M/2-1 到 M - 1 个关键字，非叶子结点存储指向关键字范围的子结点； 所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p>
</li>
<li>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</li>
<li>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</li>
</ul>
<p><img src="/2020/02/16/B树介绍/1581863461822.png" alt="1581863461822"></p>
<p>这两种树都是平衡的多分树，它们都可以用于文件的索引结构，但B树只能支持随机检索，而B+树是有序的树，既能支持随机检索，又能支持顺序检索。</p>]]></content>
      <tags>
        <tag>B树</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>RNN相关资料（LSTM, GRU）</title>
    <url>/2020/02/15/RNN%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="pdf："><a href="#pdf：" class="headerlink" title="pdf："></a>pdf：</h4><p><a href="https://www.aclweb.org/anthology/C16-1311.pdf" target="_blank" rel="noopener">Effective LSTMs for Target-Dependent Sentiment Classification</a></p>
<h4 id="网页："><a href="#网页：" class="headerlink" title="网页："></a>网页：</h4><p><a href="https://www.jianshu.com/p/95d5c461924c" target="_blank" rel="noopener">【译】理解LSTM（通俗易懂版）</a></p>
<p><a href="https://towardsdatascience.com/understanding-gru-networks-2ef37df6c9be" target="_blank" rel="noopener">Understanding GRU Networks</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32481747" target="_blank" rel="noopener">人人都能看懂的GRU</a></p>
<p><a href="https://www.cnblogs.com/jiangxinyang/p/9376021.html" target="_blank" rel="noopener">深度学习之GRU网络</a></p>
<p><a href="https://www.jianshu.com/p/3774d46b665e" target="_blank" rel="noopener">lstm和gru结构的再理解</a></p>
<p><a href="http://www.sohu.com/a/336551522_99979179" target="_blank" rel="noopener">图解LSTM与GRU单元的各个公式和区别 </a></p>
<p><a href="https://www.analyticsvidhya.com/blog/2017/12/introduction-to-recurrent-neural-networks/" target="_blank" rel="noopener">Fundamentals of Deep Learning – Introduction to Recurrent Neural Networks</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN相关资料</title>
    <url>/2020/02/15/CNN%E7%9B%B8%E5%85%B3%E8%B5%84%E6%96%99/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="pdf："><a href="#pdf：" class="headerlink" title="pdf："></a>pdf：</h4><p><a href="https://www.aclweb.org/anthology/D14-1181.pdf" target="_blank" rel="noopener">Convolutional Neural Networks for Sentence Classification</a></p>
<h4 id="网页："><a href="#网页：" class="headerlink" title="网页："></a>网页：</h4><p><a href="https://www.cnblogs.com/yelbosh/p/5808706.html" target="_blank" rel="noopener">卷积神经网络CNN在自然语言处理中的应用</a></p>
<h4 id="卷积与矩阵乘法："><a href="#卷积与矩阵乘法：" class="headerlink" title="卷积与矩阵乘法："></a>卷积与矩阵乘法：</h4><p><img src="/2020/02/15/CNN相关资料/卷积与矩阵乘法.jpg" alt="卷积与矩阵乘法"></p>
<p><img src="/2020/02/15/CNN相关资料/example.jpg" alt="example"></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>移动零</title>
    <url>/2020/02/05/%E7%A7%BB%E5%8A%A8%E9%9B%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">移动零（难度：简答）</a></p>
<p><img src="/2020/02/05/移动零/1580888243775.png" alt="1580888243775"></p>
<p>问题的两个要求是：</p>
<ul>
<li>将所有 0 移动到数组末尾。</li>
<li>所有非零元素必须保持其原始顺序。</li>
</ul>
<p>这里很好地认识到这两个需求是相互排斥的，也就是说，你可以解决单独的子问题，然后将它们组合在一起以得到最终的解决方案。</p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><ul>
<li>一个指针<code>i</code>从前到后遍历数组，每当遇到非0数时，令 <code>nums[cur] = nums[i]; cur++;</code>，<code>cur</code>是另一个指针（从0开始），记录当前位置。</li>
<li>当<code>i</code>遍历完后，此时<code>cur</code>指向的位置到数组的末尾全赋为0即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)&#123;</span><br><span class="line">                nums[cur] = nums[i];</span><br><span class="line">                cur++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur &lt; nums.length)&#123;</span><br><span class="line">            nums[cur] = <span class="number">0</span>;</span><br><span class="line">            cur++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/02/05/移动零/1580890229187.png" alt="1580890229187"></p>
<p><strong>复杂度</strong></p>
<ul>
<li>时间复杂度：O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最小覆盖子串</title>
    <url>/2020/01/28/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener">最小覆盖子串（难度：困难）</a></p>
<p><img src="/2020/01/28/最小覆盖子串/1580195563488.png" alt="1580195563488"></p>
<h4 id="方法：滑动窗口"><a href="#方法：滑动窗口" class="headerlink" title="方法：滑动窗口"></a>方法：滑动窗口</h4><h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ol>
<li><p>初始，<code>left</code>指针和<code>right</code>指针都指向<code>s</code>的第一个元素.</p>
</li>
<li><p>将 <code>right</code>指针右移，扩张窗口，直到得到一个可行窗口，亦即包含<code>t</code>的全部字母的窗口。</p>
</li>
<li><p>得到可行的窗口后，将<code>left</code>指针逐个右移，若得到的窗口依然可行，则更新最小窗口大小。</p>
</li>
<li><p>若窗口不再可行，则跳转至 2。</p>
</li>
</ol>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="number">0</span></span><br><span class="line">        res = <span class="string">""</span></span><br><span class="line">        need = defaultdict(int)</span><br><span class="line">        window = defaultdict(int)</span><br><span class="line">        minLen = len(s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            need[i] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> right &lt; len(s):</span><br><span class="line">            window[s[right]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> self.con(need,window):</span><br><span class="line">                <span class="keyword">if</span> len(s[left:right+<span class="number">1</span>]) &lt; minLen:</span><br><span class="line">                    minLen = len(s[left:right+<span class="number">1</span>])</span><br><span class="line">                    res = s[left:right+<span class="number">1</span>]</span><br><span class="line">                window[s[left]] -= <span class="number">1</span></span><br><span class="line">                left += <span class="number">1</span></span><br><span class="line">            right += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">con</span><span class="params">(self, need, window)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> need.keys():</span><br><span class="line">            <span class="keyword">if</span> need[key] &gt; window[key]:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p><img src="/2020/01/28/最小覆盖子串/1580201292271.png" alt="1580201292271"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>滑动窗口最大值</title>
    <url>/2020/01/22/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">滑动窗口最大值（难度：困难）</a></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579702056767.png" alt="1579702056767"></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579702078067.png" alt="1579702078067"></p>
<h4 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h4><p>遍历每个滑动窗口，找到每个窗口的最大值。一共有 N - k + 1 个滑动窗口，每个有 k 个元素，于是算法的时间复杂度为 O(Nk)，表现较差。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)-(k<span class="number">-1</span>)):</span><br><span class="line">            j = i + k<span class="number">-1</span></span><br><span class="line">            res.append(max(nums[i:j+<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/22/滑动窗口最大值/1579666044377.png" alt="1579666044377"></p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><ul>
<li>时间复杂度：O(Nk)。其中 <code>N</code> 为数组中元素个数。</li>
<li>空间复杂度：O<em>(</em>N<em>−</em>k+1)，用于输出数组。</li>
</ul>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><p>详细讲解见<a href="https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetcode-3/</a></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        left = [<span class="number">0</span>]*n</span><br><span class="line">        right = [<span class="number">0</span>]*n</span><br><span class="line">        left[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        right[n<span class="number">-1</span>] = nums[n<span class="number">-1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n):</span><br><span class="line">            <span class="comment"># 从左到右</span></span><br><span class="line">            <span class="keyword">if</span> i % k == <span class="number">0</span>: </span><br><span class="line">                <span class="comment"># block start</span></span><br><span class="line">                left[i] = nums[i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left[i] = max(left[i<span class="number">-1</span>], nums[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 从右到左</span></span><br><span class="line">            j = n - i - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (j+<span class="number">1</span>) % k == <span class="number">0</span>:</span><br><span class="line">                <span class="comment"># block end</span></span><br><span class="line">                right[j] = nums[j]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right[j] = max(right[j+<span class="number">1</span>], nums[j])</span><br><span class="line">        </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n-k+<span class="number">1</span>):</span><br><span class="line">            j = i+k<span class="number">-1</span></span><br><span class="line">            res.append(max(right[i], left[j]))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/22/滑动窗口最大值/1579669254322.png" alt="1579669254322"></p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(N)，我们对长度为 N 的数组处理了 3次。</p>
<p>空间复杂度：O(N)，用于存储长度为 N 的 left 和 right 数组，以及长度为 N - k + 1的输出数组。</p>
<h4 id="方法三：双端队列"><a href="#方法三：双端队列" class="headerlink" title="方法三：双端队列"></a>方法三：双端队列</h4><p><img src="/2020/01/22/滑动窗口最大值/1579703855488.png" alt="1579703855488"></p>
<p><img src="/2020/01/22/滑动窗口最大值/1579703901936.png" alt="1579703901936"></p>
<p>思路：维护窗口，向右移动时左侧超出窗口的值弹出，因为需要的是窗口内的最大值，所以只要保证窗口内的值是递减的即可，小于新加入的值全部弹出。最左端即为窗口最大值 </p>
<h5 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSlidingWindow</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        temp = []</span><br><span class="line">        res = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(nums): <span class="comment"># i是索引，v是值</span></span><br><span class="line">            <span class="comment"># 左侧超出窗口的值弹出</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;=k <span class="keyword">and</span> temp[<span class="number">0</span>]&lt;=i-k:</span><br><span class="line">                temp.pop(<span class="number">0</span>) <span class="comment"># pop索引为0的数</span></span><br><span class="line">            <span class="keyword">while</span> temp <span class="keyword">and</span> nums[temp[<span class="number">-1</span>]] &lt;= v:</span><br><span class="line">                temp.pop() <span class="comment"># pop最后一个数</span></span><br><span class="line">            temp.append(i)</span><br><span class="line">            <span class="keyword">if</span> i&gt;=k<span class="number">-1</span>:</span><br><span class="line">                res.append(nums[temp[<span class="number">0</span>]])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/22/滑动窗口最大值/1579704974700.png" alt="1579704974700"></p>
<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(N)，每个元素被处理两次- 其索引被添加到双向队列中和被双向队列删除。</p>
<p>空间复杂度：O(N)，输出数组使用了O(N−k+1) 空间，双向队列使用了 O(k)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>递归</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的中序遍历</title>
    <url>/2020/01/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">二叉树的中序遍历（难度：中等）</a></p>
<p><img src="/2020/01/21/二叉树的中序遍历/1579622453083.png" alt="1579622453083"></p>
<p><strong>中序遍历：左-中-右</strong></p>
<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>定义一个辅助函数来实现递归。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List &lt; Integer &gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">        List &lt; Integer &gt; res = <span class="keyword">new</span> ArrayList &lt; &gt; ();</span><br><span class="line">        helper(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, List &lt; Integer &gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.left, res);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                helper(root.right, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。递归函数 T(n) = 2 T(n/2)+1。<br>空间复杂度：最坏情况下需要空间O(n)，平均情况为O(logn)。</p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>颜色标记法：</p>
<blockquote>
<p>作者：hzhu212<br>链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/yan-se-biao-ji-fa-yi-chong-tong-yong-qie-jian-ming/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>其核心思想如下：</p>
<ul>
<li>使用颜色标记节点的状态，新节点为白色，已访问的节点为灰色。</li>
<li>如果遇到的节点为白色，则将其标记为灰色，然后将其右子节点、自身、左子节点依次入栈。</li>
<li>如果遇到的节点为灰色，则将节点的值输出。</li>
</ul>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        WHITE, GRAY = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        res = []</span><br><span class="line">        stack = [(WHITE, root)]</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            color, node = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> color == WHITE:</span><br><span class="line">                stack.append((WHITE, node.right))</span><br><span class="line">                stack.append((GRAY, node))</span><br><span class="line">                stack.append((WHITE, node.left))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p>如要实现前序、后序遍历，只需要调整左右子节点的入栈顺序即可。</p>
<h5 id="另一种写法："><a href="#另一种写法：" class="headerlink" title="另一种写法："></a>另一种写法：</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: TreeNode)</span> -&gt; List[int]:</span></span><br><span class="line">        stack = []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/21/二叉树的中序遍历/1579622422214.png" alt="1579622422214"></p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。</p>
<p>空间复杂度：O(n)。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">算法</th>
<th style="text-align:left">执行用时</th>
<th style="text-align:left">内存消耗</th>
<th style="text-align:left">语言</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">方法二：迭代（另一种写法）</td>
<td style="text-align:left">28 ms</td>
<td style="text-align:left">13 MB</td>
<td style="text-align:left">Python3</td>
</tr>
<tr>
<td style="text-align:left">方法二：迭代（颜色标价法）</td>
<td style="text-align:left">36 ms</td>
<td style="text-align:left">12.7 MB</td>
<td style="text-align:left">Python3</td>
</tr>
<tr>
<td style="text-align:left">方法一：递归</td>
<td style="text-align:left">0 ms</td>
<td style="text-align:left">34.6 MB</td>
<td style="text-align:left">Java</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树中第k小的元素</title>
    <url>/2020/01/21/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">二叉搜索树中第K小的元素（难度：中等）</a></p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620616705.png" alt="1579620616705"></p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620662544.png" alt="1579620662544"></p>
<p>此题与<a href="https://qypx.github.io/2020/01/21/二叉树的中序遍历/">二叉树的中序遍历（难度：中等）</a>类似，只需稍加变化。</p>
<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>通过构造 BST 的中序遍历序列，则第 <code>k-1</code> 个元素就是第 <code>k</code> 小的元素。</p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/7dc3fe454519e27105c5aaf57d20b26137bd77c56bb0289830bf18116627de12-file_1579413216156.jpg" alt="7dc3fe454519e27105c5aaf57d20b26137bd77c56bb0289830bf18116627de12-file_1579413216156"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        inorder(root,arr);</span><br><span class="line">        <span class="keyword">return</span> arr.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode root, List arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)</span><br><span class="line">                inorder(root.left, arr);</span><br><span class="line">            arr.add(root.val);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)</span><br><span class="line">                inorder(root.right, arr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579620513520.png" alt="1579620513520"></p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(N)，遍历了整个树。</p>
<p>空间复杂度：O(N)，用了一个数组存储中序序列。</p>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>在栈的帮助下，可以将方法一的递归转换为迭代，这样可以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。</p>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176.jpg" alt="25159a5137867644b75f203ee1917645d2cd454d8f4871e371d7edfa67bef083-file_1579413216176"></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            root = stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> root.val</span><br><span class="line">            root = root.right</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/21/二叉搜索树中第k小的元素/1579621550313.png" alt="1579621550313"></p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(H+k)，其中 H指的是树的高度，由于我们开始遍历之前，要先向下达到叶，当树是一个平衡树时：复杂度为O(logN+k)。当树是一个不平衡树时：复杂度为 O(N+k)，此时所有的节点都在左子树。</p>
<p>空间复杂度：O(H+k)。当树是一个平衡树时：O(logN+k)。当树是一个非平衡树时：O(N+k)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续序列</title>
    <url>/2020/01/20/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">最长连续序列（难度：困难）</a></p>
<p><img src="/2020/01/20/最长连续序列/1579513410172.png" alt="1579513410172"></p>
<h4 id="方法：哈希表（HashSet）"><a href="#方法：哈希表（HashSet）" class="headerlink" title="方法：哈希表（HashSet）"></a>方法：哈希表（HashSet）</h4><p>因为一个序列可能在 <code>nums</code> 数组的任意一个数字开始，我们可以枚举每个数字作为序列的第一个数字，搜索所有的可能性 （暴力法）。优化：将数组中的数字用HashSet保存，实现O(1)的时间查询，同时，我们只对 <code>当前数字 - 1</code> 不在哈希表里的数字，作为连续序列的第一个数字去找对应的最长序列，这是因为其他数字一定已经出现在了某个序列里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">            </span><br><span class="line">        HashSet&lt;Integer&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)</span><br><span class="line">            hashSet.add(num);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(!hashSet.contains(nums[i]-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">int</span> curNum = nums[i];</span><br><span class="line">                <span class="keyword">while</span>(hashSet.contains(curNum+<span class="number">1</span>))&#123;</span><br><span class="line">                    curLen++;</span><br><span class="line">                    curNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen,curLen);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。尽管在 for 循环中嵌套了一个 while 循环，时间复杂度看起来像是二次方级别的。但其实它是线性的算法。因为只有当 curNum 遇到了一个序列的开始， while 循环才会被执行（也就是 curNum-1 不在数组 nums 里）， while 循环在整个运行过程中只会被迭代 n 次。这意味着尽管看起来时间复杂度为 O(n⋅n) ，实际这个嵌套循环只会运行O(n+n)=O(n) 次。所有的计算都是线性时间的，所以总的时间复杂度是 O(n)的。</p>
<p>空间复杂度：O(n)。为了实现 O(1)的查询，我们对哈希表分配线性空间，以保存 nums 数组中的 O(n)个数字。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet</title>
    <url>/2020/01/20/HashSet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>无序列表HashSet是采用hash表来实现的。其中的元素没有按顺序排列，add()、remove()以及contains()等方法都是复杂度为O(1)的方法。 </li>
<li>无序列表列表TreeSet是采用树结构实现(红黑树算法)。元素是按顺序进行排列，但是add()、remove()以及contains()等方法都是复杂度为O(log (n))的方法。它还提供了一些方法来处理排序的set，如first(), last(), headSet(), tailSet()等等</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode/</a></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>Feeding Data to your Cluster - Kafka &amp; Flume</title>
    <url>/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579416693703.png" alt="1579416693703"></p>
<h4 id="What-is-streaming"><a href="#What-is-streaming" class="headerlink" title="What is streaming?"></a>What is streaming?</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579417084705.png" alt="1579417084705"></p>
<p>With streaming technologies such as Kafka, you can actually process new data as it’s generated into your cluster, maybe you’re gonna save it into HDFS, maybe you’ll save it into HBase or some other database or maybe you’ll actually process it in real time as it comes in.</p>
<p>Usually when we’re talking about Big Data, there’s a big flow of it coming in all the time and you want to be dealing with it as it comes instead of storing it up and dealing with it in batches. </p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579417930302.png" alt="1579417930302"></p>
<h4 id="Enter-Kafka"><a href="#Enter-Kafka" class="headerlink" title="Enter Kafka"></a>Enter Kafka</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579418299281.png" alt="1579418299281"></p>
<p>The good thing is that Kafka because it stores it, consumers can catch up from where they last left off, so it will maintain the point where each consumer left off and allow them to just pick up whenever they want to. So it can publish data in real time to your consumers, but if your consumer goes off line or just wants to catch up from some point in the past, it can do that too.</p>
<a id="more"></a>
<h4 id="Kafka-architecture"><a href="#Kafka-architecture" class="headerlink" title="Kafka architecture"></a>Kafka architecture</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419075767.png" alt="1579419075767"></p>
<p>Even though it says app, that doesn’t necessarily mean you’re going to be developing an app in order to use Kafka, often there are ones you can just use off the shelf and Kafka even comes with some built-in that might serve your purposes.</p>
<p>You can make these pretty fancy systems that are very scalable, very fast, that can transform data and store it, and do whatever you want with it really, as it comes in.</p>
<h4 id="How-Kafka-scales"><a href="#How-Kafka-scales" class="headerlink" title="How Kafka scales"></a>How Kafka scales</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419261062.png" alt="1579419261062"></p>
<h3 id="Let’s-play"><a href="#Let’s-play" class="headerlink" title="Let’s play"></a>Let’s play</h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579419425921.png" alt="1579419425921"></p>
<h4 id="Activity-Setting-up-Kafka-and-publishing-some-data"><a href="#Activity-Setting-up-Kafka-and-publishing-some-data" class="headerlink" title="[Activity] Setting up Kafka, and publishing some data"></a>[Activity] Setting up Kafka, and publishing some data</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963832#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963832#overview</a></p>
<p>Kafka depends on ZooKeeper to keep track of what topics exists.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579420886266.png" alt="1579420886266"></p>
<p>in the real world, this would be massive floods of data coming in from massive web server fleets and things. It can handle that and publish it scalably and reliably to wherever it needs to go. So that’s really what it’s all about, it’s a scalable and reliable mechanism for publishing and subscribing to massive data streams.</p>
<h4 id="Activity-Publishing-web-logs-with-Kafka"><a href="#Activity-Publishing-web-logs-with-Kafka" class="headerlink" title="[Activity] Publishing web logs with Kafka"></a>[Activity] Publishing web logs with Kafka</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963846#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963846#overview</a></p>
<p>So let’s do something a little bit closer to what you might do in reality. Let’s use a built-in Kafka connector to actually monitor a file and publish new lines on that file to a given Kafka topic that then get written out to some other file somewhere else.</p>
<p>使用的一些Linux语句：</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422270057.png" alt="1579422270057"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422355086.png" alt="1579422355086"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422381621.png" alt="1579422381621"></p>
<h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579422490612.png" alt="1579422490612"></p>
<h4 id="What-is-Flume"><a href="#What-is-Flume" class="headerlink" title="What is Flume?"></a>What is Flume?</h4><p>You can really think of Flume as a bonafide part of the Hadoop ecosystem, as opposed to Kafka which is much more general purpose in its design.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579423582139.png" alt="1579423582139"></p>
<p>Now you might think to yourself “Why can’t I just directly transfer data across to my HDFS cluster?” Well, you need some sort of a buffer in between these two things.</p>
<h4 id="Flume-Agent"><a href="#Flume-Agent" class="headerlink" title="Flume Agent"></a>Flume Agent</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579423781528.png" alt="1579423781528"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425760102.png" alt="1579425760102"></p>
<p>Flume与Kafka的一个区别：It’s not really like Kafka where Kafka just stores up data indefinitely and people can pull that data in whenever they want to. Kafka does expire data after some amount of time, but with Flume, basically your sink grabs data from Flume and once it’s been grabbed from the channel it gets deleted, so flume does not hang onto your messages or your events any longer than it needs to, as soon as your sync processes it, it throws it away. Kafka is a little bit more easier to set up if you have data going to multiple different places that might be pulling at different rates.</p>
<h4 id="Built-in-Source-Types"><a href="#Built-in-Source-Types" class="headerlink" title="Built-in Source Types"></a>Built-in Source Types</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425301835.png" alt="1579425301835"></p>
<h4 id="Built-in-Sink-Types"><a href="#Built-in-Sink-Types" class="headerlink" title="Built-in Sink Types"></a>Built-in Sink Types</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579424846813.png" alt="1579424846813"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579424947616.png" alt="1579424947616"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425396680.png" alt="1579425396680"></p>
<p>It’s basically a way of smoothing out the traffic between the data coming in from your logs or whatever your source might be and where you’re writing it to.</p>
<h3 id="Let’s-play-1"><a href="#Let’s-play-1" class="headerlink" title="Let’s play"></a>Let’s play</h3><h4 id="Activity-Set-up-Flume-and-publish-logs-with-it"><a href="#Activity-Set-up-Flume-and-publish-logs-with-it" class="headerlink" title="[Activity] Set up Flume and publish logs with it"></a>[Activity] Set up Flume and publish logs with it</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963868#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963868#overview</a></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425190618.png" alt="1579425190618"></p>
<p>All you really need to do to get Flume running is write a configuration file that defines what sources channels and sinks are associated with each agent that you want in your Flume setup.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425924768.png" alt="1579425924768"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579427003629.png" alt="1579427003629"></p>
<h4 id="Activity-Set-up-Flume-to-monitor-a-directory-and-store-its-data-in-HDFS"><a href="#Activity-Set-up-Flume-to-monitor-a-directory-and-store-its-data-in-HDFS" class="headerlink" title="[Activity] Set up Flume to monitor a directory and store its data in HDFS"></a>[Activity] Set up Flume to monitor a directory and store its data in HDFS</h4><p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579425361515.png" alt="1579425361515"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579426725240.png" alt="1579426725240"></p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579426873190.png" alt="1579426873190"></p>
<p>What ends up happening is that we get new subdirectories being generated for each 10 minute interval that goes by.</p>
<p><img src="/2020/01/19/Feeding-Data-to-your-Cluster-Kafka/1579427060001.png" alt="1579427060001"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Kafka</tag>
        <tag>Flume</tag>
      </tags>
  </entry>
  <entry>
    <title>Using non-relational data stores with Hadoop - NoSQL &amp; HBase &amp; MongoDB</title>
    <url>/2020/01/16/Using-non-relational-data-stores-with-Hadoop/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h3 id="Why-NoSQL"><a href="#Why-NoSQL" class="headerlink" title="Why NoSQL?"></a>Why NoSQL?</h3><p>We’ve talked about integrating Hadoop with SQL solutions - MySQL - RDBMSs, if you will - relational database management systems - and those are very handy for giving you the power of a rich analytical query language like SQL to answer your business questions. But, you know, they do take a little bit of time to execute. So <strong>if you’re doing analytic work, relational databases are awesome. </strong>Even if you’re running a small, like, say, an internal web site or a very small-scale web site, something like MySQL can even vend that data to the outside world pretty well.</p>
<p>BUT let’s imagine you need to take things up to the next level. You’re going to start to run into some limitations with SQL and relational database systems.</p>
<p>Maybe you don’t really need the ability to issue arbitrary queries across your entire dataset. Maybe all you need is just the ability to <strong>very quickly answer a specific question </strong>like “What movie should I recommend for this customer?” or “What web pages has this customer looked at in the past?” </p>
<p>And if you need to do that <strong>at a very large scale very quickly across a massive dataset</strong>, something like MySQL might not cut it. You know, if you’re an Amazon or a Google, you might need something that can even <strong>handle tens of thousands of transactions per second without breaking a sweat. And that’s where NoSQL comes in.</strong></p>
<p>These are alternative database systems that <em>give up</em> a rich query language like SQL <em>for</em> the ability to very quickly and at great scale answer very simple questions. So for systems like that you want something called NoSQL, also known as non-relational databases, or not only SQL - that’s a term that comes up sometimes, too. And <strong>these systems are built to scale horizontally forever, and also built to be very fast and very resilient.</strong></p>
<p>Up first, let’s talk about HBase. HBase is actually built on top of HDFS, so it allows you to have a very fast, very scalable transactional system to query your data that’s stored on a horizontally partitioned HDFS file system. So if you need to expose your massive data that’s sitting on your Hadoop cluster, Hbase can be a great way to expose that data to a web service, to web applications, anything that needs to operate very quickly and at a very high scale.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579161940219.png" alt="1579161940219"></p>
<a id="more"></a>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579162098786.png" alt="1579162098786"></p>
<p>if you think about things like Amazon or Google, people are always buying new things or always searching for new things, new web sites are always coming out, so this data is always just getting bigger and bigger and bigger over time. So that has to live on some sort of a distributed cluster, like a Hadoop cluster. You’re just not going to fit that into a single hard drive on a single database. You need something that’s more horizontally scalable, where you can keep on adding capacity as your data continues to grow over time.</p>
<p>It’s not just about random access to planet-size data - it’s also planet-size access to that data. Imagine you’re running a web site like Amazon, where you need to very quickly retrieve the list of things people ordered, or the things they looked at, or what movies they should be recommended, or on Google - what they searched for in the past. That all has to happen at extremely large scale. Tens of thousands of people per second might be hitting your service to actually retrieve this information in real time.</p>
<p>Again, a single Oracle database or MySQL database is not gonna cut it, when you’re talking about that kind of transaction rates on that large of a data set.</p>
<p>过去没有NoSQL, Hadoop时，采用的方法：</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579162897675.png" alt="1579162897675"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579163190865.png" alt="1579163190865"></p>
<p>All you need is an API that says, “given this customer ID, give me back this list of information”, or “given</p>
<p>this item identifier, give me back this information about this item”. So, more often than not, all you really need at runtime is a simple API that allows you to get information for a given key or put information into a given key.</p>
<p>These are basically, key-value data stores at a high level. And if that’s all you need, then you don’t need a big fancy relational database. All you need is a more scalable system that can be very easily horizontally partitioned for given key ranges, that just answers the question: “Give me this stuff for this key”.</p>
<p>And you can always do both, too. For example, you can have a Hadoop cluster that you’re running Hive on, or Pig, or Spark, to actually answer the more complex questions that you have, but for the things you are doing at a very high scale, at very high transaction rates, you can bolt on a NoSQL database to actually handle that part of the problem. It’s not a question of one or the other - it’s about having the right tools in place for the right jobs.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579163943922.png" alt="1579163943922"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579165798303.png" alt="1579165798303"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579165874566.png" alt="1579165874566"></p>
<h3 id="What-is-HBase"><a href="#What-is-HBase" class="headerlink" title="What is HBase"></a>What is HBase</h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579166108894.png" alt="1579166108894"></p>
<p>HBase is built on top of HDFS. So if you’re storing massive datasets on an HDFS file system, HBase can be used to actually vend that to the outside world at a very large scale.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579170600274.png" alt="1579170600274"></p>
<p>Just like every other NoSQL solution, it <strong>does not have a query language, but it does have an API</strong> that can very quickly answer the question “what are the values for this key?” or “store this value for this key”.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579170812851.png" alt="1579170812851"></p>
<h4 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579171017155.png" alt="1579171017155"></p>
<h4 id="HBase-architecture"><a href="#HBase-architecture" class="headerlink" title="HBase architecture"></a>HBase architecture</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579172096734.png" alt="1579172096734"></p>
<p>Basically, it’s split up into different region servers. This is the core of HBase itself. When we talk about regions, we’re talking about ranges of keys, so it’s just like sharding or range partitioning in more traditional database systems. But the magic of it all is that it can automatically adapt, so, as your data grows, it can automatically repartition things, and if you add more servers to the mix, it can automatically deal with that at runtime.</p>
<p>So there’s a very complex mechanism that involves write-ahead commit logs and, merging things together over time asynchronously. But you don’t have to worry about those details - HBase does it for you. All you need to know is that it can automatically distribute your data amongst a fleet of region servers, so an entire cluster, if you will.</p>
<p>Now, when you have an application that’s actually talking to HBase - a web application or a web server - it’s not actually going to talk to these master nodes directly, it’s going to be talking to region servers directly.</p>
<h4 id="HBase-data-model"><a href="#HBase-data-model" class="headerlink" title="HBase data model"></a>HBase data model</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579172733321.png" alt="1579172733321"></p>
<p>What’s different about HBase is that it has the concept of column families. So you don’t define a fixed set of columns for each row in your database. Instead you define column families, and each column family can contain a very large number of individual columns.</p>
<p>This comes in handy where you have cases of sparse data.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579174693898.png" alt="1579174693898"></p>
<h4 id="Ways-to-access-HBase"><a href="#Ways-to-access-HBase" class="headerlink" title="Ways to access HBase"></a>Ways to access HBase</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579175017006.png" alt="1579175017006"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579174915921.png" alt="1579174915921"></p>
<h3 id="Activity-Import-movie-ratings-into-HBase"><a href="#Activity-Import-movie-ratings-into-HBase" class="headerlink" title="[Activity] Import movie ratings into HBase"></a>[Activity] Import movie ratings into HBase</h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579178657253.png" alt="1579178657253"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579179141807.png" alt="1579179141807"></p>
<p>Now we’re going to run a REST service on top of HBase. It’s just a service that you can query through</p>
<p>HTTP requests, and we’re going to write a client that actually queries that service to store and retrieve</p>
<p>data through the REST service.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963426#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963426#overview</a></p>
<p>返回结果：</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579179897880.png" alt="1579179897880"></p>
<h3 id="MongoDB-Overview"><a href="#MongoDB-Overview" class="headerlink" title="MongoDB Overview"></a>MongoDB Overview</h3><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579180346655.png" alt="1579180346655"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579180457304.png" alt="1579180457304"></p>
<p>CAP theorem: <strong>MongoDB chooses consistency and partition-tolerance.</strong></p>
<p>Since it dose have to deal with big data, partition-tolerance is something is has to do, and MongoDB chooses consistency over availability.</p>
<p>So MongoDB has a single master, a single primary database that you have to talk to all the time to ensure consistency. But if that master goes down, it will result in a period of unavailability, while a new primary database is put into place.</p>
<h4 id="Document-based-data-model"><a href="#Document-based-data-model" class="headerlink" title="Document-based data model"></a>Document-based data model</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579235814767.png" alt="1579235814767"></p>
<p>The big thing that’s different about MongoDB is that you can stick pretty much anything you want into MongoDB - basically, any JSON blob of data you can shove into a document in MongoDB. It doesn’t have to be structured, you don’t have to have the same schema across each document. You can put whatever you want in there.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579236174990.png" alt="1579236174990"></p>
<p>You still need to think about what the queries are you going to be performing on this database and design your database schema accordingly. Think about what indices you might need for fast lookups for the queries you’re going to do. At the end of the day, it’s still a NoSQL database, so you cannot do joins efficiently, so you want to make sure your schema is denormalized as much as you can. </p>
<h4 id="MongoDB-terminology"><a href="#MongoDB-terminology" class="headerlink" title="MongoDB terminology"></a>MongoDB terminology</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579238197250.png" alt="1579238197250"></p>
<p>在MongoDB中我们讨论 Databse, Collection, 和 Document, 而不是 Database, Table, 和 Row.</p>
<p>A MongoDB database contains collections, and a collection contains a collection of documents.</p>
<p>And the main restriction here is simply that you cannot move data between collections across different databases, so if you do need to reference data between different collections, they do need to be within the same database.</p>
<h4 id="Replication-Sets"><a href="#Replication-Sets" class="headerlink" title="Replication Sets"></a>Replication Sets</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579250924977.png" alt="1579250924977"></p>
<p>MongoDB has a single-master architecture, the idea being that we want to have consistency over availability, but you can have these secondary databases that maintain copies over time from your primary database, so, as writes happen to your primary database, those writes get replicated through an operation log to any secondary nodes that you might have attached to it.</p>
<p>The way that replication chain works is kind of arbitrary. It actually just tries to figure out which server can it talk to most quickly.</p>
<p>And I want to stress again that we haven’t even talked about big data yet. What we’re talking about here in replica sets is just having a single monolithic MongoDB server, where all of the data sits on that single server, and we’re replicating that data to backup servers.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254081608.png" alt="1579254081608"></p>
<h4 id="Sharding-How-MongoDB-handles-big-data"><a href="#Sharding-How-MongoDB-handles-big-data" class="headerlink" title="Sharding (How MongoDB handles big data)"></a>Sharding (How MongoDB handles big data)</h4><p>For actually scaling out data across more than one server with MongoDB, we need to set up something called sharding.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254450944.png" alt="1579254450944"></p>
<p>The way sharding works is that we actually have multiple replica sets, where each replica set is responsible for some range of values on some indexed value in my database. So in order to get sharding to work, it requires that you set up an index on some unique value on your collection, and that index is used to actually balance the load of information among multiple replica sets, and then on each application server, whatever you’re using to talk to MongoDB, you’ll run a process called “mongos”, and “mongos” talks to exactly three configuration servers that you have running somewhere that knows about how things are partitioned and then uses that to figure out which replica set do I talk to to get the information that I want.</p>
<p>“mongos” is running something called a balancer in the background. So, over time, if it finds that it actually doesn’t have an even distribution of values in whatever field you’re partitioning on, it can rebalance things across your replica sets in real time over time.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579254879640.png" alt="1579254879640"></p>
<h4 id="Neat-Things-about-MongoDB"><a href="#Neat-Things-about-MongoDB" class="headerlink" title="Neat Things about MongoDB"></a>Neat Things about MongoDB</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579255204023.png" alt="1579255204023"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579255278039.png" alt="1579255278039"></p>
<h3 id="Activity-Install-MongoDB-and-integrate-Spark-with-MongoDB"><a href="#Activity-Install-MongoDB-and-integrate-Spark-with-MongoDB" class="headerlink" title="[Activity] Install MongoDB and integrate Spark with MongoDB"></a>[Activity] Install MongoDB and integrate Spark with MongoDB</h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963458#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963458#overview</a></p>
<p>We’re going to read in the “u.user” data file from the MovieLens dataset, convert that into a dataframe in Spark and then write that dataframe out to MongoDB, and then we’re going to read it back and do a little query on it.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579328591006.png" alt="1579328591006"></p>
<p>What we’re not doing is loading this data into Spark locally and then running a query on it - what it’s</p>
<p>actually doing is figuring out how do I translate this SQL query into a MongoDB query and actually</p>
<p>execute that on MongoDB and return the results back from MongoDB.</p>
<h3 id="Activity-Using-the-MongoDB-Shell"><a href="#Activity-Using-the-MongoDB-Shell" class="headerlink" title="[Activity] Using the MongoDB Shell"></a>[Activity] Using the MongoDB Shell</h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963462#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963462#overview</a></p>
<p>启动MongoDB Shell:</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406411404.png" alt="1579406411404"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579331041897.png" alt="1579331041897"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579331085161.png" alt="1579331085161"></p>
<p>注意一点：we never set up an index. So when I said, “go find user ID 100”, it couldn’t do that very efficiently, and I actually had to do a full table scan, because MongoDB doesn’t automatically index things for you.</p>
<p>I can do <code>db.users.explain().find( {user_id: 100} )</code> , and that will do an explain on the query, telling you what it will do under the hood to actually execute the command “find” on the expression “{user_id: 100}”. And you can see here all it’s doing is a scan on the “winningPlan”, looking for user ID 100 going forward. So it’s kind of just starts at the beginning of the entire database and chugs through it forward one record, one document at a time, until it stumbles across user ID 100, so, obviously, not the most efficient way of doing a lookup.</p>
<p>So to fix that, let’s make an index. To do that, I can say, <code>db.users.createIndex( {user_id: 1} )</code> -and what this means is I want to create an index on the “user_id” field and the “1” just means it’s ascending. So that’s going to give you back a sort order that’s in ascending order, if you want to optimize sorts as well.</p>
<p>Once it has its index on the “user_id” field, it can much more quickly look up where to find a given document for that user ID.</p>
<p><strong>MongoDB does not set up an index for you on your primary key. You have to do it by hand, and if you forget to do it, your database is going to be horribly inefficient when you do lookups.</strong></p>
<p>Let’s aggregate all of the users by occupation and figure out the average age for each occupation.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405319292.png" alt="1579405319292"></p>
<p>In MongoDB things that start with a dollar sign mean that this has some sort of a special meaning to MongoDB, so “$group” is a command that MongoDB recognizes.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405698972.png" alt="1579405698972"></p>
<p>How many users are in our database?</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579405757587.png" alt="1579405757587"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406239652.png" alt="1579406239652"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406303820.png" alt="1579406303820"></p>
<h3 id="Choosing-a-database-technology"><a href="#Choosing-a-database-technology" class="headerlink" title="Choosing a database technology"></a>Choosing a database technology</h3><h4 id="Integration-considerations"><a href="#Integration-considerations" class="headerlink" title="Integration considerations"></a>Integration considerations</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406708880.png" alt="1579406708880"></p>
<p>Different technologies have different connectors for different other technologies. </p>
<p>例如, if you have a big analytics job that’s currently running in Apache Spark, then you probably want to limit yourself to external databases that can connect easily to Apache Spark.</p>
<p>又例如, Maybe you have some front-end system that actually depends on having a SQL interface to a back-end database, and you’re thinking about moving from a monolithic relational database to a distributed non-relational database. In that case, it might make life a lot easier if the non-relational database you’re moving to offers some sort of SQL-like interface that can be easily migrated to from your front-end application.</p>
<h4 id="Scaling-requirements"><a href="#Scaling-requirements" class="headerlink" title="Scaling requirements"></a>Scaling requirements</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579406971416.png" alt="1579406971416"></p>
<p>How much data are you really talking about? Is it going to grow unbounded over time?</p>
<p>If so, then you need some sort of a database technology that is not limited to the data that you can store on one PC, right? You’re going to have to look at something like Cassandra or MongoDB or HBase, where you can actually distribute the storage of your data across an entire cluster and scale horizontally instead of vertically.</p>
<p>Think, too, about your transaction rates: how many requests do you intend to get per second? You know, if we’re talking about thousands, then, again, a single database server is not going to cut it. You need something that’s distributed, where you can spread out the load of those transactions more evenly.</p>
<h4 id="Support-considerations"><a href="#Support-considerations" class="headerlink" title="Support considerations"></a>Support considerations</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579407277634.png" alt="1579407277634"></p>
<p>So do you actually have the in-house expertise to spin up this new technology and actually configure it properly? It’s going to be harder than you think, especially if you’re using this in the real world or in any sort of situation, where you have personally identifiable information in the mix from your end users. In that case, you need to make sure you’re thinking very deeply about the <strong>security</strong> of your system, and the truth is most of the NoSQL databases we talked about, if you just configure them with their default settings, there’ll be no security at all. Anybody at all can connect to these things and retrieve data or write data into them, so you need to make sure you have someone available who knows what they’re doing for setting this up in a secure manner.</p>
<p>That might mean if you are in a big organization that has these experts in house, that’s great, don’t even think about it - but if you’re in a smaller organization, you might want to consider: does this technology I’m choosing actually offer professional paid support that will help guide me through these setup decisions and the initial administration of my server over time? Or are there administrators that I can outsource the ongoing administration to over time? So in this case, you know, a more corporate solution like MongoDB might actually be a good choice, because, you know, they have paid support, and even for the more open-source Apache projects, there are companies out there that do offer paid professional support for them as well, so do your homework and try to figure out: can I really do this on my own, and if not, what resources are out there in the marketplace to help me? </p>
<h4 id="CAP-considerations"><a href="#CAP-considerations" class="headerlink" title="CAP considerations"></a>CAP considerations</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579407517312.png" alt="1579407517312"></p>
<p>So again, the way to think about this is when you’re thinking about the scale of your requirements, do you need to have partition tolerance? Do you have sufficient scale, where you know you’re going to eventually need more than one server serving up the data just for handling the transactions you’re talking about, and also for the scale of the data that you’re talking about? If so, partition tolerance is non-negotiable, you need that one, and your only real choice in that case is consistency or availability.</p>
<p>And that will determine which one of these sides of the triangle you might want to lean toward. So the type of application will determine what you want there. Is it actually OK if your system goes down for a few seconds or a few minutes? If not, then availability’s going to be your prime concern. Is it OK if you have eventual consistency, where, if you write something, people might get the old value back on subsequent reads for a few seconds? If so, who cares about consistency, right? Again, I would take availability instead. But if you’re dealing with something that’s dealing with real transactional information like, you know, stock transactions or some sort of financial transactions, you might value consistency above all else, and in that case, you want to really focus on that corner of the triangle.</p>
<blockquote>
<p>注：Now, I should point out that the CAP theorem isn’t really a hard-and-fast rule. The reality is these tradeoffs have become a little bit more loose in recent years. For example, consider Cassandra: is it really trading off consistency for availability and partition tolerance? Well, you can actually configure the amount of consistency that you want from Cassandra - you can tell it, “I want to make sure I get back the same result from every replica of this data before I actually consider that transaction to be final”, and if you’re running it in that mode, you’re kind of getting all three.</p>
<p>The lines are getting blurred between these different tradeoffs over time. So the honest truth is any of these technologies can be made to work in pretty much any situation, if you try hard enough. It’s really a question of choosing the technology that’s best suited to the tradeoffs that you want to make.</p>
</blockquote>
<h4 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579408720595.png" alt="1579408720595"></p>
<p>If you don’t need to set up a highly complex NoSQL cluster and something that needs a lot of maintenance, like, you know, MongoDB or HBase, where you have all these external servers that maintain its configuration, don’t do it, if you don’t need to. </p>
<p><strong>Think about the minimum requirements that you need for your system and keep it as simple as possible.</strong></p>
<p>If you don’t need to deal with massive scale, don’t deploy a NoSQL database, if you don’t already have one, right? Just use a MySQL instance somewhere, it will be fine.</p>
<p>So keep it simple, do not deploy a whole new system that does not have good expertise within your organization, unless you really need to. Simple technologies and simple architectures are going to be a lot easier to maintain.</p>
<h4 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h4><p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579408982980.png" alt="1579408982980"></p>
<p>Go with MySQL.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409021695.png" alt="1579409021695"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409163590.png" alt="1579409163590"></p>
<p>Well, first of all, step back and ask yourself, “do I even have enough scale here to warrant a non-relational database at all? Why am I even thinking about this question - right? - if all I’m doing is analytics, that’s what Hadoop is for, that’s what Spark is for.”</p>
<p>如果只是需要分析：You can import this data into HDFS on your cluster and analyze it offline. </p>
<p>如果是想要很快的得到结果：If we’re not talking about high transaction rates here, where we care about very quickly getting the answer to a specific query over and over and over again, thousands of times per second, - that’s the sort of a problem that NoSQL databases are meant for.</p>
<p>You could solve this problem just by importing your log data into HDFS, but it doesn’t involve external databases at all. Once that data is residing on my HDFS cluster, I can write a Spark job that mines that data, assigns the appropriate structure to it, and it can actually run machine learning algorithms on it even using Spark’s MLlib.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409497341.png" alt="1579409497341"></p>
<p>Just use your Hadoop cluster and the capabilities that the Hadoop ecosystem gives you, without resorting to outside database technologies.</p>
<p>There’s no need here to set up an external database at all necessarily, unless you need to vend this data to a very large audience externally. So if you were actually building Google Analytics for real, where you had, you know, millions of people that wanted to hit it and get answers from it at once, then, sure, you’d want to expose that through some sort of an external database system that’s integrated with your cluster.</p>
<p>But if you’re just using this internally for analytic use, there’s no need to even talk about things like NoSQL or Mongo or Cassandra or something like that.</p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409662825.png" alt="1579409662825"></p>
<p>Consistency:  it’s OK if, for a few seconds after new recommendations have been computed for a user, that you’re still getting the old recommendations.</p>
<p>So, thinking back to the CAP theorem, we care about availability, we care about partition tolerance very much, the thing that we’re willing to give up, maybe, is consistency.</p>
<p>In that case, Cassandra might be a good choice. </p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579409873125.png" alt="1579409873125"></p>
<p><img src="/2020/01/16/Using-non-relational-data-stores-with-Hadoop/1579410043297.png" alt="1579410043297"></p>
<p>We posed this scenario, where you’re building a massive stock trading system, where maybe you want to run a big analytics job on Hadoop or Spark in the background, but you still need to have some sort of a front-end interface to the actual stock trades themselves, so what would be a good choice of a database in this situation?</p>
<p>选择 MongoDB 或者 HBase 都可以。对于 MongoDB, there is a big company behind it that makes its living selling support for it. 另一方面，Now, there are other companies out there that do specialize in offering support for things like HBase or other Apache projects, so don’t make that a hard decision there.</p>
]]></content>
      <tags>
        <tag>Hadoop</tag>
        <tag>HBase</tag>
        <tag>MongoDB</tag>
        <tag>NoSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Using relational data stores with Hadoop —— Hive &amp; Sqoop</title>
    <url>/2020/01/15/Using-relational-data-stores-with-Hadoop-%E2%80%94%E2%80%94-Hive/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h2 id="HIVE"><a href="#HIVE" class="headerlink" title="HIVE"></a>HIVE</h2><p>We can actually make your Hadoop cluster look like a relational database through a technology called <strong>Hive</strong>. And there’s also ways of integrating a new Hadoop cluster with a MySQL database.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579064046135.png" alt="1579064046135"></p>
<h3 id="What-is-Hive"><a href="#What-is-Hive" class="headerlink" title="What is Hive?"></a>What is Hive?</h3><p>It lets you write standard SQL queries that look just like you’d be using them on MySQL, but actually execute them on data that’s stored across your entire cluster, maybe on an HDFS cluster as well.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579064255091.png" alt="1579064255091"></p>
<h4 id="Why-Hive"><a href="#Why-Hive" class="headerlink" title="Why Hive"></a>Why Hive</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579082214734.png" alt="1579082214734"></p>
<h4 id="Why-not-Hive"><a href="#Why-not-Hive" class="headerlink" title="Why not Hive"></a>Why not Hive</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579083363568.png" alt="1579083363568"></p>
<p>It’s not really meant for being hit with tons of queries all at once, from a website or something like that. That’s where you use something like HBase instead.</p>
<p>Hive is a bunch of smoke and mirrors to make it look like a database, so you can issue SQL queries on it, but it isn’t really.</p>
<a id="more"></a>
<h4 id="HiveQL"><a href="#HiveQL" class="headerlink" title="HiveQL"></a>HiveQL</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579084456353.png" alt="1579084456353"></p>
<h3 id="Activity-Use-Hive-to-find-the-most-popular-movie"><a href="#Activity-Use-Hive-to-find-the-most-popular-movie" class="headerlink" title="[Activity] Use Hive to find the most popular movie"></a>[Activity] Use Hive to find the most popular movie</h3><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963170#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963170#overview</a></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085359675.png" alt="1579085359675"></p>
<p>或写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT title, COUNT(movieID) AS ratingCount</span><br><span class="line">FROM ratings JOIN names ON ratings.movieID = names.movieID</span><br><span class="line">GROUP BY ratings.movieID</span><br><span class="line">ORDER BY ratingCount DESC;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085980578.png" alt="1579085980578"></p>
<p>We used views in Hive to split up a more complicated query into something more readable and more manageable.</p>
<p>执行时会花一点时间，remember this isn’t really a relational database, so things like joins are kind of painful when you’re not dealing with normalized data.</p>
<p>执行后会发现新创建的view出现在了Database里：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579085692727.png" alt="1579085692727"></p>
<p>Your views are persistent, they’re stored to disk.</p>
<p>若此时再执行会出错，可写成： <code>CREATE VIEW IF NOT EXISTS topMovieIDs ...</code></p>
<p>Just to clean up our mess and not leave that around: <code>DROP VIEW topMovieIDs;</code></p>
<h3 id="How-Hive-works"><a href="#How-Hive-works" class="headerlink" title="How Hive works?"></a>How Hive works?</h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579086892876.png" alt="1579086892876"></p>
<h4 id="Schema-on-read"><a href="#Schema-on-read" class="headerlink" title="Schema on read"></a>Schema on read</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579087836551.png" alt="1579087836551"></p>
<p>One of the basic concepts pf Hive is something called <em>schema on read</em>, and this is what separates it from a more traditional database. With a real relational database, it uses something called <em>schema on write</em> where you define the schema of your database before you load the data into it, and it’s actually enforced at the time that you write the data to disk. </p>
<p>Hive flips that on its head. It takes unstructured data and just sort of applies a schema to it as it’s being read instead.</p>
<p>So, Hive isn’t creating some structured relational database under the hood, that would be very inefficient, it’s just taking the existing data that you have on your cluster and imparting a schema to it when it’s read in.</p>
<h4 id="Where-is-the-data-内部表与外部表"><a href="#Where-is-the-data-内部表与外部表" class="headerlink" title="Where is the data? (内部表与外部表)"></a>Where is the data? (内部表与外部表)</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579089471741.png" alt="1579089471741"></p>
<p>对于 managed table, if you do a “DROP TABLE” command from Hive, then that data is gone.</p>
<p>But sometimes you want to share that data with other systems that are outside of Hive. So that’s where external tables come in. “CREATE EXTERNAL TABLE” with “Location” says, “I’m going to use Hive on this data here, but I’m not going to own it anymore”. So I drop this table, it’s going to drop the metadata, 但是原数据不会被删除。</p>
<h4 id="Partitioning-分区"><a href="#Partitioning-分区" class="headerlink" title="Partitioning 分区"></a>Partitioning 分区</h4><p>If you do have a massive dataset and your queries tend to be on a specific partition of that data, partitioning in Hive can be a very important optimization. </p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579096514448.png" alt="1579096514448"></p>
<p>We wouldn’t have to scan over the entire customer database, we could just scan over the actual files that are specific to the country that I’m interested in.</p>
<h4 id="Ways-to-use-Hive"><a href="#Ways-to-use-Hive" class="headerlink" title="Ways to use Hive"></a>Ways to use Hive</h4><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579096909189.png" alt="1579096909189"></p>
<h3 id="Activity-Use-Hive-to-find-the-movie-with-the-highest-average-rating"><a href="#Activity-Use-Hive-to-find-the-movie-with-the-highest-average-rating" class="headerlink" title="[Activity] Use Hive to find the movie with the highest average rating"></a>[Activity] Use Hive to find the movie with the highest average rating</h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579149719149.png" alt="1579149719149"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579097528758.png" alt="1579097528758"></p>
<p>或写成：？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT title, AVG(rating) as avgRating</span><br><span class="line">FROM ratings JOIN names on ratings.movieID = names.movieID</span><br><span class="line">GROUP BY ratings.movieID</span><br><span class="line">HAVING COUNT(ratings.movieID)  &gt; 10</span><br><span class="line">ORDER BY avgRating DESC;</span><br></pre></td></tr></table></figure>
<h2 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h2><h3 id="Integrating-MySQL-with-Hadoop"><a href="#Integrating-MySQL-with-Hadoop" class="headerlink" title="Integrating MySQL with Hadoop"></a>Integrating MySQL with Hadoop</h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579149997458.png" alt="1579149997458"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579150738331.png" alt="1579150738331"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579150774304.png" alt="1579150774304"></p>
<h3 id="Import-Export-data-MySQL-lt-gt-HDFS-Hadoop"><a href="#Import-Export-data-MySQL-lt-gt-HDFS-Hadoop" class="headerlink" title="Import/Export data (MySQL &lt;-&gt; HDFS/Hadoop)"></a>Import/Export data (MySQL &lt;-&gt; HDFS/Hadoop)</h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579151204058.png" alt="1579151204058"></p>
<p>Export data from your database into Hadoop:</p>
<ol>
<li>kick off a bunch of mappers (只有mappers, all we’re doing is moving data and transforming it from one place to another, there’s no real reduce going on here.)</li>
<li>all these mappers are going to talk to your HDFS cluster on your Hadoop cluster and populate a big old table on HDFS, which is a giant text file (例如逗号分隔的数据), and from there, you can use tools like Hive or Pig on it.</li>
</ol>
<p>REMEMBER, the power of HDFS is that file might be distributed across many different hosts, blocks, and also stored redundantly. We’ve done more than just dump our database to a file here - we’ve dumped it into HDFS, which opens up a whole world of possibilities for analyzing it in a robust, scalable and a manner that can be resilient to failure.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579156422401.png" alt="1579156422401"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579157592193.png" alt="1579157592193"></p>
<p>与导入HDFS一样，导入Hive同样会kick off a MapReduce job.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579154105803.png" alt="1579154105803"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159508995.png" alt="1579159508995"></p>
<h3 id="Play-with-MySQL-and-Sqoop"><a href="#Play-with-MySQL-and-Sqoop" class="headerlink" title="Play with MySQL and Sqoop"></a>Play with MySQL and Sqoop</h3><p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579154231118.png" alt="1579154231118"></p>
<h4 id="Activity-Install-MySQL-and-import-our-movie-data"><a href="#Activity-Install-MySQL-and-import-our-movie-data" class="headerlink" title="[Activity] Install MySQL and import our movie data"></a>[Activity] Install MySQL and import our movie data</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963236#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963236#overview</a></p>
<h4 id="Activity-Use-Sqoop-to-import-data-from-MySQL-to-HDFS-Hive"><a href="#Activity-Use-Sqoop-to-import-data-from-MySQL-to-HDFS-Hive" class="headerlink" title="[Activity] Use Sqoop to import data from MySQL to HDFS/Hive"></a>[Activity] Use Sqoop to import data from MySQL to HDFS/Hive</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963266#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963266#overview</a></p>
<p>由 MySQL 导入 HDFS 后：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579156905400.png" alt="1579156905400"></p>
<p>由 MySQL 导入Hive后：</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579157822360.png" alt="1579157822360"></p>
<blockquote>
<p>注：These sorts of tools that we’re using with Hadoop are really intended for big datasets, so there’s a lot of overhead for doing what’s actually a pretty simple operation. It doesn’t make sense if you’re using small datasets. 如果数据集很小，在一个host就能装下，没必要用这些工具，用MySQL就足够了。</p>
</blockquote>
<h4 id="Activity-Use-Sqoop-tp-export-data-from-Hadoop-to-MySQL"><a href="#Activity-Use-Sqoop-tp-export-data-from-Hadoop-to-MySQL" class="headerlink" title="[Activity] Use Sqoop tp export data from Hadoop to MySQL"></a>[Activity] Use Sqoop tp export data from Hadoop to MySQL</h4><p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963272#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963272#overview</a></p>
<ol>
<li>首先需要知道 where the data in Hive actually resides. REMEMBER, Hive is just a schema-on-read sort of deal. The actual data itself if just stored as a plain old text somewhere, and all Hive is doing is imparting structure to it when it’s being read. </li>
</ol>
<p>On Hortonworks:</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579158771230.png" alt="1579158771230"></p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579158823550.png" alt="1579158823550"></p>
<p>不是靠逗号分隔的，Hive actually uses low ASCII values, like 1 and 2 and 3, to delimit its data. </p>
<ol>
<li>在导入前，MySQL中要先有 target table</li>
</ol>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159104056.png" alt="1579159104056"></p>
<p>3.</p>
<p><img src="/2020/01/15/Using-relational-data-stores-with-Hadoop-——-Hive/1579159601163.png" alt="1579159601163"></p>
<p>和import一样，export也会kick off a bunch of mappers using MapReduce.</p>
<blockquote>
<p>什么时候需要从Hive导入MySQL: From a practical standpoint, if you need to expose your data to a database that’s more well-suited for OLTP. Sometimes you’ll be doing some huge operation using Hive or some other tool on your cluster, but the output of that operation might be small enough to fit on a single database.</p>
</blockquote>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>We talked about making your Hadoop cluster look like a MySQL database or a SQL database, using Hive.</p>
<p>And we also talked about using your Hadoop cluster with a real MySQL database as well. Kind of two different directions there.</p>
<p>Next, let’s talk about <strong>NoSQL</strong>. Sometimes you actually want to expose your data in a way that’s more amenable to <strong>real-time queries</strong>, and there’s a bunch of ways to do that and also ways of integrating Hadoop with systems that are more real-time in nature.</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
        <tag>Sqoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Course Overview</title>
    <url>/2020/01/14/Hadoop-Course-Overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>课程：</p>
<p><a href="https://www.udemy.com/course-dashboard-redirect/?course_id=996228" target="_blank" rel="noopener"><img src="https://i.udemycdn.com/course/240x135/996228_af5f_3.jpg" alt="The Ultimate Hands-On Hadoop - Tame your Big Data!"></a><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/" target="_blank" rel="noopener"><strong>The Ultimate Hands-On Hadoop - Tame your Big Data!</strong></a></p>
<p><a href="https://sundog-education.com/hadoop-materials/" target="_blank" rel="noopener">Course Materials</a></p>
<h4 id="What-you’ll-learn"><a href="#What-you’ll-learn" class="headerlink" title="What you’ll learn"></a>What you’ll learn</h4><ul>
<li>Design distributed systems that manage “big data” using Hadoop and related technologies.</li>
<li>Use HDFS and MapReduce for storing and analyzing data at scale.</li>
<li>Use Pig and Spark to create scripts to process data on a Hadoop cluster in more complex ways.</li>
<li>Analyze relational data using Hive and MySQL</li>
<li>Analyze non-relational data using HBase, Cassandra, and MongoDB</li>
<li>Query data interactively with Drill, Phoenix, and Presto</li>
<li>Choose an appropriate data storage technology for your application</li>
<li>Understand how Hadoop clusters are managed by YARN, Tez, Mesos, Zookeeper, Zeppelin, Hue, and Oozie.</li>
<li>Publish data to your Hadoop cluster using Kafka, Sqoop, and Flume</li>
<li>Consume streaming data using Spark Streaming, Flink, and Storm</li>
</ul>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/2020/01/14/Spark/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考 <a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/985-2/</a></p>
</blockquote>
<h3 id="1-Introduction-to-Spark"><a href="#1-Introduction-to-Spark" class="headerlink" title="1. Introduction to Spark"></a>1. Introduction to Spark</h3><p><img src="/2020/01/14/Spark/1578976053911.png" alt="1578976053911"></p>
<p><img src="/2020/01/14/Spark/1578976261212.png" alt="1578976261212"></p>
<p>There’s a lot of cool features built on top of Spark, like things for machine learning and graph analysis and streaming data.</p>
<h4 id="1-1-Spark-运行架构"><a href="#1-1-Spark-运行架构" class="headerlink" title="1.1 Spark 运行架构"></a>1.1 Spark 运行架构</h4><h5 id="1-1-1-架构设计"><a href="#1-1-1-架构设计" class="headerlink" title="1.1.1 架构设计"></a>1.1.1 架构设计</h5><p><img src="/2020/01/14/Spark/image-20220110152940708.png" alt="image-20220110152940708"></p>
<p>Spark运行架构包括集群资源管理器（Cluster Manager）、运行作业任务的工作节点（Worker  Node）、每个应用的任务控制节点（Driver）和每个工作节点上负责具体任务的执行进程（Executor）。其中，集群资源管理器可以是Spark自带的资源管理器，也可以是YARN或Mesos等资源管理框架。</p>
<p>如下图所示，在Spark中，一个应用（Application）由一个任务控制节点（Driver）和若干个作业（Job）构成，一个作业由多个阶段（Stage）构成，一个阶段由多个任务（Task）组成。当执行一个应用时，任务控制节点会向集群管理器（Cluster  Manager）申请资源，启动Executor，并向Executor发送应用程序代码和文件，然后在Executor上执行任务，运行结束后，执行结果会返回给任务控制节点，或者写到HDFS或者其他数据库中。</p>
<p><img src="/2020/01/14/Spark/image-20220110153314705.png" alt="image-20220110153314705"></p>
<h5 id="1-1-2-运行流程"><a href="#1-1-2-运行流程" class="headerlink" title="1.1.2 运行流程"></a>1.1.2 运行流程</h5><p>Spark的基本运行流程如下：<br> （1）当一个Spark应用被提交时，首先需要为这个应用构建起基本的运行环境，即由任务控制节点（Driver）创建一个SparkContext，由SparkContext负责和资源管理器（Cluster Manager）的通信以及进行资源的申请、任务的分配和监控等。SparkContext会向资源管理器注册并申请运行Executor的资源；<br> （2）资源管理器为Executor分配资源，并启动Executor进程，Executor运行情况将随着“心跳”发送到资源管理器上；<br> （3）SparkContext根据RDD的依赖关系构建DAG图，DAG图提交给DAG调度器（DAGScheduler）进行解析，将DAG图分解成多个“阶段”（每个阶段都是一个任务集），并且计算出各个阶段之间的依赖关系，然后把一个个“任务集”提交给底层的任务调度器（TaskScheduler）进行处理；Executor向SparkContext申请任务，任务调度器将任务分发给Executor运行，同时，SparkContext将应用程序代码发放给Executor；<br> （4）任务在Executor上运行，把执行结果反馈给任务调度器，然后反馈给DAG调度器，运行完毕后写入数据并释放所有资源。</p>
<p><img src="/2020/01/14/Spark/image-20220110154056575.png" alt="image-20220110154056575"></p>
<p>总体而言，Spark运行架构具有以下特点：<br> （1）每个应用都有自己专属的Executor进程，并且该进程在应用运行期间一直驻留。Executor进程以多线程的方式运行任务，减少了多进程任务频繁的启动开销，使得任务执行变得非常高效和可靠；<br> （2）Spark运行过程与资源管理器无关，只要能够获取Executor进程并保持通信即可；<br> （3）Executor上有一个BlockManager存储模块，类似于键值存储系统（把内存和磁盘共同作为存储设备），在处理迭代计算任务时，不需要把中间结果写入到HDFS等文件系统，而是直接放在这个存储系统上，后续有需要时就可以直接读取；在交互式查询场景下，也可以把表提前缓存到这个存储系统上，提高读写IO性能；<br> （4）任务采用了数据本地性和推测执行等优化机制。数据本地性是尽量将计算移到数据所在的节点上进行，即“计算向数据靠拢”，因为移动计算比移动数据所占的网络资源要少得多。而且，Spark采用了延时调度机制，可以在更大的程度上实现执行过程优化。比如，拥有数据的节点当前正被其他的任务占用，那么，在这种情况下是否需要将数据移动到其他的空闲节点呢？答案是不一定。因为，如果经过预测发现当前节点结束当前任务的时间要比移动数据的时间还要少，那么，调度就会等待，直到当前节点可用。</p>
<h4 id="1-2-Spark-特点"><a href="#1-2-Spark-特点" class="headerlink" title="1.2 Spark 特点"></a>1.2 Spark 特点</h4><h5 id="1-2-1-Scalable"><a href="#1-2-1-Scalable" class="headerlink" title="1.2.1 Scalable"></a>1.2.1 Scalable</h5><p><img src="/2020/01/14/Spark/捕获.JPG" alt="捕获"></p>
<h5 id="1-2-2-Fast"><a href="#1-2-2-Fast" class="headerlink" title="1.2.2 Fast"></a>1.2.2 Fast</h5><p><img src="/2020/01/14/Spark/1578977218206.png" alt="1578977218206"></p>
<p>Spark除了比MapReduce更快以外，还有一个优势：MapReduce is very limited in what it can do. You have to think about things in terms of mappers and reducers, whereas Spark provides a framework for removing that level of though from you, you can just think more about your end results and program toward that and think less about how to actual distribute it across the cluster.</p>
<a id="more"></a>
<h5 id="1-2-3-Hot"><a href="#1-2-3-Hot" class="headerlink" title="1.2.3 Hot"></a>1.2.3 Hot</h5><p><img src="/2020/01/14/Spark/1578977501017.png" alt="1578977501017"></p>
<h5 id="1-2-4-Not-that-hard-可使用的语言，RDD"><a href="#1-2-4-Not-that-hard-可使用的语言，RDD" class="headerlink" title="1.2.4 Not that hard (可使用的语言，RDD)"></a>1.2.4 Not that hard (可使用的语言，RDD)</h5><p><img src="/2020/01/14/Spark/1578977890605.png" alt="1578977890605"></p>
<p>A few lines of code can actually kick off some very complex analysis on a cluster.</p>
<p>Spark 2.0 which came out in 2006, they’ve built on top of RDDs to produce something called a data set. That’s a little bit more of a SQL focused take on an RDD, but at the end of the day, it’s still built around the RDD.</p>
<h4 id="1-3-Components-of-Spark"><a href="#1-3-Components-of-Spark" class="headerlink" title="1.3 Components of Spark"></a>1.3 Components of Spark</h4><p><img src="/2020/01/14/Spark/1578978133377.png" alt="1578978133377"></p>
<p>Spark has a lot of depth to it, so while you could just program at the RDD level within <strong>Spark Core</strong>, there are also libraries built on top of Spark that are part of Spark itself.</p>
<p><strong>Spark Streaming</strong>: Instead of doing batch processing of data, you can actually input data in real time. Data can be ingested as it’s being produced, and then Spark can analyze it across some window of time, and you can output the results of that analysis to a database or some NoSQL data store, all within a few lines of code.</p>
<p><strong>Spark SQL</strong>: Very hot area right now. It’s basically a SQL interface to Spark. You can write SQL queries against your data using Spark SQL. It allows us to do more optimizations beyond the directed acyclic graph, because it can do SQL optimizations on the queries that you’re actually running.</p>
<p><strong>MLLib</strong>: An entire library of machine learning and data mining tools that you can run on a data set that’s in Spark.</p>
<p><strong>GraphX</strong>: That’s the graph in terms of graph theory. Imagine for example, you have a social network graph, and you want to analyze the properties of that graph, and see who’s connected to who and what way, and what are the shortest path and things like that, GraphX provides a very extensible way of doing that.</p>
<p>SO, very rich ecosystem surrounding Spark that lets you do a wide variety of tasks on big data across the cluster.</p>
<h4 id="这门课将使用的语言及Scala"><a href="#这门课将使用的语言及Scala" class="headerlink" title="这门课将使用的语言及Scala"></a>这门课将使用的语言及Scala</h4><p><img src="/2020/01/14/Spark/1578979417251.png" alt="1578979417251"></p>
<p>If you do want to end up using Spark in production in the real world, Python is OK to start with, but you probably want to move to Scala. </p>
<p><img src="/2020/01/14/Spark/1578979634184.png" alt="1578979634184"></p>
<p>It’s not very hard to move from Python to Scala. </p>
<h3 id="2-RDD-The-Resilient-Distributed-Dataset"><a href="#2-RDD-The-Resilient-Distributed-Dataset" class="headerlink" title="2. RDD (The Resilient Distributed Dataset)"></a>2. RDD (The Resilient Distributed Dataset)</h3><p><img src="/2020/01/14/Spark/1578989468387.png" alt="1578989468387"></p>
<h4 id="2-1-What-is-RDD"><a href="#2-1-What-is-RDD" class="headerlink" title="2.1 What is RDD?"></a>2.1 What is RDD?</h4><p><img src="/2020/01/14/Spark/1578989673088.png" alt="1578989673088"></p>
<p>It’s an abstraction across all the nastiness that happens under the hood to actually make sure your job is evenly distributed across your cluster that it can handle failures in a resilient manner, and at the end of the day, it just looks like a dataset to you.</p>
<p>From a programming standpoint, an RDD is just a dataset to you. But under the hood, it’s resilient and distributed and you don’t have to think about that very much.</p>
<p>一个RDD就是一个分布式对象集合，本质上是一个只读的分区记录集合，每个RDD可以分成多个分区，每个分区就是一个数据集片段，并且一个RDD的不同分区可以被保存到集群中不同的节点上，从而可以在集群中的不同节点上进行并行计算。</p>
<p>RDD是只读的记录分区的集合，不能直接修改，只能基于稳定的物理存储中的数据集来创建RDD，或者通过在其他RDD上执行确定的转换操作（如map、join和groupBy）而创建得到新的RDD。</p>
<p>RDD提供了一组丰富的操作以支持常见的数据运算，分为<strong>“行动”（Action）</strong>和<strong>“转换”（Transformation）</strong>两种类型，前者用于执行计算并指定输出的形式，后者指定RDD之间的相互依赖关系。两类操作的主要区别是，转换操作（比如map、filter、groupBy、join等）接受RDD并返回RDD，而行动操作（比如count、collect等）接受RDD但是返回非RDD（即输出一个值或结果）。</p>
<p>RDD典型的执行过程如下：</p>
<ol>
<li>RDD读入外部数据源（或者内存中的集合）进行创建；</li>
<li>RDD经过一系列的“转换”操作，每一次都会产生不同的RDD，供给下一个“转换”使用；</li>
<li>最后一个RDD经“行动”操作进行处理，并输出到外部数据源（或者变成Scala集合或标量）。</li>
</ol>
<p>需要说明的是，RDD采用了<strong>惰性调用</strong>（更多关于惰性调用的内容见后文），即在RDD的执行过程中（如图9-8所示），真正的计算发生在RDD的“行动”操作，对于“行动”之前的所有“转换”操作，Spark只是记录下“转换”操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。</p>
<p><img src="/2020/01/14/Spark/image-20220110150112274.png" alt="image-20220110150112274"></p>
<h4 id="2-2-How-do-you-make-RDD"><a href="#2-2-How-do-you-make-RDD" class="headerlink" title="2.2 How do you make RDD"></a>2.2 How do you make RDD</h4><p><img src="/2020/01/14/Spark/1578989938843.png" alt="1578989938843"></p>
<p>The SparkContext is sort of the environment that your driver program runs within Spark, and it is what creates RDDs.</p>
<h4 id="2-3-Create-RDD"><a href="#2-3-Create-RDD" class="headerlink" title="2.3 Create RDD"></a>2.3 Create RDD</h4><p><img src="/2020/01/14/Spark/1578990141827.png" alt="1578990141827"></p>
<p><img src="/2020/01/14/Spark/1579012530332.png" alt="1579012530332"></p>
<p><img src="/2020/01/14/Spark/1578990969096.png" alt="1578990969096"></p>
<p>Once you have an RDD, what do you do with it?</p>
<h4 id="2-4-Transform-RDD"><a href="#2-4-Transform-RDD" class="headerlink" title="2.4 Transform RDD"></a>2.4 Transform RDD</h4><p><img src="/2020/01/14/Spark/1579008653516.png" alt="1579008653516"></p>
<p><em>map</em>: apply some function to every input row of your RDD and create a new RDD that is transformed in some way. Map is used when you have a one to one relationship </p>
<p><em>flatmap</em>: 与map的区别在于，使用map, input于output是一对一的关系，使用flatmap, can have any relationship, where your input lines may or may not result in one or more output lines. 例如，maybe you want to split out each input line into multiple rows, or maybe you want to discard some of the input lines if they’re invalid.</p>
<p><em>filter</em>: can be used to take stuff out of an RDD so you can provide that with some function that determines whether or not a row survives.</p>
<p><em>distinct</em>: gives you back the distinct unique values in an RDD. </p>
<p><em>sample</em>: sample them randomly.</p>
<p><img src="/2020/01/14/Spark/1579008991727.png" alt="1579008991727"></p>
<p><img src="/2020/01/14/Spark/1579009321705.png" alt="1579009321705"></p>
<h4 id="2-5-RDD-actions"><a href="#2-5-RDD-actions" class="headerlink" title="2.5 RDD actions"></a>2.5 RDD actions</h4><p><img src="/2020/01/14/Spark/1579009474269.png" alt="1579009474269"></p>
<h4 id="2-6-Lazy-evaluation-惰性调用"><a href="#2-6-Lazy-evaluation-惰性调用" class="headerlink" title="2.6 Lazy evaluation 惰性调用"></a>2.6 Lazy evaluation 惰性调用</h4><p><img src="/2020/01/14/Spark/1579009528882.png" alt="1579009528882"></p>
<p>So basically, as you go through this script and transform your RDD’s, until you hit an action, all that’s doing is building up this graph, this chain of dependencies within your driver script, and only when that action is called does it actually figure out the quickest path through those dependencies. And it’s at that point that it actually kicks off the job on your cluster.</p>
<p>RDD采用了惰性调用，即在RDD的执行过程中，真正的计算发生在RDD的“行动”操作，对于“行动”之前的所有“转换”操作，Spark只是记录下“转换”操作应用的一些基础数据集以及RDD生成的轨迹，即相互之间的依赖关系，而不会触发真正的计算。</p>
<p>例：一个Spark的“Hello World”程序<br> 这里以一个“Hello World”入门级Spark程序来解释RDD执行过程，这个程序的功能是读取一个HDFS文件，计算出包含字符串“Hello World”的行数。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sc= <span class="keyword">new</span> <span class="type">SparkContext</span>(“spark:<span class="comment">//localhost:7077”,”Hello World”, “YOUR_SPARK_HOME”,”YOUR_APP_JAR”)</span></span><br><span class="line"><span class="keyword">val</span> fileRDD = sc.textFile(“hdfs:<span class="comment">//192.168.0.103:9000/examplefile”)</span></span><br><span class="line"><span class="keyword">val</span> filterRDD = fileRDD.filter(_.contains(“<span class="type">Hello</span> <span class="type">World</span>”))</span><br><span class="line">filterRDD.cache()</span><br><span class="line">filterRDD.count()</span><br></pre></td></tr></table></figure>
<p>第1行代码用于创建SparkContext对象；第2行代码从HDFS文件中读取数据创建一个RDD；第3行代码对fileRDD进行转换操作得到一个新的RDD，即filterRDD；第4行代码表示对filterRDD进行持久化，把它保存在内存或磁盘中（这里采用cache接口把数据集保存在内存中），方便后续重复使用，当数据被反复访问时（比如查询一些热点数据，或者运行迭代算法），这是非常有用的，而且通过cache()可以缓存非常大的数据集，支持跨越几十甚至上百个节点；第5行代码中的count()是一个行动操作，用于计算一个RDD集合中包含的元素个数。这个程序的执行过程如下：</p>
<ul>
<li>创建这个Spark程序的执行上下文，即创建SparkContext对象；</li>
<li>从外部数据源（即HDFS文件）中读取数据创建fileRDD对象；</li>
<li>构建起fileRDD和filterRDD之间的依赖关系，形成DAG图，这时候并没有发生真正的计算，只是记录转换的轨迹；</li>
<li>执行到第5行代码时，count()是一个行动类型的操作，触发真正的计算，开始实际执行从fileRDD到filterRDD的转换操作，并把结果持久化到内存中，最后计算出filterRDD中包含的元素个数。</li>
</ul>
<h4 id="2-7-RDD-特性"><a href="#2-7-RDD-特性" class="headerlink" title="2.7 RDD 特性"></a>2.7 RDD 特性</h4><p>总体而言，Spark采用RDD以后能够实现高效计算的主要原因如下：<br> （1）高效的容错性。现有的分布式共享内存、键值存储、内存数据库等，为了实现容错，必须在集群节点之间进行数据复制或者记录日志，也就是在节点之间会发生大量的数据传输，这对于数据密集型应用而言会带来很大的开销。在RDD的设计中，数据只读，不可修改，如果需要修改数据，必须从父RDD转换到子RDD，由此在不同RDD之间建立了血缘关系。所以，RDD是一种天生具有容错机制的特殊集合，不需要通过数据冗余的方式（比如检查点）实现容错，而只需通过RDD父子依赖（血缘）关系重新计算得到丢失的分区来实现容错，无需回滚整个系统，这样就避免了数据复制的高开销，而且重算过程可以在不同节点之间并行进行，实现了高效的容错。此外，RDD提供的转换操作都是一些粗粒度的操作（比如map、filter和join），RDD依赖关系只需要记录这种粗粒度的转换操作，而不需要记录具体的数据和各种细粒度操作的日志（比如对哪个数据项进行了修改），这就大大降低了数据密集型应用中的容错开销；<br> （2）中间结果持久化到内存。数据在内存中的多个RDD操作之间进行传递，不需要“落地”到磁盘上，避免了不必要的读写磁盘开销；<br> （3）存放的数据可以是Java对象，避免了不必要的对象序列化和反序列化开销。</p>
<h4 id="2-8-RDD-之间的依赖关系"><a href="#2-8-RDD-之间的依赖关系" class="headerlink" title="2.8 RDD 之间的依赖关系"></a>2.8 RDD 之间的依赖关系</h4><blockquote>
<p>参考<br><a href="https://blog.csdn.net/weixin_43958974/article/details/122292746" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43958974/article/details/122292746</a><br><a href="http://dblab.xmu.edu.cn/blog/985-2/" target="_blank" rel="noopener">http://dblab.xmu.edu.cn/blog/985-2/</a></p>
</blockquote>
<p>在 Spark 中，RDD 分区的数据不支持修改，是只读的。如果想更新 RDD 分区中的数据，那么只能对原有 RDD 进行转化操作，也就是在原来 RDD 基础上创建一个新的RDD。</p>
<p>那么，在整个任务的运算过程中，RDD 的每次转换都会生成一个新的 RDD，因此 RDD 们之间会产生前后依赖的关系。</p>
<p>说白了，就是相当于将对原始 RDD 分区数据的整个运算进行了拆解，当运算中出现异常情况导致分区数据丢失时，Spark 可以通过依赖关系从上一个 RDD 中重新计算丢失的数据，而不是对最开始的 RDD 分区数据重新进行计算。</p>
<p>在 RDD 的依赖关系中，我们将上一个 RDD 称为父RDD，下一个 RDD 称为子RDD。RDD中的依赖关系分为窄依赖（Narrow Dependency）与宽依赖（Wide Dependency），下图展示了两种依赖之间的区别。</p>
<p><img src="/2020/01/14/Spark/image-20220111154127159.png" alt="image-20220111154127159"></p>
<p><strong>窄依赖</strong>表现为一个父RDD的分区对应于一个子RDD的分区，或多个父RDD的分区对应于一个子RDD的分区。<br><strong>宽依赖</strong>则表现为存在一个父RDD的一个分区对应一个子RDD的多个分区。</p>
<p>总体而言，如果父RDD的一个分区只被一个子RDD的一个分区所使用就是窄依赖，否则就是宽依赖。</p>
<blockquote>
<p>有个形象的比喻，如果父 RDD 中的一个分区有多个孩子（被多个分区依赖），也就是超生了，就为宽依赖；反之，如果只有一个孩子（只被一个分区依赖），那么就为窄依赖。</p>
</blockquote>
<p>窄依赖典型的操作包括map、filter、union等，宽依赖典型的操作包括groupByKey、sortByKey等。对于连接（join）操作，可以分为两种情况。<br> （1）对输入进行协同划分，属于窄依赖（上图(a)所示）。所谓协同划分（co-partitioned）是指多个父RDD的某一分区的所有“键（key）”，落在子RDD的同一个分区内，不会产生同一个父RDD的某一分区，落在子RDD的两个分区的情况。<br> （2）对输入做非协同划分，属于宽依赖，如上图(b)所示。</p>
<p> 对于窄依赖的RDD，可以以流水线的方式计算所有父分区，不会造成网络之间的数据混合。对于宽依赖的RDD，则通常伴随着<strong>Shuffle</strong>操作，即首先需要计算好所有父分区数据，然后在节点之间进行Shuffle。</p>
<blockquote>
<p>在窄依赖中子 RDD 的每个分区数据的生成操作都是可以并行执行的，而在宽依赖中需要所有父 RDD 的 Shuffle 结果完成后再执行。</p>
</blockquote>
<p>Spark的这种依赖关系设计，使其具有了天生的容错性，大大加快了Spark的执行速度。因为，RDD数据集通过“血缘关系”记住了它是如何从其它RDD中演变过来的，血缘关系记录的是粗颗粒度的转换操作行为，当这个RDD的部分分区数据丢失时，它可以通过血缘关系获取足够的信息来重新运算和恢复丢失的数据分区，由此带来了性能的提升。相对而言，在两种依赖关系中，窄依赖的失败恢复更为高效，它只需要根据父RDD分区重新计算丢失的分区即可（不需要重新计算所有分区），而且可以并行地在不同节点进行重新计算。而对于宽依赖而言，单个节点失效通常意味着重新计算过程会涉及多个父RDD分区，开销较大。此外，Spark还提供了数据检查点和记录日志，用于持久化中间RDD，从而使得在进行失败恢复时不需要追溯到最开始的阶段。在进行故障恢复时，Spark会对数据检查点开销和重新计算RDD分区的开销进行比较，从而自动选择最优的恢复策略。</p>
<h4 id="2-9-阶段的划分"><a href="#2-9-阶段的划分" class="headerlink" title="2.9 阶段的划分"></a>2.9 阶段的划分</h4><p>在 Spark 执行作业时，会按照 Stage 划分不同的 RDD，生成一个完整的最优执行计划，使每个 Stage 内的 RDD 都尽可能在各个节点上并行地被执行。</p>
<p>Spark通过分析各个RDD的依赖关系生成了DAG，再通过分析各个RDD中的分区之间的依赖关系来决定如何划分阶段。具体划分方法是：在DAG中进行反向解析，遇到宽依赖就断开，遇到窄依赖就把当前的RDD加入到当前的阶段中；将窄依赖尽量划分在同一个阶段中，可以实现流水线计算。</p>
<p>因此，划分宽窄依赖也是 Spark 优化执行计划的一个重要步骤，宽依赖是划分执行计划中 Stage 的依据，对于宽依赖必须要等到上一个 Stage 计算完成之后才能计算下一个阶段。</p>
<p>例：如图9-11所示，假设从HDFS中读入数据生成3个不同的RDD（即A、C和E），通过一系列转换操作后再将计算结果保存回HDFS。对DAG进行解析时，在依赖图中进行反向解析，由于从RDD A到RDD B的转换以及从RDD B和F到RDD  G的转换，都属于宽依赖，因此，在宽依赖处断开后可以得到三个阶段，即阶段1、阶段2和阶段3。可以看出，在阶段2中，从map到union都是窄依赖，这两步操作可以形成一个流水线操作，比如，分区7通过map操作生成的分区9，可以不用等待分区8到分区9这个转换操作的计算结束，而是继续进行union操作，转换得到分区13，这样流水线执行大大提高了计算的效率。</p>
<p><img src="/2020/01/14/Spark/image-20220111155020607.png" alt="image-20220111155020607"></p>
<p>由上述论述可知，把一个DAG图划分成多个“阶段”以后，每个阶段都代表了一组关联的、相互之间没有Shuffle依赖关系的任务组成的任务集合。每个任务集合会被提交给任务调度器（TaskScheduler）进行处理，由任务调度器将任务分发给Executor运行。</p>
<h4 id="2-10-RDD-运行过程"><a href="#2-10-RDD-运行过程" class="headerlink" title="2.10 RDD 运行过程"></a>2.10 RDD 运行过程</h4><p>总结一下RDD在Spark架构中的运行过程（如下图所示）：<br> （1）创建RDD对象；<br> （2）SparkContext负责计算RDD之间的依赖关系，构建DAG；<br> （3）DAGScheduler负责把DAG图分解成多个阶段，每个阶段中包含了多个任务，每个任务会被任务调度器分发给各个工作节点（Worker Node）上的Executor去执行。</p>
<p><img src="/2020/01/14/Spark/image-20220111155253448.png" alt="image-20220111155253448"></p>
<h4 id="2-9-Using-RDD’s-in-Spark"><a href="#2-9-Using-RDD’s-in-Spark" class="headerlink" title="2.9 Using RDD’s in Spark"></a>2.9 Using RDD’s in Spark</h4><p>Find the movie with the lowest average rating - with RDD’s.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6082670#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6082670#overview</a></p>
<p><img src="/2020/01/14/Spark/1579014872589.png" alt="1579014872589"></p>
<h3 id="3-Spark-SQL-DataFrames-and-DataSets"><a href="#3-Spark-SQL-DataFrames-and-DataSets" class="headerlink" title="3. Spark SQL (DataFrames and DataSets)"></a>3. Spark SQL (DataFrames and DataSets)</h3><p><img src="/2020/01/14/Spark/1579012722667.png" alt="1579012722667"></p>
<p>Now, let’s talk about Spark SQL and the Spark 2.0 way of doing things using dataframes and datasets.</p>
<p><img src="/2020/01/14/Spark/1579012953410.png" alt="1579012953410"></p>
<p><img src="/2020/01/14/Spark/1579013215223.png" alt="1579013215223"></p>
<p><img src="/2020/01/14/Spark/1579013233354.png" alt="1579013233354"></p>
<p><img src="/2020/01/14/Spark/1579013961536.png" alt="1579013961536"></p>
<p>DataFrame is really a dataset of row objects, and DataSet is a more general term that can contain any sort of typed information, not necessarily a row like you have in a DataFrame.</p>
<p><img src="/2020/01/14/Spark/1579014168231.png" alt="1579014168231"></p>
<p><img src="/2020/01/14/Spark/1579014221441.png" alt="1579014221441"></p>
<p>Spark SQL is very extensible, you can create user defined functions that plug into a SQL and create your own functions you can use within your SQL queries.</p>
<p>SO, this is the power of DataFrames and DataSets in Spark 2.0 and Spark SQL. The other thing that’s worth noting is that this is sort of the unified API between different subsystems of Spark going forward. You’ll see that in Spark 2 the MLLib machine learning library of the Spark streaming library, all now have DataSet based APIs that you can use, so DataSets are kind of the common denominator between these different systems that allow you to pass data between them. </p>
<p>So, not only do you get performance benefits by using DataSets in Spark 2, you also get easier ways of actually using all these capabilities built on top of Spark we can mix and match them in interesting ways.</p>
<h4 id="Using-DataSets-in-Spark-2"><a href="#Using-DataSets-in-Spark-2" class="headerlink" title="Using DataSets in Spark 2"></a>Using DataSets in Spark 2</h4><p>Find the movie with lowest average rating - with DataFrames.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963108#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963108#overview</a></p>
<p><img src="/2020/01/14/Spark/1579014920753.png" alt="1579014920753"></p>
<h3 id="4-Using-MLLib-in-Spark"><a href="#4-Using-MLLib-in-Spark" class="headerlink" title="4. Using MLLib in Spark"></a>4. Using MLLib in Spark</h3><p>movie recommendations (通过predict rating)</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963112#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963112#overview</a></p>
<p><img src="/2020/01/14/Spark/1579059887637.png" alt="1579059887637"></p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><p><img src="/2020/01/14/Spark/1579060756315.png" alt="1579060756315"></p>
<p><img src="/2020/01/14/Spark/1579062594969.png" alt="1579062594969"></p>
<p><img src="/2020/01/14/Spark/1579062687242.png" alt="1579062687242"></p>
<p>check your result</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6115596#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/6115596#overview</a></p>
<p>The DataFrame approach is a lot easier to use, and when you’re running it at a large scale it’s going to be faster as well.</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>存储过程</title>
    <url>/2020/01/13/%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>存储过程（Stored Procedure）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。</p>
<p>存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。</p>
<p>存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。</p>
<h4 id="什么是存储过程？"><a href="#什么是存储过程？" class="headerlink" title="什么是存储过程？"></a>什么是存储过程？</h4><p>存储过程就是作为可执行对象存放在数据库中的一个或多个SQL命令。<br>通俗来讲：存储过程其实就是能完成一定操作的一组SQL语句。</p>
<h4 id="为什么要使用存储过程？"><a href="#为什么要使用存储过程？" class="headerlink" title="为什么要使用存储过程？"></a>为什么要使用存储过程？</h4><p>1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。<br>2.当对数据库进行复杂操作时，可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。<br>3.存储过程可以重复使用，可减少数据库开发人员的工作量。<br>4.安全性高，可设定只有某些用户才具有对指定存储过程的使用权</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>存储过程可封装，并隐藏复杂的商业逻辑。</li>
<li>存储过程可以回传值，并可以接受参数。</li>
<li>存储过程无法使用 SELECT 指令来运行，因为它是子程序，与查看表，数据表或用户定义函数不同。</li>
<li>存储过程可以用在数据检验，强制实行商业逻辑等。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>存储过程，往往定制化于特定的数据库上，因为支持的编程语言不同，当切换到其他厂商的数据库系统时，需要重写原有的存储过程。</li>
<li>存储过程的性能调校与撰写，受限于各种数据库系统。</li>
</ul>
<p>存储过程：存储过程就是编译好了的一些sql语句。</p>
<ol>
<li><p>存储过程因为SQL语句已经预编绎过了，因此运行的速度比较快。</p>
</li>
<li><p>可保证数据的安全性和完整性。通过存储过程可以使没有权限的用户在控制之下间接地存取数据库，从而保证数据的安全。通过存储过程可以使相关的动作在一起发生，从而可以维护数据库的完整性。</p>
</li>
<li>可以降低网络的通信量。存储过程主要是在服务器上运行，减少对客户机的压力。</li>
<li>存储过程可以接受参数、输出参数、返回单个或多个结果集以及返回值。可以向程序返回错误原因</li>
<li>存储过程可以包含程序流、逻辑以及对数据库的查询。同时可以实体封装和隐藏数据逻辑。</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>事务与锁</title>
    <url>/2020/01/13/%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><!-- toc -->
<h4 id="事务-Transaction"><a href="#事务-Transaction" class="headerlink" title="事务 Transaction"></a>事务 Transaction</h4><p>事务：是一系列的数据库操作 (a group of SQL statement)，是数据库应用的基本逻辑单位。</p>
<p>事务性质：(<span style="color:red">ACID</span>)</p>
<ul>
<li>原子性（atomicity）。即不可分割性，事务要么全部被执行，要么就全部不被执行。</li>
<li>一致性或可串性（consistency）。事务的执行使得数据库从一种正确状态转换成另一种正确状态。</li>
<li>隔离性（isolation）。在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务。</li>
<li>持久性（durability）。事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。</li>
</ul>
<p><img src="/2020/01/13/事务与锁/1578903852566.png" alt="1578903852566"></p>
<p><img src="/2020/01/13/事务与锁/1578903920125.png" alt="1578903920125"></p>
<p><img src="/2020/01/13/事务与锁/1578904033183.png" alt="1578904033183"></p>
<p><img src="/2020/01/13/事务与锁/1578904133622.png" alt="1578904133622"></p>
<p><img src="/2020/01/13/事务与锁/1578904156358.png" alt="1578904156358"></p>
<a id="more"></a>
<p><img src="/2020/01/13/事务与锁/1578904553025.png" alt="1578904553025"></p>
<p><img src="/2020/01/13/事务与锁/1578904582538.png" alt="1578904582538"></p>
<p><img src="/2020/01/13/事务与锁/1578904641058.png" alt="1578904641058"></p>
<p><img src="/2020/01/13/事务与锁/1578904660894.png" alt="1578904660894"></p>
<p><img src="/2020/01/13/事务与锁/1578904679577.png" alt="1578904679577"></p>
<p><code>可串行化</code>：多个事务的并发执行是正确的，当且仅当其结果与某一次序串行地执行它们时的结果相同，称这种调度策略是可串行化调度。</p>
<p><img src="/2020/01/13/事务与锁/1578904744883.png" alt="1578904744883"></p>
<h4 id="并发控制-Concurrency-Control"><a href="#并发控制-Concurrency-Control" class="headerlink" title="并发控制 Concurrency Control"></a>并发控制 Concurrency Control</h4><p><strong>并发控制：</strong> 所谓并发控制，是指多用户共享的系统中，许多用户可能同时对同一数据进行操作。</p>
<p><img src="/2020/01/13/事务与锁/1578904973251.png" alt="1578904973251"></p>
<p><img src="/2020/01/13/事务与锁/1578905068177.png" alt="1578905068177"></p>
<p><img src="/2020/01/13/事务与锁/1578905172492.png" alt="1578905172492"></p>
<p><img src="/2020/01/13/事务与锁/1578905192362.png" alt="1578905192362"></p>
<h5 id="共享锁与排他锁（或叫互斥锁）"><a href="#共享锁与排他锁（或叫互斥锁）" class="headerlink" title="共享锁与排他锁（或叫互斥锁）"></a>共享锁与排他锁（或叫互斥锁）</h5><p><img src="/2020/01/13/事务与锁/1578905290193.png" alt="1578905290193"></p>
<p><img src="/2020/01/13/事务与锁/1578905458095.png" alt="1578905458095"></p>
<h5 id="两段锁协议（Two-Phase-Locking-——-2PL）"><a href="#两段锁协议（Two-Phase-Locking-——-2PL）" class="headerlink" title="两段锁协议（Two-Phase Locking —— 2PL）"></a>两段锁协议（Two-Phase Locking —— 2PL）</h5><p><a href="https://www.jianshu.com/p/5c78f5c4d57b" target="_blank" rel="noopener">https://www.jianshu.com/p/5c78f5c4d57b</a></p>
<p>两段锁协议规定所有的事务应遵守的规则：</p>
<p>① 在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁。</p>
<p>② 在释放一个封锁之后，事务不再申请和获得其它任何封锁。</p>
<p>即事务的执行分为两个阶段：</p>
<p>第一阶段是获得封锁的阶段，称为扩展阶段。</p>
<p>第二阶段是释放封锁的阶段，称为收缩阶段。</p>
<p><em>若所有事务均遵守两段锁协议，则这些事务的所有交叉调度都是可串行化的。</em></p>
<p><img src="/2020/01/13/事务与锁/1578923170158.png" alt="1578923170158"></p>
<blockquote>
<p>简单的理解两段锁，就是分为两个阶段：<br>第一阶段 只能去申请锁<br>第二阶段 只能去释放锁</p>
</blockquote>
<p><a href="https://blog.csdn.net/weixin_38118016/article/details/90271468" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/90271468</a></p>
<p>举个例子，假设有一个表 t，主键是 id，其中一个字段是 k，在下面的操作中，事务 B 的 update 语句执行时，会是什么现象呢 ？</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203512941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>这个问题的结论取决于事务 A 执行完前两条语句后，持有哪些锁，以及在什么时候释放。</p>
<p>实际上，事务 A 持有两个记录的行锁，都是在 commit 的时候才释放的，所以事务 B 的 update 就会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能被继续执行。也就是说，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，需要等事务结束时才释放，这就是两阶段锁协议，分为加锁阶段和解锁阶段，所有的 lock 操作都在 unlock 操作之后。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客 userA 要在影院 cinema 购买电影票，需要涉及以下操作：</p>
<ol>
<li><p>扣除顾客 userA 账户余额</p>
</li>
<li><p>增加影院 cinema 账户余额</p>
</li>
<li><p>记录一条交易日志</p>
</li>
</ol>
<p>也就是说，完成这次交易，需要 update 两条记录， insert 一条记录。当然为了保证交易的原子性，我们需要这三个操作放在一个事务中。与此同时，还有顾客 userB 也在影院购买电影票，那么你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>首先发现冲突的部分是语句 2，就是两个事务都要给 cinema 的账户余额增加电影票价。根据两阶段协议，不论怎么安排语句，所有的操作需要的行锁都是在事务提交的时候才释放的，要想使行锁在事务中不会停留太长时间，最大程度的减少事务之间的锁等待，应该把语句 2 放在最后面。如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203204823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>死锁：事务循环等待数据锁，则会死锁。<br>死锁处理：预防死锁协议，死锁恢复机制。</p>
<p><img src="/2020/01/13/事务与锁/1578905609640.png" alt="1578905609640"></p>
<p><a href="https://blog.csdn.net/weixin_38118016/article/details/90271468" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38118016/article/details/90271468</a></p>
<p>如下图所示，事务 A 在等待事务 B 释放 id = 2 的行锁，而事务 B 在等待 事务 A 释放 id = 1 的行锁，事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p><img src="https://img-blog.csdnimg.cn/20190516203204496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODExODAxNg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在并发系统中，<strong>不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程进入无限等待的状态</strong>，成为死锁。</p>
<p>当进入死锁状态时，有下列 2 种策略：</p>
<ol>
<li><p>设置超时时间，第一个被锁住的事务 A 等待超过多少秒会超时退出（例如50s），其他事务得以执行。然而对于在线服务来说，这个等待时间往往是无法接受的。如果设置太短 (如1s)，可能有的事务只是简单的锁等待，就被退出了，会出现很多误伤。</p>
</li>
<li><p>发起死锁检测，发现死锁之后主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。比如回滚事务 A，让事务 B 继续执行。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>索引Index</title>
    <url>/2020/01/13/%E7%B4%A2%E5%BC%95Index/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/13/索引Index/1578902807233.png" alt="1578902807233"></p>
<a id="more"></a>
<p>MySQL官方文档：</p>
<blockquote>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/</a></p>
</blockquote>
<p>MySQL Tutorial:</p>
<blockquote>
<p><a href="https://www.tutorialspoint.com/mysql/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/mysql/index.htm</a></p>
</blockquote>
<h2 id="快速导航"><a href="#快速导航" class="headerlink" title="快速导航"></a>快速导航</h2><p><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener">CREATE TABLE 官方手册</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html" target="_blank" rel="noopener">CREATE INDEX 官方手册</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener">ALTER TABLE 官方手册</a><br><a href="#jump6.2">使用explain查看是否使用索引</a><br><a href="#jump_index_zuzhibiao">索引组织表</a><br><a href="#jump_index_several">主键索引(聚簇索引，聚集索引)、非主键索引(普通索引，二级索引，非聚簇索引)</a><br><a href="#jump_covering_index">覆盖索引</a><br><a href="#jump_leftmost_prefix">最左前缀</a><br><a href="#jump_pushed_down">索引下推</a></p>
<h2 id="第一部分：MySQL中索引的操作"><a href="#第一部分：MySQL中索引的操作" class="headerlink" title="第一部分：MySQL中索引的操作"></a>第一部分：MySQL中索引的操作</h2><blockquote>
<p>参考：<br><a href="https://www.tutorialspoint.com/mysql/mysql-indexes" target="_blank" rel="noopener">https://www.tutorialspoint.com/mysql/mysql-indexes</a><br><a href="https://www.runoob.com/mysql/mysql-index.html" target="_blank" rel="noopener">https://www.runoob.com/mysql/mysql-index.html</a><br><a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html#create-table-indexes-keys" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/create-table.html#create-table-indexes-keys</a></p>
</blockquote>
<p>索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索引包含多个列。</p>
<p>实际上，索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录。</p>
<p>用户看不到索引，它们仅用于加速查询，并且数据库搜索引擎将使用它们非常快速地定位记录。</p>
<p>对于具有索引的表，INSERT和UPDATE语句会花费更多的时间，而SELECT语句会变得更快。原因是在执行插入或更新时，数据库还需要插入或更新索引值。</p>
<p><img src="/2020/01/13/索引Index/1578902869016.png" alt="1578902869016"></p>
<h3 id="1-MySQL中的索引有哪些"><a href="#1-MySQL中的索引有哪些" class="headerlink" title="1. MySQL中的索引有哪些"></a>1. MySQL中的索引有哪些</h3><ul>
<li><code>PRIMAY KEY</code><br>A unique index where all key columns must be defined as <code>NOT NULL</code>. If they are not explicitly declared as <code>NOT NULL</code>, MySQL declares them so implicitly (and silently). 一个表只能有一个 <code>PRIMARY KEY</code>.  <code>PRIMARY KEY</code> 的名字始终是 <code>PRIMARY</code>, which thus cannot be used as the name for any other kind of index.<br>If you do not have a <code>PRIMARY KEY</code> and an application asks for the <code>PRIMARY KEY</code> in your tables, MySQL returns the first <code>UNIQUE</code> index that has no <code>NULL</code> columns as the <code>PRIMARY KEY</code>.<br>In <code>InnoDB</code> tables, keep the <code>PRIMARY KEY</code> short to minimize storage overhead for secondary indexes. Each secondary index entry contains a copy of the primary key columns for the corresponding row. (See <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">Section 14.6.2.1, “Clustered and Secondary Indexes”</a>.)<br>In the created table, a <code>PRIMARY KEY</code> is placed first, followed by all <code>UNIQUE</code> indexes, and then the nonunique indexes. This helps the MySQL optimizer to prioritize which index to use and also more quickly to detect duplicated <code>UNIQUE</code> keys.<br>A <code>PRIMARY KEY</code> can be a multiple-column index. <code>PRIMARY KEY(key_part, ...)</code> clause.<br>In MySQL, the name of a <code>PRIMARY KEY</code> is <code>PRIMARY</code>. For other indexes, if you do not assign a name, the index is assigned the same name as the first indexed column, with an optional suffix (<code>_2</code>, <code>_3</code>, <code>...</code>) to make it unique. You can see index names for a table using <code>SHOW INDEX FROM tbl_name</code>. See <a href="https://dev.mysql.com/doc/refman/5.6/en/show-index.html" target="_blank" rel="noopener">Section 13.7.5.23, “SHOW INDEX Statement”</a>.</li>
</ul>
<ul>
<li><code>KEY | INDEX</code><br><code>KEY</code> is normally a synonym for <code>INDEX</code>. The key attribute <code>PRIMARY KEY</code> can also be specified as just <code>KEY</code> when given in a column definition. This was implemented for compatibility with other database systems.<br>也就是说key和index通常是一样的，这样是为了和其他数据库的兼容性而实现的。<br>但是并不是所有的key和index都是一样的，如果创建的是约束，比如PRIMARY KEY，FOREIGN KEY这种表示约束的，只能用key。(<a href="https://blog.csdn.net/kusedexingfu/article/details/78347354" target="_blank" rel="noopener">https://blog.csdn.net/kusedexingfu/article/details/78347354</a>)</li>
</ul>
<ul>
<li><code>UNIQUE</code><br>A <code>UNIQUE</code> index creates a constraint such that all values in the index must be distinct. An error occurs if you try to add a new row with a key value that matches an existing row. For all engines, a <code>UNIQUE</code> index permits multiple <code>NULL</code> values for columns that can contain <code>NULL</code>. If you specify a prefix value for a column in a <code>UNIQUE</code> index, the column values must be unique within the prefix length.<br>If a table has a <code>PRIMARY KEY</code> or <code>UNIQUE NOT NULL</code> index that consists of a single column that has an integer type, you can use <code>_rowid</code> to refer to the indexed column in <a href="https://dev.mysql.com/doc/refman/5.6/en/select.html" target="_blank" rel="noopener"><code>SELECT</code></a> statements, as described in <a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html#create-index-unique" target="_blank" rel="noopener">Unique Indexes</a>.</li>
</ul>
<ul>
<li><code>FULLTEXT</code><br>A <code>FULLTEXT</code> index is a special type of index used for full-text searches. Only the <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-storage-engine.html" target="_blank" rel="noopener"><code>InnoDB</code></a> and <a href="https://dev.mysql.com/doc/refman/5.6/en/myisam-storage-engine.html" target="_blank" rel="noopener"><code>MyISAM</code></a> storage engines support <code>FULLTEXT</code> indexes. They can be created only from <a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>CHAR</code></a>, <a href="https://dev.mysql.com/doc/refman/5.6/en/char.html" target="_blank" rel="noopener"><code>VARCHAR</code></a>, and <a href="https://dev.mysql.com/doc/refman/5.6/en/blob.html" target="_blank" rel="noopener"><code>TEXT</code></a> columns.  See <a href="https://dev.mysql.com/doc/refman/5.6/en/fulltext-search.html" target="_blank" rel="noopener">Section 12.10, “Full-Text Search Functions”</a>, for details of operation.</li>
</ul>
<p>还有 SPATIAL, FOREIGN KEY 等的介绍见 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html#create-table-indexes-keys" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/create-table.html#create-table-indexes-keys</a>.</p>
<h3 id="2-CREATE-UNIQUE-INDEX-创建普通索引-简单索引-与唯一索引"><a href="#2-CREATE-UNIQUE-INDEX-创建普通索引-简单索引-与唯一索引" class="headerlink" title="2. CREATE [UNIQUE] INDEX 创建普通索引(简单索引)与唯一索引"></a>2. CREATE [UNIQUE] INDEX 创建普通索引(简单索引)与唯一索引</h3><p>唯一索引意味着索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>普通索引没有任何限制，它允许表中有重复值。</p>
<p>下面是在表上创建索引的语法（可以使用一个或多个列来创建索引）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> index_name <span class="keyword">ON</span> table_name (column1, column2,...);</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">ONLINE</span> | <span class="keyword">OFFLINE</span>] [<span class="keyword">UNIQUE</span> | FULLTEXT | SPATIAL] <span class="keyword">INDEX</span> index_name</span><br><span class="line">    [index_type]</span><br><span class="line">    <span class="keyword">ON</span> tbl_name (key_part,...)</span><br><span class="line">    [index_option]</span><br><span class="line">    [algorithm_option | lock_option] ...</span><br><span class="line"></span><br><span class="line">key_part:</span><br><span class="line">    col_name [(<span class="keyword">length</span>)] [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line"></span><br><span class="line">index_option: &#123;</span><br><span class="line">    KEY_BLOCK_SIZE [=] <span class="keyword">value</span></span><br><span class="line">  | index_type</span><br><span class="line">  | <span class="keyword">WITH</span> PARSER parser_name</span><br><span class="line">  | <span class="keyword">COMMENT</span> <span class="string">'string'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index_type:</span><br><span class="line">    <span class="keyword">USING</span> &#123;BTREE | <span class="keyword">HASH</span>&#125;</span><br><span class="line"></span><br><span class="line">algorithm_option:</span><br><span class="line">    ALGORITHM [=] &#123;<span class="keyword">DEFAULT</span> | INPLACE | COPY&#125;</span><br><span class="line"></span><br><span class="line">lock_option:</span><br><span class="line">    <span class="keyword">LOCK</span> [=] &#123;<span class="keyword">DEFAULT</span> | <span class="keyword">NONE</span> | <span class="keyword">SHARED</span> | EXCLUSIVE&#125;</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create an index on tutorials_tbl using tutorial_author.</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> AUTHOR_INDEX <span class="keyword">ON</span> tutorials_tbl (tutorial_author);</span><br></pre></td></tr></table></figure>
<p>对于普通索引，只需从上述statement中省略UNIQUE关键字即可。</p>
<p>如果希望按降序索引列中的值，可以在列名后添加保留字DESC。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE UNIQUE INDEX AUTHOR_INDEX ON tutorials_tbl (tutorial_author DESC)</span><br></pre></td></tr></table></figure>
<p>注：<strong>CREATE INDEX 不能用来创建 PRIMARY KEY.</strong><br><a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a> is mapped to an <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> statement to create indexes. See <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener">Section 13.1.7, “ALTER TABLE Statement”</a>.<br> <a href="https://dev.mysql.com/doc/refman/5.6/en/create-index.html" target="_blank" rel="noopener"><code>CREATE INDEX</code></a> cannot be used to create a <code>PRIMARY KEY</code>; use <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener"><code>ALTER TABLE</code></a> instead. </p>
<h3 id="3-使用-ALTER-命令添加和删除索引"><a href="#3-使用-ALTER-命令添加和删除索引" class="headerlink" title="3. 使用 ALTER 命令添加和删除索引"></a>3. 使用 ALTER 命令添加和删除索引</h3><ul>
<li><strong><code>ALTER TABLE tbl_name ADD PRIMARY KEY (column_list)</code></strong> - 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。</li>
<li><strong><code>ALTER TABLE tbl_name ADD UNIQUE [INDEX | KEY] [index_name] (column_list)</code></strong> - 该语句创建一个索引，其值必须是唯一的（除了NULL外，NULL可能会出现多次）。</li>
<li><strong><code>ALTER TABLE tbl_name ADD {INDEX | KEY} [index_name] (column_list)</code></strong> - 添加普通索引，索引值可出现多次。</li>
<li><strong><code>ALTER TABLE tbl_name ADD FULLTEXT [INDEX | KEY] [index_name] (column_list)</code></strong> - 创建一个特殊的FULLTEXT索引，该索引用于文本搜索。</li>
</ul>
<blockquote>
<p> 更多关于 alter table 的语法见 <a href="https://dev.mysql.com/doc/refman/5.6/en/alter-table.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/alter-table.html</a></p>
</blockquote>
<p>示例：在现有表中添加索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD INDEX (c);</span><br></pre></td></tr></table></figure>
<p>注：当用 create index 创建索引时，必须指定索引的名字，否则mysql会报错；用 ALTER TABLE 创建索引时，可以不指定索引名字，若不指定mysql会自动生成索引名字。</p>
<p>可以在 ALTER 命令中使用 DROP 子句来删除索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> PRIMARY <span class="keyword">KEY</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tbl_name <span class="keyword">DROP</span> &#123;<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>&#125; index_name;</span><br></pre></td></tr></table></figure>
<p>尝试以下示例来删除上面创建的索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP INDEX (c);</span><br></pre></td></tr></table></figure>
<h4 id="3-1-使用-ALTER-命令添加和删除主键"><a href="#3-1-使用-ALTER-命令添加和删除主键" class="headerlink" title="3. 1 使用 ALTER 命令添加和删除主键"></a>3. 1 使用 ALTER 命令添加和删除主键</h4><p>可以以相同的方式添加主键，But make sure the Primary Key works on columns, which are NOT NULL.</p>
<p>下面的代码是在现有表中添加主键。这将首先使列不为NULL，然后将其添加为主键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl MODIFY i INT NOT NULL;</span><br><span class="line">mysql&gt; ALTER TABLE testalter_tbl ADD PRIMARY KEY (i);</span><br></pre></td></tr></table></figure>
<p>也可以使用 ALTER 命令删除主键：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE testalter_tbl DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure>
<p>删除主键时只需指定 <code>PRIMARY KEY</code>，但在删除不是 PRIMARY KEY 的索引时，必须指定索引名。</p>
<h3 id="4-创建表时直接指定索引"><a href="#4-创建表时直接指定索引" class="headerlink" title="4. 创建表时直接指定索引"></a>4. 创建表时直接指定索引</h3><p>普通索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">	&#123;<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>&#125; [indexName] (username)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(  </span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,   </span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">	<span class="keyword">UNIQUE</span> [indexName] (username)  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	PRIMARY <span class="keyword">KEY</span>(<span class="keyword">ID</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法二</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable(</span><br><span class="line">	<span class="keyword">ID</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	username <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>, </span><br><span class="line">    s <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="keyword">index</span> k(k)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-使用-DROP-命令删除索引"><a href="#5-使用-DROP-命令删除索引" class="headerlink" title="5. 使用 DROP 命令删除索引"></a>5. 使用 DROP 命令删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> mytable;</span><br></pre></td></tr></table></figure>
<h3 id="6-显示索引信息"><a href="#6-显示索引信息" class="headerlink" title="6. 显示索引信息"></a>6. 显示索引信息</h3><h4 id="6-1-show-index"><a href="#6-1-show-index" class="headerlink" title="6.1 show index"></a>6.1 show index</h4><p>可以使用 <strong>SHOW INDEX</strong> 命令列出与表关联的所有索引。可以通过添加 \G 进行垂直格式输出，以避免长行换行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; SHOW INDEX FROM table_name\G</span><br><span class="line">........</span><br></pre></td></tr></table></figure>
<h4 id="6-2-可用explain来查看是否使用索引"><a href="#6-2-可用explain来查看是否使用索引" class="headerlink" title="6.2 可用explain来查看是否使用索引"></a><span id="jump6.2">6.2 可用explain来查看是否使用索引</span></h4><p>explain结果中key代表使用的索引名称，若为NULL，则未使用索引。</p>
<p>explain结果输出的内容</p>
<blockquote>
<p>参考 <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/8.0/en/explain-output.html</a></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Column</th>
<th style="text-align:left">JSON Name</th>
<th style="text-align:left">Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id" target="_blank" rel="noopener"><code>id</code></a></td>
<td style="text-align:left"><code>select_id</code></td>
<td style="text-align:left">The <code>SELECT</code> identifier</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type" target="_blank" rel="noopener"><code>select_type</code></a></td>
<td style="text-align:left">None</td>
<td style="text-align:left">The <code>SELECT</code> type</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table" target="_blank" rel="noopener"><code>table</code></a></td>
<td style="text-align:left"><code>table_name</code></td>
<td style="text-align:left">The table for the output row</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions" target="_blank" rel="noopener"><code>partitions</code></a></td>
<td style="text-align:left"><code>partitions</code></td>
<td style="text-align:left">The matching partitions</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type" target="_blank" rel="noopener"><code>type</code></a></td>
<td style="text-align:left"><code>access_type</code></td>
<td style="text-align:left">The join type</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys" target="_blank" rel="noopener"><code>possible_keys</code></a></td>
<td style="text-align:left"><code>possible_keys</code></td>
<td style="text-align:left">The possible indexes to choose</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key" target="_blank" rel="noopener"><code>key</code></a></td>
<td style="text-align:left"><code>key</code></td>
<td style="text-align:left">The index actually chosen</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len" target="_blank" rel="noopener"><code>key_len</code></a></td>
<td style="text-align:left"><code>key_length</code></td>
<td style="text-align:left">The length of the chosen key</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref" target="_blank" rel="noopener"><code>ref</code></a></td>
<td style="text-align:left"><code>ref</code></td>
<td style="text-align:left">The columns compared to the index</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows" target="_blank" rel="noopener"><code>rows</code></a></td>
<td style="text-align:left"><code>rows</code></td>
<td style="text-align:left">Estimate of rows to be examined</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered" target="_blank" rel="noopener"><code>filtered</code></a></td>
<td style="text-align:left"><code>filtered</code></td>
<td style="text-align:left">Percentage of rows filtered by table condition</td>
</tr>
<tr>
<td style="text-align:left"><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra" target="_blank" rel="noopener"><code>Extra</code></a></td>
<td style="text-align:left">None</td>
<td style="text-align:left">Additional information</td>
</tr>
</tbody>
</table>
</div>
<h5 id="6-2-1-关于explain中的type和extra"><a href="#6-2-1-关于explain中的type和extra" class="headerlink" title="6.2.1 关于explain中的type和extra"></a>6.2.1 关于explain中的type和extra</h5><p>例如：现有表city2如下：</p>
<p><img src="/2020/01/13/索引Index/1605591080992.png" alt="1605591080992"></p>
<p>city2上的索引如下图所示：（id为主键，(age,name)联合索引）</p>
<p><img src="/2020/01/13/索引Index/1605591141489.png" alt="1605591141489"></p>
<p>查询1：<strong><code>explain select name,age from city2 where age=20\G</code></strong><br>查询内容在索引内，where 条件为索引最左列</p>
<p><img src="/2020/01/13/索引Index/1605591319736.png" alt="1605591319736"></p>
<p>👆 type 是 ref，表明用到了索引，extra 是 using index，表示索引覆盖了.（即不用回表）</p>
<p>查询2：<strong><code>explain select name, age from city2 where name=&#39;bob&#39;\G</code></strong><br> 查询内容在索引内，where条件为索引第二列，这次不是最左列了</p>
<p><img src="/2020/01/13/索引Index/1605591642645.png" alt="1605591642645"></p>
<p>👆 type 是 index，表明发生了索引扫描（因为where条件不是最左列的缘故），extra 是 using where; using index（using index代表索引覆盖了，不用回表，using where代表发生了过滤），</p>
<p>查询3：<strong><code>explain select address from city2 where age=20\G</code></strong><br>查询内容不在索引内，where 条件为索引最左列</p>
<p><img src="/2020/01/13/索引Index/1605592157733.png" alt="1605592157733"></p>
<p>👆 extra 是 NULL，type 是 ref，表明虽然用到了索引，但是没有索引覆盖，产生了回表。</p>
<p>查询4：<strong><code>explain select address from city2 where name=&#39;bob&#39;\G</code></strong><br>查询内容不在索引范围内，where条件为索引第二列</p>
<p><img src="/2020/01/13/索引Index/1605592577124.png" alt="1605592577124"></p>
<p>👆 type 是 all，代表全表扫描，extra 是 using where 说明在全表扫描后发生了过滤。（走全表扫描的原因是查询内容不在索引范围内，且where条件没有最左列，所以引擎选择了走全表扫描。）</p>
<p>更多例子见 <a href="https://blog.csdn.net/jeffrey11223/article/details/79100761" target="_blank" rel="noopener">https://blog.csdn.net/jeffrey11223/article/details/79100761</a></p>
<h6 id="1-EXPLAIN-Join-Types"><a href="#1-EXPLAIN-Join-Types" class="headerlink" title="(1) EXPLAIN Join Types"></a>(1) EXPLAIN Join Types</h6><p>explain中type的解释</p>
<p>The <code>type</code> column of <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html" target="_blank" rel="noopener"><code>EXPLAIN</code></a> output describes how tables are joined.  The following list describes the join types, ordered from the best type to the worst:</p>
<p>下面只列出了部分</p>
<ul>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_system" target="_blank" rel="noopener"><code>system</code></a><br>The table has only one row (= system table). This is a special case of the <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> join type.</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a><br>The table has at most one matching row, which is read at the start of the query. Because there is only one row, values from the column in this row can be regarded as constants by the rest of the optimizer. <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> tables are very fast because they are read only once.<br><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> is used when you compare all parts of a <code>PRIMARY KEY</code> or <code>UNIQUE</code> index to constant values. In the following queries, <em>tbl_name</em> can be used as a <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_const" target="_blank" rel="noopener"><code>const</code></a> table:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name <span class="keyword">WHERE</span> primary_key=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tbl_name</span><br><span class="line">  <span class="keyword">WHERE</span> primary_key_part1=<span class="number">1</span> <span class="keyword">AND</span> primary_key_part2=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a><br>All rows with matching index values are read from this table for each combination of rows from the previous tables. <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a> is used if the join uses only a leftmost prefix of the key or if the key is not a <code>PRIMARY KEY</code> or <code>UNIQUE</code> index (in other words, if the join cannot select a single row based on the key value). If the key that is used matches only a few rows, this is a good join type.<br><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a> can be used for indexed columns that are compared using the <code>=</code> or <code>&lt;=&gt;</code> operator. In the following examples, MySQL can use a <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref" target="_blank" rel="noopener"><code>ref</code></a> join to process <em>ref_table</em>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table <span class="keyword">WHERE</span> key_column=expr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column=other_table.column;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ref_table,other_table</span><br><span class="line">  <span class="keyword">WHERE</span> ref_table.key_column_part1=other_table.column</span><br><span class="line">  <span class="keyword">AND</span> ref_table.key_column_part2=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a><br>The <code>index</code> join type is the same as <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a>, except that the index tree is scanned. This occurs two ways:</p>
<ul>
<li>If the index is a covering index for the queries and can be used to satisfy all data required from the table, only the index tree is scanned. In this case, the <code>Extra</code> column says <code>Using index</code>. An index-only scan usually is faster than <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a> because the size of the index usually is smaller than the table data.</li>
<li>A full table scan is performed using reads from the index to look up data rows in index order. <code>Uses index</code> does not appear in the <code>Extra</code> column.</li>
</ul>
<p>MySQL can use this join type when the query uses only columns that are part of a single index.</p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a><br>A full table scan is done for each combination of rows from the previous tables. This is normally not good if the table is the first table not marked const, and usually very bad in all other cases. Normally, you can avoid ALL by adding indexes that enable row retrieval from the table based on constant values or column values from earlier tables.</p>
</li>
</ul>
<h6 id="2-EXPLAIN-Extra-Information"><a href="#2-EXPLAIN-Extra-Information" class="headerlink" title="(2) EXPLAIN Extra Information"></a>(2) EXPLAIN Extra Information</h6><p>explian中extra的解释</p>
<p>If you want to make your queries as fast as possible, look out for <code>Extra</code> column values of <code>Using filesort</code> and <code>Using temporary</code>.</p>
<p>下面只列出了一部分：</p>
<ul>
<li><code>Distinct</code> (JSON property: <code>distinct</code>)<br>MySQL is looking for distinct values, so it stops searching for more rows for the current row combination after it has found the first matching row.</li>
</ul>
<ul>
<li><code>Full scan on NULL key</code> (JSON property: <code>message</code>)<br>This occurs for subquery optimization as a fallback strategy when the optimizer cannot use an index-lookup access method.</li>
</ul>
<ul>
<li><code>Using filesort</code> (JSON property: <code>using_filesort</code>)<br>MySQL must do an extra pass to find out how to retrieve the rows in sorted order. The sort is done by going through all rows according to the join type and storing the sort key and pointer to the row for all rows that match the <code>WHERE</code> clause. The keys then are sorted and the rows are retrieved in sorted order. See <a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html" target="_blank" rel="noopener">Section 8.2.1.16, “ORDER BY Optimization”</a>.</li>
</ul>
<ul>
<li><p><code>Using index</code> (JSON property: <code>using_index</code>)<br>The column information is retrieved from the table using only information in the index tree without having to do an additional seek to read the actual row. This strategy can be used when the query uses only columns that are part of a single index.<br>For <code>InnoDB</code> tables that have a user-defined clustered index, that index can be used even when <code>Using index</code> is absent from the <code>Extra</code> column. This is the case if <code>type</code> is <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a> and <code>key</code> is <code>PRIMARY</code>.</p>
</li>
<li><p><code>Using index condition</code> (JSON property: <code>using_index_condition</code>)<br>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary. See <a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Section 8.2.1.6, “Index Condition Pushdown Optimization”</a>.</p>
</li>
<li><p><code>Using temporary</code> (JSON property: <code>using_temporary_table</code>)<br>To resolve the query, MySQL needs to create a temporary table to hold the result. This typically happens if the query contains <code>GROUP BY</code> and <code>ORDER BY</code> clauses that list columns differently.</p>
</li>
<li><p><code>Using where</code> (JSON property: <code>attached_condition</code>)<br>A <code>WHERE</code> clause is used to restrict which rows to match against the next table or send to the client. Unless you specifically intend to fetch or examine all rows from the table, you may have something wrong in your query if the <code>Extra</code> value is not <code>Using where</code> and the table join type is <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all" target="_blank" rel="noopener"><code>ALL</code></a> or <a href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_index" target="_blank" rel="noopener"><code>index</code></a>.</p>
</li>
</ul>
<p>Tables are read by accessing index tuples and testing them first to determine whether to read full table rows. In this way, index information is used to defer (“push down”) reading full table rows unless it is necessary. See <a href="https://dev.mysql.com/doc/refman/8.0/en/index-condition-pushdown-optimization.html" target="_blank" rel="noopener">Section 8.2.1.6, “Index Condition Pushdown Optimization”</a>.</p>
<h3 id="7-什么时候该使用索引"><a href="#7-什么时候该使用索引" class="headerlink" title="7. 什么时候该使用索引"></a>7. 什么时候该使用索引</h3><p><img src="/2020/01/13/索引Index/1578902891139.png" alt="1578902891139"></p>
<h3 id="8-什么时候不该使用索引"><a href="#8-什么时候不该使用索引" class="headerlink" title="8. 什么时候不该使用索引"></a>8. 什么时候不该使用索引</h3><p>索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p>
<p>建立索引会占用磁盘空间的索引文件。</p>
<p><img src="/2020/01/13/索引Index/1578902910331.png" alt="1578902910331"></p>
<h2 id="第二部分：索引的常见模型"><a href="#第二部分：索引的常见模型" class="headerlink" title="第二部分：索引的常见模型"></a>第二部分：索引的常见模型</h2><blockquote>
<p>参考 <a href="https://time.geekbang.org/column/article/69236" target="_blank" rel="noopener">https://time.geekbang.org/column/article/69236</a></p>
</blockquote>
<p>索引的常见模型：哈希表、有序数组和搜索树。</p>
<p>例如，现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字。</p>
<h3 id="1-哈希表"><a href="#1-哈希表" class="headerlink" title="1. 哈希表"></a>1. 哈希表</h3><p>哈希索引的示意图如下：</p>
<p><img src="/2020/01/13/索引Index/1605000393037.png" alt="1605000393037"></p>
<p>从上图可以看到，四个ID_card_n的值并不是递增的（即并不是身份证号越大，算出来的N越大）</p>
<p><strong>优点</strong>：增加新的数据时，只需往后追加。</p>
<p><strong>缺点</strong>：因为不是有序的，所以哈希索引做区间查询的速度是很慢的。例如查找身份证号在[ID_card_X, ID_card_Y]区间的所有用户，就必须全部扫描一遍了。</p>
<p><strong>哈希表这种结构适用于只有等值查询的场景，比如 Memcached 及其他一些 NoSQL 引擎。</strong></p>
<h3 id="2-有序数组"><a href="#2-有序数组" class="headerlink" title="2. 有序数组"></a>2. 有序数组</h3><p><strong>优点</strong>：有序数组在等值查询和范围查询场景中的性能都非常优秀。</p>
<p>还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="/2020/01/13/索引Index/1605000914282.png" alt="1605000914282"></p>
<p>查找身份证号对应的名字，用二分法可以快速得到，时间复杂度 O(log(N))。</p>
<p>同时很显然，这个索引结构支持范围查询。若要查身份证号在[ID_card_X, ID_card_Y]区间的User, 可以先二分法找到ID_card_x（如果不存在ID_card_X,就找到大于ID_card_X的第一个user)，然后向右谝历，直到查到第一个大于ID_card)Y的身份证号，退出循环。</p>
<p><strong>缺点</strong>：如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就它须得挪动后面所有的记录，成本太高。</p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人囗信息，这类不会再修改的数据。</p>
<h3 id="3-搜索树"><a href="#3-搜索树" class="headerlink" title="3. 搜索树"></a>3. 搜索树</h3><p>还是上面根据身份证号查名字的例子，如果我们用二叉搜索树来实现的话，示意图如下所示：</p>
<p><img src="/2020/01/13/索引Index/1605080367750.png" alt="1605080367750"></p>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查 ID_card_n2 的话，按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度杂度是O(log(N))。</p>
<p>当然为了维持 O(Iog(N)) 的查询复杂度，需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10ms的时间，这个查询可真够慢的。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用<strong><span style="color:red">“N 叉”树</span></strong>。这里，“N 叉”树中的“N”取决于数据块的大小。</p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。考虑到树根的数据块总是在内存中的，一个 10 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p><strong>N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</strong></p>
<blockquote>
<p>N叉树的N值，可以通过page大小间接控制</p>
</blockquote>
<h2 id="第三部分：InnoDB的索引模型"><a href="#第三部分：InnoDB的索引模型" class="headerlink" title="第三部分：InnoDB的索引模型"></a>第三部分：InnoDB的索引模型</h2><blockquote>
<p>参考 <a href="https://time.geekbang.org/column/article/69236" target="_blank" rel="noopener">https://time.geekbang.org/column/article/69236</a></p>
</blockquote>
<h3 id="1-InnoDB索引组织结构"><a href="#1-InnoDB索引组织结构" class="headerlink" title="1. InnoDB索引组织结构"></a>1. InnoDB索引组织结构</h3><p>在 MySQL 中，索引是在存储引擎层实现的，所以并没有统一的索引标准，即不同存储引擎的索引的工作方式并不一样。而即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。由于 InnoDB 存储引擎在 MySQL 数据库中使用最为广泛，所以下面以 InnoDB 为例，分析一下其中的索引模型。</p>
<p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为<strong><span id="jump_index_zuzhibiao">索引组织表</span></strong>。又因为前面我们提到的，InnoDB 使用了 <strong>B+ 树</strong>索引模型，所以数据都是存储在 B+ 树中的。</p>
<blockquote>
<p><span style="color:red">每一个索引在 InnoDB 里面对应一棵 B+ 树。</span></p>
</blockquote>
<p>假设，我们有一个主键列为ID的表，表中有字段 k，并且在k上有索引。这个表的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt;create table T(</span><br><span class="line">id int primary key，</span><br><span class="line">k int not null，</span><br><span class="line">name varchar(16)，</span><br><span class="line">index(k)) engine=InnoDB;</span><br></pre></td></tr></table></figure>
<p>表中R1-R5的(ID,k)值分别为(100, 1)、(200, 2)、(300,3)、(500,5) 和 (600, 6)，两棵树的示例示意图如下。</p>
<p><img src="/2020/01/13/索引Index/1605086187154.png" alt="1605086187154"></p>
<p>R1代表的是一行，左边是主键索引，右边是非主键索引。</p>
<blockquote>
<p><strong>innoDB B+树的叶子节点是page (页)，一个页里面可以存多个行</strong><br>索引只能定位到page，page内部怎么去定位行数据：page内部有个有序数组，二分法</p>
</blockquote>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为<span style="color:red" id="jump_index_several"><strong>主键索引</strong></span>和<strong><span style="color:red">非主键索引（也叫普通索引）</span></strong>。<br><strong>主键索引的叶子节点存的是整行数据</strong>。在 InnoDB 里，主键索引也被称为<strong><span style="color:red">聚簇索引（clustered index）</span></strong>。<br><strong>非主键索引的叶子节点内容是主键的值</strong>。在 InnoDB 里，非主键索引也被称为<strong><span style="color:red">二级索引（secondary index）</span></strong>。</p>
<p>根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</li>
<li>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，<strong>基于非主键索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p>
<p><img src="/2020/01/13/索引Index/1605236459443.png" alt="1605236459443"></p>
<h4 id="1-1-聚簇索引（也称主键索引，聚集索引，clustered-index）"><a href="#1-1-聚簇索引（也称主键索引，聚集索引，clustered-index）" class="headerlink" title="1.1 聚簇索引（也称主键索引，聚集索引，clustered index）"></a><span style="color:Red">1.1 聚簇索引（也称主键索引，聚集索引，clustered index）</span></h4><blockquote>
<p>参考 <a href="https://www.cnblogs.com/jiawen010/p/11805241.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiawen010/p/11805241.html</a></p>
</blockquote>
<p><strong>InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，聚簇索引就是按照每张表的主键构造一颗B+树，同时叶子节点中存放的就是整张表的行记录数据，也将聚集索引的叶子节点称为数据页。这个特性决定了索引组织表中数据也是索引的一部分。一张表只有一个聚簇索引。</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而<strong>是一种数据存储方式</strong>。具体细节依赖于其实现方式。</p>
<p>MySQL数据库中innodb存储引擎，B+树索引可以分为聚簇索引（也称聚集索引，clustered index）和<span style="color:red">辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index）</span>。这两种索引内部都是B+树，聚集索引的叶子节点存放着一整行的数据。</p>
<p>Innobd中的主键索引是一种聚簇索引，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引。</p>
<blockquote>
<p><span style="color:red">Innodb使用的是聚簇索引，MyISam使用的是非聚簇索引。</span><br>MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>
<p>问：主键索引是聚集索引还是非聚集索引？<br>在Innodb下主键索引是聚集索引，在Myisam下主键索引是非聚集索引</p>
</blockquote>
<p>Innodb通过主键聚集数据，如果没有定义主键，innodb会选择非空的唯一索引代替。如果没有这样的索引，innodb会隐式的定义一个主键来作为聚簇索引。</p>
<p>聚簇索引的优缺点 </p>
<p>优点：</p>
<ol>
<li>数据访问更快，因为聚簇索引将索引和数据保存在同一个B+树中，因此从聚簇索引中获取数据比非聚簇索引更快</li>
<li>聚簇索引对于主键的排序查找和范围查找速度非常快</li>
</ol>
<p>缺点：</p>
<ol>
<li>插入速度严重依赖于插入顺序，按照主键的<strong>顺序插入</strong>是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个<strong>自增的ID列为主键</strong></li>
<li><strong>更新主键的代价很高</strong>，因为将会导致被更新的行移动。因此，对于InnoDB表，我们一般定义主键为不可更新。</li>
<li>二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</li>
</ol>
<h4 id="1-2-辅助索引（也称非聚簇索引，二级索引，非主键索引，普通索引，secondary-index）"><a href="#1-2-辅助索引（也称非聚簇索引，二级索引，非主键索引，普通索引，secondary-index）" class="headerlink" title="1.2 辅助索引（也称非聚簇索引，二级索引，非主键索引，普通索引，secondary index）"></a><span style="color:red">1.2 辅助索引（也称非聚簇索引，二级索引，非主键索引，普通索引，secondary index）</span></h4><blockquote>
<p>参考 <a href="https://www.cnblogs.com/jiawen010/p/11805241.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiawen010/p/11805241.html</a></p>
</blockquote>
<p>在<strong>聚簇索引之上创建的索引称之为辅助索引</strong>，辅助索引访问数据总是需要二次查找。辅助索引叶子节点存储的不再是行的物理位置，而是主键值。通过辅助索引首先找到的是主键值，再通过主键值找到数据行的数据页，再通过数据页中的Page Directory找到数据行。</p>
<p>Innodb辅助索引的叶子节点并<strong>不包含行记录的全部数据</strong>，叶子节点除了包含键值外，还包含了相应行数据的聚簇索引键。（见上图图4）</p>
<p>辅助索引的存在不影响数据在聚簇索引中的组织，所以一张表可以有多个辅助索引。在innodb中有时也称辅助索引为二级索引。</p>
<p>辅助索引会包含主键列，所以，<strong>如果主键定义的比较大，其他索引也将很大</strong>。如果想在表上定义 、很多索引，则争取尽量把主键定义得小一些。InnoDB 不会压缩索引。</p>
<blockquote>
<p>In <code>InnoDB</code> tables, keep the <code>PRIMARY KEY</code> short to minimize storage overhead for secondary indexes. Each secondary index entry contains a copy of the primary key columns for the corresponding row. (See <a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-index-types.html" target="_blank" rel="noopener">Section 14.6.2.1, “Clustered and Secondary Indexes”</a>.)</p>
<p>(来自 <a href="https://dev.mysql.com/doc/refman/5.6/en/create-table.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/create-table.html</a>)</p>
</blockquote>
<p><img src="/2020/01/13/索引Index/1605671203873.png" alt="1605671203873"></p>
<h4 id="1-3-小结"><a href="#1-3-小结" class="headerlink" title="1.3 小结"></a>1.3 小结</h4><blockquote>
<p>参考 <a href="https://www.cnblogs.com/jiawen010/p/11805241.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiawen010/p/11805241.html</a></p>
</blockquote>
<ul>
<li>为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。</li>
<li>用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</li>
</ul>
<p>聚簇索引和非聚簇索引的区别：</p>
<ul>
<li>聚簇索引的叶子节点存放的是主键值和数据行，<strong>支持覆盖索引</strong>；二级索引的叶子节点存放的是主键值或指向数据行的指针。</li>
<li>由于节子节点(数据页)只能按照一颗B+树排序，故<strong>一张表只能有一个聚簇索引</strong>。辅助索引的存在不影响聚簇索引中数据的组织，所以一张表可以有多个辅助索引</li>
</ul>
<p>注： <strong><span id="jump_covering_index">覆盖索引（covering index）</span></strong>指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。（关于覆盖索引更详细内容见<a href="#jump4">第四部分：覆盖索引</a>）</p>
<h3 id="2-索引维护"><a href="#2-索引维护" class="headerlink" title="2. 索引维护"></a>2. 索引维护</h3><p>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为<strong>页分裂</strong>。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<h3 id="3-关于自增主键"><a href="#3-关于自增主键" class="headerlink" title="3. 关于自增主键"></a>3. 关于自增主键</h3><p>你可能在一些建表规范里面见到过类似的描述，要求建表语司里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
<p>自增主键是指自增列上定义的主键，在建表浯句中一般是这么定义的：<code>NOT NULL PRIMARY KEY AUTO INCREMENT</code>。</p>
<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而用业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型(bigint)则是8个字节。</p>
<p>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</p>
<p>所以，从性能和存储空间方面考量，自增主键往往是更合理的选择。</p>
<p>有没有什么场景适合用业务字段直接做主键的呢？还是有的。比如，有些业务的场景需求是这样的：</p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>这就是典型的KV(key-value)场景，由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。<br>这时候我们就要优先考虑上一段提到的”尽量使用主键查询”原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><p>B+ 树能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。</p>
<p>由于 InnoDB 是索引组织表，一般情况下建议创建一个自增主键，这样非主键索引占用的空间最小。</p>
<p>问题：对于上面例子中的 InnoDB 表 T，如果你要重建索引 k，你的两个 SQL 语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> <span class="keyword">index</span> k;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> <span class="keyword">index</span>(k);</span><br></pre></td></tr></table></figure>
<p>如果你要重建主键索引，也可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> T <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure>
<h4 id="问：对于上面这两个重建索引的做法，有没有不合适的？"><a href="#问：对于上面这两个重建索引的做法，有没有不合适的？" class="headerlink" title="问：对于上面这两个重建索引的做法，有没有不合适的？"></a>问：对于上面这两个重建索引的做法，有没有不合适的？</h4><blockquote>
<p>注：为什么要重建索引？<br>前面提到，索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。</p>
</blockquote>
<p>答案：重建索引 k 的做法是合理的，可以达到省空间的目的。但是，重建主键的过程不合理。<br>1.直接删掉主键索引，会使得所有二级索引都失效，并且会用ROWID来做主键索引。<br>2.不论是删除主键还是创建主键，都会将整个表重建。所以连着执行这两个语句的话，第一个语句就白做了。这两个语句，你可以用这个语句代替 ：<code>alter table T engine=InnoDB</code>。👈原地重建表结构</p>
<h2 id="第四部分：覆盖索引"><a href="#第四部分：覆盖索引" class="headerlink" title="第四部分：覆盖索引"></a><span id="jump4">第四部分：覆盖索引</span></h2><blockquote>
<p>参考 <a href="https://time.geekbang.org/column/article/69636" target="_blank" rel="noopener">https://time.geekbang.org/column/article/69636</a></p>
</blockquote>
<p>在下面这个表T中，如果执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？<br>表的初始化语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    s <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span>,</span><br><span class="line">    <span class="keyword">index</span> k(k)</span><br><span class="line">) <span class="keyword">engine</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> T <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">1</span>,<span class="string">'aa'</span>),(<span class="number">200</span>,<span class="number">2</span>,<span class="string">'bb'</span>),(<span class="number">300</span>,<span class="number">3</span>,<span class="string">'cc'</span>),(<span class="number">500</span>,<span class="number">5</span>,<span class="string">'cc'</span>),(<span class="number">600</span>,<span class="number">6</span>,<span class="string">'ff'</span>),(<span class="number">700</span>,<span class="number">7</span>,<span class="string">'gg'</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/13/索引Index/1605443844487.png" alt="1605443844487"></p>
<p>这条SQL查询语句的执行流程：</p>
<ol>
<li>在k索引树上找到 k=3 的记录，取得 ID=300;</li>
<li>再到 ID 索引树查到 ID=300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k=5，取得 ID=500；</li>
<li>再回到 ID 索引树查到 ID=500对应的R4；</li>
<li>在 k 索引树取下一个值 k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为<strong>覆盖索引</strong>。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是2。</p>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：在一个市民信息表，是否有必要将身份证号和名字建立联合索引？</p>
<p>假设这个市民表的定义是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tuser`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`id_card`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`ismale`</span> <span class="built_in">tinyint</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`id_card`</span> (<span class="string">`id_card`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`name_age`</span> (<span class="string">`name`</span>,<span class="string">`age`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure>
<p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务 DBA，或者称为业务数据架构师的工作。</p>
<p><img src="/2020/01/13/索引Index/1605236364285.png" alt="1605236364285"></p>
<h2 id="第五部分：最左前缀原则"><a href="#第五部分：最左前缀原则" class="headerlink" title="第五部分：最左前缀原则"></a>第五部分：最左前缀原则</h2><blockquote>
<p>参考 <a href="https://time.geekbang.org/column/article/69636" target="_blank" rel="noopener">https://time.geekbang.org/column/article/69636</a></p>
</blockquote>
<p>如果为每一种查询都设计一个索引，索引是不是太多了。如果现在要按照市民的身份证号取查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>
<h3 id="1-最左前缀"><a href="#1-最左前缀" class="headerlink" title="1. 最左前缀"></a><span id="jump_leftmost_prefix">1. 最左前缀</span></h3><p><strong>B+树这种索引结构，可以利用索引的”最左前缀“，来定位记录。</strong></p>
<p>用（name, age）这个联合索引来分析：</p>
<p><img src="/2020/01/13/索引Index/1605450882634.png" alt="1605450882634"></p>
<p>可以看到，<strong>索引项是按照索引定义里面出现的字段顺序排序的。→</strong> 即先按name排序，再按age排序</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到 ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的 SQL 语句的条件是<code>where name like ‘张 %’</code>。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，<span style="color:blue">不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</span></p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p>
<p>这里我们的评估标准是，<span style="color:blue">索引的复用能力</span>。<strong><span style="color:orange">因为可以支持最左前缀，所以当已经有了 (a,b) 这个联合索引后，一般就不需要单独在 a 上建立索引了</span></strong>。<strong>因此，第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的</strong>。</p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建 (身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于 a、b 各自的查询呢？<strong>查询条件里面只有 b 的语句，是无法使用 (a,b) 这个联合索引的</strong>，这时候你不得不维护另外一个索引，也就是说你需要同时维护 (a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name 字段是比 age 字段大的 ，那我就建议你创建一个（name,age）的联合索引和一个 (age) 的单字段索引。</p>
<h3 id="2-索引下推"><a href="#2-索引下推" class="headerlink" title="2. 索引下推"></a><span id="jump_pushed_down">2. 索引下推</span></h3><p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like '张%' and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>根据前缀索引规则，这个语句在搜索索引树的时候，只能用 “张”（索引只有(name, age)），找到第一个满足条件的记录 ID3。当然，这还不错，总比全表扫描要好。然后呢？当然是判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而 MySQL 5.6 引入的<strong>索引下推优化（index condition pushdown)</strong>， 可以<strong>在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</p>
<p>图 3 和图 4，是这两个过程的执行流程图。</p>
<p><img src="/2020/01/13/索引Index/1605451488975.png" alt="1605451488975"></p>
<p><img src="/2020/01/13/索引Index/1605451552321.png" alt="1605451552321"></p>
<h3 id="3-小结"><a href="#3-小结" class="headerlink" title="3. 小结"></a>3. 小结</h3><p>在满足语句需求的情况下， 尽量少地访问资源是数据库设计的重要原则之一。在使用数据库的时候，尤其是在设计表结构时，也要以减少资源消耗作为目标。</p>
<p>问题：实际上主键索引也是可以使用多个字段的。DBA 小吕在入职新公司的时候，就发现自己接手维护的库里面，有这么一个表，表结构定义类似这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`geek`</span> (</span><br><span class="line">  <span class="string">`a`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`b`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`d`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`a`</span>,<span class="string">`b`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`c`</span> (<span class="string">`c`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`ca`</span> (<span class="string">`c`</span>,<span class="string">`a`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`cb`</span> (<span class="string">`c`</span>,<span class="string">`b`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<p>公司的同事告诉他说，由于历史原因，这个表需要 a、b 做联合主键，这个小吕理解了。</p>
<p>但是，学过本章内容的小吕又纳闷了，既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？</p>
<p>同事告诉他，是因为他们的业务里面有这样的两种语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> geek <span class="keyword">where</span> c=N <span class="keyword">order</span> <span class="keyword">by</span> a <span class="keyword">limit</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> geek <span class="keyword">where</span> c=N <span class="keyword">order</span> <span class="keyword">by</span> b <span class="keyword">limit</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h4 id="问：这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？"><a href="#问：这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？" class="headerlink" title="问：这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？"></a>问：这位同事的解释对吗，为了这两个查询模式，这两个索引是否都是必须的？为什么呢？</h4><p>答案：ca索引不需要，cb索引需要</p>
<p><img src="/2020/01/13/索引Index/1605452048904.png" alt="1605452048904"></p>
<p><img src="/2020/01/13/索引Index/1605452080320.png" alt="1605452080320"></p>
<p><img src="/2020/01/13/索引Index/1605452122669.png" alt="1605452122669"></p>
<p><img src="/2020/01/13/索引Index/1605452156592.png" alt="1605452156592"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>视图View</title>
    <url>/2020/01/13/%E8%A7%86%E5%9B%BEView/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/13/视图View/1578902313361.png" alt="1578902313361"></p>
<p><img src="/2020/01/13/视图View/1578902382330.png" alt="1578902382330"></p>
<p><img src="/2020/01/13/视图View/1578902994931.png" alt="1578902994931"></p>
<p><img src="/2020/01/13/视图View/1578903023109.png" alt="1578903023109"></p>
<p><code>INSERT INTO Viewname {column1,column2,…} values(exp1,exp2,…);</code>//插入视图实际影响表</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hive介绍</title>
    <url>/2020/01/12/Hive%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p> 参考：<br> <a href="https://blog.csdn.net/PowerBlogger/article/details/83626449" target="_blank" rel="noopener">https://blog.csdn.net/PowerBlogger/article/details/83626449</a><br> <a href="https://blog.csdn.net/u010886217/article/details/83796151" target="_blank" rel="noopener">https://blog.csdn.net/u010886217/article/details/83796151</a><br> 《Hadoop构建数据仓库实践》</p>
<p> 更多内容见Hive官方文档<br> <a href="https://cwiki.apache.org/confluence/display/Hive/Home#Home-UserDocumentation" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/Home#Home-UserDocumentation</a></p>
</blockquote>
<h2 id="1-什么是Hive？"><a href="#1-什么是Hive？" class="headerlink" title="1.什么是Hive？"></a>1.什么是Hive？</h2><p>Hive 是 Hadoop 生态圈的数据仓库软件，里面有表的概念，使用类似于 SQL 的语言（HiveQL）读、写、管理分布式存储上的大数据集。它建立在 Hadoop 之上，具有以下功能和特点：</p>
<ul>
<li>通过 HiveQL 方便地访问数据，<strong>适合执行 ETL、报表查询、数据分析等数据仓库任务</strong>。</li>
<li>提供一种机制，给各种各样的数据格式添加结构。</li>
<li>直接访问 HDFS 的文件，或者访问如 HBase 的其他数据存储。</li>
<li>可以通过 MapReduce、Spark 或 Tez 等多种计算框架执行查询。</li>
</ul>
<p>Hive 被设计成一个可扩展的、高性能的、容错的、与输入数据格式松耦合的系统，<strong>适合于数据仓库中的汇总、分析、批处理查询等任务，而不适合联机事务处理（OLTP）的工作场景</strong>。Hive 包括 HCatalog 和 WebHCat 两个组件。HCatalog 是 Hadoop 的表和存储管理层，允许使用 Pig 和 MapReduce 等数据处理工具的用户更容易读写集群中的数据。WebHCat 提供了一个服务，可以使用 HTTP 接口执行 MapReduce （或 YARN）、Pig、Hive 作业或元数据操作。</p>
<p>HiveQL 只处理结构化数据，并且不区分大小写（与SQL一样）。</p>
<p><span style="color:red">Hive 里的数据最终存储在 HDFS 的文件中</span>，常用的数据文件格式有以下4种：<strong>TEXTFILE、SEQUENCEFILE、RCFILE、ORCFILE</strong>。（关于文件格式的更详细内容见 <a href="#jump3.1.2">3.1.2 file format</a>）。在 Hive 中文件格式指的是记录以怎样的编码格式被存储到文件中。不同文件格式的主要区别在于它们的数据编码、压缩率、使用的空间和磁盘I/O。在加载数据的过程中，Hive不会对数据本身进行任何修改，而只是将数据内容复制或者移动到相应的HDFS目录中。</p>
<p>当用户向传统数据库中增加数据时，系统会检查写入的数据与表结构是否匹配，如果不匹配则拒绝插入数据，这就是所谓的<strong>写时模式</strong>。Hive与此不同，它使用的是<strong>读时模式</strong>，即直到读取时再进行数据校验（加载数据时不进行数据格式的校验，读取数据时如果不合法则显示NULL。这种模式的优点在于加载数据迅速）。在向 Hive 装载数据时，它并不验证数据与表结构是否匹配，但这时它会检查文件格式是否和表定义相匹配。</p>
<h2 id="2-Hive的原理"><a href="#2-Hive的原理" class="headerlink" title="2.Hive的原理"></a>2.Hive的原理</h2><p><strong>Hive 将用户的 HiveQL 语句进行解析，优化，最终把一个个的HiveQL语句转换为 MapReduce 作业提交到 Hadoop 集群上，Hadoop进行作业的调度及监控，作业完成后将执行结果返回给用户。</strong>所以，<strong>Hive并不进行计算，只是把HiveQL解析为MapperReduce在HDFS集群中运行而已</strong>，所以Hive的效率并不高。</p>
<h3 id="2-1-Hive-的体系结构"><a href="#2-1-Hive-的体系结构" class="headerlink" title="2.1 Hive 的体系结构"></a>2.1 Hive 的体系结构</h3><p>Hive 的体系结构如下图所示：</p>
<p><img src="/2020/01/12/Hive介绍/1606383486184.png" alt="1606383486184"></p>
<p>Hive建立在 Hadoop 的分布式文件系统 HDFS 和 MapReduce 之上。上图显示了 Hadoop1 和 Hadoop2 中的两种 MapReduce 组件。</p>
<p>在 HDFS 和 MapReduce 之上，图中显示了 Hive 驱动程序和元数据存储。Hive 驱动程序及其编译器负责编译、优化和执行 HiveQL。依赖于具体情况，Hive 驱动程序可能选择在本地执行 Hive 语句或命令，也可能是产生一个 MapReduce 作业。Hive 驱动程序把元数据存储在数据库中。</p>
<p>默认配置下，Hive 在内建的 Derby 关系数据库系统中存储元数据，这种方式被称为嵌入模式。在这种模式下，Hive 驱动程序、元数据和 Derby 全部运行在同一个 Java 虚拟机中（JVM）。它只支持单一 Hive 会话，所以不能用于多用户的生产环境。Hive 还允许将元数据存储于本地或远程的外部数据库中，这种设置可以更好地支持 Hive 的多会话生产环境。并且，可以配置任何与 JDBC API 兼容的关系数据库系统存储元数据，如 MySQL、Oracle 等。（元数据默认存储在Hive自带的Derby数据库中，但由于Derby不能实现并发访问，所以我们一般使用 MySQL 进行替换）。</p>
<p>对应用支持的关键组件是 Hive Thrift 服务。任何与 JDBC 兼容的应用，都可以通过绑定的 JDBC 驱动访问 Hive。与 ODBC 兼容的客户端，如 Linux 下典型的 unixODBC 和 isql 应用程序，可以从远程 Linux 客户端访问 Hive。</p>
<p>架构图的最上面包括一个命令行接口（CLI），可以在 Linux 终端窗口向 Hive 驱动程序直接发出查询或管理命令。还有一个简单的 Web 界面，通过它可以从浏览器访问 Hive 管理表及其数据。</p>
<h2 id="3-Hive建表语句"><a href="#3-Hive建表语句" class="headerlink" title="3.Hive建表语句"></a><span id="jump3">3.Hive建表语句</span></h2><blockquote>
<p>参考<br><a href="https://blog.csdn.net/qq_36743482/article/details/78383964" target="_blank" rel="noopener">https://blog.csdn.net/qq_36743482/article/details/78383964</a><br><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a></p>
</blockquote>
<p>Hive建表方式共有三种：</p>
<ul>
<li>直接建表法</li>
<li>查询建表法</li>
<li>like建表法</li>
</ul>
<h3 id="3-1-法一：直接建表法"><a href="#3-1-法一：直接建表法" class="headerlink" title="3.1 法一：直接建表法"></a>3.1 法一：直接建表法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(col_name data_type);</span><br></pre></td></tr></table></figure>
<p>完整的syntax:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name    -- (Note: TEMPORARY available in Hive 0.14.0 and later)</span><br><span class="line">  [(col_name data_type [column_constraint_specification] [COMMENT col_comment], ... [constraint_specification])]</span><br><span class="line">  [COMMENT table_comment]</span><br><span class="line">  [PARTITIONED BY (col_name data_type [COMMENT col_comment], ...)]</span><br><span class="line">  [CLUSTERED BY (col_name, col_name, ...) [SORTED BY (col_name [ASC|DESC], ...)] INTO num_buckets BUCKETS]</span><br><span class="line">  [SKEWED BY (col_name, col_name, ...)                  -- (Note: Available in Hive 0.10.0 and later)]</span><br><span class="line">     ON ((col_value, col_value, ...), (col_value, col_value, ...), ...)</span><br><span class="line">     [STORED AS DIRECTORIES]</span><br><span class="line">  [</span><br><span class="line">   [ROW FORMAT row_format] </span><br><span class="line">   [STORED AS file_format]</span><br><span class="line">     | STORED BY &apos;storage.handler.class.name&apos; [WITH SERDEPROPERTIES (...)]  -- (Note: Available in Hive 0.6.0 and later)</span><br><span class="line">  ]</span><br><span class="line">  [LOCATION hdfs_path]</span><br><span class="line">  [TBLPROPERTIES (property_name=property_value, ...)]   -- (Note: Available in Hive 0.6.0 and later)</span><br><span class="line">  [AS select_statement];   -- (Note: Available in Hive 0.5.0 and later; not supported for external tables)</span><br><span class="line"> </span><br><span class="line">CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS] [db_name.]table_name</span><br><span class="line">  LIKE existing_table_or_view_name</span><br><span class="line">  [LOCATION hdfs_path];</span><br><span class="line"> </span><br><span class="line">data_type</span><br><span class="line">  : primitive_type</span><br><span class="line">  | array_type</span><br><span class="line">  | map_type</span><br><span class="line">  | struct_type</span><br><span class="line">  | union_type  -- (Note: Available in Hive 0.7.0 and later)</span><br><span class="line"> </span><br><span class="line">primitive_type</span><br><span class="line">  : TINYINT</span><br><span class="line">  | SMALLINT</span><br><span class="line">  | INT</span><br><span class="line">  | BIGINT</span><br><span class="line">  | BOOLEAN</span><br><span class="line">  | FLOAT</span><br><span class="line">  | DOUBLE</span><br><span class="line">  | DOUBLE PRECISION -- (Note: Available in Hive 2.2.0 and later)</span><br><span class="line">  | STRING</span><br><span class="line">  | BINARY      -- (Note: Available in Hive 0.8.0 and later)</span><br><span class="line">  | TIMESTAMP   -- (Note: Available in Hive 0.8.0 and later)</span><br><span class="line">  | DECIMAL     -- (Note: Available in Hive 0.11.0 and later)</span><br><span class="line">  | DECIMAL(precision, scale)  -- (Note: Available in Hive 0.13.0 and later)</span><br><span class="line">  | DATE        -- (Note: Available in Hive 0.12.0 and later)</span><br><span class="line">  | VARCHAR     -- (Note: Available in Hive 0.12.0 and later)</span><br><span class="line">  | CHAR        -- (Note: Available in Hive 0.13.0 and later)</span><br><span class="line"> </span><br><span class="line">array_type</span><br><span class="line">  : ARRAY &lt; data_type &gt;</span><br><span class="line"> </span><br><span class="line">map_type</span><br><span class="line">  : MAP &lt; primitive_type, data_type &gt;</span><br><span class="line"> </span><br><span class="line">struct_type</span><br><span class="line">  : STRUCT &lt; col_name : data_type [COMMENT col_comment], ...&gt;</span><br><span class="line"> </span><br><span class="line">union_type</span><br><span class="line">   : UNIONTYPE &lt; data_type, data_type, ... &gt;  -- (Note: Available in Hive 0.7.0 and later)</span><br><span class="line"> </span><br><span class="line">row_format</span><br><span class="line">  : DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">        [MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</span><br><span class="line">        [NULL DEFINED AS char]   -- (Note: Available in Hive 0.13 and later)</span><br><span class="line">  | SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</span><br><span class="line"> </span><br><span class="line">file_format:</span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  | TEXTFILE    -- (Default, depending on hive.default.fileformat configuration)</span><br><span class="line">  | RCFILE      -- (Note: Available in Hive 0.6.0 and later)</span><br><span class="line">  | ORC         -- (Note: Available in Hive 0.11.0 and later)</span><br><span class="line">  | PARQUET     -- (Note: Available in Hive 0.13.0 and later)</span><br><span class="line">  | AVRO        -- (Note: Available in Hive 0.14.0 and later)</span><br><span class="line">  | JSONFILE    -- (Note: Available in Hive 4.0.0 and later)</span><br><span class="line">  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br><span class="line"> </span><br><span class="line">column_constraint_specification:</span><br><span class="line">  : [ PRIMARY KEY|UNIQUE|NOT NULL|DEFAULT [default_value]|CHECK  [check_expression] ENABLE|DISABLE NOVALIDATE RELY/NORELY ]</span><br><span class="line"> </span><br><span class="line">default_value:</span><br><span class="line">  : [ LITERAL|CURRENT_USER()|CURRENT_DATE()|CURRENT_TIMESTAMP()|NULL ] </span><br><span class="line"> </span><br><span class="line">constraint_specification:</span><br><span class="line">  : [, PRIMARY KEY (col_name, ...) DISABLE NOVALIDATE RELY/NORELY ]</span><br><span class="line">    [, PRIMARY KEY (col_name, ...) DISABLE NOVALIDATE RELY/NORELY ]</span><br><span class="line">    [, CONSTRAINT constraint_name FOREIGN KEY (col_name, ...) REFERENCES table_name(col_name, ...) DISABLE NOVALIDATE </span><br><span class="line">    [, CONSTRAINT constraint_name UNIQUE (col_name, ...) DISABLE NOVALIDATE RELY/NORELY ]</span><br><span class="line">    [, CONSTRAINT constraint_name CHECK [check_expression] ENABLE|DISABLE NOVALIDATE RELY/NORELY ]</span><br></pre></td></tr></table></figure>
<p>(👆来自官网 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL</a><br>[] 表示可选，| 表示选其一)</p>
<p>注：</p>
<ul>
<li>不使用 EXTERNAL 时，创建的是内部表。</li>
<li>表和列的注释（COMMENT）是字符串文字(单引号)。</li>
<li>要为表指定一个数据库，要么在<code>CREATE TABLE</code>语句之前使用<code>USE database_name</code>语句，要么用一个数据库名称限定表名(<code>database_name.table_name</code>)。</li>
<li>See <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-AlterTable" target="_blank" rel="noopener">Alter Table</a> for more information about table comments, table properties, and SerDe properties.</li>
<li>See <a href="https://cwiki.apache.org/confluence/display/Hive/Tutorial#Tutorial-TypeSystem" target="_blank" rel="noopener">Type System</a> and <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Types" target="_blank" rel="noopener">Hive Data Types</a> for details about the primitive and complex data types.</li>
</ul>
<p>这里我们针对里面的一些不同于关系型数据库的地方进行说明。</p>
<h4 id="3-1-1-row-format"><a href="#3-1-1-row-format" class="headerlink" title="3.1.1 row format"></a><span id="jump3.1.1">3.1.1 row format</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ROW FORMAT DELIMITED [FIELDS TERMINATED BY char [ESCAPED BY char]] [COLLECTION ITEMS TERMINATED BY char]</span><br><span class="line">[MAP KEYS TERMINATED BY char] [LINES TERMINATED BY char]</span><br><span class="line">[NULL DEFINED AS char]   -- (Note: Available in Hive 0.13 and later)</span><br><span class="line">| SERDE serde_name [WITH SERDEPROPERTIES (property_name=property_value, property_name=property_value, ...)]</span><br></pre></td></tr></table></figure>
<p>Hive将HDFS上的文件映射成表结构，通过分隔符来区分列（比如‘,’, ‘;’ or ‘^’等），row format就是用于指定序列化和反序列化的规则。<br>比如对于以下记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,xiaoming,book-TV-code,beijing:chaoyang-shagnhai:pudong</span><br><span class="line">2,lilei,book-code,nanjing:jiangning-taiwan:taibei</span><br><span class="line">3,lihua,music-book,heilongjiang:haerbin</span><br></pre></td></tr></table></figure>
<p><strong>逗号</strong>用于分割列，即FIELDS TERMINATED BY ‘,’，分割为如下列 <strong>ID</strong>、<strong>name</strong>、<strong>hobby</strong>（该字段是数组形式，通过 ‘-’ 进行分割，即COLLECTION ITEMS TERMINATED BY ‘-’）、<strong>address</strong>（该字段是键值对形式map，通过 ‘:’ 分割键值，即 MAP KEYS TERMINATED BY ‘:’）；<br>而 LINES TERMINATED BY char 用于区分不同条的数据，默认是换行符；</p>
<p>写法形如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> xxx(</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line">FILEDS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span> </span><br><span class="line">COLLECTION ITEMS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'-'</span> </span><br><span class="line"><span class="keyword">MAP</span> <span class="keyword">KEYS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">':'</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>(↑未测试)</p>
<h4 id="3-1-2-file-format（HDFS文件存放的格式）"><a href="#3-1-2-file-format（HDFS文件存放的格式）" class="headerlink" title="3.1.2 file format（HDFS文件存放的格式）"></a><span id="jump3.1.2">3.1.2 file format（HDFS文件存放的格式）</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">file_format:</span><br><span class="line">  : SEQUENCEFILE</span><br><span class="line">  | TEXTFILE    -- (Default, depending on hive.default.fileformat configuration)</span><br><span class="line">  | RCFILE      -- (Note: Available in Hive 0.6.0 and later)</span><br><span class="line">  | ORC         -- (Note: Available in Hive 0.11.0 and later)</span><br><span class="line">  | PARQUET     -- (Note: Available in Hive 0.13.0 and later)</span><br><span class="line">  | AVRO        -- (Note: Available in Hive 0.14.0 and later)</span><br><span class="line">  | JSONFILE    -- (Note: Available in Hive 4.0.0 and later)</span><br><span class="line">  | INPUTFORMAT input_format_classname OUTPUTFORMAT output_format_classname</span><br></pre></td></tr></table></figure>
<p>默认TEXTFILE，即文本格式，可以直接打开。</p>
<h6 id="3-1-2-1-TEXTFILE"><a href="#3-1-2-1-TEXTFILE" class="headerlink" title="3.1.2.1 TEXTFILE"></a>3.1.2.1 TEXTFILE</h6><p>TEXTFILE就是普通的文本型文件，是 Hadoop 里最常用的输入输出格式，也是 Hive 的默认文件格式。如果表定义为TEXTFILE，则可以向该表中装载以逗号、TAB或空格作为分隔符的数据，也可以导入JSON格式的数据。<br>文本文件中除了可以包含普通的字符串、数字、日期等简单数据类型外，还可以包含复杂的集合数据类型。Hive 支持 <strong>STRUCT</strong>、<strong>MAP</strong> 和 <strong>ARRAY</strong> 三种集合数据类型。</p>
<h6 id="示例1：以TAB为列间分隔符的文本文件"><a href="#示例1：以TAB为列间分隔符的文本文件" class="headerlink" title="示例1：以TAB为列间分隔符的文本文件"></a><span style="color:blue">示例1：以TAB为列间分隔符的文本文件</span></h6><p>创建一个文本文件/root/data.csv，录入四列两行数据，列之间用TAB符号作为分隔符，文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a1	1	b1	c1</span><br><span class="line">a2	2	b2	c2</span><br></pre></td></tr></table></figure>
<p>执行下面的语句创建表、装载数据、查询表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立TEXTFILE格式的表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_textfile(</span><br><span class="line">    c1 <span class="keyword">string</span>, </span><br><span class="line">    c2 <span class="built_in">int</span>, </span><br><span class="line">    c3 <span class="keyword">string</span>, </span><br><span class="line">    c4 <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> </span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br><span class="line"><span class="comment">-- 向表中导入数据</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'root/data.csv'</span> <span class="keyword">into</span> <span class="keyword">table</span> t_textfile;</span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_textfile;</span><br></pre></td></tr></table></figure>
<p>查询结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; select * from t_textfile;</span><br><span class="line">OK</span><br><span class="line">a1	1	b1	c1</span><br><span class="line">a2	2	b2	c2</span><br><span class="line">Time taken: 0.493 seconds, Fetched: 2 row(s)</span><br></pre></td></tr></table></figure>
<h6 id="示例2：JSON格式的数据文件"><a href="#示例2：JSON格式的数据文件" class="headerlink" title="示例2：JSON格式的数据文件"></a><span style="color:blue">示例2：JSON格式的数据文件</span></h6><p>建立一个json文件/root/simple.json，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;foo&quot;:&quot;abc&quot;, &quot;bar&quot;:&quot;2009101100000&quot;, &quot;quux&quot;:&#123;&quot;quuxid&quot;:1234, &quot;quuxname&quot;:&quot;sam&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>执行下面的语句创建表、装载数据、查询表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据实际目录添加hive-hcatalog-core.jar包</span></span><br><span class="line">add jar /opt/cloudera/parcels/CDH-5.7.0-1.cdh5.7.0.p0.45/lib/oozie/libtools/hive-hcatalog-core.jar;</span><br><span class="line"><span class="comment">-- 建立测试表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> my_table(</span><br><span class="line">	foo <span class="keyword">string</span>,</span><br><span class="line">	bar <span class="keyword">string</span>,</span><br><span class="line">	quux <span class="keyword">struct</span>&lt;quuxid:<span class="built_in">int</span>, quuxname:<span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> serde <span class="string">'org.apache.hive.hcatalog.data.JsonSerDe'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br><span class="line"><span class="comment">-- 装载数据</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/simple.json'</span> <span class="keyword">into</span> <span class="keyword">table</span> my_table;</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> foo, bar, quux.quuxid, quux.quuxname <span class="keyword">from</span> my_table;</span><br></pre></td></tr></table></figure>
<p>查询结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK</span><br><span class="line">abc	2009101100000	1234	sam</span><br><span class="line">Time taken: 22.051 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<h6 id="示例3：complex-json表中含有结构类型嵌套和结构、数组、结构三层嵌套。"><a href="#示例3：complex-json表中含有结构类型嵌套和结构、数组、结构三层嵌套。" class="headerlink" title="示例3：complex_json表中含有结构类型嵌套和结构、数组、结构三层嵌套。"></a><span style="color:blue">示例3：complex_json表中含有结构类型嵌套和结构、数组、结构三层嵌套。</span></h6><p>建立一个json文件/root/complex.json，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;docid&quot;:&quot;abc&quot;, &quot;user&quot;:</span><br><span class="line">	&#123;&quot;id&quot;:1234, &quot;username&quot;:&quot;sam1234&quot;, &quot;name&quot;:&quot;sam&quot;,	&quot;shippingaddress&quot;:</span><br><span class="line">		&#123;&quot;address1&quot;:&quot;123 main st.&quot;, &quot;address2&quot;:&quot;&quot;, &quot;city&quot;:&quot;durham&quot;, &quot;state&quot;:&quot;nc&quot;&#125;, </span><br><span class="line">	&quot;orders&quot;:[&#123;&quot;itemid&quot;:6789, &quot;orderdate&quot;:&quot;11/11/2012&quot;&#125;,&#123;&quot;itemid&quot;:4352, &quot;orderdate&quot;:&quot;12/12/2012&quot;&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行下面的语句创建表、装载数据、查询表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立测试表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> complex_json(</span><br><span class="line">	docid <span class="keyword">string</span>,</span><br><span class="line">	<span class="keyword">user</span> <span class="keyword">struct</span>&lt;<span class="keyword">id</span>: <span class="built_in">int</span>,</span><br><span class="line">				username: <span class="keyword">string</span>,</span><br><span class="line">				<span class="keyword">name</span>:	<span class="keyword">string</span>,</span><br><span class="line">				shippingaddress: strcuct&lt;address1: <span class="keyword">string</span>,</span><br><span class="line">										 address2: <span class="keyword">string</span>,</span><br><span class="line">										 city: <span class="keyword">string</span>,</span><br><span class="line">										 state: <span class="keyword">string</span>&gt;,</span><br><span class="line">				orders: <span class="built_in">array</span>&lt;<span class="keyword">struct</span>&lt;itemid:<span class="built_in">int</span>,</span><br><span class="line">									 oderdatate:<span class="keyword">string</span>&gt;&gt;</span><br><span class="line">    			&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> serde <span class="string">'org.apache.hive.hcatalog.data.JsonSerDe'</span></span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> textfile;</span><br><span class="line"><span class="comment">-- 装载数据</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/complex.json'</span> overwrite <span class="keyword">into</span> <span class="keyword">table</span> complex_json;</span><br><span class="line"><span class="comment">-- 查询</span></span><br><span class="line"><span class="keyword">select</span> docid, user.id, user.shipping address.city <span class="keyword">as</span> city,</span><br><span class="line">	user.orders[<span class="number">0</span>].itemid <span class="keyword">as</span> order0id,</span><br><span class="line">	user.orders[<span class="number">1</span>].itemid <span class="keyword">as</span> order1id</span><br><span class="line"><span class="keyword">from</span> complex_json;</span><br></pre></td></tr></table></figure>
<p>查询结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK</span><br><span class="line">abc	1234	durham	6789	4352</span><br><span class="line">Time taken: 18.744 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<p>查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> docid, user.id, user.orders.itemid <span class="keyword">from</span> complex_json;</span><br></pre></td></tr></table></figure>
<p>查询结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OK</span><br><span class="line">abc	1234	[6789,4352]</span><br><span class="line">Time taken: 17.755 seconds, Fetched: 1 row(s)</span><br></pre></td></tr></table></figure>
<h6 id="3-1-2-2-SEQUENCEFILE"><a href="#3-1-2-2-SEQUENCEFILE" class="headerlink" title="3.1.2.2  SEQUENCEFILE"></a>3.1.2.2  SEQUENCEFILE</h6><p>Hadoop处理少量大文件比大量小文件的性能要好。如果文件小于Hadoop定义的块尺寸（Hadoop 2.x默认是128MB），可以认为是小文件。元数据的增长将转化为NameNode的开销。如果有大量小文件，NameNode会成为性能瓶颈。为了解决这个问题，Hadoop引入了sequence文件，将sequence作为存储小文件的容器。</p>
<p>Sequence文件是由二进制键值对组成的平面文件。Hive将查询转化成MapReduce作业时，决定一个给定记录的哪些键/值对被使用。Sequence文件是可分割的二进制格式，主要的用途是联合多个小文件。</p>
<p>SEQUENCEFILE格式的输入输出包是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.hadoop.mapred.SequenceFileInputFormat</span><br><span class="line">org.apache.hadoop.hive.ql.io.HiveSequenceFileOutputFormat</span><br></pre></td></tr></table></figure>
<h6 id="示例"><a href="#示例" class="headerlink" title="示例"></a><span style="color:blue">示例</span></h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立SEQUENCEFILE格式的表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_sequencefile(</span><br><span class="line">    c1 <span class="keyword">string</span>, </span><br><span class="line">    c2 <span class="built_in">int</span>, </span><br><span class="line">    c3 <span class="keyword">string</span>, </span><br><span class="line">    c4 <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> </span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> sequencefile;</span><br><span class="line"><span class="comment">-- 向表中导入数据</span></span><br><span class="line"><span class="comment">-- 与TEXTFILE有些不同，因为SEQUENCEFILE是二进制格式，所以需要从其他表向SEQUENCEFILE表插入数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_sequencefile <span class="keyword">select</span> * <span class="keyword">from</span> t_textfile;</span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_sequencefile;</span><br></pre></td></tr></table></figure>
<h6 id="3-1-2-3-RCFILE"><a href="#3-1-2-3-RCFILE" class="headerlink" title="3.1.2.3 RCFILE"></a>3.1.2.3 RCFILE</h6><p>RCFILE指的是Record Columnar File，是一种高压缩率的二进制文件格式，被用于在一个时间点操作多行的场景。RCFILEs是由二进制键/值对组成的平面文件。RCFILE以记录的形式存储表中的列，即<strong>列存储方式</strong>。它先分割行做水平分区，然后分割列做垂直分区。RCFILE把一行的元数据作为键，把行数据作为值。这种面向列的存储在执行数据分析时更高效。</p>
<p>RCFILE格式的输入输出包是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.hadoop.hive.ql.io.RCFileInputFormat</span><br><span class="line">org.apache.hadoop.hive.ql.io.RCFileOutputFormat</span><br></pre></td></tr></table></figure>
<h6 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><span style="color:blue">示例</span></h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立RCFILE格式的表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_rcfile(</span><br><span class="line">    c1 <span class="keyword">string</span>, </span><br><span class="line">    c2 <span class="built_in">int</span>, </span><br><span class="line">    c3 <span class="keyword">string</span>, </span><br><span class="line">    c4 <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> </span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> rcfile;</span><br><span class="line"><span class="comment">-- 向表中导入数据</span></span><br><span class="line"><span class="comment">-- 不能直接向RCFILE表中导入数据，需要从其他表向RCFILE表插入数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_rcfile <span class="keyword">select</span> * <span class="keyword">from</span> t_textfile;</span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_rcfile;</span><br></pre></td></tr></table></figure>
<h6 id="3-1-2-4-ORCFILE"><a href="#3-1-2-4-ORCFILE" class="headerlink" title="3.1.2.4 ORCFILE"></a>3.1.2.4 ORCFILE</h6><p>ORC指的是Optimized Record Columnar，即相对于其他文件格式，它以更优化的方式存储数据。ORC能将原始数据的大小缩减75%，从而提升了数据处理的速度。ORC比Text、Sequence和RC文件格式有更好的性能，而且ORC是目前Hive中唯一支持事务的文件格式。</p>
<p>ORCFILE格式的输入输出包是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.apache.hadoop.hive.ql.io.orc</span><br></pre></td></tr></table></figure>
<h6 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><span style="color:blue">示例</span></h6><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建立ORCFILE格式的表</span></span><br><span class="line"><span class="keyword">use</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_orcfile(</span><br><span class="line">    c1 <span class="keyword">string</span>, </span><br><span class="line">    c2 <span class="built_in">int</span>, </span><br><span class="line">    c3 <span class="keyword">string</span>, </span><br><span class="line">    c4 <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span> </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span> </span><br><span class="line"><span class="keyword">stored</span> <span class="keyword">as</span> orcfile;</span><br><span class="line"><span class="comment">-- 向表中导入数据</span></span><br><span class="line"><span class="comment">-- 不能直接向ORCFILE表中导入数据，需要从其他表向ORCFILE表插入数据</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> t_orcfile <span class="keyword">select</span> * <span class="keyword">from</span> t_textfile;</span><br><span class="line"><span class="comment">-- 查询表</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_orcfile;</span><br></pre></td></tr></table></figure>
<h6 id="3-1-2-5-总结"><a href="#3-1-2-5-总结" class="headerlink" title="3.1.2.5 总结"></a>3.1.2.5 总结</h6><p>应该依数据需求选择适当的文件格式，如：</p>
<ul>
<li>如果数据有参数化的分隔符，那么可以选择TEXTFILE格式</li>
<li>如果数据所在文件比块尺寸小，可以选择SEQUENCEFILE格式</li>
<li>如果想执行数据分析，并高效地存储数据，可以选择RCFILE格式</li>
<li>如果希望减小数据所需的存储空间并提升性能，可以选择ORCFILE格式</li>
</ul>
<h4 id="3-1-3-例子：创建内部表"><a href="#3-1-3-例子：创建内部表" class="headerlink" title="3.1.3 例子：创建内部表"></a>3.1.3 例子：创建内部表</h4><p>如下：根据上述文件内容(见<a href="#jump3.1.1">3.1.1 row format</a>)，创建一个表t1</p>
<h5 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1. 创建表"></a>1. 创建表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">id</span>      <span class="built_in">int</span>,</span><br><span class="line">    <span class="keyword">name</span>    <span class="keyword">string</span>,</span><br><span class="line">    hobby   <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;,</span><br><span class="line">    <span class="keyword">add</span>     <span class="keyword">map</span>&lt;<span class="keyword">String</span>,<span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'-'</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p> <img src="/2020/01/12/Hive介绍/1603599880662.png" alt="1603599880662"></p>
<h5 id="2-查看表的描述"><a href="#2-查看表的描述" class="headerlink" title="2.查看表的描述"></a>2.查看表的描述</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc t1;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603599824805.png" alt="1603599824805"></p>
<h5 id="3-装载数据"><a href="#3-装载数据" class="headerlink" title="3. 装载数据"></a><span id="jump3.1.3.3">3. 装载数据</span></h5><blockquote>
<p>参考《Hadoop构建数据仓库实践》</p>
</blockquote>
<h6 id="a-向非分区表中装载数据"><a href="#a-向非分区表中装载数据" class="headerlink" title="a. 向非分区表中装载数据"></a>a. 向非分区表中装载数据</h6><p><strong>（1）使用 LOAD</strong></p>
<p>先准备一个本地文本文件 a.txt，其中只有一行记录 ‘aaa’.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;mkdir test</span><br><span class="line">&gt;cd test</span><br><span class="line">&gt;echo &apos;aaa&apos; &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>将这行记录装载到一个表中，并查看HDFS上生成的数据文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; use test;</span><br><span class="line">hive&gt; drop table if exists t1;</span><br><span class="line">hive&gt; create table t1(name string);</span><br><span class="line">hive&gt; load data local inpath &apos;/root/test&apos; into table t1;</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1;</span><br><span class="line">Found 1 items</span><br><span class="line">-rwxrwxrwt	3	root	hive	4	2016-10-20	13:52	/user/hive/warehouse/test.db/t1/a.txt</span><br><span class="line">hive&gt; dfs -cat /user/hive/warehouse/test.db/t1/a.txt;</span><br><span class="line">aaa</span><br></pre></td></tr></table></figure>
<p>可以看到，hive命令行中除了可以执行HiveQL语句，还可以执行Hadoop的dfs命令。<strong>Load语句实际执行了一个复制文件的操作</strong>。通常我们在load语句中指定的路径是一个目录，而不是单个独立的文件。Hive会将该目录下的所有文件都复制到目标位置。这使得用户将更方便地组织数据到多个文件中，同时可以在不修改Hive脚本的前提下修改文件命名规则。文件会被复制到目标路径下而且文件名保持不变。</p>
<p>上面的HiveQL语句向t1表中装载了数据’aaa’，并在默认的数据仓库目录下生成了数据文件 /user/hive/warehouse/test.db/t1/a.txt，实际上数据文件是纯文本格式，内容就是 ‘aaa’。</p>
<p>在本地文件a.txt中添加一行’bbb’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;bbb&apos; &gt;&gt; a.txt</span><br></pre></td></tr></table></figure>
<p>然后再执行下面的HiveQL语句并查看结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; load data local inpath &apos;/root/test&apos; into table t1;</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1;</span><br><span class="line">Found 2 items</span><br><span class="line">-rwxrwxrwt	3	root	hive	4	2016-10-20	13:52	/user/hive/warehouse/test.db/t1/a.txt</span><br><span class="line">-rwxrwxrwt	3	root	hive	8	2016-10-20	14:18	/user/hive/warehouse/test.db/t1/a_copy_1.txt</span><br><span class="line">hive&gt; dfs -cat /user/hive/warehouse/test.db/t1/a.txt;</span><br><span class="line">aaa</span><br><span class="line">hive&gt; dfs -cat /user/hive/warehouse/test.db/t1/a_copy_1.txt;</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure>
<p>可以看到，现在表中有3条数据，并且新生成了数据文件a_copy_1.txt。原来的a.txt文件中的内容还是’aaa’，新生成的a_copy_1.txt文件中的内容是第二次装载的两行数据。即，每次装载会生成一个新的文件，如果目录中装载的文件已经存在，那么再次装载会生成一个原文件的复制，表中数据对应的是表目录下的所有文件的内容。</p>
<p><strong>（2）使用 LOAD OVERWRITE</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; drop table if exists t2;</span><br><span class="line">hive&gt; create table t2(name string);</span><br><span class="line">hive&gt; load data local inpath &apos;/root/test&apos; overwrite into table t2;</span><br><span class="line">hive&gt; select * from t2;</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t2;</span><br><span class="line">Found 1 items</span><br><span class="line">-rwxrwxrwt	3	root	hive	8	2016-10-20	14:43	/user/hive/warehouse/test.db/t2/a.txt</span><br><span class="line">hive&gt; dfs -cat /user/hive/warehouse/test.db/t2/a.txt;</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br></pre></td></tr></table></figure>
<p>可以看到，现在t2表中只有两条数据，在表目录下生成了数据文件a.txt。现在编辑本地文件a.txt，使其只有一行’ccc’。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &apos;ccc&apos; &gt; a.txt</span><br></pre></td></tr></table></figure>
<p>再执行下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; load data local inpath &apos;/root/test&apos; overwrite into table t2;</span><br><span class="line">hive&gt; select * from t2;</span><br><span class="line">ccc</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t2;</span><br><span class="line">Found 1 items</span><br><span class="line">-rwxrwxrwt	3	root	hive	4	2016-10-20	14:50	/user/hive/warehouse/test.db/t2/a.txt</span><br><span class="line">hive&gt; dfs -cat /user/hive/warehouse/test.db/t2/a.txt;</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>
<p>可以看到，现在表中只有一条数据’ccc’，数据文件名没变，但其内容重新生成。</p>
<h6 id="b-向分区表中装载数据"><a href="#b-向分区表中装载数据" class="headerlink" title="b. 向分区表中装载数据"></a>b. 向分区表中装载数据</h6><p><strong>（1）load</strong></p>
<p>准备本地文本文件a.txt，其中只有一行’aaa’，然后执行下面的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; create table  t1(name string) partitioned by (country string, state string);</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1;</span><br><span class="line">hive&gt; load data local inpath &apos;/root/test&apos; into table t1 partition (country=&apos;us&apos;, state=&apos;ca&apos;);</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa	us	ca</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1/country=us/state=ca;</span><br><span class="line">Found 1 items</span><br><span class="line">-rwxrwxrwt	3	root	hive	4	2016-10-20	15:10	/user/hive/warehouse/test.db/t1/country=us/state=ca/a.txt</span><br></pre></td></tr></table></figure>
<p>可以看到，建立t1表后，装载数据前，表目录下没有任何文件。<strong>load语句创建了分区目录country=us/state=ca，并将本地文件复制到分区目录下</strong>。从查询的角度看，<strong>向t1表中装载了数据’aaa’</strong>。<strong>查询结果显示了三列，除了原始的文本文件中的数据，还包括了两个分区列的值。分区列总是在表的最后显示</strong>。</p>
<p>load overwrite装载数据与非分区表类似，不再赘述。</p>
<p><strong>（2）alter table tablename add partition</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt; alter table t1 add partition(country=&apos;us&apos;, state=&apos;cb&apos;) location &apos;/a&apos;;</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1/country=us;</span><br><span class="line">Found 1 items</span><br><span class="line">drwxrwxrwt	-	root	hive	0	2016-10-20	15:40	/user/hive/warehouse/test.db/t1/country=us/state=ca</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa	us	ca</span><br><span class="line">hive&gt; dfs -cp /user/hive/warehouse/test.db/t1/country=us/state=ca/a.txt /a;</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa	us	ca</span><br><span class="line">aaa	us	cb</span><br><span class="line">hive&gt; dfs -ls /user/hive/warehouse/test.db/t1/country=us;</span><br><span class="line">Found 1 items</span><br><span class="line">drwxrwxrwt	-	root	hive	0	2016-10-20	15:40	/user/hive/warehouse/test.db/t1/country=us/state=ca</span><br><span class="line">hive&gt; dfs -ls /a;</span><br><span class="line">Found 1 items</span><br><span class="line">-rw-r--r--	3	root	supergroup	4	2016-10-20	15:41	/a/a.txt</span><br><span class="line">hive&gt; dfs -rm /user/hive/warehouse/test.db/t1/country=us/state=ca/a.txt;</span><br><span class="line">hive&gt; select * from t1;</span><br><span class="line">aaa	us	cb</span><br></pre></td></tr></table></figure>
<p>说明：表中原有一条数据’aaa’。添加一个新分区，并指定位置为’/a’。把已经存在的数据文件a.txt复制到目录’/a’里。此时查询已经有属于不同分区的两条数据。删除country=’us’且state=’ca’分区的数据文件。此时查询表只有属于country=’us’且state=’cb’分区的一条数据。整个过程中HDFS中都没有存在过coutry=us/state=cb的目录。</p>
<p><strong>对Hive表的数据装载特性总结如下：</strong></p>
<ul>
<li>load与load overwrite的区别是：<ul>
<li>load：每次执行会生成新的数据文件，文件中是本次装载的数据，表中数据对应的是表目录下的所有文件的内容。</li>
<li>load overwrite：若表（或分区）的数据文件不存在则生成，存在则重新生成数据文件内容（覆盖掉以前的）。</li>
</ul>
</li>
<li>分区表比非分区表多了一种alter table … add partition的数据装载方式</li>
<li>对于分区表（无论内部还是外部），load与load overwrite会自动建立名为分区键值的目录，而alter table … add partition，只要用location指定数据文件所在的目录即可。</li>
<li>对于外部表，除了在删除表时只删除元数据而保留表数据目录外，其数据装载行为与内部表相同。</li>
</ul>
<hr>
<p>创建一个文件粘贴上述记录，并上载即可，如下图：</p>
<p><img src="/2020/01/12/Hive介绍/1603600131112.png" alt="1603600131112"></p>
<p>然后上载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local inpath &apos;/home/hadoop/Desktop/data&apos; overwrite into table t1;</span><br></pre></td></tr></table></figure>
<p>查看表内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from t1;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603600188322.png" alt="1603600188322"></p>
<h5 id="4-查看文件位置"><a href="#4-查看文件位置" class="headerlink" title="4. 查看文件位置"></a>4. 查看文件位置</h5><p>t1表在哪儿呢？在我们之前配置的默认路径里（/user/hive/warehouse）</p>
<p><img src="/2020/01/12/Hive介绍/1603609902727.png" alt="1603609902727"></p>
<p>通过命令行获取位置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc formatted table_name;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603610044780.png" alt="1603610044780"></p>
<h5 id="5-删除内部表"><a href="#5-删除内部表" class="headerlink" title="5. 删除内部表"></a>5. 删除内部表</h5><p><img src="/2020/01/12/Hive介绍/1603610161316.png" alt="1603610161316"></p>
<p><img src="/2020/01/12/Hive介绍/1603610193337.png" alt="1603610193337"></p>
<p>观察HDFS上的文件，发现t1已经不在了</p>
<p><img src="/2020/01/12/Hive介绍/1603610402205.png" alt="1603610402205"></p>
<h4 id="3-1-4-例子：创建外部表"><a href="#3-1-4-例子：创建外部表" class="headerlink" title="3.1.4 例子：创建外部表"></a>3.1.4 例子：创建外部表</h4><h5 id="1-创建表-1"><a href="#1-创建表-1" class="headerlink" title="1. 创建表"></a>1. 创建表</h5><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> t2(</span><br><span class="line">    <span class="keyword">id</span>      <span class="built_in">int</span></span><br><span class="line">   ,<span class="keyword">name</span>    <span class="keyword">string</span></span><br><span class="line">   ,hobby   <span class="built_in">array</span>&lt;<span class="keyword">string</span>&gt;</span><br><span class="line">   ,<span class="keyword">add</span>     <span class="keyword">map</span>&lt;<span class="keyword">String</span>,<span class="keyword">string</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span></span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span></span><br><span class="line">collection items <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'-'</span></span><br><span class="line"><span class="keyword">map</span> <span class="keyword">keys</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">':'</span></span><br><span class="line">location <span class="string">'/user/t2'</span></span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603600496450.png" alt="1603600496450"></p>
<h5 id="2-装载数据"><a href="#2-装载数据" class="headerlink" title="2. 装载数据"></a>2. 装载数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">load data local inpath &apos;/home/hadoop/Desktop/data&apos; overwrite into table t2;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603600549196.png" alt="1603600549196"></p>
<h5 id="3-查看文件位置"><a href="#3-查看文件位置" class="headerlink" title="3. 查看文件位置"></a>3. 查看文件位置</h5><p>在/user/目录下，可以看到t2文件</p>
<p><img src="/2020/01/12/Hive介绍/1603609992170.png" alt="1603609992170"></p>
<p>通过命令行获得位置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc formatted table_name;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603610068333.png" alt="1603610068333"></p>
<h5 id="4-删除外部表"><a href="#4-删除外部表" class="headerlink" title="4. 删除外部表"></a>4. 删除外部表</h5><p><img src="/2020/01/12/Hive介绍/1603610449476.png" alt="1603610449476"></p>
<p><img src="/2020/01/12/Hive介绍/1603610471246.png" alt="1603610471246"></p>
<p>观察HDFS上的文件，t2仍然存在</p>
<p><img src="/2020/01/12/Hive介绍/1603610518016.png" alt="1603610518016"></p>
<p>因而删除外部表仅仅会删除元数据。</p>
<p>重新创建外部表t2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create external table t2(</span><br><span class="line">    id      int</span><br><span class="line">   ,name    string</span><br><span class="line">   ,hobby   array&lt;string&gt;</span><br><span class="line">   ,add     map&lt;String,string&gt;</span><br><span class="line">)</span><br><span class="line">row format delimited</span><br><span class="line">fields terminated by &apos;,&apos;</span><br><span class="line">collection items terminated by &apos;-&apos;</span><br><span class="line">map keys terminated by &apos;:&apos;</span><br><span class="line">location &apos;/user/t2&apos;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/Hive介绍/1603610616445.png" alt="1603610616445"></p>
<p>不往里面插入数据，我们select * 看看结果</p>
<p><img src="/2020/01/12/Hive介绍/1603610644871.png" alt="1603610644871"></p>
<p>可见数据仍然在！</p>
<h3 id="3-2-法二：查询建表法（Create-Table-As-Select-CTAS-）"><a href="#3-2-法二：查询建表法（Create-Table-As-Select-CTAS-）" class="headerlink" title="3.2 法二：查询建表法（Create Table As Select (CTAS)）"></a>3.2 法二：查询建表法（Create Table As Select (CTAS)）</h3><p>通过AS 查询语句完成建表：<strong>将子查询的结果存在新表里，有数据</strong><br>一般用于中间表。</p>
<p>可以通过一个create-table-as-select（CTAS）语句中的查询结果来创建和填充表。 CTAS创建的表是原子表，这意味着在填充所有查询结果之前，其他用户不会看到该表。因此，其他用户要么看到包含完整查询结果的表，要么根本看不到表。</p>
<p>CTAS有两部分，SELECT部分可以是HiveQL支持的任何SELECT语句 (<a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select" target="_blank" rel="noopener">SELECT statement</a>)； CREATE部分从SELECT部分获取schema，并使用其他表属性（例如SerDe和存储格式）创建目标表。( The CREATE part of the CTAS takes the resulting schema from the SELECT part and creates the target table with other table properties such as the SerDe and storage format.)</p>
<p>CTAS具有以下限制：</p>
<blockquote>
<p>参考 <a href="https://blog.csdn.net/qq_26442553/article/details/79593504" target="_blank" rel="noopener">使用create table …as创建表时要注意的问题_涤生手记-CSDN博客</a></p>
</blockquote>
<ul>
<li><p>目标表不能是外部表。</p>
</li>
<li><p>目标表不能是列表存储表 (list bucketing table)。</p>
</li>
<li><p>hive中用CTAS创建表，所创建的表统一都是非分区表，不管源表是否是分区表。所以对于分区表的创建使用CTAS一定要注意分区功能的丢失。当然创建表以后可以添加分区，成为分区表（从Hive 3.2.0开始，CTAS语句可以为目标表定义分区规范。(can define a partitioning specification for the target table (<a href="https://issues.apache.org/jira/browse/HIVE-20241" target="_blank" rel="noopener">HIVE-20241</a>) 示例如下：（关于如何查询hive版本，见 <a href="#jump6">6.命令</a>））</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE partition_ctas_1 PARTITIONED BY (key) AS</span><br><span class="line">SELECT value, key FROM src where key &gt; 200 and key &lt; 300;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CTAS创建表时不能添加注释，这种方式多用于临时表、中间表的创建，不是结果表，且即使源表有注释，使用CTAS创建的表也会丢失源表的字段注释。</p>
</li>
</ul>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE new_key_value_store</span><br><span class="line">   ROW FORMAT SERDE &quot;org.apache.hadoop.hive.serde2.columnar.ColumnarSerDe&quot;</span><br><span class="line">   STORED AS RCFile</span><br><span class="line">   AS</span><br><span class="line">SELECT (key % 1024) new_key, concat(key, value) key_value_pair</span><br><span class="line">FROM key_value_store</span><br><span class="line">SORT BY new_key, key_value_pair;</span><br></pre></td></tr></table></figure>
<p>上面的CTAS语句使用从SELECT语句结果得到的schema（new_key DOUBLE，key_value_pair STRING）创建目标表new_key_value_store。如果SELECT语句未指定列别名，则列名将自动分配给_col0，_col1和_col2等。此外，新目标表是使用特定的SerDe和存储格式创建的，独立于SELECT语句里的源表。</p>
<p>Starting with <a href="https://issues.apache.org/jira/browse/HIVE-1180" target="_blank" rel="noopener">Hive 0.13.0</a>, the SELECT statement can include one or more common table expressions (CTEs), as shown in the <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select#LanguageManualSelect-SelectSyntax" target="_blank" rel="noopener">SELECT syntax</a>. For an example, see <a href="https://cwiki.apache.org/confluence/display/Hive/Common+Table+Expression#CommonTableExpression-CTEinViews,CTAS,andInsertStatements" target="_blank" rel="noopener">Common Table Expression</a>.<br>（关于CTEs的介绍见 <a href="https://www.cnblogs.com/Neo-ds/p/4804900.html" target="_blank" rel="noopener">Common Table Expressions (CTE) - ndong - 博客园 (cnblogs.com)</a>）</p>
<p>能够<strong>从一个表选择数据到另一个表</strong>是Hive最强大的特性之一。Hive在执行查询时处理数据从源格式到目标格式的转换。</p>
<p>根据例子我们建一张表：t3</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t3 as</span><br><span class="line">select</span><br><span class="line">    id,</span><br><span class="line">    name</span><br><span class="line">from t2</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>会执行MapReduce过程。<br>查看表结构及内容，发现是有数据的，并且由于没有指定外部表和location，该表在默认位置，即是内部表。</p>
<p><img src="/2020/01/12/Hive介绍/1603613699566.png" alt="1603613699566"></p>
<h3 id="3-3-法三：like建表法"><a href="#3-3-法三：like建表法" class="headerlink" title="3.3 法三：like建表法"></a>3.3 法三：like建表法</h3><p><strong>会创建结构完全相同的表，但是没有数据。</strong><br>常用于中间表.</p>
<p><strong>(尝试过like建表法可以生成分区表)</strong></p>
<p>LIKE形式的CREATE TABLE允许您精确地复制现有表定义（而无需复制其数据）。<br>与CTAS相比，以下语句创建了一个新的empty_key_value_store表，它的定义在表名以外的所有细节上与现有key_value_store完全匹配。 新表不包含任何行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE empty_key_value_store</span><br><span class="line">LIKE key_value_store [TBLPROPERTIES (property_name=property_value, ...)];</span><br></pre></td></tr></table></figure>
<p>在Hive 0.8.0之前，CREATE TABLE LIKE view_name将复制该视图。 在Hive 0.8.0和更高版本中，CREATE TABLE LIKE view_name通过使用view_name schema（字段(fields)和分区列(partition columns)）, 使用SerDe和文件格式的默认值来创建一个表。</p>
<p>注：上面语句中如果不使用 EXTERNAL 关键字，若源表是外部表的话，生成的新表也将是外部表；若源表是内部表的话，生成的新表也将是内部表。若语句中包含 EXTERNAL 关键字且源表是内部表的话，生成的新表将是外部表。即使在这种场景下，LOCATION 子句同样是可选的。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table t4 like t2;</span><br></pre></td></tr></table></figure>
<p>可以发现，不会执行MapReduce，且表结构和t2完全一样，但是没有数据。</p>
<p><img src="/2020/01/12/Hive介绍/1603614353762.png" alt="1603614353762"></p>
<h2 id="4-Hive中表的类型"><a href="#4-Hive中表的类型" class="headerlink" title="4. Hive中表的类型"></a>4. Hive中表的类型</h2><p>Hive中有5种表：内部表，外部表，临时表，分区表，桶表（分桶表）</p>
<h3 id="4-1-内部表与外部表"><a href="#4-1-内部表与外部表" class="headerlink" title="4.1 内部表与外部表"></a><span id="jump4.1">4.1 内部表与外部表</span></h3><p>不使用 <code>EXTERNAL</code> 创建的表称为管理表 (也叫做内部表) (managed table)，因为Hive管理它的数据。若要确定一个表是内部表还是外部表，使用 <a href="https://cwiki.apache.org/confluence/display/Hive/Managed+vs.+External+Tables#Managedvs.ExternalTables-DescribeTable/View/Column" target="_blank" rel="noopener">DESCRIBE FORMATTED table_name</a> 可以得到表的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Table Type: MANAGED_TABLE 或者 EXTERNAL_TABLE</span><br></pre></td></tr></table></figure>
<p>（注：此命令还会显示许多其他信息，例如表的创建人，创建时间，location等等）</p>
<p>默认情况下，Hive创建内部表，其中文件、元数据和统计信息由内部Hive进程管理 。 有关内部表与外部表之间差异的详细信息，请参阅 <a href="https://cwiki.apache.org/confluence/display/Hive/Managed+vs.+External+Tables" target="_blank" rel="noopener">Managed vs. External Tables</a>。</p>
<h4 id="4-1-1-Feature-comparison"><a href="#4-1-1-Feature-comparison" class="headerlink" title="4.1.1 Feature comparison"></a>4.1.1 Feature comparison</h4><ul>
<li>ARCHIVE/UNARCHIVE/TRUNCATE/MERGE/CONCATENATE only work for managed tables</li>
<li>DROP deletes data for managed tables while it only deletes metadata for external ones</li>
<li>ACID/Transactional only works for managed tables</li>
<li><a href="https://issues.apache.org/jira/browse/HIVE-18513" target="_blank" rel="noopener">Query Results Caching</a> only works for managed tables</li>
<li>Only the RELY constraint is allowed on external tables</li>
<li>Some Materialized View features only work on managed tables</li>
</ul>
<h4 id="4-1-2-内部表（Managed-Table）"><a href="#4-1-2-内部表（Managed-Table）" class="headerlink" title="4.1.2 内部表（Managed Table）"></a>4.1.2 内部表（Managed Table）</h4><p>A managed table is stored under the <a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.metastore.warehouse.dir" target="_blank" rel="noopener">hive.metastore.warehouse.dir</a> path property, by default in a folder path similar to <code>/user/hive/warehouse/databasename.db/tablename/</code>. The default location can be overridden by the <code>location</code> property during table creation. If a managed table or partition is dropped, the data and metadata associated with that table or partition are deleted. If the PURGE option is not specified, the data is moved to a trash folder for a defined duration.</p>
<p>Use managed tables when Hive should manage the lifecycle of the table, or when generating temporary tables.</p>
<p>内部表的主要问题是只能用 Hive 访问，不方便和其他系统共享数据。例如，有一份由 Pig 或其他工具创建并且主要由这一工具使用的数据，同时希望使用 Hive 在这份数据上执行一些查询，可是并没有给予 Hive 对数据的所有权，这时就不能使用内部表了。我们可以创建一个外部表指向这份数据，而并不需要对其具有所有权。</p>
<p>删除内部表会同时删除存储数据和元数据。</p>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 建表方式一</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(</span><br><span class="line">    <span class="keyword">id</span>	<span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">STRING</span>,</span><br><span class="line">    age <span class="built_in">INT</span>,</span><br><span class="line">    gfs <span class="built_in">ARRAY</span>&lt;<span class="keyword">STRING</span>&gt;,</span><br><span class="line">    address <span class="keyword">MAP</span>&lt;<span class="keyword">STRING</span>,<span class="keyword">STRING</span>&gt;,</span><br><span class="line">    info <span class="keyword">STRUCT</span>&lt;country:<span class="keyword">String</span>,province:<span class="keyword">String</span>,shi:<span class="keyword">String</span>&gt;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">' '</span> </span><br><span class="line">COLLECTION ITEMS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span></span><br><span class="line"><span class="keyword">MAP</span> <span class="keyword">KEYS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">':'</span> </span><br><span class="line"><span class="keyword">LINES</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\n'</span></span><br><span class="line">LOCATION <span class="string">"/test"</span>; <span class="comment">-- 可以设置源数据的位置，若不设置默认就在Hive的工作目录区（关于表的存放位置，可使用 desc formatted tablename 进行查看）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表方式二</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> gfstbl1 <span class="keyword">like</span> gfstbl; <span class="comment">-- 只是创建表结构</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 建表方式三</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> gfstbl2 <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">id</span>,<span class="keyword">name</span>,gfs,address <span class="keyword">from</span> gfstbl; </span><br><span class="line"><span class="comment">-- 会创建相应的表结构，并且插入数据，相当于完整的赋值</span></span><br></pre></td></tr></table></figure>
<p>关于建表的更详细介绍见 <a href="#jump3">3. Hive建表语句</a></p>
<p><strong>加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/root/gfs.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> gfstbl;</span><br></pre></td></tr></table></figure>
<p>更详细介绍见 <a href="#jump5">5. 向Hive表种插入数据</a></p>
<p><strong>查看表描述信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> [<span class="keyword">EXTENDED</span>|FORMATTED] table_name</span><br><span class="line">如 <span class="keyword">DESCRIBE</span> FORMATTED gfstbl;</span><br></pre></td></tr></table></figure>
<p>DESCRIBE显示列的列表（the list of columns），包括给定表的分区列（partition columns）。 如果指定了EXTENDED关键字，则它将以Thrift序列化形式显示表的所有元数据。 这通常只在调试时有用，而不适用于一般使用。 如果指定了FORMATTED关键字，则它将以表格格式显示元数据。</p>
<h4 id="4-1-3-外部表（External-Table）"><a href="#4-1-3-外部表（External-Table）" class="headerlink" title="4.1.3 外部表（External Table）"></a>4.1.3 外部表（External Table）</h4><p>An external table describes the metadata/schema on external files. External table files can be accessed and managed by processes outside of Hive. External tables can access data stored in sources such as Azure Storage Volumes (ASV) or remote HDFS locations. If the structure or partitioning of an external table is changed, an <a href="https://cwiki.apache.org/confluence/display/Hive/Managed+vs.+External+Tables#Managedvs.ExternalTables-RecoverPartitions(MSCKREPAIRTABLE" target="_blank" rel="noopener">MSCK REPAIR TABLE table_name</a>) statement can be used to refresh metadata information.</p>
<p>Use external tables when files are already present or in remote locations, and the files should remain even if the table is dropped.</p>
<p>外部表方便对已有数据的集成。因为表是外部的，所以 Hive 并不认为其完全拥有这个表的数据。在对外部表执行删除操作时，只是删除掉描述表的元数据信息，并不会删除表数据。</p>
<p>数据存储位置由用户自己指定，<strong>由HDFS管理，删除外部表时仅仅会删除元数据，存储数据不会受到影响。</strong></p>
<ul>
<li>适用情形：<br>当一份日志需要多个小组一起分析，分析完了之后创建的表就可以删除了。但是普通的表删除的同时也会把数据删除，这样就会影响到其他小组的分析，而且日志数据也不能随便删除。所以，需要外部表，删除外部表，不会删除对应的HDFS上的数据。</li>
</ul>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">external</span> <span class="keyword">table</span> wc_external (</span><br><span class="line">    word1 <span class="keyword">STRING</span>, </span><br><span class="line">    word2 <span class="keyword">STRING</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">' '</span> </span><br><span class="line">location <span class="string">'/test/external'</span>; <span class="comment">-- location可加可不加，不加location默认是在hive的工作目录区</span></span><br></pre></td></tr></table></figure>
<h4 id="4-1-4-内部表与外部表的区别"><a href="#4-1-4-内部表与外部表的区别" class="headerlink" title="4.1.4 内部表与外部表的区别"></a>4.1.4 内部表与外部表的区别</h4><ul>
<li>内部表数据由Hive自身管理，外部表数据由HDFS管理；</li>
<li>内部表数据存储的位置是hive.metastore.warehouse.dir（默认：/user/hive/warehouse），外部表数据的存储位置由自己制定；</li>
<li>对内部表的修改会将修改直接同步给元数据，而对外部表的表结构和分区进行修改，则需要修复（MSCK REPAIR TABLE table_name;）</li>
<li>创建表时：创建内部表时，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径， 不对数据的位置做任何改变。</li>
<li>删除表时：在删除表的时候，内部表的元数据和数据会被一起删除，而外部表只删除元数据，不删除数据（HDFS上的文件不会被删除）。这样外部表相对来说更加安全些，数据组织也更加灵活，方便共享源数据</li>
</ul>
<h3 id="4-2-临时表（Temporary-Table）"><a href="#4-2-临时表（Temporary-Table）" class="headerlink" title="4.2 临时表（Temporary Table）"></a>4.2 临时表（Temporary Table）</h3><p>在当前会话期间存在，会话结束后自动销毁。</p>
<ul>
<li>适用情形<br>临时分析，在关闭hive客户端后，临时表就会消失。主要用于存储不重要的中间结果集，不重要的表。</li>
</ul>
<p>临时表具有以下限制：</p>
<ul>
<li>不支持分区列。</li>
<li>不支持创建索引。</li>
</ul>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TEMPORARY</span> <span class="keyword">table</span> ttabc(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">String</span></span><br><span class="line">) </span><br><span class="line"><span class="comment">-- 临时表的声明周期是一次会话，进入hive shell创建一张表，关闭shell后，表丢失，临时表不支持分区</span></span><br></pre></td></tr></table></figure>
<p><strong>建表并加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">TEMPORARY</span> <span class="keyword">table</span> dept_tmp(  </span><br><span class="line">    deptno <span class="built_in">int</span>,  </span><br><span class="line">    dname <span class="keyword">string</span>,</span><br><span class="line">    loc <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span>  </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">'/opt/datas/dept.txt'</span> <span class="keyword">into</span> <span class="keyword">table</span> dept_tmp;</span><br></pre></td></tr></table></figure>
<p><strong>查看location信息：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">desc formatted dept_tmp;</span><br><span class="line">Location:               hdfs://172.19.199.187:8020/tmp/hive/hadoop/68174383-f427-4629-9707-0ab1c9b07726/_tmp_space.db/d872efec-1294-48b0-9071-31cf98d46400    </span><br><span class="line">Table Type:             MANAGED_TABLE</span><br></pre></td></tr></table></figure>
<h3 id="4-3-分区表（Partitioned-Table）"><a href="#4-3-分区表（Partitioned-Table）" class="headerlink" title="4.3 分区表（Partitioned Table）"></a><span id="jump4.4">4.3 分区表（Partitioned Table）</span></h3><p>可以使用 <code>PARTITIONED BY</code> 子句创建分区表。 一个表可以具有一个或多个分区列，并为分区列中的每个不同值组合创建一个单独的数据目录。 此外，可以使用 <code>CLUSTERED BY</code> 列对表或分区进行存储，并且可以通过 <code>SORT BY</code> 列在该存储区中对数据进行排序（tables or partitions can be bucketed using CLUSTERED BY columns, and data can be sorted within that bucket via SORT BY columns. ）。 这样可以提高某些查询的性能。</p>
<blockquote>
<p>更多关于bucket 的内容见 <a href="#jump4.4">4.4 分桶表（Bucket Tables） </a></p>
</blockquote>
<p>如果在创建分区表时收到以下错误消息：“ FAILED: Error in semantic analysis: Column repeated in partitioning columns”，则表示您试图将分区列包含在表本身的数据中。 您可能确实定义了该列，但是，您创建的分区将创建一个可查询的伪列，因此您必须将表列重命名为其他名称（用户不应在其上查询！）。</p>
<p>(You probably really do have the column defined. However, the partition you create makes a pseudocolumn on which you can query, so you must rename your table column to something else (that users should not query on!).)</p>
<p>例如，假设原始未分区表具有三列：id，date和name。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id int,</span><br><span class="line">date date,</span><br><span class="line">name varchar</span><br></pre></td></tr></table></figure>
<p>现在您要按日期分区。 您的Hive定义可以使用“ dtDontQuery”作为列名，以便可以将“ date”用于分区（和查询）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name ( </span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">	dtDontQuery <span class="keyword">string</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line">partitioned <span class="keyword">by</span> (<span class="built_in">date</span> <span class="keyword">string</span>)</span><br></pre></td></tr></table></figure>
<p>现在，您的用户仍将查询<code>where date =&#39;...&#39;</code>，但第二列dtDontQuery将保留原始值。</p>
<hr>
<p>分区表将数据按照某个字段或者关键字分成多个子目录来存储，防止暴力扫描全表。</p>
<ul>
<li><p>适用情形</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">logs</span> <span class="keyword">where</span> <span class="built_in">date</span> = <span class="string">'20171209'</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通表执行流程：对全表的数据进行查询，然后进行过滤操作。</li>
<li>分区表执行流程：直接加载对应文件路径下的数据。</li>
</ul>
<p>适用于大数据量，可以通过分区快速定位需要查询的数据，<strong>分区表的作用主要是提高查询检索的效率 。</strong></p>
</li>
</ul>
<p>分区表的优势体现在可维护性和性能两方面，而且分区表还可以将数据以一种符合业务逻辑的方式进行组织，因此是数据仓库中经常使用的一种技术。内部表和外部表都可以创建相应的分区表，分别称之为内部分区表和外部分区表。</p>
<p>先看一个内部分区表的例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(</span><br><span class="line">    viewtime <span class="built_in">int</span>,</span><br><span class="line">	userid <span class="built_in">bigint</span>,</span><br><span class="line">	page_url <span class="keyword">string</span>,</span><br><span class="line">	referrer_url <span class="keyword">string</span>,</span><br><span class="line">	ip <span class="keyword">string</span> <span class="keyword">COMMENT</span> <span class="string">'ip address of the user'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'this is the page view table'</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span> (dt <span class="keyword">string</span>, country <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\001'</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p><code>CREATE TABLE</code> 语句的 <code>PARTITIONED BY</code> 子句用于创建分区表。上面的语句创建一个名为 page_view 的分区表。这是一个常见的页面浏览记录表，包含浏览时间、浏览用户ID、浏览页面的URL、上一个访问的URL和用户的IP地址五个字段。该表以日期和国家作为分区字段，存储为SEQUENCEFILE文件格式。文件中的数据分别使用默认的Ctrl-A和换行符作为列和行的分隔符。</p>
<p>使用 DESCRIBE FORMATTED 命令会显示出分区键。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> FORMATTED page_view;</span><br></pre></td></tr></table></figure>
<p>输出信息中把表字段和分区字段分开显示。</p>
<p>分区表改变了 Hive 对数据存储的组织方式。如果是一个非分区表，那么只会有一个page_view目录与之对应，而对于分区表，当向表中装载数据后，Hive 将会创建好可以反映分区结构的子目录。</p>
<p>对数据进行分区，最重要的原因就是为了更快地查询。如果用户的查询包含了 <code>where dt=&#39;...&#39; and country=&#39;...&#39;</code> 这样的条件，查询优化器只需要扫描一个分区目录即可。</p>
<p><strong>静态分区表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> day_hour_table (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span>, </span><br><span class="line">    <span class="keyword">content</span> <span class="keyword">string</span></span><br><span class="line">) </span><br><span class="line">partitioned <span class="keyword">by</span> (dt <span class="built_in">int</span>, <span class="keyword">hour</span> <span class="built_in">int</span>) </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\t'</span> ;</span><br></pre></td></tr></table></figure>
<p><strong>加载数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- insert单条插入的方式往分区表中插入数据：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">9</span>,<span class="keyword">hour</span>=<span class="number">1</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">9</span>,<span class="keyword">hour</span>=<span class="number">2</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">8</span>,<span class="keyword">hour</span>=<span class="number">1</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">8</span>,<span class="keyword">hour</span>=<span class="number">2</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">"a2 bc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- load批量插入的方式往分区表中插入数据：</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> inpath <span class="string">"/root/ceshi"</span> <span class="keyword">into</span> <span class="keyword">table</span> day_table <span class="keyword">partition</span> (dt=<span class="number">10</span>,<span class="keyword">hour</span>=<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>删除Hive分区表中的分区：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_table <span class="keyword">DROP</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10</span>,<span class="keyword">hour</span>=<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>创建\添加分区：</strong></p>
<p>Syntax:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] <span class="keyword">PARTITION</span> partition_spec [LOCATION <span class="string">'location'</span>]</span><br><span class="line">[, <span class="keyword">PARTITION</span> partition_spec [LOCATION <span class="string">'location'</span>], ...];</span><br><span class="line"></span><br><span class="line">partition_spec:</span><br><span class="line">	  : (partition_column = partition_col_value, partition_column = partition_col_value, ...)</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 创建一个空分区：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_hour_table <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10000</span>, <span class="keyword">hour</span>=<span class="number">2000</span>);</span><br><span class="line"><span class="comment">-- 然后将数据上传到空分区对应的目录下，分区表中就会显示数据</span></span><br><span class="line">hdfs dfs -put ........</span><br><span class="line"><span class="comment">-- 或者也可用 insert overwrite</span></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> day_hour_table <span class="keyword">partition</span>(dt=<span class="number">10000</span>, <span class="keyword">hour</span>=<span class="number">2000</span>)</span><br><span class="line"><span class="keyword">select</span> ...</span><br><span class="line"><span class="comment">-- 创建一个空分区并且将空分区指向数据位置：</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> day_hour_table <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> (dt=<span class="number">10000</span>, <span class="keyword">hour</span>=<span class="number">2000</span>) location <span class="string">"/test"</span></span><br></pre></td></tr></table></figure>
<p><strong>动态分区表：</strong></p>
<p>动态分区表和静态分区表建表语句相同，插入数据的方式不同</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition=<span class="literal">true</span>;</span><br><span class="line"><span class="keyword">set</span> hive.exec.dynamic.partition.mode=nonstrict;</span><br></pre></td></tr></table></figure>
<p>动态分区可以根据数据本身的特征自动来划分分区，<code>load data …</code> 只是将数据上传到HDFS指定目录，所以我们需要使用from insert的方式插入数据，hive才会根据分区设置自动将数据进行分区。（详细内容见👇）</p>
<p><strong>动态分区插入（Dynamic Partition Inserts）</strong></p>
<blockquote>
<p>参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML</a></p>
</blockquote>
<p>在动态分区插入中，用户可以提供部分分区规范，这意味着只需在PARTITION子句中指定分区列名列表 ( specifying the list of partition column names)。列值是可选的 (The column values are optional)。如果给定一个分区列值 (partition column value)，我们称其为静态分区，否则为动态分区。每个动态分区列都有一个来自select语句的相应输入列。这意味着动态分区的创建由输入列的值决定。动态分区列必须在SELECT语句的列中最后指定，并且按照它们在PARTITION()子句中出现的顺序指定。</p>
<blockquote>
<p>In the dynamic partition inserts, users can give partial partition specifications, which means just specifying the list of partition column names in the PARTITION clause. The column values are optional. If a partition column value is given, we call this a static partition, otherwise it is a dynamic partition. Each dynamic partition column has a corresponding input column from the select statement. This means that the dynamic partition creation is determined by the value of the input column. The dynamic partition columns must be <strong>specified last</strong> among the columns in the SELECT statement and <strong>in the same order</strong> in which they appear in the PARTITION() clause.</p>
</blockquote>
<p>As of Hive 3.0.0 (<a href="https://issues.apache.org/jira/browse/HIVE-19083" target="_blank" rel="noopener">HIVE-19083</a>) there is no need to specify dynamic partition columns. Hive will automatically generate partition specification if it is not specified.</p>
<style>
table th:first-of-type {
    width: 220px;
}
table th:nth-of-type(2) {
    width: 70px;
}
</style>

<div class="table-container">
<table>
<thead>
<tr>
<th>Configuration property</th>
<th>Default</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hive.exec.dynamic.partition</code></td>
<td><code>true</code></td>
<td>Needs to be set to <code>true</code> to enable dynamic partition inserts</td>
</tr>
<tr>
<td><code>hive.exec.dynamic.partition.mode</code></td>
<td><code>strict</code></td>
<td>In <code>strict</code> mode, the user must specify at least one static partition in case the user accidentally overwrites all partitions, in <code>nonstrict</code> mode all partitions are allowed to be dynamic</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions.pernode</code></td>
<td>100</td>
<td>Maximum number of dynamic partitions allowed to be created in each mapper/reducer node</td>
</tr>
<tr>
<td><code>hive.exec.max.dynamic.partitions</code></td>
<td>1000</td>
<td>Maximum number of dynamic partitions allowed to be created in total</td>
</tr>
<tr>
<td><code>hive.exec.max.created.files</code></td>
<td>100000</td>
<td>Maximum number of HDFS files created by all mappers/reducers in a MapReduce job</td>
</tr>
<tr>
<td><code>hive.error.on.empty.partition</code></td>
<td><code>false</code></td>
<td>Whether to throw an exception if dynamic partition insert generates empty results</td>
</tr>
</tbody>
</table>
</div>
<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM page_view_stg pvs</span><br><span class="line">INSERT OVERWRITE TABLE page_view PARTITION(dt=&apos;2008-06-08&apos;, country)</span><br><span class="line">       SELECT pvs.viewTime, pvs.userid, pvs.page_url, pvs.referrer_url, null, null, pvs.ip, pvs.cnt</span><br></pre></td></tr></table></figure>
<p>在这里，country 分区将由SELECT子句的最后一列（即pvs.cnt）动态创建。Note that the name is not used. 在 nonstrict 模式下，the <code>dt</code> partition could also be dynamically created.</p>
<p>关于 INSERT 的语法见 <a href="#jump5.2.1">5.2.1 INSERT INTO/OVERWRITE TABLE SELECT</a>.</p>
<h3 id="4-4-分桶表（Bucked-Tables）"><a href="#4-4-分桶表（Bucked-Tables）" class="headerlink" title="4.4 分桶表（Bucked Tables）"></a><span id="jump4.4">4.4 分桶表（Bucked Tables）</span></h3><p>将数据按照某个字段和桶的数量，对指定字段进行取模运算，拆分成多个小文件来存储，模相同的存储在同一个小文件中，提高join以及抽样的效率。</p>
<ul>
<li>适用情形<br>数据有严重的数据倾斜，分布不均匀，但是相对来说每个桶中的数据量会比较平均。桶与桶之间做join等查询的时候，会有优化。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing=<span class="literal">true</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_bu(  </span><br><span class="line">    empno <span class="built_in">int</span>,  </span><br><span class="line">    ename <span class="keyword">string</span>,</span><br><span class="line">    job <span class="keyword">string</span>,  </span><br><span class="line">    mgr <span class="built_in">int</span>,</span><br><span class="line">    hiredate <span class="keyword">string</span>,  </span><br><span class="line">    sal <span class="keyword">double</span>,  </span><br><span class="line">    comm <span class="keyword">double</span>,  </span><br><span class="line">    deptno <span class="built_in">int</span></span><br><span class="line">)</span><br><span class="line">CLUSTERED <span class="keyword">BY</span>(deptno) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS</span><br><span class="line"><span class="keyword">row</span> <span class="keyword">format</span> <span class="keyword">delimited</span>  </span><br><span class="line"><span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\t'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> overwrite <span class="keyword">table</span> emp_bu_2 <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure>
<p>分桶表是对列值取哈希值的方式，将不同数据放到不同文件中存储，由列值的哈希值除以桶的个数来决定每条数据划分在哪个桶中。对于hive中每一个表、分区都可以进一步进行分桶。</p>
<p>For an int, it’s easy, <code>hash_int(i) == i</code>. 例如基于user_id进行分桶时， if user_id were an int, and there were 10 buckets, we would expect all user_id’s that end in 0 to be in bucket 1, all user_id’s that end in a 1 to be in bucket 2, etc. </p>
<p><strong>建表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> psnbucket( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>, </span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">STRING</span>, </span><br><span class="line">    age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (age) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure>
<p><strong>插入数据：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> psnbucket <span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, age <span class="keyword">from</span> original;</span><br></pre></td></tr></table></figure>
<p><strong>分桶表+分区表：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> psnbucket_partition( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span>, </span><br><span class="line">    <span class="keyword">name</span> <span class="keyword">STRING</span>, </span><br><span class="line">    age <span class="built_in">INT</span></span><br><span class="line">) </span><br><span class="line">PARTITIONED <span class="keyword">BY</span>(height <span class="keyword">DOUBLE</span>) </span><br><span class="line">CLUSTERED <span class="keyword">BY</span> (age) <span class="keyword">INTO</span> <span class="number">4</span> BUCKETS </span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span> </span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL+BucketedTables" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL+BucketedTables</a></p>
</blockquote>
<p>Bucketed tables are fantastic in that they allow much more efficient <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Sampling" target="_blank" rel="noopener">sampling</a> than do non-bucketed tables, and they may later allow for time saving operations such as mapside joins. However, the bucketing specified at table creation is not enforced when the table is written to, and so it is possible for the table’s metadata to advertise properties which are not upheld by the table’s actual layout. This should obviously be avoided. Here’s how to do it right.</p>
<p>First, <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-Create/Drop/TruncateTable" target="_blank" rel="noopener">table creation</a>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_info_bucketed(user_id <span class="built_in">BIGINT</span>, firstname <span class="keyword">STRING</span>, lastname <span class="keyword">STRING</span>)</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'A bucketed copy of user_info'</span></span><br><span class="line">PARTITIONED <span class="keyword">BY</span>(ds <span class="keyword">STRING</span>)</span><br><span class="line">CLUSTERED <span class="keyword">BY</span>(user_id) <span class="keyword">INTO</span> <span class="number">256</span> BUCKETS;</span><br></pre></td></tr></table></figure>
<p>Note that we specify a column (user_id) to base the bucketing.<br>Then we populate the table</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> hive.enforce.bucketing = <span class="literal">true</span>;  <span class="comment">-- (<span class="doctag">Note:</span> Not needed in Hive 2.x onward)</span></span><br><span class="line">FROM user_id</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> user_info_bucketed</span><br><span class="line"><span class="keyword">PARTITION</span> (ds=<span class="string">'2009-02-25'</span>)</span><br><span class="line"><span class="keyword">SELECT</span> userid, firstname, lastname <span class="keyword">WHERE</span> ds=<span class="string">'2009-02-25'</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Version 0.x and 1.x only</strong><br>The command <code>set hive.enforce.bucketing = true;</code> allows the correct number of reducers and the cluster by column to be automatically selected based on the table. Otherwise, you would need to set the number of reducers to be the same as the number of buckets as in <code>set mapred.reduce.tasks = 256;</code> and have a <code>CLUSTER BY ...</code> clause in the select.</p>
</blockquote>
<p>What can go wrong? As long as you use the syntax above and <code>set hive.enforce.bucketing = true</code> (for Hive 0.x and 1.x), the tables should be populated properly. Things can go wrong if the bucketing column type is different during the insert and on read, or if you manually cluster by a value that’s different from the table definition.</p>
<p><strong>Bucketed Sorted Tables</strong></p>
<blockquote>
<p>参考<br><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-TemporaryTables" target="_blank" rel="noopener">https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-TemporaryTables</a></p>
</blockquote>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> page_view(viewTime <span class="built_in">INT</span>, userid <span class="built_in">BIGINT</span>,</span><br><span class="line">     page_url <span class="keyword">STRING</span>, referrer_url <span class="keyword">STRING</span>,</span><br><span class="line">     ip <span class="keyword">STRING</span> <span class="keyword">COMMENT</span> <span class="string">'IP Address of the User'</span>)</span><br><span class="line"> <span class="keyword">COMMENT</span> <span class="string">'This is the page view table'</span></span><br><span class="line"> PARTITIONED <span class="keyword">BY</span>(dt <span class="keyword">STRING</span>, country <span class="keyword">STRING</span>)</span><br><span class="line"> CLUSTERED <span class="keyword">BY</span>(userid) SORTED <span class="keyword">BY</span>(viewTime) <span class="keyword">INTO</span> <span class="number">32</span> BUCKETS</span><br><span class="line"> <span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></span><br><span class="line">   <span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\001'</span></span><br><span class="line">   COLLECTION ITEMS <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\002'</span></span><br><span class="line">   <span class="keyword">MAP</span> <span class="keyword">KEYS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">'\003'</span></span><br><span class="line"> <span class="keyword">STORED</span> <span class="keyword">AS</span> SEQUENCEFILE;</span><br></pre></td></tr></table></figure>
<p>In the example above, the page_view table is bucketed (clustered by) userid and within each bucket the data is sorted in increasing order of viewTime. Such an organization allows the user to do efficient sampling on the clustered column - in this case userid. The sorting property allows internal operators to take advantage of the better-known data structure while evaluating queries, also increasing efficiency. MAP KEYS and COLLECTION ITEMS keywords can be used if any of the columns are lists or maps.</p>
<p>CLUSTERED BY和SORTED BY创建命令不会影响将数据插入表的方式，而只会影响数据的读取方式。 这意味着用户必须注意正确地插入数据，方法是将reducer的数量指定为等于存储桶的数量，并在查询中使用CLUSTER BY和SORT BY命令。</p>
<h2 id="5-向Hive表中插入数据"><a href="#5-向Hive表中插入数据" class="headerlink" title=" 5. 向Hive表中插入数据"></a><span id="jump5"> 5. 向Hive表中插入数据</span></h2><h3 id="5-1-Load"><a href="#5-1-Load" class="headerlink" title="5.1 Load"></a>5.1 Load</h3><blockquote>
<p>参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Loadingfilesintotables" target="_blank" rel="noopener">LanguageManual DML - Apache Hive - Apache Software Foundation</a></p>
</blockquote>
<p>Loading files into tables. 此种方式适合把文件中的数据插入Hive表</p>
<p>Syntax:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> [<span class="keyword">LOCAL</span>] INPATH <span class="string">'filepath'</span> [OVERWRITE] <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> [<span class="keyword">LOCAL</span>] INPATH <span class="string">'filepath'</span> [OVERWRITE] <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...)] [INPUTFORMAT <span class="string">'inputformat'</span> SERDE <span class="string">'serde'</span>] (<span class="number">3.0</span> <span class="keyword">or</span> later)</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<p>Hive 3.0之前的加载操作是纯复制/移动操作，将数据文件移动到与Hive表相对应的位置</p>
<ul>
<li><em>filepath</em> 可以是:<ul>
<li>相对路径, 如 project/data1</li>
<li>绝对路径, 如 /user/hive/project/data1</li>
<li>a full URI with scheme and (optionally) an authority, such as hdfs://namenode:9000/user/hive/project/data1</li>
<li><strong>如果使用了关键字LOCAL，filepath would be referred from the server where hive beeline is running otherwise it would use the HDFS path.</strong></li>
</ul>
</li>
<li>The target being loaded to can be a table or a partition. If the table is partitioned, then one must specify a specific partition of the table by specifying values for all of the partitioning columns.</li>
<li><em>filepath</em> 可以指向文件（在这种情况下，Hive会将文件移至表中），也可以是目录（在这种情况下，Hive会将目录中的所有文件移至表中）。 In either case, <em>filepath</em> addresses a set of files.</li>
<li>如果指定了关键字 LOCAL，则<ul>
<li>load命令将在本地文件系统中查找文件路径。 如果指定的是相对路径，它将相对于用户的当前工作目录进行解释。 用户也可以为本地文件指定完整的URI - for example: <code>file:///user/hive/project/data1</code></li>
<li>the load command will try to copy all the files addressed by <em>filepath</em> to the target filesystem. The target file system is inferred by looking at the location attribute of the table. The copied data files will then be moved to the table.</li>
<li>如果要装载的文件在服务器上，使用LOCAL；如果在HDFS中，不使用LOCAL。</li>
</ul>
</li>
<li>如果未指定关键字 LOCAL，则Hive将使用文件路径的完整URI（如果已指定），或将应用以下规则：<ul>
<li>If scheme or authority are not specified, Hive will use the scheme and authority from the hadoop configuration variable <code>fs.default.name</code> that specifies the Namenode URI.</li>
<li>If the path is not absolute, then Hive will interpret it relative to <code>/user/&lt;username&gt;</code></li>
<li>Hive will <em>move</em> the files addressed by <em>filepath</em> into the table (or partition)</li>
</ul>
</li>
<li>如果使用了 OVERWRITE 关键字，目标表（或分区）中的内容将会被删掉并被替换为filepath指向的文件； 否则，filepath指向的文件将被追加到表中。</li>
</ul>
<p>例：将HDFS中的文件导入分区表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LOAD DATA INPATH &apos;/user/kelly/test-ml/20210901predict_result.csv&apos; OVERWRITE INTO TABLE &apos;ads_base.xxxx&apos; partition(dt=20210901)</span><br></pre></td></tr></table></figure>
<h4 id="实例1：将CSV文件导入Hive表"><a href="#实例1：将CSV文件导入Hive表" class="headerlink" title="实例1：将CSV文件导入Hive表"></a>实例1：将CSV文件导入Hive表</h4><blockquote>
<p>参考：<a href="https://sparkbyexamples.com/apache-hive/hive-load-csv-file-into-table/" target="_blank" rel="noopener">Hive Load CSV File into Table — SparkByExamples</a></p>
</blockquote>
<p>（1）首先需创建hive表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> emp.employee (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span>,</span><br><span class="line">	<span class="keyword">name</span> <span class="keyword">string</span>,</span><br><span class="line">	age <span class="built_in">int</span>,</span><br><span class="line">	gender <span class="keyword">string</span> </span><br><span class="line">)</span><br><span class="line"><span class="keyword">COMMENT</span> <span class="string">'Employee Table'</span></span><br><span class="line"><span class="keyword">ROW</span> <span class="keyword">FORMAT</span> <span class="keyword">DELIMITED</span></span><br><span class="line"><span class="keyword">FIELDS</span> <span class="keyword">TERMINATED</span> <span class="keyword">BY</span> <span class="string">','</span>;</span><br></pre></td></tr></table></figure>
<p><strong>注:</strong> 为了将csv文件导入Hive表, 建表时需要使用 <code>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;</code></p>
<p>（2）使用 <code>rz</code> 命令将电脑本地文件上传至服务器</p>
<p>注：先关闭本地文件，再 <code>rz</code>，且文件中不要包含header，否则会被一起导入表中</p>
<p>（3）将服务器上的文件上传至HDFS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">登录hive</span><br><span class="line">hive&gt;dfs -put 服务器上的文件路径 HDFS中的文件路径</span><br><span class="line">例：</span><br><span class="line">hive&gt;dfs -put /data/test/data.csv /user/kelly/data;</span><br><span class="line">若目标路径不存在，需先新建路径：</span><br><span class="line">hive&gt;dfs -mkdir /user/kelly/data;</span><br><span class="line">↑其中/user/kelly为已存在路径</span><br><span class="line">（若多个层级缺失，加上-p参数，创建所有缺失目录）</span><br><span class="line"></span><br><span class="line">如果像重跑覆盖，加上-f参数：</span><br><span class="line">hive&gt;dfs -put -f xxx xxx</span><br></pre></td></tr></table></figure>
<p>（4）将HDFS中的csv导入Hive表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt;LOAD DATA INPATH &apos;/user/kelly/data/data.csv&apos; OVERWRITE INTO TABLE emp.employee;</span><br></pre></td></tr></table></figure>
<p>若使用 <code>overwrite</code>，则会删掉目标表里已有的数据，并导入文件中的数据</p>
<p>使用 <code>select * from emp.employee</code> 查看是否写入成功。</p>
<p><span style="color:red"><strong>注：</strong>对于LOAD DATA INAPTH：LOAD 后，HDFS中的源数据会被删掉</span></p>
<p>法二：直接将服务器（即local filesystem）上的csv导入Hive表</p>
<p>Use <code>LOCAL</code> optional clause to load CSV file from the local filesystem into the Hive table without uploading to HDFS.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt;LOAD DATA LOCAL INPATH &apos;/data/test/data.csv&apos; OVERWRITE INTO TABLE emp.employee;</span><br></pre></td></tr></table></figure>
<p><span style="color:red"><strong>注：</strong>对于LOAD DATA LOCAL INAPTH：与从HDFS导入不同，local file system 中的源数据不会被删掉。</span></p>
<p>另：使用 <code>partition</code></p>
<p>如果目标表是分区表，使用 <code>partition</code> 将数据导入特定的分区中。并且可使用 <code>overwrite</code> 覆盖该分区（删掉原有的数据并装载现在的数据）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt;LOAD DATA INPATH &apos;/user/kelly/data/data.csv&apos; OVERWRITE INTO TABLE emp.employee PARTITION(date=2020);</span><br></pre></td></tr></table></figure>
<h4 id="实例2：将hive表内容导出为csv"><a href="#实例2：将hive表内容导出为csv" class="headerlink" title="实例2：将hive表内容导出为csv"></a>实例2：将hive表内容导出为csv</h4><p>hive表的内容实际是存在hdfs上的，可以直接导出到服务器本地：</p>
<p>read_data.sh</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">local_path=<span class="string">'./docs/predict_data.csv'</span></span><br><span class="line"></span><br><span class="line">hive -e <span class="string">"insert overwrite local directory './docs/predict_data_dir/'</span></span><br><span class="line"><span class="string">ROW FORMAT DELIMITED FIELDS TERMINATED BY '\u0000'</span></span><br><span class="line"><span class="string">select * from xx_db.xx_table</span></span><br><span class="line"><span class="string">where dt=xxx;</span></span><br><span class="line"><span class="string">"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要表头：</span></span><br><span class="line"><span class="comment"># 生成表头，并写入最终的csv文件中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法一：执行完后，最好检查一下csv的表头是否正确</span></span><br><span class="line"><span class="comment">#hive  -e 'SET hive.cli.print.header=true; SELECT * FROM xx_db.xx_table LIMIT 0' &gt; ./docs/predict_data.csv </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二：先表表头存入文件</span></span><br><span class="line">cat ./docs/final_features.txt | sed <span class="string">'s/,/\t/g'</span>&gt; <span class="variable">$local_path</span></span><br><span class="line">cat ./docs/predict_data_dir/* &gt;&gt; <span class="variable">$local_path</span>  <span class="comment">#把000000_0，000001_0这样的文件通过追加的方式，写入最终的csv文件中</span></span><br><span class="line">sed -i <span class="string">'s/,/-/g'</span> <span class="variable">$local_path</span></span><br><span class="line">sed -i <span class="string">'s/[\t]/,/g'</span> <span class="variable">$local_path</span></span><br><span class="line">sed -i <span class="string">'s/\x00/,/g'</span> <span class="variable">$local_path</span></span><br></pre></td></tr></table></figure>
<p>可指定分隔符为逗号：<code>ROW FORMAT DELIMITED FIELDS TERMINATED BY &#39;,&#39;</code>，但若字段中的内容含有逗号，则需使用其他分隔符。</p>
<p>注：<code>sed s/,/\t/g</code> 意思是将所有逗号替换为\t</p>
<h3 id="5-2-Insert"><a href="#5-2-Insert" class="headerlink" title="5.2 Insert"></a>5.2 Insert</h3><h4 id="5-2-1-INSERT-INTO-OVERWRITE-TABLE-SELECT"><a href="#5-2-1-INSERT-INTO-OVERWRITE-TABLE-SELECT" class="headerlink" title="5.2.1 INSERT INTO/OVERWRITE TABLE SELECT"></a><span id="jump5.2.1">5.2.1 INSERT INTO/OVERWRITE TABLE SELECT</span></h4><blockquote>
<p>参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-InsertingdataintoHiveTablesfromqueries" target="_blank" rel="noopener">LanguageManual DML - Apache Hive - Apache Software Foundation</a></p>
</blockquote>
<p>Inserting data into Hive Tables from queries. 此种方式适合把Hive表里的数据插入另一张Hive表。</p>
<p>Syntax</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Standard syntax:</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...) [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] <span class="keyword">SELECT</span> select_statement1 <span class="keyword">FROM</span> from_statement;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...)] <span class="keyword">SELECT</span> select_statement1 <span class="keyword">FROM</span> from_statement;</span><br><span class="line"> </span><br><span class="line">Hive extension (multiple inserts):</span><br><span class="line">FROM from_statement</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...) [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] <span class="keyword">SELECT</span> select_statement1</span><br><span class="line">[<span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ... [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] <span class="keyword">SELECT</span> select_statement2]</span><br><span class="line">[<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ...] <span class="keyword">SELECT</span> select_statement2] ...;</span><br><span class="line">FROM from_statement</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename1 [<span class="keyword">PARTITION</span> (partcol1=val1, partcol2=val2 ...)] <span class="keyword">SELECT</span> select_statement1</span><br><span class="line">[<span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ...] <span class="keyword">SELECT</span> select_statement2]</span><br><span class="line">[<span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename2 [<span class="keyword">PARTITION</span> ... [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]] <span class="keyword">SELECT</span> select_statement2] ...;</span><br><span class="line"> </span><br><span class="line">Hive extension (dynamic partition inserts):</span><br><span class="line"><span class="keyword">INSERT</span> OVERWRITE <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[=val1], partcol2[=val2] ...) <span class="keyword">SELECT</span> select_statement <span class="keyword">FROM</span> from_statement;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename <span class="keyword">PARTITION</span> (partcol1[=val1], partcol2[=val2] ...) <span class="keyword">SELECT</span> select_statement <span class="keyword">FROM</span> from_statement;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li><code>INSERT OVERWRITE</code> 将<span style="color:red">覆盖表或分区中的任何现有数据</span><ul>
<li>unless <code>IF NOT EXISTS</code> is provided for a partition (as of Hive <a href="https://issues.apache.org/jira/browse/HIVE-2612" target="_blank" rel="noopener">0.9.0</a>).</li>
<li>As of Hive 2.3.0 (<a href="https://issues.apache.org/jira/browse/HIVE-15880" target="_blank" rel="noopener">HIVE-15880</a>), if the table has <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-listTableProperties" target="_blank" rel="noopener">TBLPROPERTIES</a> (“auto.purge”=”true”) the previous data of the table is not moved to Trash when INSERT OVERWRITE query is run against the table. This functionality is applicable only for managed tables (see <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-ManagedandExternalTables" target="_blank" rel="noopener">managed tables</a>) and is turned off when “auto.purge” property is unset or set to false.</li>
</ul>
</li>
<li><code>INSERT INTO</code> 将<span style="color:red">追加到表或分区，保持现有数据不变</span><ul>
<li>As of Hive <a href="https://issues.apache.org/jira/browse/HIVE-6406" target="_blank" rel="noopener">0.13.0</a>, a table can be made <strong>immutable</strong> by creating it with <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DDL#LanguageManualDDL-CreateTable" target="_blank" rel="noopener">TBLPROPERTIES (“immutable”=”true”)</a>. The default is “immutable”=”false”.<br>如果表中已经存在任何数据，则不允许在不可变表中执行INSERT INTO行为，但如果不可变表为空，则插入INTO仍然可以工作。 INSERT OVERWRITE 的行为不受“不可变”表属性的影响。<br>不可变表可以防止由于脚本错误地多次运行而将数据加载到表中的意外更新。The first insert into an immutable table succeeds and successive inserts fail, resulting in only one set of data in the table, instead of silently succeeding with multiple copies of the data in the table.</li>
</ul>
</li>
<li>可以对表或分区进行插入。如果表是分区表，则必须通过指定所有分区列的值来指定一个特定的分区. If <a href="https://cwiki.apache.org/confluence/display/Hive/Configuration+Properties#ConfigurationProperties-hive.typecheck.on.insert" target="_blank" rel="noopener">hive.typecheck.on.insert</a> is set to true, these values are validated, converted and normalized to conform to their column types (Hive <a href="https://issues.apache.org/jira/browse/HIVE-5297" target="_blank" rel="noopener">0.12.0</a> onward). </li>
<li>可以在同一查询中指定多个插入子句（也称为多表插入）。</li>
<li>The output of each of the select statements is written to the chosen table (or partition). Currently the OVERWRITE keyword is mandatory and implies that the contents of the chosen table or partition are replaced with the output of corresponding select statement.</li>
<li>The output format and serialization class is determined by the table’s metadata (as specified via DDL commands on the table).</li>
<li>As of Hive <a href="https://issues.apache.org/jira/browse/HIVE-9353" target="_blank" rel="noopener">1.1.0</a> the TABLE keyword is optional.</li>
<li>As of Hive <a href="https://issues.apache.org/jira/browse/HIVE-9481" target="_blank" rel="noopener">1.2.0</a> each INSERT INTO T can take a column list like INSERT INTO T (z, x, c1).  See Description of <a href="https://issues.apache.org/jira/browse/HIVE-9481" target="_blank" rel="noopener">HIVE-9481</a> for examples.</li>
</ul>
<p><strong>Notes</strong></p>
<ul>
<li>Multi Table Inserts minimize the number of data scans required. Hive can insert data into multiple tables by scanning the input data just once (and applying different query operators to the input data). 多表插入可最大程度地减少所需的数据扫描次数。 Hive可以通过只扫描一次输入数据（并应用不同的查询运算符到输入数据）来将数据插入到多个表中。</li>
<li>Starting with <a href="https://issues.apache.org/jira/browse/HIVE-1180" target="_blank" rel="noopener">Hive 0.13.0</a>, the select statement can include one or more common table expressions (CTEs) as shown in the <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select#LanguageManualSelect-SelectSyntax" target="_blank" rel="noopener">SELECT syntax</a>. For an example, see <a href="https://cwiki.apache.org/confluence/display/Hive/Common+Table+Expression#CommonTableExpression-CTEinViews,CTAS,andInsertStatements" target="_blank" rel="noopener">Common Table Expression</a>.</li>
</ul>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rest <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tableA;</span><br><span class="line">		</span><br><span class="line">习惯写法 from提前  减少SQL代码的冗余</span><br><span class="line">from day_hour_table</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> rest </span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) ;</span><br></pre></td></tr></table></figure>
<h4 id="5-2-2-INSERT-INTO-…-VALUES"><a href="#5-2-2-INSERT-INTO-…-VALUES" class="headerlink" title="5.2.2 INSERT INTO … VALUES"></a>5.2.2 INSERT INTO … VALUES</h4><blockquote>
<p>参考 <a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-InsertingvaluesintotablesfromSQL" target="_blank" rel="noopener">LanguageManual DML - Apache Hive - Apache Software Foundation</a></p>
</blockquote>
<p>Inserting values into tables from SQL. 此种方式适合将具体数值（少量）插入到Hive表。</p>
<p>Syntax：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Standard Syntax:</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> tablename [<span class="keyword">PARTITION</span> (partcol1[=val1], partcol2[=val2] ...)] <span class="keyword">VALUES</span> values_row [, values_row ...]</span><br><span class="line">  </span><br><span class="line"><span class="keyword">Where</span> values_row <span class="keyword">is</span>:</span><br><span class="line">( <span class="keyword">value</span> [, <span class="keyword">value</span> ...] )</span><br><span class="line"><span class="keyword">where</span> a <span class="keyword">value</span> <span class="keyword">is</span> either <span class="literal">null</span> <span class="keyword">or</span> <span class="keyword">any</span> valid <span class="keyword">SQL</span> literal</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ul>
<li>VALUES 子句中列出的每一行都会被插入到表中（插入多行数据可以写到一个insert into语句中）</li>
<li>表中的每一列都需提供需要插入的值。允许用户只向某些列插入值的标准SQL语法目前还不支持。为了模拟标准SQL，用户不希望赋值的列可以提供null。</li>
<li>使用 INSERT INTO … VALUES 语句不支持 complex datatypes (array, map, struct, union)</li>
</ul>
<p>例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (<span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>), age <span class="built_in">INT</span>, gpa <span class="built_in">DECIMAL</span>(<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line">  CLUSTERED <span class="keyword">BY</span> (age) <span class="keyword">INTO</span> <span class="number">2</span> BUCKETS <span class="keyword">STORED</span> <span class="keyword">AS</span> ORC;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> students</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">'fred flintstone'</span>, <span class="number">35</span>, <span class="number">1.28</span>), (<span class="string">'barney rubble'</span>, <span class="number">32</span>, <span class="number">2.32</span>);</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> pageviews (userid <span class="built_in">VARCHAR</span>(<span class="number">64</span>), <span class="keyword">link</span> <span class="keyword">STRING</span>, came_from <span class="keyword">STRING</span>)</span><br><span class="line">  PARTITIONED <span class="keyword">BY</span> (datestamp <span class="keyword">STRING</span>) CLUSTERED <span class="keyword">BY</span> (userid) <span class="keyword">INTO</span> <span class="number">256</span> BUCKETS <span class="keyword">STORED</span> <span class="keyword">AS</span> ORC;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pageviews <span class="keyword">PARTITION</span> (datestamp = <span class="string">'2014-09-23'</span>)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">'jsmith'</span>, <span class="string">'mail.com'</span>, <span class="string">'sports.com'</span>), (<span class="string">'jdoe'</span>, <span class="string">'mail.com'</span>, <span class="literal">null</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pageviews <span class="keyword">PARTITION</span> (datestamp)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">'tjohnson'</span>, <span class="string">'sports.com'</span>, <span class="string">'finance.com'</span>, <span class="string">'2014-09-23'</span>), (<span class="string">'tlee'</span>, <span class="string">'finance.com'</span>, <span class="literal">null</span>, <span class="string">'2014-09-21'</span>);</span><br><span class="line">  </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> pageviews</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="string">'tjohnson'</span>, <span class="string">'sports.com'</span>, <span class="string">'finance.com'</span>, <span class="string">'2014-09-23'</span>), (<span class="string">'tlee'</span>, <span class="string">'finance.com'</span>, <span class="literal">null</span>, <span class="string">'2014-09-21'</span>);</span><br></pre></td></tr></table></figure>
<h2 id="6-命令"><a href="#6-命令" class="headerlink" title="6. 命令"></a><span id="jump6">6. 命令</span></h2><p>这里的命令指非sql语句，例如设置属性或添加资源。它们可以在HiveQL脚本中使用，也可以直接在CLI或Beeline中使用。</p>
<p>如何查看hive版本：</p>
<p>在安装了hive的服务器上运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive --version</span><br></pre></td></tr></table></figure>
<p>Hive shell 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hive&gt;quit;</span><br><span class="line">退出interactive shell（或使用ctrl + c）</span><br><span class="line"></span><br><span class="line">! &lt;command&gt;</span><br><span class="line">Executes a shell command from the Hive shell.</span><br><span class="line">例如：</span><br><span class="line">hive&gt;!ls;</span><br><span class="line">（查看进入hive shell前所在路径下的文件）</span><br><span class="line"></span><br><span class="line">dfs &lt;dfs command&gt;</span><br><span class="line">Executes a dfs command from the Hive shell.</span><br><span class="line">例如：</span><br><span class="line">hive&gt;dfs -ls /user;</span><br><span class="line">（查看hdfs中/user目录下的文件）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hive</tag>
      </tags>
  </entry>
  <entry>
    <title>笔试知识点</title>
    <url>/2020/01/12/%E7%AC%94%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h4><p>HBase是一个分布式的、面向列的开源数据库。</p>
<p>题目来源于：<a href="https://www.cnblogs.com/cxchanpin/p/7381890.html" target="_blank" rel="noopener">https://www.cnblogs.com/cxchanpin/p/7381890.html</a></p>
<ul>
<li><p>HBase来源于哪篇博文？ C</p>
<p>A. The Google File System</p>
<p>B. MapReduce</p>
<p>C. BigTable</p>
<p>D. Chubby</p>
</li>
</ul>
<hr>
<ul>
<li><p>下对HBase的描写叙述哪些是正确的？ B、C、D</p>
<p>A. 不是开源的</p>
<p>B. 是面向列的</p>
<p>C. 是分布式的</p>
<p>D. 是一种NoSQL数据库</p>
</li>
</ul>
<a id="more"></a>
<hr>
<ul>
<li><p>HBase依靠（）存储底层数据 A</p>
<p>A. HDFS</p>
<p>B. Hadoop</p>
<p>C. Memory</p>
<p>D. MapReduce</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase依赖（）提供消息通信机制 A</p>
<p>A. Zookeeper</p>
<p>B. Chubby</p>
<p>C. RPC</p>
<p>D. Socket</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase依赖（）提供强大的计算能力 D</p>
<p>A. Zookeeper</p>
<p>B. Chubby</p>
<p>C. RPC</p>
<p>D. MapReduce</p>
</li>
</ul>
<hr>
<ul>
<li><p>MapReduce与HBase的关系，哪些描写叙述是正确的？ B、C</p>
<p>A. 两者不可或缺。MapReduce是HBase能够正常执行的保证</p>
<p>B. 两者不是强关联关系，没有MapReduce，HBase能够正常执行</p>
<p>C. MapReduce能够直接訪问HBase</p>
<p>D. 它们之间没有不论什么关系</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下哪些选项正确描写叙述了HBase的特性？ A、B、C、D</p>
<p>A. 高可靠性</p>
<p>B. 高性能</p>
<p>C. 面向列</p>
<p>D. 可伸缩</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下与Zookeeper类似的框架是？D</p>
<p>A. Protobuf</p>
<p>B. Java</p>
<p>C. Kafka </p>
<p>D. Chubby</p>
</li>
</ul>
<p>Kafka是一个高吞吐量分布式消息系统。kafka的数据仅仅会顺序append。数据的删除策略是累积到一定程度或者超过一定时间再删除。Kafka还有一个独特的地方是将消费者信息保存在client而不是MQserver。这样server就不用记录消息的投递过程，每一个client都自己知道自己下一次应该从什么地方什么位置读取消息。消息的投递过程也是采用client主动pull的模型，这样大大减轻了server的负担。Kafka还强调降低数据的序列化和拷贝开销，它会将一些消息组织成Message Set做批量存储和发送，而且client在pull数据的时候，尽量以zero-copy的方式传输。利用sendfile（相应java里的 FileChannel.transferTo/transferFrom）这种高级IO函数来降低拷贝开销。可见，kafka是一个精心设计，特定于某些应用的MQ系统，这种偏向特定领域的MQ系统我预计会越来越多，垂直化的产品策略值的考虑。</p>
<p>Chubby首先是一个分布式的文件系统。Chubby可以提供机制使得client可以在Chubby service上创建文件和运行一些文件的基本操作。说它是分布式的文件系统，是由于一个Chubby cell是一个分布式的系统。一般包括了5台机器，整个文件系统是部署在这5台机器上的。</p>
<p>从更高一点的语义层面上，Chubby是一个 lock service。一个针对松耦合的分布式系统的lock service。所谓lock service，就是这个service可以提供开发者经经常使用的“锁”，“解锁”功能。通过Chubby，一个分布式系统中的上千个client都可以 对于某项资源进行“加锁”，“解锁”。</p>
<p>那么，Chubby是如何实现这种“锁”功能的？就是通过文件。Chubby中的“锁”就是文件。在上例中，创建文件事实上就是进行“加锁”操作，创建文件成功的那个server事实上就是抢占到了“锁”。用户通过打开、关闭和读取文件。获取共享锁或者独占锁； 而且通过通信机制，向用户发送更新信息。</p>
<p>综上所述。Chubby是一个lock service。通过这个lock service能够解决分布式中的一致性问题。而这个lock service的实现是一个分布式的文件系统。</p>
<hr>
<ul>
<li><p>以下与HDFS类似的框架是？C</p>
<p>A. NTFS</p>
<p>B. FAT32</p>
<p>C. GFS (也是分布式文件系统，谷歌自己的分布式文件系统)</p>
<p>D. EXT3</p>
</li>
</ul>
<hr>
<ul>
<li><p>以下哪些概念是HBase框架中使用的？A、C</p>
<p>A. HDFS</p>
<p>B. GridFS</p>
<p>C. Zookeeper</p>
<p>D. EXT3</p>
</li>
</ul>
<hr>
<h5 id="HFile"><a href="#HFile" class="headerlink" title="HFile"></a>HFile</h5><p><span style="color:red">HFile是HBase存储数据的文件组织形式</span></p>
<ul>
<li><p>HFile数据格式中的Data字段用于（）。A</p>
<p>A. 存储实际的KeyValue数据</p>
<p>B. 存储数据的起点</p>
<p>C. 指定字段的长度</p>
<p>D. 存储数据块的起点</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的MetaIndex字段用于（）。D</p>
<p>A. Meta块的长度</p>
<p>B. Meta块的结束点</p>
<p>C. Meta块数据内容</p>
<p>D. Meta块的起始点</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的Magic字段用于（）。A</p>
<p>A. 存储随机数，防止数据损坏</p>
<p>B. 存储数据的起点</p>
<p>C. 存储数据块的起点</p>
<p>D. 指定字段的长度</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的KeyValue数据格式，下列选项描写叙述正确的是（）。A、D</p>
<p>A. 是byte[]数组</p>
<p>B. 没有固定的结构</p>
<p>C. 数据的大小是定长的</p>
<p>D. 有固定的结构</p>
</li>
</ul>
<hr>
<ul>
<li><p>HFile数据格式中的KeyValue数据格式中Value部分是（）。C</p>
<p>A. 拥有复杂结构的字符串</p>
<p>B. 字符串</p>
<p>C. 二进制数据</p>
<p>D. 压缩数据</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase中的批量载入底层使用（）实现。A</p>
<p>A. MapReduce</p>
<p>B. Hive</p>
<p>C. Coprocessor</p>
<p>D. Bloom Filter</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase性能优化包括以下的哪些选项？A、B、C、D</p>
<p>A. 读优化</p>
<p>B. 写优化</p>
<p>C. 配置优化</p>
<p>D. JVM优化</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase构建二级索引的实现方式有哪些？ A、B</p>
<p>A. MapReduce</p>
<p>B. Coprocessor</p>
<p>(HBase在0.92之后引入了协处理器(coprocessors)，实现一些激动人心的新特性：可以轻易建立二次索引、复杂过滤器(谓词下推)以及訪问控制等)</p>
<p>C. Bloom Filter</p>
<p>D. Filter</p>
</li>
</ul>
<hr>
<ul>
<li><p>关于HBase二级索引的描写叙述。哪些是正确的？A、B</p>
<p>A. 核心是倒排表</p>
<p>B. 二级索引概念是相应Rowkey这个“一级”索引</p>
<p>C. 二级索引使用平衡二叉树</p>
<p>D. 二级索引使用LSM结构</p>
</li>
</ul>
<hr>
<ul>
<li><p>下列关于Bloom Filter的描写叙述正确的是？A、C</p>
<p>A. 是一个非常长的二进制向量和一系列随机映射函数</p>
<p>B. 没有误算率</p>
<p>C. 有一定的误算率</p>
<p>D. 能够在Bloom Filter中删除元素</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase官方版本号能够安装在什么操作系统上？A、B、C</p>
<p>A. CentOS</p>
<p>B. Ubuntu</p>
<p>C. RedHat</p>
<p>D. Windows</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase虚拟分布式模式须要（）个节点？A</p>
<p>A. 1</p>
<p>B. 2</p>
<p>C. 3</p>
<p>D. 最少3个</p>
</li>
</ul>
<hr>
<ul>
<li><p>HBase分布式模式最好须要（）个节点？C</p>
<p>A. 1</p>
<p>B. 2</p>
<p>C. 3</p>
</li>
</ul>
<hr>
<ul>
<li><p>下列哪些选项是安装HBase前所必须安装的？A、B</p>
<p>A. 操作系统</p>
<p>B. JDK</p>
<p>C. Shell Script</p>
<p>D. Java Code</p>
</li>
</ul>
<hr>
<ul>
<li><p>解压.tar.gz结尾的HBase压缩包使用的Linux命令是？A</p>
<p>A. tar -zxvf</p>
<p>B. tar -zx</p>
<p>C. tar -s</p>
<p>D. tar -nf</p>
</li>
</ul>
<hr>
<ul>
<li>从Hadoop 2.7.3 版本开始，HDFS中Block size 的默认大小为128MB.</li>
</ul>
<hr>
<h4 id="SQL面试题"><a href="#SQL面试题" class="headerlink" title="SQL面试题"></a>SQL面试题</h4><p><a href="https://www.cnblogs.com/huolong-blog/p/7603454.html" target="_blank" rel="noopener">https://www.cnblogs.com/huolong-blog/p/7603454.html</a></p>
<ul>
<li><p>触发器的作用？</p>
<p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么是存储过程？用什么来调用？</p>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。</p>
</li>
</ul>
<hr>
<ul>
<li><p>索引的作用？和它的优点缺点是什么？</p>
<p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。简单地说，索引是一个数据结构，用来快速访问数据库表格或者视图里的数据。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么是事务？什么是锁？</p>
<p>事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就失败，以后操作就会回滚到操作前状态，或者是上个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。</p>
<p>锁：在所有的DBMS中，锁是实现事务的关键，锁可以保证事务的完整性和并发性。与现实生活中锁一样，它可以使某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。</p>
</li>
</ul>
<hr>
<ul>
<li><p>什么叫视图？游标是什么？</p>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。游标用于定位结果集的行。</p>
</li>
</ul>
<h4 id="算法工程师能力评估（牛客）"><a href="#算法工程师能力评估（牛客）" class="headerlink" title="算法工程师能力评估（牛客）"></a>算法工程师能力评估（牛客）</h4><p><img src="/2020/01/12/笔试知识点/1581870524984.png" alt="1581870524984"></p>
<p><img src="/2020/01/12/笔试知识点/1581864564384.png" alt="1581864564384"></p>
<p><img src="/2020/01/12/笔试知识点/1581864653934.png" alt="1581864653934"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581864678069.png" alt="1581864678069"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581864809633.png" alt="1581864809633"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581864854892.png" alt="1581864854892"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581864889064.png" alt="1581864889064"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581864916612.png" alt="1581864916612"></p>
<p>B树相关知识见<a href="https://qypx.github.io/2020/02/16/B树介绍/">这里</a></p>
<hr>
<ul>
<li>具有3个结点的二叉树有几种形态？</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581865489812.png" alt="1581865489812"></p>
<p>解析：</p>
<pre><code> 这是组合计数问题，最常见的catalan数，C(n)=(1/(n+1))*((2*n)!/(n!*n!)) 

 3个节点详细如图： 
</code></pre><p><img src="/2020/01/12/笔试知识点/1581865572237.png" alt="1581865572237"></p>
<hr>
<ul>
<li>已知一棵二叉树前序遍历和中序遍历分别为 <code>ABDEGCFH</code> 和 <code>DBGEACHF</code>，则该二叉树的后序遍历为多少？</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581865717797.png" alt="1581865717797"></p>
<p>解析：</p>
<p><strong>前序遍历确定根节点，中序遍历确定左右子树</strong>。</p>
<p><img src="/2020/01/12/笔试知识点/1581866226956.png" alt="1581866226956"></p>
<hr>
<ul>
<li>已知数据表A中每个元素距其最终位置不远，为节省时间排序，应采用什么方法排序？</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581866323542.png" alt="1581866323542"></p>
<p>解析：</p>
<ul>
<li><p>插入排序：如果平均每个元素离最终位置相距c个元素，则其复杂度为O(cn)，一共n趟，每次比较c次； </p>
</li>
<li><p>快速排序：最好的、平均的复杂度都是O(nlog(n))，如果每次选择的中间数都最小或最大，那就是最坏的情况，复杂度是O(n*n)；所以快速排序和元素的位置没有关系，跟选择的中间数有关。 </p>
</li>
<li><p>堆排序：复杂度一直是O(nlog(n)); </p>
</li>
<li><p>直接选择排序：跟元素位置没有关系，都要遍历n遍，每遍找出最小或最大数来，复杂度是O(n*n)； </p>
<p>答案是插入排序。 </p>
</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581866854874.png" alt="1581866854874"></p>
<hr>
<ul>
<li>将N条长度均为M的有序链表进行合并，合并以后的链表也保持有序，时间复杂度为()?</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581867137493.png" alt="1581867137493"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581867157973.png" alt="1581867157973"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581867257640.png" alt="1581867257640"></p>
<p>解析：这个是卡特兰数的经典应用，但是这个问题不是一两句话能说得清的。</p>
<p>可采取代入法，n=1或n=2代入，均可得到正确答案。</p>
<hr>
<ul>
<li>T(n) = 25T(n/5)+n^2的时间复杂度？</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581867385697.png" alt="1581867385697"></p>
<p>解析：Master Theorem</p>
<p><img src="/2020/01/12/笔试知识点/1581867450572.png" alt="1581867450572"></p>
<hr>
<ul>
<li>连续自然数之和为1000的共有几组？（m，n都为自然数，单独1个数也算作“连续自然数”）</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581868980583.png" alt="1581868980583"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581869129932.png" alt="1581869129932"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581869211656.png" alt="1581869211656"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581869344795.png" alt="1581869344795"></p>
<p><img src="/2020/01/12/笔试知识点/1581869369324.png" alt="1581869369324"></p>
<hr>
<ul>
<li>写出a*(b-c*d)+e-f/g*(h+i*j-k)的逆波兰表达式。</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581869439352.png" alt="1581869439352"></p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95" target="_blank" rel="noopener">逆波兰表达式</a></p>
<hr>
<ul>
<li>下列关于线性表，二叉平衡树，哈希表存储数据的优劣描述错误的是？</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581869526156.png" alt="1581869526156"></p>
<p>解析：<strong>在平衡二叉树中插入结点要随时保证插入后整棵二叉树是平衡的，所以可能需要通过一次或多次树旋转来重新平衡这个树</strong>。</p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581869693305.png" alt="1581869693305"></p>
<p><img src="/2020/01/12/笔试知识点/1581869715738.png" alt="1581869715738"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581869761466.png" alt="1581869761466"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581869840257.png" alt="1581869840257"></p>
<hr>
<ul>
<li>如果一个堆栈的入栈序列是A,B,C,D,E,则堆栈的不可能输出顺序是（）。</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581869901758.png" alt="1581869901758"></p>
<hr>
<ul>
<li>若以{4,5,6,7,8}作为叶子结点的权值构造哈夫曼树，则其带权路径长度是（）。</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581870076226.png" alt="1581870076226"></p>
<p>解析：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20161031/6306378_1477892872536_FB5C81ED3A220004B71069645F112867" alt="img"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1581870138420.png" alt="1581870138420"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581870210402.png" alt="1581870210402"></p>
<hr>
<ul>
<li>设某颗二叉树中有360个结点，则该二叉树的最小高度是？(包括根节点)</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1581870300117.png" alt="1581870300117"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1581870472998.png" alt="1581870472998"></p>
<hr>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><hr>
<ul>
<li><p>时间序列模型中，哪一个模型可以较好的拟合波动性的分析和预测 (D)</p>
<p>A. AR模型</p>
<p>B. MA模型</p>
<p>C. ARMA模型</p>
<p>D. GARCH模型</p>
</li>
</ul>
<p>解析：</p>
<p>参考 <a href="https://blog.csdn.net/s1491695565/article/details/52093003" target="_blank" rel="noopener">https://blog.csdn.net/s1491695565/article/details/52093003</a></p>
<p>时间序列中常用预测技术  一个时间序列是一组对于某一变量连续时间点或连续时段上的观测值。</p>
<p><strong>1.  移动平均法 (MA)</strong></p>
<p>1.1. 简单移动平均法</p>
<p>设有一时间序列y1,y2,…, 则按数据点的顺序逐点推移求出N个数的平均数，即可得到一次移动平均数.</p>
<p> 1.2 趋势移动平均法  </p>
<p>当时间序列没有明显的趋势变动时，使用一次移动平均就能够准确地反映实际情况，直接用第t周期的一次移动平均数就可预测第t+1周期之值。</p>
<p>时间序列出现线性变动趋势时，用一次移动平均数来预测就会出现滞后偏差。修正的方法是在一次移动平均的基础上再做二次移动平均，利用移动平均滞后偏差的规律找出曲线的发展方向和发展趋势，然后才建立直线趋势的预测模型。故称为趋势移动平均法。</p>
<p><strong>2.  自回归模型(AR)</strong></p>
<p>AR模型是一种线性预测，即已知N个数据，可由模型推出第N点前面或后面的数据（设推出P点）.</p>
<p>本质类似于插值，其目的都是为了增加有效数据，只是AR模型是由N点递推，而插值是由两点（或少数几点）去推导多点，所以AR模型要比插值方法效果更好。</p>
<p><strong>3. 自回归滑动平均模型(ARMA)</strong></p>
<p>其建模思想可概括为：逐渐增加模型的阶数，拟合较高阶模型，直到再增加模型的阶数而剩余残差方差不再显著减小为止。</p>
<p><strong>4. GARCH模型</strong></p>
<p>回归模型。除去和普通回归模型相同的之处，GARCH对误差的方差进行了进一步的建模。特别适用于波动性的分析和预测。</p>
<p><strong>4. 指数平滑法</strong></p>
<p>移动平均法的预测值实质上是以前观测值的加权和，且对不同时期的数据给予相同的加权。这往往不符合实际情况。</p>
<p>指数平滑法则对移动平均法进行了改进和发展，其应用较为广泛。</p>
<p>基本思想都是：预测值是以前观测值的加权和，且对不同的数据给予不同的权，新数据给较大的权，旧数据给较小的权。</p>
<p>根据平滑次数不同，指数平滑法分为：一次指数平滑法、二次指数平滑法和三次指数平滑法等。</p>
<hr>
<ul>
<li><p>下面对集成学习模型中的弱学习者描述错误的是 (C)</p>
<p>A. 他们经常不会过拟合</p>
<p>B. 他们通常带有高偏差，所以其并不能解决复杂学习问题</p>
<p>C. 他们通常会过拟合</p>
</li>
</ul>
<p>弱学习器：略优于随机猜测的学习器。（西瓜书）</p>
<hr>
<ul>
<li><p>xgboost对缺失值的处理方法：</p>
<p>把缺失值分别放到左叶子节点和右叶子节点中，计算增益。哪个增益大就放到哪个叶子节点。</p>
</li>
</ul>
<hr>
<ul>
<li>Hive四大表类型：<ul>
<li>内部表</li>
<li>外部表</li>
<li>分区表</li>
<li>桶表（或叫分桶表）</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>能在O(1)时间内访问线性表的第i个元素的结构是 ( )</p>
<p><img src="/2020/01/12/笔试知识点/1582361004130.png" alt="1582361004130"></p>
</li>
</ul>
<p><img src="/2020/01/12/笔试知识点/1582360970415.png" alt="1582360970415"></p>
<hr>
<ul>
<li><p>只要数据元素保持有序，则查找时就可以采用折半查找方法 ( )</p>
<p><img src="/2020/01/12/笔试知识点/1582361114265.png" alt="1582361114265"></p>
</li>
</ul>
<hr>
<ul>
<li><p>一个长度为32的有序表，若采用二分查找一个不存在的元素，则比较次数最多是 ( )</p>
<p><img src="/2020/01/12/笔试知识点/1582361203067.png" alt="1582361203067"></p>
</li>
</ul>
<hr>
<ul>
<li><p>分块查找的基本思想是首先在索引表中进行查找，以便确定给定的关键字可能存在的块号，然后再在相应的块内进行顺序查找。( )</p>
<p><img src="/2020/01/12/笔试知识点/1582361360734.png" alt="1582361360734"></p>
</li>
</ul>
<hr>
<ul>
<li><p>下列说法中错误的是( )</p>
<p>A. 插入排序某些情况下复杂度为O(n)</p>
<p>B. 排序二叉树元素查找的复杂度可能为O(n)</p>
<p>C. 对于有序列表的排序最快的是快速排序</p>
<p>D. 在有序列表中通过二分查找的复杂度一定为O(logn)</p>
</li>
</ul>
<p>答案：C</p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582363721071.png" alt="1582363721071"></p>
<p>C选项应该为插入排序？</p>
<hr>
<ul>
<li><p>在长度为n的顺序线性表中顺序查找值为x的元素时，查找成功时的平均查找长度（假定查找每个元素的概率均相等）为（）</p>
<p><img src="/2020/01/12/笔试知识点/1582363882820.png" alt="1582363882820"></p>
</li>
</ul>
<hr>
<ul>
<li><p>折半查找与二元查找树的时间性能在最坏的情况下是相同的 ( )</p>
<p><img src="/2020/01/12/笔试知识点/1582363973719.png" alt="1582363973719"></p>
</li>
</ul>
<hr>
<ul>
<li><p>使用KMP算法在文本串S中找m模式串P是一种常见的方法。假设S=P={xyxyyxxyx}，亦即将S对自己进行匹配，匹配过程中正确的next数组是( )</p>
<p><img src="/2020/01/12/笔试知识点/1582364106629.png" alt="1582364106629"></p>
</li>
</ul>
<p>解析：参考 <a href="https://blog.csdn.net/qq_37969433/article/details/82947411" target="_blank" rel="noopener">https://blog.csdn.net/qq_37969433/article/details/82947411</a></p>
<p><img src="/2020/01/12/笔试知识点/1582364410421.png" alt="1582364410421"></p>
<hr>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><span style="color:red">基选归堆不变（运行时间不发生变化，与初始状态无关）</span></p>
<p><span style="color:red">快选希堆不稳（是不稳定的排序） </span></p>
<ul>
<li><p>已给图，( )是该图的正确的拓扑排序序列</p>
<p>​    <img src="/2020/01/12/笔试知识点/1582371132616.png" alt="1582371132616"></p>
</li>
<li><p>在用邻接表表示图时，拓扑排序算法时间复杂度为( )</p>
<p><img src="/2020/01/12/笔试知识点/1582374420342.png" alt="1582374420342"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582374447488.png" alt="1582374447488"></p>
</li>
</ul>
<hr>
<ul>
<li><p>下面的排序方法中，关键字比较次数与记录的初始排序无关的是( )</p>
<p><img src="/2020/01/12/笔试知识点/1582371218204.png" alt="1582371218204"></p>
</li>
</ul>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582371246385.png" alt="1582371246385"></p>
<p><img src="https://qypx.github.io/2020/01/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1578640411160.png" alt="1578640411160"></p>
<p><span style="color:red">基选归堆不变（运行时间不发生变化，与初始状态无关）</span></p>
<hr>
<ul>
<li><p>下列排序算法不稳定的有 ( )</p>
<p><img src="/2020/01/12/笔试知识点/1582372396395.png" alt="1582372396395"></p>
</li>
</ul>
<p><span style="color:red">快选希堆不稳（是不稳定的排序） </span></p>
<hr>
<ul>
<li><p>下列说法错误的是( )</p>
<p><img src="/2020/01/12/笔试知识点/1582372339161.png" alt="1582372339161"></p>
</li>
</ul>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582372667692.png" alt="1582372667692"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582372732725.png" alt="1582372732725"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582372932412.png" alt="1582372932412"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582372984413.png" alt="1582372984413"></p>
<p><img src="/2020/01/12/笔试知识点/1582373764364.png" alt="1582373764364"></p>
<p><img src="/2020/01/12/笔试知识点/1582373826092.png" alt="1582373826092"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582373868980.png" alt="1582373868980"></p>
<p>以下来源于百度百科：</p>
<p>基数排序：最低位优先(Least Significant Digit first)法，简称LSD法：</p>
<p><img src="/2020/01/12/笔试知识点/1582374257291.png" alt="1582374257291"></p>
<p><img src="/2020/01/12/笔试知识点/1582374278992.png" alt="1582374278992"></p>
<p><img src="/2020/01/12/笔试知识点/1582374296292.png" alt="1582374296292"></p>
<hr>
<ul>
<li><p>下列排序算法中，( ) 在某趟排序结束后不一定能选出一个元素放到其最终位置上</p>
<p><img src="/2020/01/12/笔试知识点/1582374591201.png" alt="1582374591201"></p>
</li>
</ul>
<p>解析：</p>
<p>选 择 排 序 (Selection sort)： 是 一 种 简 单 直 观 的 排 序 算 法 。 它 的 工 作 原 理 是 每 一 次 从 待 排 序 的 数 据 元 素 中 选 出 最 小 （ 或 最 大 ） 的 一 个元 素 ， 存 放 在 序 列 的 起 始 位 置 ， 直 到 全 部 待 排 序 的 数 据 元 素 排 完 ，所 以 每 一 趟 选 择 的 元 素 都 会 放 在 他 的 最 终 位 置 </p>
<p>冒 泡 排 序 ：它 重 复 地 走 访 过 要 排 序 的 数 列 ， 一 次 比 较 两 个 元 素 ， 如 果 他 们 的 顺 序 错 误 就 把 他 们 交 换 过 来 。 走 访 数 列 的 工 作 是 重 复 地 进 行 直 到 没 有 再 需 要 交 换 ， 也 就 是 说 该 数 列 已 经 排 序 完 成 。 比 如 按 照 升 序 排 序 则 每 一 趙 会 将 前 面 未 排 序 部 分 的 最 大 的 往 后 交 换 到 已 排 序 的 最 前 面 ， 为 其 最 终 位 置 </p>
<p>堆 排 序 ：如 果 要 求 升 序 则 建 立 大 根 堆 ， 降 序 则 建 立 小 根 堆 ， 堆 顶 元 素 为 最 大 或 者 最 小 的 元 素 ， 将 这 个 元 素 与 最 后 一 个 位 置 的 元 素 交 换 ， 再 将 剩 余 元 素 还 原 成 大 小 跟 堆 ， 每 一 趙 都 会 选 出 一 个 未 排 序 中 的 最 大 或 者 最 小 放 大 他 的 最 终 位 置 </p>
<p>希 尔 排 序： 由 于 是 按 照 增 量 排 序 ， 步 长 不 同 可 能 元 素 不 一 定 到 他 最 终 位 置 ， 所 以 选 C </p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582375139504.png" alt="1582375139504"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582381646518.png" alt="1582381646518"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582381694491.png" alt="1582381694491"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582381746786.png" alt="1582381746786"></p>
<hr>
<ul>
<li><p>下面( )排序算法在输入数据逆序情况下排序速度最快</p>
<p><img src="/2020/01/12/笔试知识点/1582381909114.png" alt="1582381909114"></p>
</li>
<li><p>对于基本有序的序列，按照哪种排序方式最快：</p>
<p><img src="/2020/01/12/笔试知识点/1582381995803.png" alt="1582381995803"></p>
</li>
</ul>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582382048981.png" alt="1582382048981"></p>
<hr>
<p><img src="/2020/01/12/笔试知识点/1582382128578.png" alt="1582382128578"></p>
<p>解析：</p>
<p><img src="/2020/01/12/笔试知识点/1582382202047.png" alt="1582382202047"></p>
<hr>]]></content>
      <categories>
        <category>笔试</category>
      </categories>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语言</title>
    <url>/2020/01/12/sql%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="DDL与DML"><a href="#DDL与DML" class="headerlink" title="DDL与DML"></a>DDL与DML</h3><p>DDL: maintaining structure of database. (CREATE, DROP, ALTER, RENAME)</p>
<p>DML: maintaining contents of database. (SELECT, INSERT, DELETE, UPDATE)</p>
<p><img src="/2020/01/12/sql语言/1578825616684.png" alt="1578825616684"></p>
<a id="more"></a>
<h4 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h4><p><img src="/2020/01/12/sql语言/1578900159995.png" alt="1578900159995"></p>
<blockquote>
<p>注：字符为单引号</p>
</blockquote>
<p><code>INSERT INTO tablename {column1,column2,…}values(exp1,exp2,…);</code>  //插入</p>
<h4 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h4><p><img src="/2020/01/12/sql语言/1578900315795.png" alt="1578900315795"></p>
<h4 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h4><p><img src="/2020/01/12/sql语言/1578900364614.png" alt="1578900364614"></p>
<h4 id="CREATE"><a href="#CREATE" class="headerlink" title="CREATE"></a>CREATE</h4><p><img src="/2020/01/12/sql语言/1578899962419.png" alt="1578899962419"></p>
<p><strong>CREATE的时候，先CREATE没有外键的表，最后CREATE有外键的表</strong></p>
<p>假设我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。这个表的建表语句是：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> T (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">    k <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>),</span><br><span class="line">    <span class="keyword">index</span> (k)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure>
<h4 id="DROP"><a href="#DROP" class="headerlink" title="DROP"></a>DROP</h4><p><img src="/2020/01/12/sql语言/1578900950689.png" alt="1578900950689"></p>
<p><strong>DROP的时候，先DROP有外键的表，最后DROP没有外键的表</strong></p>
<h4 id="ALTER"><a href="#ALTER" class="headerlink" title="ALTER"></a>ALTER</h4><p>例如增加一列</p>
<p><img src="/2020/01/12/sql语言/1578901179360.png" alt="1578901179360"></p>
<h4 id="RENAME"><a href="#RENAME" class="headerlink" title="RENAME"></a>RENAME</h4><p><img src="/2020/01/12/sql语言/1578901685944.png" alt="1578901685944"></p>
<h3 id="语法顺序与执行顺序"><a href="#语法顺序与执行顺序" class="headerlink" title="语法顺序与执行顺序"></a>语法顺序与执行顺序</h3><p><img src="/2020/01/12/sql语言/1578825674160.png" alt="1578825674160"></p>
<p><img src="/2020/01/12/sql语言/1578825736061.png" alt="1578825736061"></p>
<p>相当于就是 SELECT [DISTINCT] 的顺序换了一下。</p>
<h3 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h3><p><img src="/2020/01/12/sql语言/1596791792580.png" alt="1596791792580"></p>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p><img src="/2020/01/12/sql语言/1596791382343.png" alt="1596791382343"></p>
<h3 id="找最大值"><a href="#找最大值" class="headerlink" title="找最大值"></a>找最大值</h3><h4 id="例一：哪一个物品有最高的cost"><a href="#例一：哪一个物品有最高的cost" class="headerlink" title="例一：哪一个物品有最高的cost?"></a>例一：哪一个物品有最高的cost?</h4><p><img src="/2020/01/12/sql语言/1596791476146.png" alt="1596791476146"></p>
<p>If two different items have highest price, 第一个query会把两个都返回，第二个query只会返回一个</p>
<h4 id="例二：找出有最多空房间的楼层"><a href="#例二：找出有最多空房间的楼层" class="headerlink" title="例二：找出有最多空房间的楼层"></a>例二：找出有最多空房间的楼层</h4><p><a href="http://sqlfiddle.com/#!9/492887/22" target="_blank" rel="noopener">http://sqlfiddle.com/#!9/492887/22</a></p>
<p><img src="/2020/01/12/sql语言/1597394612354.png" alt="1597394612354"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> blockfloor <span class="keyword">as</span> <span class="string">"Floor"</span>,</span><br><span class="line">       <span class="keyword">count</span>(*) <span class="keyword">AS</span>  <span class="string">"No of available rooms"</span></span><br><span class="line"><span class="keyword">FROM</span> room</span><br><span class="line"><span class="keyword">WHERE</span> unavailable=<span class="string">'0'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> blockfloor</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">count</span>(*) =</span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="keyword">max</span>(zz) <span class="keyword">AS</span> highest_total</span><br><span class="line">   <span class="keyword">FROM</span></span><br><span class="line">     ( <span class="keyword">SELECT</span> blockfloor ,</span><br><span class="line">              <span class="keyword">count</span>(*) <span class="keyword">AS</span> zz</span><br><span class="line">      <span class="keyword">FROM</span> room</span><br><span class="line">      <span class="keyword">WHERE</span> unavailable=<span class="string">'0'</span></span><br><span class="line">      <span class="keyword">GROUP</span> <span class="keyword">BY</span> blockfloor ) <span class="keyword">AS</span> t );</span><br></pre></td></tr></table></figure>
<p>注：以下写法错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> BlockFloor, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> <span class="string">"maximum number of rooms available"</span></span><br><span class="line"><span class="keyword">FROM</span> Room</span><br><span class="line"><span class="keyword">WHERE</span> Unavailable=<span class="number">0</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> BlockFloor</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) = </span><br><span class="line">	(<span class="keyword">SELECT</span> <span class="keyword">MAX</span>(<span class="keyword">COUNT</span>(*))</span><br><span class="line">	<span class="keyword">FROM</span> Room</span><br><span class="line">	<span class="keyword">WHERE</span> Unavailable = <span class="number">0</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> BlockFloor);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/sql语言/1597394696134.png" alt="1597394696134"></p>
<h4 id="例三：找出第二高的薪水"><a href="#例三：找出第二高的薪水" class="headerlink" title="例三：找出第二高的薪水"></a>例三：找出第二高的薪水</h4><p><a href="https://leetcode.com/problems/second-highest-salary/" target="_blank" rel="noopener">https://leetcode.com/problems/second-highest-salary/</a></p>
<p><img src="/2020/01/12/sql语言/1599193947629.png" alt="1599193947629"></p>
<p>如何避免有多个最大值的情况：使用DISTINCT：Sort the distinct salary in descend order，再用LIMIT和OFFSET</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 法一：Using sub-query and LIMIT clause</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">     <span class="keyword">FROM</span> Employee</span><br><span class="line">     <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">     <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>) <span class="keyword">AS</span> SecondHighestSalary;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 法二：Using IFNULL and LIMIT clause: </span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">IFNULL</span>(</span><br><span class="line">      (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Salary</span><br><span class="line">       <span class="keyword">FROM</span> Employee</span><br><span class="line">       <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line">       <span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>),</span><br><span class="line">    <span class="literal">NULL</span>) <span class="keyword">AS</span> SecondHighestSalary;</span><br></pre></td></tr></table></figure>
<p>注：如果直接写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">    Salary <span class="keyword">AS</span> SecondHighestSalary</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    Employee</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">1</span> <span class="keyword">OFFSET</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>this solution will be judged as ‘Wrong Answer’ if there is no such second highest salary since there might be only one record in this table.</p>
<p><img src="/2020/01/12/sql语言/1599194162675.png" alt="1599194162675"></p>
<h4 id="例四：找出每门课分数都大于75的学生中，分数最高的那条记录"><a href="#例四：找出每门课分数都大于75的学生中，分数最高的那条记录" class="headerlink" title="例四：找出每门课分数都大于75的学生中，分数最高的那条记录"></a>例四：找出每门课分数都大于75的学生中，分数最高的那条记录</h4><p><a href="http://sqlfiddle.com/#!9/ee6ee5/1" target="_blank" rel="noopener">http://sqlfiddle.com/#!9/ee6ee5/1</a></p>
<p><img src="/2020/01/12/sql语言/1600917047680.png" alt="1600917047680"></p>
<p>输出：</p>
<p><img src="/2020/01/12/sql语言/1600917082998.png" alt="1600917082998"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> score = </span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="keyword">max</span>(max_score)</span><br><span class="line">  <span class="keyword">FROM</span> </span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">max</span>(Score) <span class="keyword">AS</span> max_score</span><br><span class="line">    <span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">HAVING</span> <span class="keyword">min</span>(score)&gt;<span class="number">75</span>) p);</span><br></pre></td></tr></table></figure>
<p>(👆不确定是否是正确答案)</p>
<p>注：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">max</span>(Score)</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">min</span>(score)&gt;<span class="number">75</span></span><br></pre></td></tr></table></figure>
<p>输出的结果是满足条件的每个学生各自的最高分数：</p>
<p><img src="/2020/01/12/sql语言/1600917356859.png" alt="1600917356859"></p>
<p>所以以下写法错误：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> table1</span><br><span class="line"><span class="keyword">WHERE</span> score <span class="keyword">in</span> <span class="comment">#这里更不能用等于</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">max</span>(Score)</span><br><span class="line">    <span class="keyword">FROM</span> table1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span></span><br><span class="line">    <span class="keyword">HAVING</span> <span class="keyword">min</span>(score)&gt;<span class="number">75</span>);</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/sql语言/1600917489922.png" alt="1600917489922"></p>
<p><img src="/2020/01/12/sql语言/1600917511295.png" alt="1600917511295"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>sql语句中的drop, truncate, delete</title>
    <url>/2020/01/12/sql%E8%AF%AD%E5%8F%A5%E4%B8%AD%E7%9A%84drop-truncate-delete/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考：</p>
<p><a href="https://blog.csdn.net/lovezhaohaimig/article/details/80184994" target="_blank" rel="noopener">https://blog.csdn.net/lovezhaohaimig/article/details/80184994</a></p>
<p><a href="https://www.cnblogs.com/xianyao/p/11613021.html" target="_blank" rel="noopener">https://www.cnblogs.com/xianyao/p/11613021.html</a></p>
<h4 id="1-drop-table-表名称"><a href="#1-drop-table-表名称" class="headerlink" title="1.drop table 表名称"></a>1.drop table 表名称</h4><p><strong>drop (删除表)：删除表内容和表定义，释放空间。</strong></p>
<p>简单来说就是把整个表去掉，以后要新增数据是不可能的，除非新增一个表。</p>
<p>把表的结构也删除了，下次要使用的时候要重新创建表的结构再插入数据。</p>
<p>drop语句将删除表结构被依赖的约束(constrain)，触发器(trigger)，索引(index)；依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p>
<p><strong>不能回滚</strong></p>
<h4 id="2-truncate-table-表名称"><a href="#2-truncate-table-表名称" class="headerlink" title="2.truncate table 表名称"></a>2.truncate table 表名称</h4><p><strong>truncate (清空表中的数据)：删除表内容、释放空间但不删除表定义。</strong>与drop不同的是，他只是清空表数据而已，不删除表结构。其列、约束、索引等保持不变。</p>
<p>truncate table test 后，向test表添加数据，插入的字段的id重新从1开始递增 1、2、3…..（体现了truncate删除是释放空间）</p>
<p><strong>in MySQL, resets auto_increment PKs</strong></p>
<p><strong>不能回滚</strong></p>
<p>注意:truncate 不能删除行数据,要删就要把表清空。</p>
<h4 id="3-delete-from-表名称-where-列名称-值"><a href="#3-delete-from-表名称-where-列名称-值" class="headerlink" title="3.delete from 表名称 where 列名称 = 值"></a>3.delete from 表名称 where 列名称 = 值</h4><p>delete (删除表中的数据)：删除整表中的行，表结构不会删除。</p>
<p><strong>删除内容，不删除定义，不释放空间。</strong></p>
<p>用delete删除数据，然后添加。可以看到添加之后id标识不连续。（说明delete删除不释放空间）</p>
<p>如果重新插入数据时，对应的id在上次基础之上递增 4、5、6….</p>
<p>delete语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存,以便进行回滚操作。</p>
<p><strong>即不带where的delete: 删除表内容，不删除表结构</strong></p>
<p><strong>可回滚</strong></p>
<h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h4><ul>
<li><p>执行速度，一般来说: drop&gt; truncate &gt; delete。</p>
</li>
<li><p>delete语句是数据库操作语言(dml)，这个操作会放到 rollback segment中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。</p>
</li>
<li><p>truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</p>
</li>
<li><p>在实际应用中，三者的区别是明确的。</p>
<ul>
<li><p>当你不再需要该表时， 用 drop;</p>
</li>
<li><p>当你仍要保留该表，但要删除所有记录时， 用 truncate; </p>
</li>
<li><p>当你要删除部分记录时（always with a WHERE clause), 用 delete.</p>
</li>
</ul>
</li>
<li><p>truncate 与delete 比较：</p>
<ul>
<li><p>truncate table 在功能上与不带 WHERE 子句的 delete语句相同：二者均删除表中的全部行。</p>
</li>
<li><p>truncate 比 delete速度快，且使用的系统和事务日志资源少。</p>
</li>
<li><p>truncate 操作后的表比Delete操作后的表要快得多。</p>
</li>
<li><p>当表被清空后，表和表的索引将重新设置成初始大小，而delete则不能。</p>
</li>
<li>truncate 删除不能恢复，delete 可以恢复数据</li>
</ul>
</li>
</ul>
<blockquote>
<p>(<a href="http://www.itpub.net/thread-392126-1-1.html" target="_blank" rel="noopener">http://www.itpub.net/thread-392126-1-1.html</a>)</p>
<p>问：执行truncate table，除了rows会删除，index也会删除，但我执行之后，查看user_indexes，索引仍在，重新加入新资料再做查询，一样可以用到索引，是不是这里所说的删除，是指删除索引的内容，可是一般我们用delete，索引的内容不是也会跟着删除吗? 那么用truncate和delete，索引的删除又有什么不同呢?</p>
<p>答：你truncate后，你只是删除索引相应的数据，也就是你所说的内容，索引的定义并没有删除，因此在数据字典里面还有相关信息。重新插入数据后，当然还会用到原来定义的索引。你要真正删除一个索引的话，那么得用drop index index_name把索引DROP掉。delete的话，索引的内容跟truncate一样是删除的，只是物理上事实上并没有删除，这个你不要去管，你就知道索引条目也相应删除就是了。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>两数之和</title>
    <url>/2020/01/12/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">两数之和（难度：简单）</a></p>
<p><img src="/2020/01/12/两数之和/1578808347100.png" alt="1578808347100"></p>
<h4 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h4><p>遍历每个元素 x，并查找是否存在一个值与 target - x相等的目标元素。\</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == target - nums[i]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, j &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n^2)</p>
<p>空间复杂度：O(1)</p>
<hr>
<h4 id="方法二：两遍哈希表"><a href="#方法二：两遍哈希表" class="headerlink" title="方法二：两遍哈希表"></a>方法二：两遍哈希表</h4><p>为了对运行时间复杂度进行优化，我们需要一种更有效的方法来检查数组中是否存在目标元素。如果存在，我们需要找出它的索引。保持数组中的每个元素与其索引相互对应的最好方法是什么？哈希表。</p>
<p>通过以空间换取速度的方式，我们可以将查找时间从 O(n)降低到 O(1)。<strong>哈希表正是为此目的而构建的，它支持以 近似恒定的时间进行快速查找</strong>。我用“近似”来描述，是因为一旦出现冲突，查找用时可能会退化到 O(n)。但只要你仔细地挑选哈希函数，在哈希表中进行查找的用时应当被摊销为 O(1)。</p>
<p><strong>使用两次迭代。在第一次迭代中，我们将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，我们将检查每个元素所对应的目标元素（target - nums[i]）是否存在于表中。</strong>注意，该目标元素不能是 nums[i]本身！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            map.put(nums[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; i, map.get(complement) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)，遍历两次，由于哈希表将查找时间缩短到 O(1) ，所以时间复杂度为 O(n)。</p>
<p>空间复杂度：O(n)，所需的额外空间取决于哈希表中存储的元素数量。</p>
<hr>
<h4 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h4><p>在进行迭代并将元素插入到表中的同时，回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(target - nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;map.get(target - nums[i]), i&#125;;</span><br><span class="line">            map.put(nums[i],i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)，只遍历一次。</p>
<p>空间复杂度：O(n)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>最长连续递增序列</title>
    <url>/2020/01/12/%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E9%80%92%E5%A2%9E%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">最长连续递增序列（难度：简单）</a></p>
<p><img src="/2020/01/12/最长连续递增序列/1578807734778.png" alt="1578807734778"></p>
<p><img src="/2020/01/12/最长连续递增序列/1578807775519.png" alt="1578807775519"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;=<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                count++;</span><br><span class="line">                max = Math.max(max,count);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/12/最长连续递增序列/1578807884555.png" alt="1578807884555"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2020/01/10/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/10/排序算法/1578640411160.png" alt="1578640411160"></p>
<p>排序算法的稳定性，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<p><span style="color:red">* 基选归堆不变（运行时间不发生变化，与初始状态无关）</span></p>
<p><span style="color:red">* 快选希堆不稳（是不稳定的排序） </span></p>
<p><u>快 速 排 序 ：</u> </p>
<p>思 想 ： </p>
<p>1 ． 在 待 排 序 的 元 素 任 取 一 个 元 素 作 为 基 准 （ 通 常 选 第 一 个 元 素 ， 但 最 的 选 择 方 法 是 从 待 排 序 元 素 中 随 机 选 取 一 个 作 为 基 准 ） ， 称 为 基 准 元 素 ； </p>
<p>2 ． 将 待 排 序 的 元 素 进 行 分 区 ， 比 基 准 元 素 大 的 元 素 放 在 它 的 右 边 ， 比 其 小 的 放 在 它 的 左 边 ； </p>
<p>3 ． 对 左 右 两 个 分 区 重 复 以 上 步 骤 直 到 所 有 元 素 都 是 有 序 的 </p>
<p> <u>冒 泡 排 序 ：</u> </p>
<p>1 ． 比 较 相 邻 的 元 素 。 如 果 第 一 个 比 第 二 个 大 ， 就 交 换 他 们 两 个 </p>
<p>2 ． 对 每 一 对 相 邻 元 素 作 同 样 的 工 作 ， 从 开 始 第 一 对 到 结 尾 的 最 后 一 对 。 在 这 一 点 ， 最 后 的 元 素 应 该 会 是 最 大 的 数 。 </p>
<p>3 ． 针 对 所 有 的 元 素 重 复 以 上 的 步 骤 ， 除 了 最 后 一 个 </p>
<p>4 ． 持 续 每 次 对 越 来 越 少 的 元 素 重 复 上 面 的 步 骤 ， 直 到 没 有 任 何 一 对 数 字 需 要 比 较 。 </p>
<p><u>归 并 排 序 ：</u> </p>
<p>第 一 步 ： 申 请 空 间 ， 使 其 大 小 为 两 个 已 经 排 序 序 列 之 和 ， 该 空 间 用 来 存 放 合 并 后 的 序 列 </p>
<p>第 二 步 ： 设 定 两 个 指 针 ， 最 初 位 置 分 别 为 两 个 已 经 排 序 序 列 的 起 始 位 置 </p>
<p>第 三 步 ： 比 较 两 个 指 针 所 指 向 的 元 素 ， 选 择 相 对 小 的 元 素 放 入 到 合 并 空 </p>
<p>间 ， 并 移 动 指 针 到 下 一 位 置 </p>
<p>重 复 步 骤 3 直 到 某 一 指 针 超 出 序 列 尾 </p>
<p>将 另 一 序 列 剩 下 的 所 有 元 素 直 接 复 制 到 合 并 序 列 尾 </p>
<p><u>插 入 排 序 ：</u> </p>
<p>1 ． 从 有 序 数 列 和 无 序 数 列 { a2 ， a3 ,  …, an} 开 始 进 行 排 序 </p>
<p>2 ． 处 理 第 i 个 元 素 时 { i ： 2 ， 3 ，… , n } , 数 列 { a1 ， a2 ，…， ai-1} 是 已 有 序 的 ， 而 数 列 {ai,ai+1, …， an } 是 无 序 的 。 用 ai 与 ai-1, a i-2, …， a1 进 行 比 较 ， 找 出 合 适 的 位 置 将 ai 插 入 ； </p>
<p>3 ． 重 复 第 二 步 ， 共 进 行 n - i 次 插 入 处 理 ， 数 列 全 部 有 序 。 </p>
<p><u>选 择 排 序 (Selection sort)：</u></p>
<p>是 一 种 简 单 直 观 的 排 序 算 法 。 它 的 工 作 原 理 是 每 一 次 从 待 排 序 的 数 据 元 素 中 选 出 最 小 （ 或 最 大 ） 的 一 个元 素 ， 存 放 在 序 列 的 起 始 位 置 ， 直 到 全 部 待 排 序 的 数 据 元 素 排 完 ，所 以 每 一 趟 选 择 的 元 素 都 会 放 在 他 的 最 终 位 置 </p>
<p>第 i 趟排序，找到L[i…n]中最小的元素与L[i]交换位置，这样保证每一趟排序确定一个元素的最终位置</p>
<p><u>堆 排 序 ：</u></p>
<p>如 果 要 求 升 序 则 建 立 大 根 堆 ， 降 序 则 建 立 小 根 堆 ， 堆 顶 元 素 为 最 大 或 者 最 小 的 元 素 ， 将 这 个 元 素 与 最 后 一 个 位 置 的 元 素 交 换 ， 再 将 剩 余 元 素 还 原 成 大 小 跟 堆 ， 每 一 趙 都 会 选 出 一 个 未 排 序 中 的 最 大 或 者 最 小 放 大 他 的 最 终 位 置 </p>
<p><u>希 尔 排 序 (shell’s sort)：</u> </p>
<p>希尔排序(Shell’s Sort)是<a href="https://baike.baidu.com/item/插入排序/7214992" target="_blank" rel="noopener">插入排序</a>的一种，又称“缩小增量排序”（Diminishing Increment Sort），是直接插入<a href="https://baike.baidu.com/item/排序算法/5399605" target="_blank" rel="noopener">排序算法</a>的一种更高效的改进版本。希尔排序是非稳定排序算法。</p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，<a href="https://baike.baidu.com/item/算法/209025" target="_blank" rel="noopener">算法</a>便终止。</p>
<p>由 于 是 按 照 增 量 排 序 ， 步 长 不 同 可 能 元 素 不 一 定 到 他 最 终 位 置 </p>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Matrix Factorization Methods</title>
    <url>/2020/01/09/Matrix-Factorization-Methods/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Collaborative Filtering has been criticized as having limited scalability, since computing similarity matrices on very large sets of items or users can take a lot of computing horsepower. I don’t really buy this, however. Technologies such as Apache Spark allow you to distribute the construction of this matrix across a cluster if you need to. <strong>A legitimate problem with collaborative filtering is that it’s sensitive to noisy data and sparse data. You’ll only get really good results if you have a large data set to work with that’s nice and clean. </strong></p>
<p>接下来介绍一些<strong>Model-based methods</strong>. Instead of 寻找相似的物品或相似的用户, we apply data science and machine learning techniques to extract predictions from our ratings data.</p>
<p><img src="/2020/01/09/Matrix-Factorization-Methods/1578547347570.png" alt="1578547347570"></p>
<p>There are a wide variety of techniques that fall under the category of matrix factorization. They managed to find broader features of users and items on their own, like action movies or romantic. They are described by matrices. The general idea is to describe users and movies as combinations of different amounts of each feature. For example, Bob is defined as being 80% an action fan and 20% a comedy fan. We’d then know to match him up with movies that are blend about 80% action and 20% comedy. </p>
<p><img src="/2020/01/09/Matrix-Factorization-Methods/1578559424817.png" alt="1578559424817"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Neighborhood-Based Collaborative Filtering 协同过滤</title>
    <url>/2020/01/07/Neighborhood-Based-Collaborative-Filtering/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This is the idea of leveraging the behavior of others to inform what you might enjoy. At a very high level, it means finding other people like you and recommending stuff they liked. Or it might mean finding other things similar to the thing that you like. </p>
<p>That’s why we call it collaborative filtering. It’s recommending stuff based on other people’s collaborative behavior. </p>
<p>The heart of neighborhood-based collaborative filtering is the ability to find people similar to you, or items similar to items you’ve liked.</p>
<h3 id="1-Measuring-Similarity-and-Sparsity"><a href="#1-Measuring-Similarity-and-Sparsity" class="headerlink" title="1. Measuring Similarity, and Sparsity"></a>1. Measuring Similarity, and Sparsity</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372382962.png" alt="1578372382962"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578372454415.png" alt="1578372454415"></p>
<p>这里的余弦相似度和前面content-based中的余弦相似度的区别在于：Our dimensions would be things like his: Did this user like this thing? Or was this thing liked by this user? So every user or every thing might constitute its own dimension, and the dimensions are based on user behavior instead of content attributes.</p>
<p>The big challenge in measuring these similarities based on behavior data is the <strong>sparsity</strong> of the data we’re working with. This means that it’s tough for collaborative filtering to work well unless you have a lot of user behavior data to work with. You can’t compute a meaningful cosine similarity between two people when they have nothing in common, or between two items when they have no people in common. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578373973291.png" alt="1578373973291"></p>
<p>This is why collaborative filtering works well for big companies like Amazon and Netflix. They have millions of users and so they have enough data to generate meaningful relations in spite of the data sparsity. </p>
<p>Sparsity also introduces some computational challenges. You don’t want to waste time storing and processing all of that missing data, so under the hood we end up using structures like <strong>sparse arrays</strong> that avoid storing all that empty spaces in this matrix. </p>
<h3 id="2-Similarity-Metrics"><a href="#2-Similarity-Metrics" class="headerlink" title="2. Similarity Metrics"></a>2. Similarity Metrics</h3><h4 id="Adjusted-Cosine"><a href="#Adjusted-Cosine" class="headerlink" title="Adjusted Cosine"></a>Adjusted Cosine</h4><p>It’s applicable mostly to measuring the similarity between users based on their ratings. It’s based on the idea that different people might have different baselines. What Bob considers a three star movie, maybe different from what Alice considers a three star movie. </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578374644148.png" alt="1578374644148"></p>
<p>Adjusted cosine attempts to normalize these differences. Instead of measuring similarities between people based on their raw rating values, we instead measure similarities based on the difference between a user’s rating for an item and their average rating for all items. </p>
<p>Now this sounds good on paper, but in practice, data sparsity can really mess you up here. You can only get a meaningful average, or a baseline of an individual’s ratings if they have rated a lot of stuff for you to take the average of in the first place. 若有许多用户只评价了一部电影，then that data will be totally wasted with the adjusted cosine metric. 不管他们评了多少分，the difference between it and that user’s mean will be zero at that point. </p>
<p>So, adjusted cosine might be worth experimenting with, but only if you know that most of your users have rated a lot of stuff implicitly or explicitly. And if you have that much data to begin with, these differences between individuals will start to work themselves out anyway. So, you’re not likely to see as much of a difference as you might expect when using adjusted cosine. </p>
<h4 id="item-based-pearson-similarity"><a href="#item-based-pearson-similarity" class="headerlink" title="(item-based) pearson similarity"></a>(item-based) pearson similarity</h4><p>与adjusted cosine的区别在于, we look at the difference between rating and the average from all users for that given item.  </p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376440604.png" alt="1578376440604"></p>
<p>You can think of pearson similarity as measuring the similarity between people by how much they diverge from the average person’s behavior. 例如，假设大多数人都喜欢Star Wars, people who hate Star Wars are going to get a very strong similarity score from pearson similarity, because they share opinions that are not mainstream.</p>
<p>Note that the only difference between this and adjusted cosine is whether we’re talking about users or items. 这门课使用的suprise library, refers to adjusted cosine as user-based pearson similarity, because it’s basically the same thing.</p>
<h4 id="spearman-rank-correlation"><a href="#spearman-rank-correlation" class="headerlink" title="spearman rank correlation"></a>spearman rank correlation</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578376851254.png" alt="1578376851254"></p>
<ul>
<li>Instead of using an average rating value for a movie, 我们使用 its rank amongst all movies based on their average rating. </li>
<li>Instead of individual ratings for a movie, we’d rank that movie amongst all that individual’s ratings. </li>
</ul>
<p>Spearman的主要优势在于 it can deal with ordinal data effectively. 例如，if you had a rating scale, where the difference in meaning between different rating values were not the same. I’ve never seen this actually used in real world applications, but you may encounter it in the academic literature.</p>
<h4 id="mean-squared-difference"><a href="#mean-squared-difference" class="headerlink" title="mean squared difference"></a>mean squared difference</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578377776225.png" alt="1578377776225"></p>
<p>另一方面，我们可以将它应用到item上：x和y指两个不同的item, and then we’d be looking at the differences in ratings from the people these items have in common (所有评价过这两个item的人对这两个item评分的差异).</p>
<p>There are two ways of doing collaborative filtering, item based and user based, and it’s important to remember that most of these similarity metrics can apply to either approach. </p>
<p>MSD 要比余弦相似度更好理解， 但 in practice, 你通常会发现cosine works better.</p>
<h4 id="jaccard-similarity"><a href="#jaccard-similarity" class="headerlink" title="jaccard similarity"></a>jaccard similarity</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385168727.png" alt="1578385168727"></p>
<p>jaccard similarity 没有使用实际的rating vlaue. If you are dealing with implicit ratings, for example, just the fact that somebody watched something, in this case, Jaccard can be a reasonable choice that’s very fast to compute. </p>
<h4 id="Recap"><a href="#Recap" class="headerlink" title="Recap"></a>Recap</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578385386398.png" alt="1578385386398"></p>
<ul>
<li>Cosine similarity is almost always a reasonable thing to start with.</li>
<li>Adjust cosine and Pearson are two different terms for basically the same thing. It’s mean centered cosine similarities. The idea is to deal with unusual rating behavior that deviates from the mean, but in practice, it can sometimes do more harm than good.</li>
<li>Spearman ranking correlation is the same idea as Pearson, using ranking instead of raw ratings, and it’s not something you are likely to be using in practice.</li>
<li>MSD is mean squared difference, which is just an easier similarity metric to warp your head around than cosine similarity, but in practice, it usually doesn’t perform better.</li>
<li>Jaccard similarity is just looking at how many items two users have in common, or how many users two items have in common, divided by how many items or users they have between both of them. It’s really simple and well suited to implicit ratings, like binary actions, like purchasing or view something. But you can also apply cosine similarities to implicit ratings too.</li>
<li>So, and the end of the day, cosine similarity remains my default go to similarity metric. </li>
</ul>
<h3 id="3-协同过滤"><a href="#3-协同过滤" class="headerlink" title="3. 协同过滤"></a>3. 协同过滤</h3><h4 id="3-1-User-based-Collaborative-Filtering-基于用户的协同过滤-UserCF"><a href="#3-1-User-based-Collaborative-Filtering-基于用户的协同过滤-UserCF" class="headerlink" title="3.1 User-based Collaborative Filtering 基于用户的协同过滤(UserCF)"></a>3.1 User-based Collaborative Filtering 基于用户的协同过滤(UserCF)</h4><p>与基于物品的协同过滤类似的，不同的是，基于物品的协同过滤的原理是用户 U 购买了 A 物品，推荐给用户 U 和 A 相似的物品 B、C、D。而基于用户的协同过滤，是先计算用户 U 与其他的用户的相似度，然后取和 U 最相似的几个用户，把他们购买过的物品推荐给用户U。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386125836.png" alt="1578386125836"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578386158223.png" alt="1578386158223"></p>
<hr>
<h5 id="3-1-1-计算用户之间的相似度"><a href="#3-1-1-计算用户之间的相似度" class="headerlink" title="3.1.1 计算用户之间的相似度"></a>3.1.1 计算用户之间的相似度</h5><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>为了计算用户相似度，我们首先要把用户购买过物品的索引数据转化成物品被用户购买过的索引数据，即物品的倒排索引：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012706765.png" alt="1596012706765"></p>
<p>建立好物品的倒排索引后，就可以根据相似度公式计算用户之间的相似度：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012763141.png" alt="1596012763141"></p>
<p>其中 $N(a)$ 表示用户 $a$ 购买物品的数量，$N(b)$ 表示用户 $b$ 购买物品的数量，$N(a)∩N(b)$ 表示用户 $a$ 和 $b$ 购买相同物品的数量。有了用户的相似数据，针对用户 U 挑选 k 个最相似的用户，把他们购买过的物品中，U 未购买过的物品推荐给用户 U 即可。</p>
<hr>
<h5 id="3-1-2-举例"><a href="#3-1-2-举例" class="headerlink" title="3.1.2 举例"></a>3.1.2 举例</h5><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455133171.png" alt="1578455133171"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578455288882.png" alt="1578455288882"></p>
<ul>
<li>每个人和自己的余弦相似度是1</li>
<li>Bob 和 Ted的余弦相似度是0，因为他们没有评价过相同的电影</li>
<li>矩阵的上三角部分和下三角部分是对称的</li>
<li>对于 Bob 和 Ann, 虽然他们评价过不同的电影，当我们考虑相似度时，我们只看他们共同评价过的电影。在这个例子中，他们共同评价过的电影只有一部，并且评分都为5，所以他们的相似度得分为1 (100%)。</li>
</ul>
<blockquote>
<p>注：两个用户的相似度为100%并不一定代表他们喜欢相同的东西，也可以代表他们都讨厌相同的东西（例如，若 Bob 和 Ann 都给Star Wars打1分，他们仍然是100% similar）。事实上，the math behind cosine similarity works out such that <strong>if you only have one movie in common, you end up with 100% similarity no matter what. </strong>Even if Bob loved Star Wars and Ann hated it, in a sparse data situation, they both end up 100% similar. Sparse data is a huge problem with collaborative filtering, and it can lead to weird results. And sometimes, you need to enforce a minimum threshold on how many movies users have in common before you consider them at all.</p>
</blockquote>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578456962753.png" alt="1578456962753"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457107702.png" alt="1578457107702"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457502291.png" alt="1578457502291"></p>
<p>除了normalizing, 还可以例如将评分为1、2的转换成negative score, 方法不唯一，没有标准的方法，可通过试验看 what works best for the data you have.</p>
<p>应该adding in the score for a given movie if we encounter it more than once.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457620591.png" alt="1578457620591"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457759908.png" alt="1578457759908"></p>
<h5 id="3-1-3-Recap"><a href="#3-1-3-Recap" class="headerlink" title="3.1.3 Recap"></a>3.1.3 Recap</h5><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578457999015.png" alt="1578457999015"></p>
<h5 id="3-1-4-User-based-Collaborative-Filtering-Hands-On"><a href="#3-1-4-User-based-Collaborative-Filtering-Hands-On" class="headerlink" title="3.1.4 User-based Collaborative Filtering, Hands-On"></a>3.1.4 User-based Collaborative Filtering, Hands-On</h5><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleUserCF.py</p>
<h4 id="3-2-Item-based-Collaborative-Filtering-基于物品的协同过滤-ItemCF"><a href="#3-2-Item-based-Collaborative-Filtering-基于物品的协同过滤-ItemCF" class="headerlink" title="3.2 Item-based Collaborative Filtering 基于物品的协同过滤(ItemCF)"></a>3.2 Item-based Collaborative Filtering 基于物品的协同过滤(ItemCF)</h4><p>Look at the things you liked, and recommend stuff that’s similar to those things. </p>
<p>核心思想：给用户推荐那些和他们之前喜欢的物品相似的物品。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458842316.png" alt="1578458842316"></p>
<p>一些原因为什么使用物品之间的相似度可能比使用用户之间的相似度更好：</p>
<ul>
<li>Items tend to be of a more permanent nature than people. An individual’s test may change very quickly over the span of their lives. Your math book will always be similar to other math books. As such, you can get away with computing an item similarity matrix less often than user similarities, because it won’t change very quickly.</li>
<li>You usually have far fewer items to deal with than people. There are way more people than there are things to recommend to them in most cases. 即物品相似度矩阵会比用户相似度矩阵会小很多，这样不仅 make it simpler to store that matrix, it makes faster to compute as well. And when you’re dealing with massive systems like Amazon and Netflix, computational efficiency is very important. Not only does it require fewer resources, it means you can regenerate your similarities between items more often, making your system more responsive when new items are introduced.</li>
<li>使用 item similarities also makes for a better experience for new users. 一个新用户只要表现出了对某个物品的兴趣，你可以推荐与那个物品相似的物品给该用户，而使用基于用户的协同过滤，you wouldn’t have any recommendations for a new user at all until they make it into the next build of your user similarity matrix.</li>
</ul>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463648320.png" alt="1578463648320"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578463881122.png" alt="1578463881122"></p>
<p>在这个例子中，所有的相似度都为0或1，是因为数据量比较小。In the real world, you’d see more interesting and meaningful numbers here.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578464579773.png" alt="1578464579773"></p>
<hr>
<h5 id="3-2-1-计算物品相似度的方法"><a href="#3-2-1-计算物品相似度的方法" class="headerlink" title="3.2.1 计算物品相似度的方法"></a>3.2.1 计算物品相似度的方法</h5><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>基于物品的协同过滤算法首先计算物品之间的相似度， 计算相似度的方法有以下几种：</p>
<p><strong>1. 基于共同喜欢物品的用户列表计算</strong></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011528508.png" alt="1596011528508"></p>
<p>在此，分母中 $N(i)$ 是购买物品 $i$ 的用户数，$N(j)$ 是购买物品 $j$ 的用户数，而分子 $N(i)∩N(j)$是同时购买物品 $i$ 和物品 $j$ 的用户数。可见上述的公式的核心是计算同时购买这件商品的人数比例 。当同时购买这两个物品的人数越多，他们的相似度也就越高。另外值得注意的是，在分母中我们用了物品总购买人数做惩罚，也就是说某个物品可能很热门，导致它经常会被和其他物品一起购买，所以除以它的总购买人数，来降低它和其他物品的相似分数。</p>
<p><strong>2. 基于余弦的相似度计算</strong></p>
<p>上面的方法计算物品相似度是直接计算同时购买这两个物品的人数。但是也可能存在用户购买了但不喜欢的情况，所以如果数据集包含了具体的<strong>评分数据</strong>，我们可以进一步把用户评分引入到相似度计算中 。</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596011935928.png" alt="1596011935928"></p>
<p>其中 $n_{ki}$ 是用户 $k$ 对物品 $i$ 的评分，如果没有评分则为 0。</p>
<p><strong>3. 热门物品的惩罚</strong></p>
<p>对于热门物品的问题，可以用如下公式解决：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1596012034088.png" alt="1596012034088"></p>
<p>当 $\alpha ∈ (0，0.5)$时，$N(i)$ 越小，惩罚得越厉害，从而会使热门物品相关性分数下降。</p>
<hr>
<h5 id="3-2-2-Item-based-Collaborative-Filtering-Hands-On"><a href="#3-2-2-Item-based-Collaborative-Filtering-Hands-On" class="headerlink" title="3.2.2 Item-based Collaborative Filtering, Hands-On"></a>3.2.2 Item-based Collaborative Filtering, Hands-On</h5><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行SimpleItemCF.py</p>
<p>Item-based collaborative filtering is what Amazon used with outstanding success.</p>
<p>You need to test it out on several real people if possible, and then move to a large scale A/B test to see if this algorithm really is better or worse than whatever you might have today.</p>
<hr>
<h4 id="3-3-矩阵分解"><a href="#3-3-矩阵分解" class="headerlink" title="3.3 矩阵分解"></a>3.3 矩阵分解</h4><p>参考 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
<p>上述计算会得到一个相似度矩阵，而这个矩阵的大小和维度都是很大的，需要进行降维处理，用到的是SVD的降维方法，具体可以参考：<a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Machine Learning/8. ML特征工程和优化方法#25-降维方法" target="_blank" rel="noopener">降维方法</a></p>
<p><strong>基于稀疏自编码的矩阵分解</strong></p>
<p>矩阵分解技术在推荐领域的应用比较成熟，但是通过上一节的介绍，我们不难发现矩阵分解本质上只通过一次分解来对原矩阵进行逼近，特征挖掘的层次不够深入。另外矩阵分解也没有运用到物品本身的内容特征，例如书本的类别分类、音乐的流派分类等。随着神经网络技术的兴起，笔者发现通过多层感知机，可以得到更加深度的特征表示，并且可以对内容分类特征加以应用。首先，我们介绍一下稀疏自编码神经网络的设计思路。</p>
<ol>
<li><p><strong>基础的自编码结构</strong></p>
<p>最简单的自编码结构如下图，构造个三层的神经网络，我们让输出层等于输入层，且中间层的维度远低于输入层和输出层，这样就得到了第一层的特征压缩。</p>
<p><img src="https://camo.githubusercontent.com/c056188f3498f28ff6bfe618b81642ba7711a797/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d32342d34382e706e67" alt="img"></p>
<p>简单来说自编码神经网络尝试学习<strong>中间层约等于输入层</strong>的函数。换句话说，它尝试逼近一个恒等函数。如果网络的输入数据是完全随机的，比如每一个输入都是一个跟其他特征完全无关的独立同分布高斯随机变 ，那么这一压缩表示将会非常难于学习。但是如果输入数据中隐含着 些特定的结构，比如某些输入特征是彼此相关的，那么这一算法就可以发现输入数据中的这些相关性。</p>
</li>
<li><p><strong>多层结构</strong></p>
<p>基于以上的单层隐藏层的网络结构，我们可以扩展至多层网络结构，学习到更高层次的抽象特征。</p>
<p><img src="https://camo.githubusercontent.com/77fdc47c74a72f3b3c1b57ab29ec08452697eb42/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31332d33362d35312e6a7067" alt="img"></p>
</li>
</ol>
<hr>
<h3 id="4-Exercise"><a href="#4-Exercise" class="headerlink" title="4. Exercise"></a>4. Exercise</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468263883.png" alt="1578468263883"></p>
<p>我们之前是选取的top-n，例如item-based: 选择用户评价前10的电影，再找similar items；user-based: 选择与用户相似度排前10的用户，再…</p>
<p>Maybe it would be better if instead of taking the top k sources for recommendation candidates, we just use any source above some given quality threshold. 例如，用户评价4星以上的电影 should generate item-based recommendation candidates, no matter how many or how few of them there may be.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468513742.png" alt="1578468513742"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578468541742.png" alt="1578468541742"></p>
<p>可以发现一个小的改变可以使得结果很不一样。Often, you don’t just want to test different recommendation algorithms, you want to test different variations and parameters on those algorithms. In this case, I not only want to test the idea of using a threshold instead of a top k approach, I’d also want to test many different threshold values to find the best one. In the real world, you’ll find that your biggest problem is just not having enough time to run all of the different experiments you want to run to make your recommendations  better. </p>
<h3 id="5-Evaluating-Collaborative-Filtering-Systems-Offline"><a href="#5-Evaluating-Collaborative-Filtering-Systems-Offline" class="headerlink" title="5. Evaluating Collaborative Filtering Systems Offline"></a>5. Evaluating Collaborative Filtering Systems Offline</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469111053.png" alt="1578469111053"></p>
<p>Now, although <strong>we can’t measure accuracy with user based or item based collaborative filtering, because they don’t make rating predictions</strong>, we can still measure hit rate, because it is still a top-N recommender.</p>
<h4 id="code-walkthrough"><a href="#code-walkthrough" class="headerlink" title="code walkthrough"></a>code walkthrough</h4><p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行EvaluateUserCF.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469413099.png" alt="1578469413099"></p>
<p>That was surprisingly fast. One really nice property of collaborative filtering is how quickly it can generate recommendations for any given individual, once we’ve built up the similarity matrix.</p>
<p>结果5.5% is pretty good.</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578469688733.png" alt="1578469688733"></p>
<p>与EvaluateUserCF.py相比需要改变的地方：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578470341309.png" alt="1578470341309"></p>
<p>item-based的hit rate只有0.5%，相比user-based的5.5%，要差一点。</p>
<p>Item-based should be a superior approach, and that’s been proven in industry. 这里item-based要差一点应该是数据的原因。而且这只是offline evaluation. If we were to test both algorithms on real-world people using real-world data in an A/B test, the results could end up being very different.</p>
<h3 id="6-KNN-Recommenders"><a href="#6-KNN-Recommenders" class="headerlink" title="6. KNN Recommenders"></a>6. KNN Recommenders</h3><p>The concept of collaborative filtering has been applied to recommender systems that do make rating predictions, and these are generally referred to in the literature as KNN recommenders.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578471356190.png" alt="1578471356190"></p>
<p>In this sort of system, we generate recommendation candidates by predicting the ratings of everything a user hasn’t already rated, and selecting the top k items with the highest predicted ratings. This obviously isn’t a terribly efficient approach, but since we’re predicting rating values, we can measure the offline accuracy of the system using train/test or cross-validation, which is useful in the research world.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578478326957.png" alt="1578478326957"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479201990.png" alt="1578479201990"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479315924.png" alt="1578479315924"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479574982.png" alt="1578479574982"></p>
<h4 id="Running-User-and-Item-based-KNN-on-MovieLens"><a href="#Running-User-and-Item-based-KNN-on-MovieLens" class="headerlink" title="Running User and Item-based KNN on MovieLens"></a>Running User and Item-based KNN on MovieLens</h4><p>code walkthrough</p>
<p>CollaborativeFiltering文件夹里的：</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578458631113.png" alt="1578458631113"></p>
<p>运行KNNBakeOff.py</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578479972763.png" alt="1578479972763"></p>
<p>如果只看accuracy, KNN recommendation看上去是一个好方法，但是如果看 top-n recommendations, item-based和user-based推荐的都是些没听说过的电影 (obscure)，反而 random recommendation looks a lot better from a subjective standpoint.</p>
<p>So, on the surface, it looks like we may have made a system that’s pretty good at predicting ratings of movies people have already seen, but might not be very good at producing top-n recommendations.</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><p>Experiment with different KNN parameters.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480409983.png" alt="1578480409983"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480533805.png" alt="1578480533805"></p>
<p>虽然msd比cosine的RMSE要低一点，但它们推荐的内容是一样的</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480727372.png" alt="1578480727372"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578480843642.png" alt="1578480843642"></p>
<p>Well, it’s actually pretty well known that KNN doesn’t work well in practice. Unfortunately, some people conclude that collaborative filtering in general is some naive approach that should be replaced with completely different techniques. But as we’ve seen, collaborative filtering isn’t the problem, it’s forcing collaborative filtering to make rating predictions — that’s the problem. We had some pretty exciting results when we just focused on making top-N recommendations, and completely forgot about optimizing for rating accuracy, and it turns out that’s what at the heart of the problem. <strong>使用user-based CF和item-based CF,   top-N 推荐结果都是不错的。</strong></p>
<p>Ratings are not continuous in nature, and KNN treats them as though they are continuous values that can be predicted on a continuous scale. If you really want to go with KNN, it would be more appropriate to treat it as a rating classification problem than as a rating prediction problem. KNN is also very sensitive to sparse data.</p>
<p>The most fundamental thing is that accuracy isn’t everything. The main reason KNN produces underwhelming results is because it’s trying to solve the wrong problem. <strong>KNN recommender之所以推荐结果不好，是因为它解决的是rating prediction的问题，而不是推荐问题</strong>。</p>
<h3 id="7-Bleeding-Edge-Alert"><a href="#7-Bleeding-Edge-Alert" class="headerlink" title="7. Bleeding Edge Alert"></a>7. Bleeding Edge Alert</h3><p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491595381.png" alt="1578491595381"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491659157.png" alt="1578491659157"></p>
<p>The idea behind it is that users are modeled as vectors moving from one item to another in a multidimensional space. And you can predict sequences of events, like which movie a user is likely to watch next, by modeling these vectors.</p>
<p>The reason this paper is exciting is because it outperformed all of the best existing methods for recommending sequences of events in all but one case in one data set.</p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578491938065.png" alt="1578491938065"></p>
<p><img src="/2020/01/07/Neighborhood-Based-Collaborative-Filtering/1578492119528.png" alt="1578492119528"></p>
<p>Basic idea: You position individual items, like movies, in a transition space, where neighborhoods within this   space represent similarity between items. So items close together in this space are similar to each other. The dimensions corresponds to complex transition relationships between items. Since this technique depends on arranging items together into local, similar neighborhoods, I still classify it as a neighborhood -based method. </p>
<p>In this space, we can learn the vectors associated with individual users. Maybe a user who watches a Tom Cruise movie, is likely to move along to the next Tom Cruise movie, for example, and that transition would be represented by a vector in this space. We can then predict the next movie a user is like to watch by extrapolating along the vector we’ve associated with that user.</p>
<p>The paper provide the code in C++.</p>
<p>It’s all very advanced stuff, but it seems to work. So if you find yourself in the situation where you need to predict a sequence of events, like which movies or videos a person is likely to watch next given theirs past history, you might wanna do a search for translation-based recommendations and how it’s coming along in the real world.</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Content-Based Filtering</title>
    <url>/2020/01/06/Content-Based-Filtering/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Recommending items just based on the attributes of those items, instead of trying to use aggregate user behavior data.</p>
<h3 id="Cosine-Similarity"><a href="#Cosine-Similarity" class="headerlink" title="Cosine Similarity"></a>Cosine Similarity</h3><p><img src="/2020/01/06/Content-Based-Filtering/1578288453177.png" alt="1578288453177"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578288708324.png" alt="1578288708324"></p>
<p>为简单起见，假设电影只有两种类型：adventure和comedy. 一部电影若属于某种类型则为1，若不属于则为0.</p>
<p>角度 θ 一定程度上刻画了它们之间的相似度。我们想要将相似度刻画成[0,1]范围内的数，zero means not at all similar, and one means totally the same thing. 而 θ 的余弦值正好可以达到这个目的：θ 为90度，余弦值为0；θ 为0度，余弦值为1.  </p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289233556.png" alt="1578289233556"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289272295.png" alt="1578289272295"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289294315.png" alt="1578289294315"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289387292.png" alt="1578289387292"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578289605079.png" alt="1578289605079"></p>
<p>How do we assign a similarity score based on release years alone?</p>
<p>This is where some of the art of recommender systems comes in. You have to think about the nature of the data you have and what makes sense.</p>
<p>How far apart would two movies have to be for their release date alone to signify they are substantially different? A decade seems like a reasonable starting point. </p>
<p>Now we need to come up with some sort of mathematical function that smoothly scales that into the range zero to one. -&gt; 可选择指数衰减函数。</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578291075846.png" alt="1578291075846"></p>
<p>The choice of this function is completely arbitrary, but it seems like a reasonable starting point. In the real world, you’d test many variations of this function to see what really produces the best recommendations with real people. </p>
<h3 id="K-nearest-neighbors"><a href="#K-nearest-neighbors" class="headerlink" title="K-nearest-neighbors"></a>K-nearest-neighbors</h3><p>So how do we turn these similarities between movies based on their attributes into actual rating predictions?</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578292209772.png" alt="1578292209772"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578293123577.png" alt="1578293123577"></p>
<h3 id="Code-Walkthrough"><a href="#Code-Walkthrough" class="headerlink" title="Code Walkthrough"></a>Code Walkthrough</h3><p>ContentBased里的文件：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578309826515.png" alt="1578309826515"></p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578310985921.png" alt="1578310985921"></p>
<p>从结果可以看到，Content-based algorithm比random recommendations 表现得要好。</p>
<h3 id="Bleeding-Edge-Alert"><a href="#Bleeding-Edge-Alert" class="headerlink" title="Bleeding Edge Alert"></a>Bleeding Edge Alert</h3><blockquote>
<p>注：We often refer to the current state of the art as leading edge, but technology that’s still so new that it’s unproven in the real world can be risky to work with, and so we call that bleeding edge. </p>
<p>This is where we highlight some new research that looks interesting and promising, but hasn’t really made it into mainstream yet with recommender systems. </p>
</blockquote>
<h4 id="mise-en-scene"><a href="#mise-en-scene" class="headerlink" title="mise en scene"></a>mise en scene</h4><p>Some recent research and content based filtering has surrounded the use of mise en scene data. Technically, mise en scene refers to the placement of objects in a scene, but the researchers are using this term a bit more loosely to refer to the properties of the scenes in a movie or movie trailer. </p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578311747376.png" alt="1578311747376"></p>
<p>The idea is to extract properties from the film itself that can be quantified and analyzed, and see if we can come up with better movie recommendations by examining the content of the movie itself scene by scene.</p>
<p>What sort of attributes are we talking about：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578311877667.png" alt="1578311877667"></p>
<p>In principle, this should give us a feel as to the pacing and mood of the film, just based on the film itself.</p>
<p>Q：这样的数据和原来使用的 human generated genre classification 相比，是否更加有效？</p>
<p>更改代码：</p>
<p>去掉ContentKNNAlgorithm.py中第45行的注释，再在第46行上加上 <code>* mesSimilarity</code>:</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578312959234.png" alt="1578312959234"></p>
<p>再运行ContentRec.py，可得到结果如下：</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578314301934.png" alt="1578314301934"></p>
<p>从结果上看，RMSE actually got a lot worse. 一方面，This could just be an artifact of how we chose to compute mise en scene similarity scores. 另一方面，Accuracy isn’t really what we’re concerned with.</p>
<p>Again, sometimes developing recommendation systems is more an art than a science. You can’t really predict how real people will react to new recommendations they haven’t seen before. Personally, I’d be tempted to test this in an A/B test to see how it performs. </p>
<p>If you look at the research literature associated with mise en scene recommendations however, they note that it doesn’t do any favors to accuracy, but it does increase diversity. But again, increased diversity isn’t always a good thing when it comes to recommendations. It may just mean that you’re recommending random stuff that has no correlation to the user’s actually interest. Still, it was interesting to experiment with it, and it would be even more interesting to experiment with it using real people</p>
<p>Here’s a reference to the original research paper:</p>
<p><img src="/2020/01/06/Content-Based-Filtering/1578313486050.png" alt="1578313486050"></p>
<h3 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h3><ul>
<li>Use genre, release year, and mise en scene data independently.</li>
</ul>
<p><img src="/2020/01/06/Content-Based-Filtering/1578314783671.png" alt="1578314783671"></p>
<ul>
<li>See if you improve the release year based recommendations by sorting the k nearest neighbors within a given year by popularity. (sort the year-based recommendations by popularity as a secondary sort)</li>
</ul>
<p><img src="/2020/01/06/Content-Based-Filtering/1578315361933.png" alt="1578315361933"></p>
<p>Now by using popularity data, technically we’re no longer limiting our recommendations to content attributes. Popularity is behavior-based data.</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>A Recommender Engine Framework</title>
    <url>/2020/01/05/A-Recommender-Engine-Framework/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>What we need now is a framework to let us easily experiment with new recommender system algorithms, evaluate them, and compare them against each other.</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578205315867.jpg" alt="1578205315867"></p>
<h3 id="1-Our-Recommender-Engine-Architecture"><a href="#1-Our-Recommender-Engine-Architecture" class="headerlink" title="1. Our Recommender Engine Architecture"></a>1. Our Recommender Engine Architecture</h3><p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578205676375.png" alt="1578205676375"></p>
<p>Object oriented design allows us to have base classes, for example, AlgoBase, that contain functions and variables that can be shared by other classes that inherit from that base class. 例如AlgoBase中实现了fit和test方法，则无论我们实际上使用的是什么算法，我们都可以调用fit和test方法。</p>
<p>Custom指的是any custom algorithm we might develop (自己写的recommender system), and make them part of the supriselib framework.</p>
<h4 id="Create-a-custom-algorithm"><a href="#Create-a-custom-algorithm" class="headerlink" title="Create a custom algorithm"></a>Create a custom algorithm</h4><p>So, how do you write your own recommender algorithm that’s compatible with surpiselib?</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578207092161.png" alt="1578207092161"></p>
<p>All you have to do is create a new class that inherits form AlgoBase, and as far as supriselib is concerned, your algorithm has one job: to predict ratings.</p>
<blockquote>
<p>As we mentioned, supriselib is built around the architecture of predicting the ratings of every movie for every user, and giving back the top predictions as your recommendations. </p>
</blockquote>
<p>Your class have to implement an estimate function.</p>
<p>When estimate is called by supriselib framework, it’s asking you to predict a rating for the user and item passed in. </p>
<blockquote>
<p>注：这里的user id和item id是inner id. Must be mapped back to the raw user and item ids in your source data.</p>
</blockquote>
<ul>
<li>Now, we want to do more than just predict ratings. 我们想要很简单的将之前在<code>RecommenderMetrics</code>中实现的不同的evaluation metrics应用到algorithms we work with. </li>
</ul>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578207683880.png" alt="1578207683880"></p>
<p>为了做到这一点，我们将创建一个新的class叫做<code>EvaluatedAlgoritm</code>，里面创建了一个新的函数叫做<code>Evaluate</code>，that runs all the metrics in RecommenderMetrics on that algorithm. So this class makes it easy to measure accuracy, coverage, diversity and everything else on a given algorithm.</p>
<ul>
<li><p>不同的评估方法，要求对数据集的不同分割方式，于是我们创建了另一个新的class: <code>EvaluationData</code>来做到这一点。</p>
</li>
<li><p>如何连接这一切？</p>
</li>
</ul>
<p>We create an <code>EvaluationData</code> instance with our data set, create an <code>EvaluatedAlgorithm</code> for each algorithm we want to evaluate, and call <code>Evaluate</code> on each algorithm using the same <code>EvaluationData</code>. Under the hood, <code>EvaluatedAlgorithm</code> will use all the functions we defined in <code>RecommenderMetrics</code> to measure accuracy, hit rate, diversity, novelty, and coverage.</p>
<ul>
<li>Since what we generally want to do is 比较不同推荐系统, we can make life even easier by writing a class that takes care of all the comparison for us. 于是我们创建了新的class：<code>Evaluator</code>.</li>
</ul>
<p>Ideally, we want to just submit algorithms we want to evaluate against each other into this class, and let it do everything from there.</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578208719473.png" alt="1578208719473"></p>
<p>The beauty of this is that you don’t even have to use the <code>EvalutedAlgorithm</code> or <code>EvaluatedData</code> classed at all, when you want to start playing around with new algorithms and testing them against each other. All you need to do is use this <code>Evaluator</code> class, which has a really simple interface.</p>
<p>将上述framework写好后，如下这是我们比较SVD算法与random算法所需要的所有代码：</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578208901255.png" alt="1578208901255"></p>
<h3 id="2-Code-Walkthrough"><a href="#2-Code-Walkthrough" class="headerlink" title="2. Code Walkthrough"></a>2. Code Walkthrough</h3><p>Framework文件夹里：</p>
<p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578209106245.png" alt="1578209106245"></p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p><img src="/2020/01/05/A-Recommender-Engine-Framework/1578283638478.png" alt="1578283638478"></p>
<p>我们比较的是SVD和随机推荐。SVD is one of the best algorithms available right now, so it shouldn’t be surprise that SVD beats random recommendation in accuracy and hit rate no matter how we measure it.</p>
<ul>
<li>RMSE和MAE: lower is better.</li>
<li>Hit rate,包括cHR, ARHR: higher is better.</li>
<li>Coverage, diversity, novelty: need to apply some common sense to, as it’s not a clear higher-is-better sort of thing. There are trade-offs involved with these metrics.</li>
</ul>
<p>就Coverage而言，SVD的要低一些: that’s just because we are enforcing a quality threshold on the top-N recommendations we’re making with SVD, while our random recommender isn’t actually making totally random recommendations, it’s predicting movie ratings using what’s called a normal distribution centered around the average rating value, which ends up meaning all of the rating predictions it makes fall above our rating threshold, giving us 100% coverage. Having 100% coverage at the expense of having bad recommendations isn’t a trade-off worth making.</p>
<p>就Diversity和Novelty而言，SVD的都要低一些，这是我们所预期会出现的。</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Evaluate Recommender System</title>
    <url>/2020/01/04/Evaluate-Recommender-System/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-The-methodology-for-testing-recommender-systems-offline"><a href="#1-The-methodology-for-testing-recommender-systems-offline" class="headerlink" title="1. The methodology for testing recommender systems offline."></a>1. The methodology for testing recommender systems offline.</h3><h4 id="1-1-train-test-split"><a href="#1-1-train-test-split" class="headerlink" title="1.1 train/test split"></a>1.1 train/test split</h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578116193748.jpg" alt="1578116193748"></p>
<p>You measure your recommender system’s ability to predict how people rated things in the past.</p>
<p>If you do this over enough people, you can end up with a meaningful number that tells you <strong>how good your recommender system is at recommending things, or more specifically, recommending things people already watched and rated.</strong> That’s really all you can do, if you can’t test things out in an online system.</p>
<h4 id="1-2-k-fold-cross-validation"><a href="#1-2-k-fold-cross-validation" class="headerlink" title="1.2 k-fold cross-validation"></a>1.2 k-fold cross-validation</h4><p>If you really want to get fancy, it’s possible to improve on a single train/test split by using  a technique called k-fold cross validation.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578116897885.jpg" alt="1578116897885"></p>
<p>Instead of a single training set, we create many randomly assigned training sets. Each individual training set, or fold, is used to train your recommender system independently, and then we measure the accuracy of the resulting systems against your test set. So we end up with a score of how accurate each fold ends up predicting user ratings, and we can average them together.</p>
<p>This obviously takes a lot more computing power to do, but the advantage is that you don’t end up over-fitting to a single training set.</p>
<blockquote>
<p>注：By using train/test, all we can do is test our ability to predict how people rated movies they already saw. That’s not the point of a recommender system.  We want to recommend new things to people that they haven’t seen, but find interesting. However, that’s fundamentally impossible to test offline.</p>
</blockquote>
<p>We haven’t talked about how to actually come up with an accuracy metric when testing our recommender systems, so let’s cover a couple of different ways to do it.</p>
<h3 id="2-Accuracy-Metrics-RMSE-MAE"><a href="#2-Accuracy-Metrics-RMSE-MAE" class="headerlink" title="2. Accuracy Metrics (RMSE, MAE)"></a>2. Accuracy Metrics (RMSE, MAE)</h3><h4 id="2-1-MAE"><a href="#2-1-MAE" class="headerlink" title="2.1 MAE"></a>2.1 MAE</h4><p>We want to minimize MAE.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578117806539.JPG" alt="1578117806539"></p>
<h4 id="2-2-RMSE"><a href="#2-2-RMSE" class="headerlink" title="2.2 RMSE"></a>2.2 RMSE</h4><p>We want to minimize RMSE.</p>
<p>This is a more popular metric for a few reasons, but one is that <strong>it penalizes you more when your rating prediction is way off, and penalizes you less when your are reasonably close.</strong></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578117900853.jpg" alt="1578117900853"></p>
<blockquote>
<p>注：就推荐系统而言，RMSE just doesn’t matter much in the real world. 人们并不关心你的系统对他们已经看过的电影的评分预测是否准确。What does matter is which movie you put in front of users in a top-N recommender list, and how those users react to those movies when they see them recommended.</p>
</blockquote>
<h3 id="3-Top-N-Hit-Rate-Many-Ways"><a href="#3-Top-N-Hit-Rate-Many-Ways" class="headerlink" title="3. Top-N Hit Rate - Many Ways"></a>3. Top-N Hit Rate - Many Ways</h3><p>Different ways to measure the effectivenss of top-n recommenders offline:</p>
<h4 id="3-1-Hit-Rate"><a href="#3-1-Hit-Rate" class="headerlink" title="3.1 Hit Rate"></a>3.1 Hit Rate</h4><p>You generate top-n recommendations for all of the users in your test set. <strong>If one of the recommendations in a user’s top-n recommendations is something  they actually rated, you consider that a hit.</strong> You actually managed to show the user something that they found interesting enough to watch on their own already, so we consider that a success. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578119273699.jpg" alt="1578119273699"></p>
<p>How to measure hit rate? Use leave-one-out cross validation.</p>
<h4 id="3-2-leave-one-out-cross-validation"><a href="#3-2-leave-one-out-cross-validation" class="headerlink" title="3.2 leave-one-out cross validation"></a>3.2 leave-one-out cross validation</h4><p>What we do is compute the top-n recommendations for each user in our training data, and intentionally remove one of those items from that user’s training data. We then test our recommender system’s ability to recommend that item that was left out in the top-n results it creates for that user in the testing phase.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578120352619.jpg" alt="1578120352619"></p>
<p>The trouble is that it’s a lot harder to get one specific movie right while testing than to just get one of the n recommendations. So “hit rate” with “leave-one-out” tends to be very small and difficult to measure, unless you have a very large data set to work with. But it’s a much more <strong>user focused metric</strong> when you know your recommender system will be producing top-n lists in the real world, which most of them do. </p>
<h4 id="3-3-ARHR"><a href="#3-3-ARHR" class="headerlink" title="3.3 ARHR"></a>3.3 ARHR</h4><p>This metric is just like “hit rate”, but it accounts for where in the top-n list you hits appear. Instead of summing up the number of hits, we sum up the reciprocal ranking of each hit.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578122155631.jpg" alt="1578122155631"></p>
<p>You end up getting more credit for successfully recommending an item in the top slot than in the bottom slot. Again, this is a more <strong>user focused metric</strong>, since users tend to focus on the beginning of lists. </p>
<h4 id="3-4-cHR"><a href="#3-4-cHR" class="headerlink" title="3.4 cHR"></a>3.4 cHR</h4><p>Throw away hits if our predicted rating is below some threshold.</p>
<p>The idea is that we shouldn’t get credit for recommending items to a user that we think they won’t actually enjoy. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578122704818.jpg" alt="1578122704818"></p>
<p>In this example, if we had a cutoff of three stars, we throw away the hits for the second and fourth items in these test results and our hit rate metric wouldn’t count them at all. </p>
<h4 id="3-5-rHR"><a href="#3-5-rHR" class="headerlink" title="3.5 rHR"></a>3.5 rHR</h4><p>Another way to look at hit rate is to break it down by predicted rating score.</p>
<p>It can be a good way to get an idea of the distribution of how good your algorithm thinks recommended movies are that actually get a hit.  Ideally, you want to recommend movies that they actually like, and breaking down the distribution gives you some sense of how well you’re doing in more detail.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578123016707.jpg" alt="1578123016707"></p>
<p>对每一个rating type (1,2,3,4,5), print out its hit rate.</p>
<h3 id="4-Coverage-Diversity-and-Novelty"><a href="#4-Coverage-Diversity-and-Novelty" class="headerlink" title="4. Coverage, Diversity and Novelty"></a>4. Coverage, Diversity and Novelty</h3><p>Accuracy isn’t the only thing that matters.</p>
<h4 id="4-1-Coverage-覆盖度"><a href="#4-1-Coverage-覆盖度" class="headerlink" title="4.1 Coverage 覆盖度"></a>4.1 Coverage 覆盖度</h4><p>The percentage of possible recommendations that your system is able to provide. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578123495150.jpg" alt="1578123495150"></p>
<p>It’s worth noting that coverage can be at odds with accuracy. If you enforce a higher quality threshold on the recommendations you make, then you might improve your accuracy at the expense of coverage. Finding the balance of where exactly you’re better off recommending nothing at all can be delicate. </p>
<p>Coverage can also be important to watch, because it gives you a sense of how quickly new items in your catalog will start to appear in your recommendations. When a new book come out on Amazon, it won’t appear in recommendations until at least a few people buy it, therefore establishing patterns with the purchase of other items. Until those patterns exist, that new book will reduce Amazon’s coverage metric.</p>
<h4 id="4-2-Diversity-多样性"><a href="#4-2-Diversity-多样性" class="headerlink" title="4.2 Diversity 多样性"></a>4.2 Diversity 多样性</h4><p>You can think of this as measure of how broad a variety of items your recommender system is putting in front of people. An example of low diversity would be a recommender system that just recommends the next books in a series that you’ve started reading, but doesn’t recommend book from different authors, or movies related to what you’ve read.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578124451718.jpg" alt="1578124451718"></p>
<p>Diversity, at least in the context of recommender systems, isn’t always a good thing. You can achieve very high diversity by just recommending completely random items. Unusually high diversity scores mean that you just have bad recommendations more often than not. You always need to look at diversity alongside metrics that measure the quality of the recommendations as well. </p>
<h4 id="4-3-Novelty-新颖性"><a href="#4-3-Novelty-新颖性" class="headerlink" title="4.3 Novelty 新颖性"></a>4.3 Novelty 新颖性</h4><p>Similarly, novelty sounds like a good thing, but often it isn’t. Novelty is a measure of how popular the items are that you are recommending. And again, just recommending random stuff would yield very high novelty scores, since the vast majority of items are not top sellers. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578124908363.jpg" alt="1578124908363"></p>
<p>Although novelty is measurable, what to do with it is in many ways subjective. There’s a concept of user trust in a recommender system. People want to see at least a few familiar items in their recommendations that make them say, “Yeah, that’s a good recommendation for me. The system seems good”. If you only recommend things people never heard of, they may conclude that your system doesn’t really know them. Also, popular items are usually popular for a reason. They’re enjoyable by a large segment of the population, so you would expect them to be good recommendations for a large segment of the population who hasn’t read or watched them yet. If you’re not recommending some popular items, you should probably question whether your recommender system is really working as it should.</p>
<p><strong>You need to strike a balance between familiar, popular items and what we call serendipitous discovery of new items that user has never heard of before. (balance between novelty and trust)</strong>. The familiar items establish trust with the user, and the new ones allow the user to discover entirely new things that they might love. </p>
<p>Novelty is important, because the whole point of recommender systems is to surface items in what we call “the long tail”.</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578125635846.jpg" alt="1578125635846"></p>
<p>Imagine this is a plot of the sales of every item in you catalog, sorted by sales. Y 轴代表sales (popularity)，X轴代表products. Most of sales来自于一小部分items，但是”long tail” makes up a large amount of sales as well. 黄色部分的item代表了人们各自感兴趣的东西. Recommender systems can help people discover those items in the long tail that are relevant to their own unique niche interests. If you can do that successfully, then the recommendations your system makes can help new authors get discovered, can help people explore their own passions, and make money for whoever you’re building the system for as well. Everybody wins.</p>
<h3 id="5-Churn-Responsiveness-and-A-B-Tests"><a href="#5-Churn-Responsiveness-and-A-B-Tests" class="headerlink" title="5. Churn, Responsiveness, and A/B Tests"></a>5. Churn, Responsiveness, and A/B Tests</h3><h4 id="5-1-Churn"><a href="#5-1-Churn" class="headerlink" title="5.1 Churn"></a>5.1 Churn</h4><p>Another thing we can measure is Churn. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578127764650.jpg" alt="1578127764650"></p>
<p>Churn can measure how sensitive your recommender system is to new user behavior. 如果用户rate了一部新电影，会使得他的推荐内容发生很大的变化吗？If so, your churn score will be high. Maybe just showing the same recommendations too many times is a bad idea itself. 如果一个用户总是看到相同的推荐，但是不点击进去，在某个时候你应该停止推荐它而给用户推荐其他的东西。Sometimes, a little bit of randomization in your top-n recommendations can keep them looking fresh, and expose your users to more items.</p>
<p>But, just like diversity and novelty, high churn is not in itself a good thing. You could maximize your churn metric by just recommending items completely at random, 但显然这不是好的推荐。</p>
<p><strong>All these metrics need to be looked at together, and you need to understand the trade-offs between them. </strong></p>
<h4 id="5-2-Responsiveness"><a href="#5-2-Responsiveness" class="headerlink" title="5.2 Responsiveness"></a>5.2 Responsiveness</h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578128338650.jpg" alt="1578128338650"></p>
<p>If you rate  a new movie, does it affect your recommendations immediately or next day after some nightly job runs? More responsiveness would always seem to be a good thing, but in the world of business, you have to decide how responsive your recommender really needs to be, since recommender systems that have instantaneous responsiveness are complex, difficult to maintain, and expensive to build. You need to strike your own balance between responsiveness and simplicity.</p>
<blockquote>
<p> ? What’s important</p>
<p>前面讲了许多evaluate推荐系统的方法：MAE, RMSE, Hit rate in various forms, coverage, diversity, novelty, churn, and responsiveness.</p>
<p>So how do you know what to focus on? It depends.</p>
<p>It may even depend on cultural factors. Some cultures may want more diversity and novelty, while other cultures may want to stick to things that are familiar with them. </p>
<p>It also depends on what you’re trying to achieve as a business. And usually,  a business is just trying to make money, which leads to one more way to evaluate recommender systems that is arguably the most important of all: online A/B tests!</p>
</blockquote>
<h4 id="5-3-Online-A-B-Tests"><a href="#5-3-Online-A-B-Tests" class="headerlink" title="5.3 Online A/B Tests"></a>5.3 Online A/B Tests</h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578129032852.jpg" alt="1578129032852"></p>
<hr>
<blockquote>
<p>参考：</p>
<p> <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System" target="_blank" rel="noopener">https://github.com/NLP-LOVE/ML-NLP/tree/master/Project/17.%20Recommendation%20System</a></p>
</blockquote>
<p>AB测试是一种很常用的在线评测算法的实验方法。它通过一定的规则将用户随机分成几组，并对不同组的用户采用不同的算法，然后通过统计不同组用户的各种不同的评测指标比较不同算法，比如可以统计不同组用户的点击率，通过点击率比较不同算法的性能。对AB测试感兴趣的读者可以浏览一下网站<a href="http://www.abtests.com/" target="_blank" rel="noopener">http://www.abtests.com/</a> ，该网站给出了很多通过实际AB测试提高网站用户满意度的例子，从中我们可以学习到如何进行合理的AB测试。</p>
<hr>
<p>Doing online A/B tests to tune your recommender system using your real customers, and measuring how they react to your recommendations. You can put recommendations from different algorithms in front of different sets of users, and measure if they actually buy, watch, or otherwise indicate interest in the recommendations you’ve presented. </p>
<p>By always testing changes to your recommender system using controlled, online experiments, you can see if they actually cause people to discover and purchase more new things than they would have otherwise.</p>
<p>None of the metrics we’ve discussed matter more than how real customers react to the recommendations you produce in the real world. You can have the most accurate rating predictions in the world, but if customers can’t find new items to buy or watch from your system, it will be worthless from a practical standpoint. </p>
<p>Online tests can help you to avoid introducing complexity that adds no value, and remember, complex systems are difficult to maintain.</p>
<p>SO REMEMBER, offline metrics such as accuracy, diversity, and novelty can all be indicators you can look at while developing recommender systems offline, but you should never declare victory until you’ve measured a real impact on real users from your work. <strong>User behavior is the ultimate test of your work.</strong></p>
<p><strong>Accurately predicted ratings don’t necessarily make for good video recommendations. At the end of the day, the results of online A/B tests are the only evaluation that matters for your recommender system.</strong></p>
<hr>
<p> A/B 测试，常见的指标有点击率、用户停留时间、 广告收入等，需要注意分析统计显著性。同时，需要注意短期的指标和长期的指标相结合， 一些短期指标的提升有时候反而会导致长期指标下降 比如 ，经常推荐美女或者搞笑类的内容会带来短期的点击率提高，但是可能会引起长期的用户粘性下降。设计者需要从自己的产品角度出发，根据产品的需要制定评估指标，这样才能更好地指导推荐系统的优化方向。常见的评价指标如下：</p>
<p><img src="https://camo.githubusercontent.com/fcefce67e348ce386471df934a041b367eb9b529/68747470733a2f2f67697465652e636f6d2f6b6b7765697368652f696d616765732f7261772f6d61737465722f4d4c2f323031392d392d385f31342d34332d35312e706e67" alt="img"></p>
<hr>
<p>Another thing you can do is just straight up ask your users, if they think specific recommendations are good. </p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578129889414.jpg" alt="1578129889414"></p>
<p>In practice though, it’s a tough thing to do. Users will probably be confused over whether you’re asking them to rate the item or rate the recommendation, so you won’t really know how to interpret this data. It also requires extra work form your customers with no clear payoff for them, so you’re unlikely to get enough ratings on your recommendations to be useful. </p>
<p>It’s best to just stick with online A/B tests, and measure how your customers vote with their wallets on the quality of your recommendations.</p>
<h3 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h3><p><img src="/2020/01/04/Evaluate-Recommender-System/1578196100106.jpg" alt="1578196100106"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196212178.jpg" alt="1578196212178"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196333798.jpg" alt="1578196333798"></p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578196377981.jpg" alt="1578196377981"></p>
<h3 id="Code-Walkthrough"><a href="#Code-Walkthrough" class="headerlink" title="Code Walkthrough"></a>Code Walkthrough</h3><p>使用Python中的library: Suprise. <a href="supriselib.com">SupriseLib’s documentation online</a></p>
<p>Suprise is built around measuring the accuracy of recommender systems. Although this is the wrong thing to focus on, it’s really the best we can do without access to a real, large-scale website of our own.</p>
<p>Evaluating文件夹里的：</p>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578201480503.jpg" alt="1578201480503"></p>
<p>RecommenderMetrics中实现了前面讲到的用来evaluate recommender system的各种metrics.</p>
<p>TestMetrics中调用了RecommenderMetrics中的方法来实现一个real recommender system并evaluate it.</p>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p><img src="/2020/01/04/Evaluate-Recommender-System/1578201799750.jpg" alt="1578201799750"></p>
<ul>
<li><p>RMSE大概0.9，MAE大概0.7。</p>
<p>On average, our guess of rating for a given movie for a given user, was off by about 0.7 stars. RMSE is higher, meaning that we got penalized for being way off more often than we’d like.</p>
<p>Remember, error metrics are bad.  你想要RMSE与MAE越低越好，if accuracy is your goal.</p>
</li>
</ul>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578201882902.jpg" alt="1578201882902"></p>
<ul>
<li>Hit Rate大概 3%，which actually isn’t that bad, considering that only one movie was left out from each user’s rating to test with. 这个数值本身很难解释是好是坏，除非有其他的推荐系统可供比较。</li>
<li>If we break it down by rating value, you can see that our hit rate did better at higher rating predictions, which make sense and it’s what we want to see. Hit Rate在评分越高的类型中表现得更好（例如，在评分为5的电影中，Hit Rate为 6%）。</li>
<li>Cumulative Hit Rate with a 4.0 threshold isn’t much lower than the raw hit rate, meaning that we’re doing a good job of recommending items we think are good recommendations.</li>
<li>ARHR is 0.01. It takes the ranking of the hits into account. Again, it has no real value until we have other recommender systems to compare it against.</li>
</ul>
<p><img src="/2020/01/04/Evaluate-Recommender-System/1578203470922.jpg" alt="1578203470922"></p>
<ul>
<li><p>We look at user coverage for which we have at least one 4-star rating prediction, ant it’s pretty high. That’s good.</p>
</li>
<li><p>Diversity is really high at 0.96, and novelty seems pretty high, with an average popularity rank of 491. Remember there are only a few thousand movies in our data set to begin with. </p>
<p>This tells us that our algorithm is going pretty deep into the long tail to get its recommendations and that could be a problem in the real world. Novelty比较高（平均受欢迎程度排名比较靠后），说明推荐的都是比较小众的电影（long tail）.</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>So even though our accuracy metrics look okay here, diversity and novelty is telling us that we’re recommending a lot of really obscure stuff. And that could be an issue when trying to establish user trust in the system. People generally want to see a few things that at least look familiar. So I would expect this particular algorithm wouldn’t do that well in an online A/B test, but you can never really know until  you actually try it. </p>
<p>Anyhow, we now have working code now for evaluating real recommender systems!</p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>Top-N Recommender Architecture</title>
    <url>/2020/01/03/Top-N-Recommender-Architecture/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2020/01/03/Top-N-Recommender-Architecture/1578052647526.jpg" alt="1578052647526"></p>
<p><img src="/2020/01/03/Top-N-Recommender-Architecture/1578471196924.png" alt="1578471196924"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>RecSys Course Overview</title>
    <url>/2020/01/03/RecSys-Course-Overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>课程：</p>
<p><a href="https://www.udemy.com/course-dashboard-redirect/?course_id=1726410" target="_blank" rel="noopener"><img src="https://i.udemycdn.com/course/240x135/1726410_7b86.jpg" alt="Building Recommender Systems with Machine Learning and AI"></a><a href="https://www.udemy.com/course/building-recommender-systems-with-machine-learning-and-ai/learn/" target="_blank" rel="noopener"><strong>Building Recommender Systems with Machine Learning and AI</strong> </a></p>
<p><a href="https://sundog-education.com/RecSys/" target="_blank" rel="noopener">Course Materials</a></p>
<p><img src="/2020/01/03/RecSys-Course-Overview/1578048175249.jpg" alt="1578048175249"></p>
]]></content>
      <categories>
        <category>Recommender System</category>
      </categories>
      <tags>
        <tag>Recommender System</tag>
      </tags>
  </entry>
  <entry>
    <title>MapReduce</title>
    <url>/2020/01/03/MapReduce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-MapReduce-fundamental-concepts"><a href="#1-MapReduce-fundamental-concepts" class="headerlink" title="1. MapReduce fundamental concepts"></a>1. MapReduce fundamental concepts</h4><p><img src="/2020/01/03/MapReduce/1578032618932.jpg" alt="1"></p>
<p><img src="/2020/01/03/MapReduce/20200103-142610.jpg" alt="20200103-142610"></p>
<p><img src="/2020/01/03/MapReduce/1578032937052.jpg" alt="1578032937052"></p>
<h5 id="1-1-Mapper"><a href="#1-1-Mapper" class="headerlink" title="1.1 Mapper"></a>1.1 Mapper</h5><p><img src="/2020/01/03/MapReduce/1578033123727.jpg" alt="1578033123727"></p>
<p><img src="/2020/01/03/MapReduce/20200103-143446.jpg" alt="20200103-143446"></p>
<p><img src="/2020/01/03/MapReduce/1578033212508.jpg" alt="1578033212508"></p>
<p><img src="/2020/01/03/MapReduce/1578033238182.jpg" alt="1578033238182"></p>
<p>Mapper: Extract and organize what we care about.</p>
<h5 id="1-2-Shuffle-and-Sort"><a href="#1-2-Shuffle-and-Sort" class="headerlink" title="1.2 Shuffle and Sort"></a>1.2 Shuffle and Sort</h5><p><img src="/2020/01/03/MapReduce/1578033463232.jpg" alt="1578033463232"></p>
<p><img src="/2020/01/03/MapReduce/20200103-144645.jpg" alt="20200103-144645"></p>
<h5 id="1-3-Reducer"><a href="#1-3-Reducer" class="headerlink" title="1.3 Reducer"></a>1.3 Reducer</h5><p><img src="/2020/01/03/MapReduce/1578034121206.jpg" alt="1578034121206"></p>
<p><img src="/2020/01/03/MapReduce/20200103-144953.jpg" alt="20200103-144953"></p>
<p><img src="/2020/01/03/MapReduce/1578034303323.jpg" alt="1578034303323"></p>
<hr>
<h4 id="2-How-MapReduce-distributes-processing"><a href="#2-How-MapReduce-distributes-processing" class="headerlink" title="2. How MapReduce distributes processing"></a>2. How MapReduce distributes processing</h4><p><img src="/2020/01/03/MapReduce/1578034389919.jpg" alt="1578034389919"></p>
<p><img src="/2020/01/03/MapReduce/0002.jpg" alt="0002"></p>
<hr>
<h4 id="3-MapReduce-a-real-example"><a href="#3-MapReduce-a-real-example" class="headerlink" title="3. MapReduce: a real example"></a>3. MapReduce: a real example</h4><p><img src="/2020/01/03/MapReduce/1578035985411.jpg" alt="1578035985411"></p>
<p><img src="/2020/01/03/MapReduce/1578036687341.jpg" alt="1578036687341"></p>
<p>Sometimes, it’s not easy to try to force a problem into this way of thinking, and that’s a big reason why other frameworks like Spark or Hive, or other ways of processing SQL style queries have become a little bit more popular that just writing raw MapReduce code.</p>
<p>But, still, if you can easily express something in terms of mapping and reducing, this can sometimes be the most efficient way of doing it.</p>
<p><img src="/2020/01/03/MapReduce/1578037510439.jpg" alt="1578037510439"></p>
<p>Then, the results all get passed into the MapReduce framework which does shuffle and sort for us. And then, we just have to write the Reducer.</p>
<p><img src="/2020/01/03/MapReduce/1578038403968.jpg" alt="1578038403968"></p>
<p>Here’s a complete Python MapReduce script.</p>
<p><img src="/2020/01/03/MapReduce/1578039179773.jpg" alt="1578039179773"></p>
<p>This is an entire MRJOB script in Python that would use MapReduce streaming to actually execute across a cluster.</p>
<hr>
<h4 id="4-Runing-MapReduce-with-MRJOB"><a href="#4-Runing-MapReduce-with-MRJOB" class="headerlink" title="4. Runing MapReduce with MRJOB"></a>4. Runing MapReduce with MRJOB</h4><p>首先需要安装一些东西</p>
<p>Run our MapReduce job in our Hadoop installation.</p>
<p><a href="https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963054#overview" target="_blank" rel="noopener">https://www.udemy.com/course/the-ultimate-hands-on-hadoop-tame-your-big-data/learn/lecture/5963054#overview</a></p>
<p><img src="/2020/01/03/MapReduce/1578041252394.jpg" alt="1578041252394"></p>
<p><img src="/2020/01/03/MapReduce/1578041273664.jpg" alt="1578041273664"></p>
<p><img src="/2020/01/03/MapReduce/1578041300494.jpg" alt="1578041300494"></p>
<hr>
<h4 id="5-Challenge-Exercise"><a href="#5-Challenge-Exercise" class="headerlink" title="5. Challenge Exercise"></a>5. Challenge Exercise</h4><p><img src="/2020/01/03/MapReduce/1578043490000.jpg" alt="1578043490000"></p>
<p><img src="/2020/01/03/MapReduce/1578043550225.jpg" alt="1578043550225"></p>
<p><img src="/2020/01/03/MapReduce/1578043582794.jpg" alt="1578043582794"></p>
<p><img src="/2020/01/03/MapReduce/1578043608450.jpg" alt="1578043608450"></p>
<p><img src="/2020/01/03/MapReduce/1578043786325.jpg" alt="1578043786325"></p>
<hr>
<h4 id="6-Check-your-results"><a href="#6-Check-your-results" class="headerlink" title="6. Check your results"></a>6. Check your results</h4><p><img src="/2020/01/03/MapReduce/1578044582388.jpg" alt="1578044582388"></p>
<p>结果：</p>
<p><img src="/2020/01/03/MapReduce/1578044858078.jpg" alt="1578044858078"></p>
<p>movieId 50 是最popular的电影。</p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS and MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>有效的字母异位词</title>
    <url>/2020/01/02/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">有效的字母异位词（难度：简单）</a></p>
<p><img src="/2020/01/02/有效的字母异位词/1.jpg" alt="1"></p>
<h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ul>
<li>首先判断两个字符串长度是否相等，不相等则直接返回 false。</li>
<li>若相等，则初始化 26 个字母哈希表，遍历字符串 s 和 t</li>
<li><strong>s 负责在对应位置增加，t 负责在对应位置减少，如果哈希表的值都为 0，则二者是字母异位词</strong></li>
</ul>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。<br>空间复杂度：O(1)。尽管我们使用了额外的空间，但是空间的复杂性是 O(1)，因为无论 N 有多大，表的大小都保持不变。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>Java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] alpha = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            alpha[s.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">            alpha[t.charAt(i) - <span class="string">'a'</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : alpha)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/有效的字母异位词/4.jpg" alt="4"></p>
<hr>
<h4 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h4><h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(nlogn)。</p>
<p>空间复杂度：O(1)，空间取决于排序实现，如果使用 <code>heapsort</code>，通常需要 O(1)辅助空间。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/有效的字母异位词/3.jpg" alt="3"></p>
<hr>
<h4 id="方法三：利用Python中的set"><a href="#方法三：利用Python中的set" class="headerlink" title="方法三：利用Python中的set()"></a>方法三：利用Python中的set()</h4><p>Python</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) != len(t):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        set1 = set(s)</span><br><span class="line">        set2 = set(t)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> set2:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set2:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> set1:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> s.count(i) != t.count(i):</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/有效的字母异位词/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>加一</title>
    <url>/2020/01/02/%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">加一（难度：简单）</a></p>
<p><img src="/2020/01/02/加一/1.jpg" alt="1"></p>
<h4 id="方法：数组遍历"><a href="#方法：数组遍历" class="headerlink" title="方法：数组遍历"></a>方法：数组遍历</h4><p><img src="/2020/01/02/加一/2.jpg" alt="2"></p>
<p>时间复杂度：O(n)</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] plusOne(<span class="keyword">int</span>[] digits) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = digits.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            digits[i] = (digits[i]+<span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(digits[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> digits;</span><br><span class="line">        &#125;</span><br><span class="line">        digits = <span class="keyword">new</span> <span class="keyword">int</span>[digits.length+<span class="number">1</span>];</span><br><span class="line">        digits[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/加一/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>电话号码的字母组合</title>
    <url>/2020/01/02/%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/" target="_blank" rel="noopener">电话号码的字母组合（难度：中等）</a></p>
<p><img src="/2020/01/02/电话号码的字母组合/1.jpg" alt="1"></p>
<h4 id="方法：回溯"><a href="#方法：回溯" class="headerlink" title="方法：回溯"></a>方法：回溯</h4><p><img src="/2020/01/02/电话号码的字母组合/2.jpg" alt="2"></p>
<p><img src="https://pic.leetcode-cn.com/0ac574ab37f620221e702f57d6c4ffd0ba246abe41c43f9fc9637ab8f3365377-image.png" alt="img"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        phone = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">                <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>],</span><br><span class="line">                <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>],</span><br><span class="line">                <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>],</span><br><span class="line">                <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>],</span><br><span class="line">                <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">                <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>],</span><br><span class="line">                <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br><span class="line"></span><br><span class="line">        output = []</span><br><span class="line">        <span class="keyword">if</span> digits:</span><br><span class="line">            self.backtrack(<span class="string">""</span>, digits, phone, output)</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backtrack</span><span class="params">(self, combination, digit, phone, output)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(digit)==<span class="number">0</span>:</span><br><span class="line">            output.append(combination)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> phone[digit[<span class="number">0</span>]]:</span><br><span class="line">            self.backtrack(combination+letter,digit[<span class="number">1</span>:], phone, output)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/电话号码的字母组合/4.jpg" alt="4"></p>
<p><img src="/2020/01/02/电话号码的字母组合/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2020/01/02/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">盛最多水的容器（难度：中等）</a></p>
<p><img src="/2020/01/02/盛最多水的容器/1.jpg" alt="1"></p>
<h4 id="方法：双指针"><a href="#方法：双指针" class="headerlink" title="方法：双指针"></a>方法：双指针</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>两线段之间形成的区域总是会受到其中较短那条长度的限制。此外，两线段距离越远，得到的面积就越大。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul>
<li><strong>在由线段长度构成的数组中使用两个指针，一个放在开始，一个置于末尾</strong>。</li>
<li>使用变量 max_area来持续存储到目前为止所获得的最大面积。 </li>
<li>在每一步中，我们会找出指针所指向的两条线段形成的区域，更新 max_area，<strong>并将指向较短线段的指针向较长线段那端移动一步</strong>。</li>
</ul>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)，一次扫描。</p>
<p>空间复杂度：O(1)，使用恒定的空间。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> max_area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            max_area = Math.max(max_area, Math.min(height[left],height[right]) * (right-left));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max_area;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/盛最多水的容器/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式匹配</title>
    <url>/2020/01/02/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">正则表达式匹配（难度：困难）</a></p>
<p><img src="/2020/01/02/正则表达式匹配/1.jpg" alt="1"></p>
<p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/regular-expression-matching/solution/ji-yu-guan-fang-ti-jie-gen-xiang-xi-de-jiang-jie-b/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<h4 id="一、处理点号「-」通配符"><a href="#一、处理点号「-」通配符" class="headerlink" title="一、处理点号「.」通配符"></a>一、处理点号「.」通配符</h4><p>点号可以匹配任意一个字符，其实是最简单的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern: <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<h4 id="二、处理「-」通配符"><a href="#二、处理「-」通配符" class="headerlink" title="二、处理「*」通配符"></a>二、处理「*」通配符</h4><p>星号通配符可以让前一个字符重复任意次数，包括零次。那到底是重复几次呢？这需要计算机暴力穷举来算，假设重复 N 次吧。写递归的技巧是管好当下，之后的事抛给递归。具体到这里，不管 N 是多少，当前的选择只有两个：匹配 0 次、匹配 1 次。所以可以这样处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(text, pattern)</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pattern: <span class="keyword">return</span> <span class="keyword">not</span> text</span><br><span class="line">    first_match = bool(text) <span class="keyword">and</span> pattern[<span class="number">0</span>] <span class="keyword">in</span> &#123;text[<span class="number">0</span>], <span class="string">'.'</span>&#125;</span><br><span class="line">    <span class="keyword">if</span> len(pattern) &gt;= <span class="number">2</span> <span class="keyword">and</span> pattern[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">        <span class="comment"># 发现 '*' 通配符</span></span><br><span class="line">        <span class="keyword">return</span> isMatch(text, pattern[<span class="number">2</span>:]) <span class="keyword">or</span> \</span><br><span class="line">                first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern)</span><br><span class="line">    	<span class="comment"># 解释：如果发现有字符和 '*' 结合，</span></span><br><span class="line">        	<span class="comment"># 或者匹配该字符 0 次，然后跳过该字符和 '*'</span></span><br><span class="line">        	<span class="comment"># 或者当 pattern[0] 和 text[0] 匹配后，移动 text</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> first_match <span class="keyword">and</span> isMatch(text[<span class="number">1</span>:], pattern[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>可以看到，我们是通过保留 pattern 中的「*」，同时向后推移 text，来实现「*」将字符重复匹配多次的功能。</p>
<h4 id="三、动态规划"><a href="#三、动态规划" class="headerlink" title="三、动态规划"></a>三、动态规划</h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        </span><br><span class="line">        first = s <span class="keyword">and</span> p[<span class="number">0</span>] <span class="keyword">in</span> &#123;s[<span class="number">0</span>],<span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(p) &gt;= <span class="number">2</span> <span class="keyword">and</span> p[<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s,p[<span class="number">2</span>:]) <span class="keyword">or</span> (first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:],p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:],p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/正则表达式匹配/2.jpg" alt="2"></p>
<h5 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h5><p>使用两个变量 <code>i</code>, <code>j</code> 记录当前匹配到的位置，从而避免使用子字符串切片，并且将 <code>i</code>, <code>j</code> 存入memo，避免重复计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        memo = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i,j)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> (i,j) <span class="keyword">in</span> memo:</span><br><span class="line">                <span class="keyword">return</span> memo[(i,j)]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> j==len(p):</span><br><span class="line">                <span class="keyword">return</span> i==len(s)</span><br><span class="line">            </span><br><span class="line">            first = i &lt; len(s) <span class="keyword">and</span> p[j] <span class="keyword">in</span> &#123;s[i],<span class="string">'.'</span>&#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> len(p) &gt;= j+<span class="number">2</span> <span class="keyword">and</span> p[j+<span class="number">1</span>]==<span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">return</span> dp(i,j+<span class="number">2</span>) <span class="keyword">or</span> (first <span class="keyword">and</span> dp(i+<span class="number">1</span>,j))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> first <span class="keyword">and</span> dp(i+<span class="number">1</span>,j+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            memo[(i,j)] = ans</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/正则表达式匹配/3.jpg" alt="3"></p>
<h6 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h6><p>时间复杂度：用 T 和 P 分别表示匹配串和模式串的长度。对于 i=0, … , T 和 j=0, … , P 每一个 dp(i, j) 只会被计算一次，所以后面每次调用都是 O(1)的时间。因此，总时间复杂度为 O(TP) 。</p>
<p>空间复杂度：我们用到的空间仅有 O(TP)个 boolean 类型的缓存变量。所以，空间复杂度为 O(TP) 。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>单调递增的数字</title>
    <url>/2020/01/02/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/monotone-increasing-digits/" target="_blank" rel="noopener">单调递增的数字（难度：中等）</a></p>
<p><img src="/2020/01/02/单调递增的数字/1.jpg" alt="1"></p>
<h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p><img src="/2020/01/02/单调递增的数字/2.jpg" alt="2"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(self, N: int)</span> -&gt; int:</span></span><br><span class="line">        s = list(str(N))</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;len(s) <span class="keyword">and</span> s[i<span class="number">-1</span>] &lt;= s[i]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="number">0</span> &lt; i &lt; len(s) <span class="keyword">and</span> s[i<span class="number">-1</span>] &gt; s[i]:</span><br><span class="line">            s[i<span class="number">-1</span>] = str(int(s[i<span class="number">-1</span>])<span class="number">-1</span>)</span><br><span class="line">            i-=<span class="number">1</span></span><br><span class="line">        s[i+<span class="number">1</span>:] = <span class="string">'9'</span>*(len(s)-i<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> int(<span class="string">''</span>.join(s))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/单调递增的数字/3.jpg" alt="3"></p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(D)。其中 D≈logN，N 是数字的长度。<br>空间复杂度：O(D)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>整数</tag>
      </tags>
  </entry>
  <entry>
    <title>移掉K位数字</title>
    <url>/2020/01/02/%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/remove-k-digits/" target="_blank" rel="noopener">移掉K位数字（难度：中等）</a></p>
<p><img src="/2020/01/02/移掉K位数字/1.jpg" alt="1"></p>
<h4 id="方法：单调栈"><a href="#方法：单调栈" class="headerlink" title="方法：单调栈"></a>方法：单调栈</h4><p>维护一个递增栈，但当前元素小于栈顶元素，则移掉栈顶元素。</p>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>转自</p>
<blockquote>
<p>作者：monkeybing<br>链接：<a href="https://leetcode-cn.com/problems/remove-k-digits/solution/cyu-yan-zhan-shi-xian-tan-xin-suan-fa-by-monkeybin/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-k-digits/solution/cyu-yan-zhan-shi-xian-tan-xin-suan-fa-by-monkeybin/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本题采用贪心思路：</p>
<ol>
<li>如果字符串按照数字大小升序排列，只需要删除最后K个字符即可；</li>
<li>如果非升序排列，需要从前到后遍历，删除字符串中每个逆序排列的字符。由于是从前到后遍历，所以先删除的一定是高位的数字，可以保证删除后得到的最终数字最小。</li>
</ol>
<p>举例来说：如果字符串num = “123456789”, k = 3，我们只需要删除最后3个数字，得到”123456”.<br>如果字符串num = “1432219”, k = 3，需要从前到后遍历查找逆序数字，进行删除，第一个逆序数字为’4’，第二个逆序数字为’3’，第三个逆序数字为第二个’2’，最后得到”1219”。</p>
<p><strong>所以可以采用栈实现，每次遍历，判断如果栈非空，且当前数字大于栈顶数字，且k还有剩余（不为0），将栈顶数字出栈。最后将当前数字入栈。</strong><br>如果遍历完成后，k仍有剩余，则依次将栈顶数字出栈。最后栈中保存的数字即为所求。按照从栈底到栈顶输出即可。<br>注意：特判场景，如果最后所有数字均出栈，即栈为空，需要返回”0”。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeKdigits</span><span class="params">(self, num: str, k: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> k &lt;=<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> num</span><br><span class="line">        </span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> k &gt; <span class="number">0</span> <span class="keyword">and</span> stack[<span class="number">-1</span>] &gt; c:</span><br><span class="line">                stack.pop()</span><br><span class="line">                k -= <span class="number">1</span></span><br><span class="line">            stack.append(c)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> k &gt; <span class="number">0</span>:</span><br><span class="line">            stack.pop()</span><br><span class="line">            k -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'0'</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> str(int(<span class="string">''</span>.join(stack)))</span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/02/移掉K位数字/2.jpg" alt="2"></p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n).</p>
<p>空间复杂度：O(n).</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>字符串</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>贪心算法</title>
    <url>/2020/01/01/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>什么是贪心算法呢？贪心算法可以认为是动态规划算法的一个特例，相比动态规划，使用贪心算法需要满足更多的条件（贪心选择性质），但是效率比动态规划要高。</p>
<p>比如说一个算法问题使用暴力解法需要指数级时间，如果能使用动态规划消除重叠子问题，就可以降到多项式级别的时间，如果满足贪心选择性质，那么可以进一步降低时间复杂度，达到线性级别的。</p>
<p>什么是贪心选择性质呢，简单说就是：每一步都做出一个局部最优的选择，最终的结果就是全局最优。注意哦，这是一种特殊性质，其实只有一部分问题拥有这个性质。</p>
<p>比如你面前放着 100 张人民币，你只能拿十张，怎么才能拿最多的面额？显然每次选择剩下钞票中面值最大的一张，最后你的选择一定是最优的。</p>
<p>然而，大部分问题明显不具有贪心选择性质。比如打牌，对手出对儿三，按照贪心策略，你应该出尽可能小的牌刚好压制住对方，但现实情况我们甚至可能会出王炸。这种情况就不能用贪心算法，而得使用动态规划解决，参见前文<a href="https://leetcode-cn.com/problems/stone-game/solution/jie-jue-bo-yi-wen-ti-de-dong-tai-gui-hua-tong-yong/" target="_blank" rel="noopener">动态规划解决博弈问题</a>。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>无重叠区间</title>
    <url>/2020/01/01/%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/non-overlapping-intervals/" target="_blank" rel="noopener">无重叠区间（难度：中等）</a></p>
<p><img src="/2020/01/01/无重叠区间/1.jpg" alt="1"></p>
<p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-overlapping-intervals/solution/tan-xin-suan-fa-zhi-qu-jian-diao-du-wen-ti-by-labu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本文解决一个很经典的贪心算法问题 Interval Scheduling（区间调度问题）。给你很多形如 <code>[start, end]</code>的闭区间，请你设计一个算法，算出这些区间中最多有几个互不相交的区间。<br>举个例子，<code>intvs = [[1,3], [2,4], [3,6]]</code>，这些区间最多有 2 个区间互不相交，即 <code>[[1,3], [3,6]]</code>，你的算法应该返回 2。注意边界相同并不算相交。</p>
<p>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天最多能参加几个活动呢？显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。</p>
<h4 id="方法：贪心算法"><a href="#方法：贪心算法" class="headerlink" title="方法：贪心算法"></a>方法：贪心算法</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><ol>
<li>从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。</li>
<li>把所有与 x 区间相交的区间从区间集合 intvs 中删除。</li>
<li>重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。</li>
</ol>
<p><img src="https://pic.leetcode-cn.com/678752f150168fc2e53a36d30e589b76ef81a95943c018b01bef6a548bfafeeb-file_1566313617208" alt="1"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 按区间的end升序排列</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">1</span>] - b[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> x_end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] intv:intervals)&#123;</span><br><span class="line">            <span class="keyword">int</span> start = intv[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span>(x_end &lt;= start)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                x_end = intv[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(nlogn). 排序需要O(nlogn)的时间。</p>
<p>空间复杂度：O(1). 不需要额外空间。</p>
<p><img src="/2020/01/01/无重叠区间/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>区间</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title>判断子序列</title>
    <url>/2020/01/01/%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">判断子序列（难度：简单）</a></p>
<p><img src="/2020/01/01/判断子序列/3.jpg" alt="3"></p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>利用Python切片，对s中的每个字符，若在t中，下一步比较index+1开始的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> t:</span><br><span class="line">                t = t[t.index(i)+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/01/判断子序列/1.jpg" alt="1"></p>
<hr>
<h4 id="方法二：双指针"><a href="#方法二：双指针" class="headerlink" title="方法二：双指针"></a>方法二：双指针</h4><p>若相等，两个指针都往前移，若不等，快指针往前移。最后比较慢指针与s的长度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSubsequence</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">        p1 = <span class="number">0</span></span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; len(s) <span class="keyword">and</span> p2 &lt; len(t):</span><br><span class="line">            <span class="keyword">if</span> s[p1] == t[p2]:</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            p2 += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> p1 == len(s):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/01/01/判断子序列/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失的第一个正数</title>
    <url>/2019/12/31/%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数（难度：困难）</a></p>
<p><img src="/2019/12/31/缺失的第一个正数/4.jpg" alt="4"></p>
<h4 id="方法一（空间复杂度不满足要求）"><a href="#方法一（空间复杂度不满足要求）" class="headerlink" title="方法一（空间复杂度不满足要求）"></a>方法一（空间复杂度不满足要求）</h4><p>遍历一遍数组，将元素装入HashSet，再从1开始，判断元素是否在HashSet中，若不存在，则该数为缺失的第一个正数。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n).</p>
<p>空间复杂度：O(n). </p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num))</span><br><span class="line">                set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(n))</span><br><span class="line">                n++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/缺失的第一个正数/1.jpg" alt="1"></p>
<hr>
<h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>通过预处理保证数组中的数全为正数，遍历数组，当读到数字 a 时，替换索引a 处元素的符号为负数。最后返回正数所对应的索引。</p>
<h5 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h5><ul>
<li>首先检查1是否存在于数组中。如果没有，则已经完成，1 即为答案。</li>
<li>若1在数组中，则可将负数，零，和大于 n 的数替换为 1 。</li>
<li>遍历数组。当读到数字 a 时，替换索引a 处元素的符号。（即若数组中出现1，改变nums[1]的符号；若出现2，改变nums[2]的符号）<br>注意重复元素：只能改变一次符号。由于遇到数字n时，没有下标 n ，则使用索引0 处的元素来保存是否存在数字 n。</li>
<li>返回结果：<ul>
<li>从1开始遍历数组。返回第一个正数元素的下标。</li>
<li>如果 nums[0] &gt; 0，则返回 n 。</li>
<li>如果之前的步骤中没有发现 nums 中有正数元素，则返回n + 1。</li>
</ul>
</li>
</ul>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n).所有的操作一共只会遍历长度为 <code>N</code> 的数组 4 次。</p>
<p>空间复杂度：O(1).只使用了常数的空间。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 查看数组中是否包含1</span></span><br><span class="line">        <span class="keyword">int</span> contains = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="number">1</span>)&#123;</span><br><span class="line">                contains += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(contains==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 替换小于等于0的数及大于n的数为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span> || nums[i] &gt; n)</span><br><span class="line">                nums[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = Math.abs(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(a==n)</span><br><span class="line">                nums[<span class="number">0</span>] = -Math.abs(nums[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                nums[a] = -Math.abs(nums[a]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果（索引0处要单独判断，因为若数组中未出现n,则nums[0]处的值会为正数，但不该返回索引0）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/缺失的第一个正数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找重复数</title>
    <url>/2019/12/31/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">寻找重复数（难度：中等）</a></p>
<p><img src="/2019/12/31/寻找重复数/1.jpg" alt="1"></p>
<h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：<em>O</em>(nlog(n))。</p>
<p>空间复杂度：O(1) (or O(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/寻找重复数/2.jpg" alt="2"></p>
<hr>
<h4 id="方法二：集合（哈希表）"><a href="#方法二：集合（哈希表）" class="headerlink" title="方法二：集合（哈希表）"></a>方法二：集合（哈希表）</h4><h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(num))</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/寻找重复数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>缺失数字</title>
    <url>/2019/12/31/%E7%BC%BA%E5%A4%B1%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/missing-number/" target="_blank" rel="noopener">缺失数字（难度：简单）</a></p>
<p><img src="/2019/12/31/缺失数字/3.jpg" alt="3"></p>
<h4 id="方法一：数学方法"><a href="#方法一：数学方法" class="headerlink" title="方法一：数学方法"></a>方法一：数学方法</h4><p>用序列<code>[0,1,...,n]</code>的和减去给定的<code>nums</code>的和，可得到缺失的数字。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。</p>
<p>空间复杂度：O(1)。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        sum1 = sum(range(<span class="number">0</span>,len(nums)+<span class="number">1</span>)) <span class="comment"># 0,1,...,n 序列的和(或用高斯求和公式)</span></span><br><span class="line">        sum2 = sum(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum1 - sum2</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/缺失数字/1.jpg" alt="1"></p>
<p>高斯求和有溢出风险</p>
<hr>
<h4 id="方法二：位运算（异或运算）"><a href="#方法二：位运算（异或运算）" class="headerlink" title="方法二：位运算（异或运算）"></a>方法二：位运算（异或运算）</h4><p>先得到<code>[0,1,...,n]</code>的异或值，再将结果对数组<code>nums</code>中的每一个数进行一次异或运算，最终的异或结果即为这个缺失的数字。</p>
<p>在编写代码时，由于<code>[0,1,...,n]</code>恰好是这个数组的下标加上 n，因此可以用一次循环完成所有的异或运算。</p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。假设异或运算的时间复杂度是常数的。</p>
<p>空间复杂度：O(1)。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        res = len(nums) <span class="comment"># 一开始初始化为n</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(nums)):</span><br><span class="line">            res ^=  i ^ nums[i]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/31/缺失数字/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>回文链表</title>
    <url>/2019/12/29/%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">回文链表（难度：简单）</a></p>
<p><img src="/2019/12/29/回文链表/1.jpg" alt="1"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用快慢指针找到中点，对链表前半部分进行翻转。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        ListNode pre = head, prepre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一遍遍历实现翻转前半部分</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            pre = slow;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next; <span class="comment">// 若链表长度为偶数，则fast最后会指向null，若为奇数，fast最后会指向最后一个元素</span></span><br><span class="line">            pre.next = prepre;</span><br><span class="line">            prepre = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环结束后，若为偶数，slow指向后半部分第一个元素，若为奇数，slow指向中间的那个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>)</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(pre!=<span class="keyword">null</span> &amp;&amp; slow!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre.val != slow.val)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/回文链表/2.jpg" alt="2"></p>
<p><img src="/2019/12/29/回文链表/20191229-214756.jpg" alt="20191229-214756"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>翻转二叉树</title>
    <url>/2019/12/29/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/invert-binary-tree/" target="_blank" rel="noopener">翻转二叉树（难度：简单）</a></p>
<p><img src="/2019/12/29/翻转二叉树/1.jpg" alt="1"></p>
<h4 id="方法：-递归"><a href="#方法：-递归" class="headerlink" title="方法： 递归"></a>方法： 递归</h4><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n). 每个节点只被访问了一次。</p>
<p>空间复杂度：最坏情况下栈内需要存放 O(h)个方法调用，其中 h是树的高度。由于 h<em>∈</em>O<em>(</em>n)，可得出空间复杂度为 O(n)。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        TreeNode temp = invertTree(root.left);</span><br><span class="line">        root.left = invertTree(root.right);</span><br><span class="line">        root.right = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/翻转二叉树/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素2</title>
    <url>/2019/12/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">存在重复元素2（难度：简单）</a></p>
<p><img src="/2019/12/29/存在重复元素2/1.jpg" alt="1"></p>
<h4 id="方法：哈希表"><a href="#方法：哈希表" class="headerlink" title="方法：哈希表"></a>方法：哈希表</h4><p>维护一个哈希表，里面始终最多包含 k 个元素，当出现重复值时则说明在 k 距离内存在重复元素。<br>每次遍历一个元素则将其加入哈希表中，如果哈希表的大小大于 k，则移除最前面的数字。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。我们会做 n 次 搜索，删除，插入操作，每次操作都耗费常数时间。</p>
<p>空间复杂度：O(min(n,k))。开辟的额外空间取决于散列表中存储的元素的个数，也就是滑动窗口的大小。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(nums[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 因为res的大小维持为k</span></span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(res.size()&gt;k)</span><br><span class="line">                res.remove(nums[i-k]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/存在重复元素2/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>存在重复元素</title>
    <url>/2019/12/29/%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">存在重复元素（难度：简单）</a></p>
<p><img src="/2019/12/29/存在重复元素/1.jpg" alt="1"></p>
<h4 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h4><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度 : O(n)。search() 和 insert() 各自使用 n 次，每个操作耗费常数时间。</p>
<p>空间复杂度 : O(n)。哈希表占用的空间与元素数量是线性关系。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; res = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(res.contains(num))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            res.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/存在重复元素/3.jpg" alt="3"></p>
<p>另一种思路：利用Python中的set()，判断所得结果长度与原数组长度的关系</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">containsDuplicate</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">if</span> len(set1) == len(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/存在重复元素/2.jpg" alt="2"></p>
<hr>
<h4 id="方法二：-排序"><a href="#方法二：-排序" class="headerlink" title="方法二： 排序"></a>方法二： 排序</h4><p>如果存在重复元素，排序后它们应该相邻。</p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度 : O<em>(</em>nlogn)。</p>
<p>空间复杂度 : O(1)。这取决于具体的排序算法实现，通常而言，使用 <code>堆排序</code> 的话，是 O(1)。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/存在重复元素/4.jpg" alt="4"></p>
<blockquote>
<p>注：对于一些特定的 n不太大的测试样例，方法一的运行速度可能会比方法二更慢。这是因为哈希表在维护其属性时有一些开销。要注意，程序的实际运行表现和 Big-O 符号表示可能有所不同。Big-O 只是告诉我们在 <strong>充分</strong>大的输入下，算法的相对快慢。因此，在 n不够大的情况下， O(n)的算法也可以比 O(nlogn)的更慢。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中的第K个最大元素</title>
    <url>/2019/12/29/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACK%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">数组中的第K个最大元素（难度：中等）</a></p>
<p><img src="/2019/12/29/数组中的第K个最大元素/3.jpg" alt="3"></p>
<h4 id="方法一：排序"><a href="#方法一：排序" class="headerlink" title="方法一：排序"></a>方法一：排序</h4><p>先对数组进行排序，再返回倒数第 k 个元素。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(nlogn)</p>
<p>空间复杂度：O(1)</p>
<p>这个时间复杂度并不令人满意</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[-k]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/数组中的第K个最大元素/1.jpg" alt="1"></p>
<hr>
<h4 id="方法二：最小堆"><a href="#方法二：最小堆" class="headerlink" title="方法二：最小堆"></a>方法二：最小堆</h4><p>建一个只能存K个数字的小顶堆，超过K时候，每加进来一个，堆顶就要弹出一个。数组遍历完，最终堆顶的元素就是第K大的（堆里其他元素都比它还要大）。</p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(nlogk). 向大小为 k 的堆中添加元素的时间复杂度为O(logk)，我们将重复该操作 n 次，故总时间复杂度为O(nlogk)。</p>
<p>空间复杂度：O(k).</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            minHeap.add(num);</span><br><span class="line">            <span class="keyword">if</span>(minHeap.size()&gt;k)</span><br><span class="line">                minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minHeap.poll();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/29/数组中的第K个最大元素/2.jpg" alt="2"></p>
<hr>
<h4 id="方法三：快速选择"><a href="#方法三：快速选择" class="headerlink" title="方法三：快速选择"></a>方法三：快速选择</h4><p>详见<a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode/" target="_blank" rel="noopener">这里</a>.</p>
<h5 id="复杂度-2"><a href="#复杂度-2" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度 : 平均情况O<em>(</em>N)，最坏情况 O(N^2)。</p>
<p>空间复杂度 : O(1)。</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>移除链表元素</title>
    <url>/2019/12/29/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">移除链表元素（难度：简单）</a></p>
<p><img src="/2019/12/29/移除链表元素/1.jpg" alt="1"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：添加虚拟头节点解决头节点是要被删除的情况</p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>快乐数</title>
    <url>/2019/12/28/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/happy-number/" target="_blank" rel="noopener">快乐数（难度：简单）</a></p>
<p><img src="/2019/12/28/快乐数/2.jpg" alt="2"></p>
<h4 id="方法一：使用“快慢指针”思想找出循环"><a href="#方法一：使用“快慢指针”思想找出循环" class="headerlink" title="方法一：使用“快慢指针”思想找出循环"></a>方法一：使用“快慢指针”思想找出循环</h4><p>“快指针”每次走两步，“慢指针”每次走一步，当二者相等时，即为一个循环周期。此时，判断是不是因为1引起的循环，是的话就是快乐数，否则不是快乐数。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = n;</span><br><span class="line">        <span class="keyword">int</span> fast = n;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = helper(slow);</span><br><span class="line">            fast = helper(fast);</span><br><span class="line">            fast = helper(fast);</span><br><span class="line">        &#125; <span class="keyword">while</span>(slow != fast);</span><br><span class="line">        <span class="keyword">return</span> slow == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> re = n%<span class="number">10</span>;</span><br><span class="line">            sum += re*re;</span><br><span class="line">            n = n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/快乐数/1.jpg" alt="1"></p>
<hr>
<h4 id="方法二：递归"><a href="#方法二：递归" class="headerlink" title="方法二：递归"></a>方法二：递归</h4><ul>
<li>不是快乐数的数称为不快乐数(unhappy number)，所有不快乐数的数位平方和计算，最后都会进入 4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4 的循环中</li>
<li>已知规律： [1 ~ 4] 中只有 1 是快乐数，[5 ~ ∞] 的数字要么回归到 1 要么回归到 4 或 3</li>
<li>因此仅需在 n &gt; 4 时调用递归</li>
</ul>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.isHappy(sum(int(i) ** <span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> str(n))) <span class="keyword">if</span> n &gt; <span class="number">4</span> <span class="keyword">else</span> n == <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/快乐数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>求众数2</title>
    <url>/2019/12/28/%E6%B1%82%E4%BC%97%E6%95%B02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/majority-element-ii/" target="_blank" rel="noopener">求众数2（难度：中等）</a></p>
<p><img src="/2019/12/28/求众数2/1.jpg" alt="1"></p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>在Python中，先用set()找出所有出现的元素，再使用count()判断出现次数大于n/3的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">return</span> [s <span class="keyword">for</span> s <span class="keyword">in</span> set1 <span class="keyword">if</span> nums.count(s) &gt; len(nums)//<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/求众数2/2.jpg" alt="2"></p>
<p>然而时间复杂度不为O(n)。</p>
<hr>
<h4 id="方法二：Boyer-Moore-投票算法"><a href="#方法二：Boyer-Moore-投票算法" class="headerlink" title="方法二：Boyer-Moore 投票算法"></a>方法二：Boyer-Moore 投票算法</h4><p>超过n/3的数最多只能有两个。先选出两个候选人A,B（都令为nums[0]）。 遍历数组：</p>
<ol>
<li>若当前元素等于A，则A的票数++;</li>
<li><p>若当前元素等于B，则B的票数++；</p>
</li>
<li><p>若当前元素与A，B都不相等，那么检查此时A或B的票数是否减为0：</p>
<ul>
<li><p>若为0，则当前元素成为新的候选人；</p>
</li>
<li><p>若A、B票数均不为0，则A、B两个候选人的票数均减一；</p>
</li>
</ul>
</li>
</ol>
<p>遍历结束后选出了两个候选人，但是这两个候选人是否满足&gt;n//3，还需要再遍历一遍数组，找出两个候选人的具体票数。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<p><strong>代码</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span>(len(nums)==<span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        count1 = <span class="number">0</span></span><br><span class="line">        count2 = <span class="number">0</span></span><br><span class="line">        candidate1 = nums[<span class="number">0</span>]</span><br><span class="line">        candidate2 = nums[<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == candidate1:</span><br><span class="line">                count1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> num == candidate2:</span><br><span class="line">                count2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> count1 == <span class="number">0</span>:</span><br><span class="line">                    candidate1 = num</span><br><span class="line">                    count1 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> count2 == <span class="number">0</span>:</span><br><span class="line">                    candidate2 = num</span><br><span class="line">                    count2 += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    count1 -= <span class="number">1</span>;</span><br><span class="line">                    count2 -= <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> set([num <span class="keyword">for</span> num <span class="keyword">in</span> [candidate1, candidate2] <span class="keyword">if</span> nums.count(num) &gt; len(nums)//<span class="number">3</span>]) <span class="comment">#加set的原因是避免返回两个相同的数</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/求众数2/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2019/12/28/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">多数元素（难度：简单）</a></p>
<p><img src="/2019/12/28/多数元素/1.jpg" alt="1"></p>
<p><strong>注意：这样的元素只存在一个，因为出现次数大于n/2，若存在两个，则数组长度会超过n。</strong></p>
<h4 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h4><p>在Python中，先用set()找出所有出现的元素，再使用count()判断出现次数大于n/2的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        set1 = set(nums)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> set1:</span><br><span class="line">            <span class="keyword">if</span> nums.count(s) &gt; len(nums)//<span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/多数元素/2.jpg" alt="2"></p>
<hr>
<h4 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h4><p>先排序，再返回位于n/2位置的元素。</p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(nlogn)。用 Python 和 Java 将数组排序开销都为 O(nlogn)，它占据了运行的主要时间。</p>
<p>空间复杂度：O(1)或O(n)。就地排序或使用线性空间将 <code>nums</code> 数组拷贝，然后再排序。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">return</span> nums[len(nums)//<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/多数元素/3.jpg" alt="3"></p>
<hr>
<h4 id="方法三：Boyer-Moore-投票算法"><a href="#方法三：Boyer-Moore-投票算法" class="headerlink" title="方法三：Boyer-Moore 投票算法"></a>方法三：Boyer-Moore 投票算法</h4><p>从第一个数开始count=1，遇到相同的就加1，遇到不同的就减1，减到0就重新换个数开始计数，最后总能找到最多的那个。</p>
<h5 id="复杂度-1"><a href="#复杂度-1" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n)。严格执行了 n 次循环。</p>
<p>空间复杂度：O(1)。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        candidate = nums[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">                candidate = num</span><br><span class="line">            <span class="keyword">if</span> num==candidate:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/多数元素/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找峰值</title>
    <url>/2019/12/28/%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/find-peak-element/" target="_blank" rel="noopener">寻找峰值（难度：中等）</a></p>
<p><img src="/2019/12/28/寻找峰值/1.jpg" alt="1"></p>
<h4 id="方法一：线性扫描"><a href="#方法一：线性扫描" class="headerlink" title="方法一：线性扫描"></a>方法一：线性扫描</h4><p>利用连续的两个元素 <code>nums[j]</code> 和 <code>nums[j+1]</code> 不会相等这一事实，我们可以从头开始遍历 <code>nums</code>数组，当遇到<code>nums[i] &gt; nums[i+1]</code> ，即可判断 <code>nums[i]</code>为峰值。</p>
<p><strong>注意：不需要判断<code>nums[i]&gt;nums[i-1]</code>。这是由于“遍历会到达第i个元素”本身就说明上一个元素（第i- 1个）不满足 <code>nums[i] &gt; nums[i+1]</code>这一条件，也就说明 <code>nums[i-1] &lt; nums[i]</code>。</strong></p>
<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度 : O(n)。  只进行一次遍历。<br>空间复杂度 : O(1)。 只使用了常数空间。</p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.length-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="方法二：二分法查找"><a href="#方法二：二分法查找" class="headerlink" title="方法二：二分法查找"></a>方法二：二分法查找</h4><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p>时间复杂度 : O(logn)。  每一步都将搜索空间减半。<br>空间复杂度 : O(1)。 只使用了常数空间。</p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findPeakElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = nums.length-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>]) <span class="comment">// 往左搜索</span></span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;nums[mid+<span class="number">1</span>]) <span class="comment">// 往右搜索</span></span><br><span class="line">                left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/寻找峰值/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>最长重复子数组</title>
    <url>/2019/12/28/%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/" target="_blank" rel="noopener">最长重复子数组（难度：中等）</a></p>
<p><img src="/2019/12/28/最长重复子数组/1.jpg" alt="1"></p>
<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><blockquote>
<p>作者：LeetCode<br>链接：<a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray/solution/zui-chang-zhong-fu-zi-shu-zu-by-leetcode/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>设 <code>dp[i][j]</code>为 <code>A[i:]</code> 和 <code>B[j:]</code> 的最长公共前缀，那么答案为所有 <code>dp[i][j]</code> 中的最大值 <code>max(dp[i][j])</code>。若 <code>A[i] == B[j]</code>，状态转移方程为 <code>dp[i][j] = dp[i + 1][j + 1] + 1</code>，否则为 <code>dp[i][j] = 0</code>。</p>
<p><strong>复杂度分析</strong></p>
<p>时间复杂度：O(M*N)，其中 M和 N是数组 A 和 B 的长度。<br>空间复杂度：O(M*N)，即为数组 <code>dp</code> 使用的空间。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length+<span class="number">1</span>][B.length+<span class="number">1</span>]; <span class="comment">// 长度加1是为了后面的dp[i+1][j+1]</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = A.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = B.length-<span class="number">1</span>; j&gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j])</span><br><span class="line">                    dp[i][j] = dp[i+<span class="number">1</span>][j+<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/28/最长重复子数组/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最大连续1的个数</title>
    <url>/2019/12/27/%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">最大连续1的个数（难度：简单）</a></p>
<p><img src="/2019/12/27/最大连续1的个数/1.jpg" alt="1"></p>
<h4 id="方法一：一次遍历"><a href="#方法一：一次遍历" class="headerlink" title="方法一：一次遍历"></a>方法一：一次遍历</h4><p><img src="/2019/12/27/最大连续1的个数/2.jpg" alt="2"></p>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(N)。N是数组的长度。</li>
<li>空间复杂度：O(1)，仅仅使用了 <code>count</code> 和 <code>maxCount</code>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        maxcount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                maxcount = max(maxcount, count)</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> max(maxcount,count)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/27/最大连续1的个数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>区域和检索 - 数组不可变</title>
    <url>/2019/12/27/%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/range-sum-query-immutable/" target="_blank" rel="noopener">区域和检索 - 数组不可变（难度：简单）</a></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/1.jpg" alt="1"></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/2.jpg" alt="2"></p>
<hr>
<h5 id="方法二：-缓存"><a href="#方法二：-缓存" class="headerlink" title="方法二： 缓存"></a>方法二： 缓存</h5><p><img src="/2019/12/27/区域和检索-数组不可变/3.jpg" alt="3"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] sum;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        sum = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>]; <span class="comment">// 多增加一位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            sum[i+<span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum[j+<span class="number">1</span>] - sum[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your NumArray object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * NumArray obj = new NumArray(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.sumRange(i,j);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在上面的代码中，我们插入了一个虚拟 0 作为 sum 数组中的第一个元素。这个技巧可以避免在 sumrange 函数中进行额外的条件检查。</p>
</blockquote>
<p><img src="/2019/12/27/区域和检索-数组不可变/4.jpg" alt="4"></p>
<p><img src="/2019/12/27/区域和检索-数组不可变/5.jpg" alt="5"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2019/12/27/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">最长上升子序列（难度：中等）</a></p>
<p><img src="/2019/12/27/最长上升子序列/1.jpg" alt="1"></p>
<h4 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h4><p><img src="/2019/12/27/最长上升子序列/2.jpg" alt="2"></p>
<p><img src="/2019/12/27/最长上升子序列/3.jpg" alt="3"></p>
<p><img src="/2019/12/27/最长上升子序列/4.jpg" alt="4"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])</span><br><span class="line">                    dp[i] = Math.max(dp[i], <span class="number">1</span> + dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/27/最长上升子序列/5.jpg" alt="5"></p>
<h5 id="进阶：将时间复杂度降低到O-nlogn-。-使用贪心算法-二分查找"><a href="#进阶：将时间复杂度降低到O-nlogn-。-使用贪心算法-二分查找" class="headerlink" title="进阶：将时间复杂度降低到O(nlogn)。 使用贪心算法+二分查找"></a>进阶：将时间复杂度降低到O(nlogn)。 使用贪心算法+二分查找</h5>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>完全平方数</title>
    <url>/2019/12/27/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">完全平方数（难度：中等）</a></p>
<p><img src="/2019/12/27/完全平方数/1.jpg" alt="1"></p>
<h4 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h4><p>dp[i]表示i最少可以由几个平方数构成。</p>
<p>初试化dp=[0,1,2,…, n]，长度为n+1，最多次数就是全由1构成。</p>
<p>遍历dp，对于i，遍历区间[1,n]：</p>
<p>​        遍历所有平方数小于i的数j，遍历区间[1, sqrt(i)]</p>
<p>动态转移方程：</p>
<blockquote>
<p> dp[i] = min(dp[i], dp[i - j <em> j]+1)，i表示当前数字，j</em>j表示平方数</p>
</blockquote>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>时间复杂度：O(n*sqrt(n))</p>
<p>空间复杂度：O(n)</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]; <span class="comment">//dp[i]存放的是i最少可以由几个平方数构成， 初始化为[0,1,...,n]</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; i-j*j &gt;= <span class="number">0</span>; j++)&#123;</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/27/完全平方数/2.jpg" alt="2"></p>
<hr>
<h4 id="方法二：广度优先搜索（BFS）"><a href="#方法二：广度优先搜索（BFS）" class="headerlink" title="方法二：广度优先搜索（BFS）"></a>方法二：广度优先搜索（BFS）</h4><p><img src="/2019/12/27/完全平方数/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子序列</title>
    <url>/2019/12/26/%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">乘积最大子序列（难度：中等）</a></p>
<p><img src="/2019/12/26/乘积最大子序列/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/乘积最大子序列/2.jpg" alt="2"></p>
<blockquote>
<p><strong>注意：不能只保存到当前为止的最大值，还需保存到当前为止的最小值，因为若下一个数是负数，那么以前的最小值（若为负数）会变成现在的最大值</strong>.</p>
</blockquote>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> imax = nums[<span class="number">0</span>], imin = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = imin;</span><br><span class="line">                imin = imax;</span><br><span class="line">                imax = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            imax = Math.max(imax*nums[i], nums[i]);</span><br><span class="line">            imin = Math.min(imin*nums[i], nums[i]);</span><br><span class="line">            ans = Math.max(ans,imax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/26/乘积最大子序列/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>链表中的下一个更大节点</title>
    <url>/2019/12/26/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/next-greater-node-in-linked-list/" target="_blank" rel="noopener">链表中的下一个更大节点（难度：中等）</a></p>
<p><img src="/2019/12/26/链表中的下一个更大节点/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/链表中的下一个更大节点/2.jpg" alt="2"></p>
<h4 id="方法：单调栈"><a href="#方法：单调栈" class="headerlink" title="方法：单调栈"></a>方法：单调栈</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10000</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">// 栈里存放索引</span></span><br><span class="line">            arr2[length] = head.val;</span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; arr2[stack.peek()] &lt; head.val)&#123;</span><br><span class="line">                arr[stack.pop()] = head.val;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(length);</span><br><span class="line">            head = head.next;</span><br><span class="line">            length++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">            res[i] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/26/链表中的下一个更大节点/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素2</title>
    <url>/2019/12/26/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/next-greater-element-ii/" target="_blank" rel="noopener">下一个更大元素2（难度：中等）</a></p>
<p><img src="/2019/12/26/下一个更大元素2/1.jpg" alt="1"></p>
<h4 id="方法：单调栈"><a href="#方法：单调栈" class="headerlink" title="方法：单调栈"></a>方法：单调栈</h4><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-ii/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-2/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>同样是 Next Greater Number，现在假设给你的数组是个环形的，如何处理？</p>
<p>首先，计算机的内存都是线性的，没有真正意义上的环形数组，但是我们可以模拟出环形数组的效果，一般是通过 % 运算符求模（余数），获得环形特效：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n = arr.length, index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    print(arr[index % n]);</span><br><span class="line">    index++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到 Next Greater Number 的问题，增加了环形属性后，问题的难点在于：<strong>这个 Next 的意义不仅仅是当前元素的右边了，有可能出现在当前元素的左边。</strong></p>
<p>我们可以考虑这样的思路：<strong>将原始数组 “翻倍”，</strong>就是在后面再接一个原始数组，这样的话，按照之前“比身高”的流程，每个元素不仅可以比较自己右边的元素，而且也可以和左边的元素比较了。</p>
<p><img src="https://pic.leetcode-cn.com/c6dda3c6d50dddbd4518619829834235a8f84be0f34f3b32974ad6d8e76cc3b1-file_1560500960943" alt="ink-image (2)"></p>
<h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><p>时间复杂度：O(n)</p>
<p>空间复杂度：O(n)</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// i从2*n-1开始</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; stack.peek() &lt;= nums[i%n])&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            res[i%n] = stack.empty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(nums[i%n]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/12/26/下一个更大元素2/2.jpg" alt="2"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍3</title>
    <url>/2019/12/26/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/house-robber-iii/" target="_blank" rel="noopener">打家劫舍3（难度：中等）</a></p>
<p><img src="/2019/12/26/打家劫舍3/1.jpg" alt="题目"></p>
<p>以下内容转载自：</p>
<blockquote>
<p>作者：reals<br>链接：<a href="https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p>本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法<br>我们通过3个方法不断递进解决问题</p>
<ul>
<li>解法1通过递归实现，虽然解决了问题，但是复杂度太高</li>
<li>解法2通过解决方法1中的重复子问题，实现了性能的百倍提升</li>
<li>解法3 直接省去了重复子问题，性能又提升了一步</li>
</ul>
<p><img src="/2019/12/26/打家劫舍3/2.jpg" alt="2"></p>
<p><img src="/2019/12/26/打家劫舍3/3.jpg" alt="3"></p>
<p><img src="/2019/12/26/打家劫舍3/4.jpg" alt="4"></p>
<p><img src="/2019/12/26/打家劫舍3/5.jpg" alt="5"></p>
<p><img src="/2019/12/26/打家劫舍3/6.jpg" alt="6"></p>
<p><img src="/2019/12/26/打家劫舍3/7.jpg" alt="7"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>打家劫舍2</title>
    <url>/2019/12/26/%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">打家劫舍2（难度：中等）</a></p>
<p><img src="/2019/12/26/打家劫舍2/题目.jpg" alt="题目"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><strong>此题是 <a href>198. 打家劫舍</a> 的拓展版：</strong> 唯一的区别是此题中的房间是<strong>环状排列</strong>的（即首尾相接），而 198 题中的房间是<strong>单排排列</strong>的。</p>
<p><img src="/2019/12/26/打家劫舍2/1.jpg" alt="1"></p>
<p><img src="/2019/12/26/打家劫舍2/2.jpg" alt="2"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="/2019/12/26/打家劫舍2/3.jpg" alt="3"></p>
<p><img src="/2019/12/26/打家劫舍2/4.jpg" alt="4"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>创建单链表的头插法与尾插法</title>
    <url>/2019/12/26/%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8F%92%E6%B3%95%E4%B8%8E%E5%B0%BE%E6%8F%92%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://blog.csdn.net/qq_41028985/article/details/82859199" target="_blank" rel="noopener">原文</a></p>
<h4 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h4><p><img src="/2019/12/26/创建单链表的头插法与尾插法/1577345110132.jpg" alt="图1"></p>
<p><img src="/2019/12/26/创建单链表的头插法与尾插法/1.jpg" alt="1"></p>
<h4 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a>尾插法创建单链表</h4><p><img src="/2019/12/26/创建单链表的头插法与尾插法/2.jpg" alt="2"></p>
<p><img src="/2019/12/26/创建单链表的头插法与尾插法/3.jpg" alt="3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>两数相加2</title>
    <url>/2019/12/26/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">两数相加2（难度：中等）</a></p>
<p><img src="/2019/12/26/两数相加2/1577344361644.jpg" alt="题目"></p>
<h4 id="方法：双栈-头插法"><a href="#方法：双栈-头插法" class="headerlink" title="方法：双栈 + 头插法"></a>方法：双栈 + 头插法</h4><p><img src="/2019/12/26/两数相加2/1577344797002.jpg" alt="code"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>下一个更大元素1</title>
    <url>/2019/12/25/%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E5%85%83%E7%B4%A01/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/next-greater-element-i/" target="_blank" rel="noopener">下一个更大元素1（难度：简单）</a></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281453752.jpg" alt="题目"></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281497407.jpg" alt="方法"></p>
<p><img src="/2019/12/25/下一个更大元素1/1577281548614.jpg" alt="code"></p>
<h4 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h4><p><img src="/2019/12/25/下一个更大元素1/20191225-215434.jpg" alt="图解"></p>
<hr>
<h4 id="另一种写法（从后往前）"><a href="#另一种写法（从后往前）" class="headerlink" title="另一种写法（从后往前）"></a>另一种写法（从后往前）</h4><p>转自：</p>
<blockquote>
<p>作者：labuladong<br>链接：<a href="https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/</a><br>来源：力扣（LeetCode）</p>
</blockquote>
<p><img src="/2019/12/25/下一个更大元素1/1.jpg" alt="1"></p>
<p>模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nextGreaterElement(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(nums.size()); <span class="comment">// 存放答案的数组</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123; <span class="comment">// 判定个子高矮</span></span><br><span class="line">            s.pop(); <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans[i] = s.empty() ? <span class="number">-1</span> : s.top(); <span class="comment">// 这个元素身后的第一个高个</span></span><br><span class="line">        s.push(nums[i]); <span class="comment">// 进队，接受之后的身高判定吧！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for 循环要从后往前扫描元素，因为我们借助的是栈的结构，倒着入栈，其实是正着出栈。while 循环是把两个“高个”元素之间的元素排除，因为他们的存在没有意义，前面挡着个“更高”的元素，所以他们不可能被作为后续进来的元素的 Next Great Number 了。</p>
<p>这个算法的时间复杂度不是那么直观，如果你看到 for 循环嵌套 while 循环，可能认为这个算法的复杂度也是 O(n^2)，但是实际上这个算法的复杂度只有 O(n)。</p>
<p>分析它的时间复杂度，要从整体来看：总共有 n 个元素，每个元素都被 push 入栈了一次，而最多会被 pop 一次，没有任何冗余操作。所以总的计算规模是和元素规模 n 成正比的，也就是 O(n) 的复杂度。</p>
<h5 id="本题代码"><a href="#本题代码" class="headerlink" title="本题代码"></a>本题代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums2.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">// 倒着往栈里放</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.empty() &amp;&amp; nums2[i]&gt;=stack.peek())&#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],stack.empty()?-<span class="number">1</span>:stack.peek());</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums1.length; i++)</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>栈</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>删除列表中的节点</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/delete-node-in-a-linked-list/" target="_blank" rel="noopener">删除列表中的节点（难度：简单）</a></p>
<p><img src="/2019/12/25/删除列表中的节点/捕获.JPG" alt="题目"></p>
<p><img src="/2019/12/25/删除列表中的节点/1577280000099.jpg" alt="方法"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素2</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A02/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">删除排序链表中的重复元素2（难度：中等）</a></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577278156148.jpg" alt="题目"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="/2019/12/25/删除排序链表中的重复元素2/1577278207894.jpg" alt="1577278207894"></p>
<h4 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h4><p><img src="/2019/12/25/删除排序链表中的重复元素2/20191225-210253.jpg" alt="画解"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>(Java)</p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577279243671.jpg" alt="code"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素2/1577279306551.jpg" alt="结果"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>删除排序链表中的重复元素</title>
    <url>/2019/12/25/%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/" target="_blank" rel="noopener">删除排序链表中的重复元素（难度：简单）</a></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268363569.jpg" alt="题目"></p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268482086.jpg" alt="思路"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268503067.jpg" alt="1577268503067"></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268572469.jpg" alt="1577268572469"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268850082.jpg" alt="结果"></p>
<h4 id="画解"><a href="#画解" class="headerlink" title="画解"></a>画解</h4><p><img src="/2019/12/25/删除排序链表中的重复元素/1577268614488.jpg" alt="画解1"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268643223.jpg" alt="画解2"></p>
<p><img src="/2019/12/25/删除排序链表中的重复元素/1577268718737.jpg" alt="画解3"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文串</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">最长回文串（难度：简单）</a></p>
<p><img src="/2019/12/25/最长回文串/1577266515330.jpg" alt="题目"></p>
<p><img src="/2019/12/25/最长回文串/20191225-174159.jpg" alt="思路"></p>
<p><img src="/2019/12/25/最长回文串/1577267022201.jpg" alt="code"></p>
<p><img src="/2019/12/25/最长回文串/1577267058050.jpg" alt="结果"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>最长回文子串</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">最长回文子串（难度：中等）</a></p>
<p><img src="/2019/12/25/最长回文子串/0001.jpg" alt="0001"></p>
<p><img src="/2019/12/25/最长回文子串/0002.jpg" alt="0002"></p>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>回文</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子序列</title>
    <url>/2019/12/25/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">最长公共子序列（难度：中等）</a></p>
<p><img src="/2019/12/25/最长公共子序列/question.JPG" alt="题目"></p>
<h3 id="方法：动态规划"><a href="#方法：动态规划" class="headerlink" title="方法：动态规划"></a>方法：动态规划</h3><p><img src="/2019/12/25/最长公共子序列/1.JPG" alt="图1"></p>
<p><img src="/2019/12/25/最长公共子序列/2.JPG" alt="图2"></p>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p><img src="/2019/12/25/最长公共子序列/code.JPG" alt="code"></p>
<p><img src="/2019/12/25/最长公共子序列/3.JPG" alt="图3"></p>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>数据复杂度：O(mn)</p>
<p>空间复杂度：O(mn)</p>
<hr>
<h4 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h4><p>最长公共子串（Longest Common Substring）与最长公共子序列（Longest Common Subsequence）的区别： <strong>子串要求在原字符串中是连续的，而子序列则只需保持相对顺序一致，并不要求连续</strong>。例如X = {a, Q, 1, 1}; Y = {a, 1, 1, d, f}那么，{a, 1, 1}是X和Y的最长公共子序列，但不是它们的最长公共字串。</p>
<p><strong>描述：</strong></p>
<p>计算两个字符串的最大公共子串（Longest Common Substring）的长度，字符不区分大小写。</p>
<p><strong>方法</strong></p>
<p>求子串的方法和求子序列方法类似：</p>
<p><img src="/2019/12/25/最长公共子序列/1578644196190.png" alt="1578644196190"></p>
<h5 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = text1.length();</span><br><span class="line">        <span class="keyword">int</span> n2 = text2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[n1+<span class="number">1</span>][n2+<span class="number">1</span>]; <span class="comment">//多增加一行一列</span></span><br><span class="line">        <span class="keyword">int</span> longest = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1.charAt(i-<span class="number">1</span>) == text2.charAt(j-<span class="number">1</span>))</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    longest = Math.max(longest,dp[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longest;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>HDFS-Overview</title>
    <url>/2019/12/16/HDFS-Overview/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="/2019/12/16/HDFS-Overview/0001.jpg" alt="0001"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>HDFS and MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop Introduction</title>
    <url>/2019/12/15/Hadoop-Introduction/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="History"><a href="#History" class="headerlink" title="History"></a>History</h1><p><img src="/2019/12/15/Hadoop-Introduction/hadoop-history.JPG" alt="hadoop-history"></p>
<h1 id="Hadoop-Ecosystem"><a href="#Hadoop-Ecosystem" class="headerlink" title="Hadoop Ecosystem"></a>Hadoop Ecosystem</h1><p><img src="/2019/12/15/Hadoop-Introduction/hadoop-ecosystem.JPG" alt="hadoop-ecosystem"></p>
]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hadoop Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Preprocessing（数据预处理）</title>
    <url>/2019/09/21/Data-Preprocessing/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下内容来自Udemy上的课程: <a href="https://www.udemy.com/machinelearning/" target="_blank" rel="noopener"><strong>Machine Learing A-Z: Hands-On Python &amp; R in Data Science</strong></a>.</p>
<p><a href="https://www.superdatascience.com/pages/machine-learning" target="_blank" rel="noopener">datasets download</a></p>
<p>使用数据：</p>
<p><img src="/2019/09/21/Data-Preprocessing/data.JPG" alt="data"></p>
<h3 id="1-Missing-data"><a href="#1-Missing-data" class="headerlink" title="1. Missing data"></a>1. Missing data</h3><p>Common strategy: replace the missing data by the mean, median, or most frequent value of the feature column.</p>
<h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><p>以均值代替：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking care of missing data</span></span><br><span class="line"><span class="comment"># 法一：SimpleImputer(新版sklearn，以前为 from sklearn.preprocessing import Imputer)</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imputer = SimpleImputer(missing_values=np.nan, strategy = <span class="string">"mean"</span>)</span><br><span class="line">imputer.fit(X.iloc[:, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">X.iloc[:, <span class="number">1</span>:<span class="number">3</span>] = imputer.transform(X.iloc[:, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二，replace</span></span><br><span class="line"><span class="comment">#以Age为例</span></span><br><span class="line">X[<span class="string">"Age"</span>].replace(np.nan, X[<span class="string">"Age"</span>].mean(), inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法三，fillna</span></span><br><span class="line"><span class="comment"># 以Age为例</span></span><br><span class="line">X[<span class="string">"Age"</span>] = X[<span class="string">"Age"</span>].fillna(X[<span class="string">"Age"</span>].mean())</span><br><span class="line"><span class="comment"># 也可 X["Age"].fillna(X["Age"].mean(), inplace=True)</span></span><br></pre></td></tr></table></figure>
<p>例：现有 df_age 如下：</p>
<p><img src="/2019/09/21/Data-Preprocessing/1607053623367.png" alt="1607053623367"></p>
<p>Fill the missing data in column <strong>“age_boy”</strong> with 22 and fill the missing data in column <strong>“age_girl”</strong> with 21. The expected output is:</p>
<p><img src="/2019/09/21/Data-Preprocessing/1607053581148.png" alt="1607053581148"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_age = df_age.fillna(value=&#123;<span class="string">'age_boy'</span>:<span class="number">22</span>,<span class="string">'age_girl'</span>:<span class="number">21</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>删掉有缺失值的行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X.dropna(axis = <span class="number">0</span>, inplace = <span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 或写成 X = X.dropna(axis = 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可指定当哪一变量出现缺失值时，执行删除的操作</span></span><br><span class="line">X.dropna(subset=[<span class="string">"Age"</span>], axis = <span class="number">0</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>删掉有缺失值的列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">X.dropna(axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="R"><a href="#R" class="headerlink" title="R"></a>R</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = read.csv(<span class="string">'Data.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Taking care of missing data</span></span><br><span class="line">dataset$Age = ifelse(is.na(dataset$Age),</span><br><span class="line">                     ave(dataset$Age, FUN = <span class="keyword">function</span>(x) mean(x, na.rm = <span class="literal">TRUE</span>)),</span><br><span class="line">                     dataset$Age)</span><br><span class="line">dataset$Salary = ifelse(is.na(dataset$Salary),</span><br><span class="line">                        ave(dataset$Salary, FUN = <span class="keyword">function</span>(x) mean(x, na.rm = <span class="literal">TRUE</span>)),</span><br><span class="line">                        dataset$Salary)</span><br><span class="line">                        </span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line">dataset$Age = ifelse(is.na(dataset$Age),</span><br><span class="line">                     mean(dataset$Age, na.rm = <span class="literal">TRUE</span>),</span><br><span class="line">                     dataset$Age)</span><br><span class="line"></span><br><span class="line">dataset$Salary = ifelse(is.na(dataset$Salary),</span><br><span class="line">                        mean(dataset$Salary, na.rm = <span class="literal">TRUE</span>),</span><br><span class="line">                        dataset$Salary)</span><br></pre></td></tr></table></figure>
<h3 id="2-Categorical-data"><a href="#2-Categorical-data" class="headerlink" title="2. Categorical data"></a>2. Categorical data</h3><h4 id="Python-1"><a href="#Python-1" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br></pre></td></tr></table></figure>
<p>原来的X：</p>
<p><img src="/2019/09/21/Data-Preprocessing/pic1.JPG" alt="pic1"></p>
<h5 id="2-1-LabelEncoder"><a href="#2-1-LabelEncoder" class="headerlink" title="2.1 LabelEncoder"></a>2.1 LabelEncoder</h5><blockquote>
<p>LabelEncoder官方文档<br><a href="https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.LabelEncoder.html" target="_blank" rel="noopener">https://scikit-learn.org/dev/modules/generated/sklearn.preprocessing.LabelEncoder.html</a></p>
</blockquote>
<p><img src="/2019/09/21/Data-Preprocessing/1605681111923.png" alt="1605681111923"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>经过LabelEncoder编码后的X：</p>
<p><img src="/2019/09/21/Data-Preprocessing/pic2.JPG" alt="pic2"></p>
<p>But the model will think that France has lower value than Spain -&gt; that’s not the case, we have no order here. 解决办法：使用后面介绍的OneHotEncoder方法。如果是S, M, L of a T-shirt（本身有顺序）, 不必使用OneHotEncoder方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding the Dependent Variable</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">For the dependent variable, we are only going to use LabelEncoder, </span></span><br><span class="line"><span class="string">because since this is the dpendent variable, the machine learning model will know</span></span><br><span class="line"><span class="string">that it's a category, and that there is no oder between the two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">labelencoder_y = LabelEncoder()</span><br><span class="line">y = labelencoder_y.fit_transform(y)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/21/Data-Preprocessing/result2.JPG" alt="result2"></p>
<h5 id="2-2-factorize"><a href="#2-2-factorize" class="headerlink" title="2.2 factorize"></a>2.2 factorize</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder</span><br><span class="line"></span><br><span class="line">df = DataFrame([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>], columns=[<span class="string">'Col'</span>]) </span><br><span class="line"></span><br><span class="line"><span class="comment"># factorize</span></span><br><span class="line">df[<span class="string">'Fact'</span>] = pd.factorize(df[<span class="string">'Col'</span>])[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># LabelEncoder</span></span><br><span class="line">le = preprocessing.LabelEncoder()</span><br><span class="line">df[<span class="string">'Lab'</span>] = le.fit_transform(df[<span class="string">'Col'</span>])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#   Col  Fact  Lab</span></span><br><span class="line"><span class="comment"># 0   A     0    0</span></span><br><span class="line"><span class="comment"># 1   B     1    1</span></span><br><span class="line"><span class="comment"># 2   B     1    1</span></span><br><span class="line"><span class="comment"># 3   C     2    2</span></span><br></pre></td></tr></table></figure>
<p>👆可以看到factorize与LabelEncoder结果是一样的</p>
<h5 id="2-3-OneHotEncoder"><a href="#2-3-OneHotEncoder" class="headerlink" title="2.3 OneHotEncoder"></a>2.3 OneHotEncoder</h5><blockquote>
<p>OneHotEncoder官方文档<br><a href="https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html" target="_blank" rel="noopener">https://scikit-learn.org/stable/modules/generated/sklearn.preprocessing.OneHotEncoder.html</a></p>
</blockquote>
<p><img src="/2019/09/21/Data-Preprocessing/1605681883031.png" alt="1605681883031"></p>
<p><img src="/2019/09/21/Data-Preprocessing/dummy-encoding.JPG" alt="dummy encoding"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="number">0</span>])  <span class="comment"># which column you want to encode</span></span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/21/Data-Preprocessing/result1.JPG" alt="result1"></p>
<p>另一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> OneHotEncoder</span><br><span class="line"></span><br><span class="line">encoder = OneHotEncoder()</span><br><span class="line">onehotencoder = encoder.fit_transform(X.iloc[:,<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<h5 id="2-4-get-dummies"><a href="#2-4-get-dummies" class="headerlink" title="2.4 get_dummies()"></a>2.4 get_dummies()</h5><p>onehot encoding的另一种实现方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">new_col = pd.get_dummies(X[<span class="string">'Age'</span>])</span><br><span class="line"></span><br><span class="line">X_new = pd.concat([X,newcol], axis=<span class="number">1</span>)</span><br><span class="line">X_new.drop(<span class="string">'Age'</span>, axis = <span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-4-LabelEncoder-OnehotEncoder-factorize-get-dummies的区别"><a href="#2-4-LabelEncoder-OnehotEncoder-factorize-get-dummies的区别" class="headerlink" title="2.4 LabelEncoder, OnehotEncoder, factorize, get_dummies的区别"></a>2.4 LabelEncoder, OnehotEncoder, factorize, get_dummies的区别</h5><blockquote>
<p>参考 <a href="https://medium.com/@vaibhavshukla182/want-to-know-the-diff-among-pd-factorize-a8591eb3347d" target="_blank" rel="noopener">https://medium.com/@vaibhavshukla182/want-to-know-the-diff-among-pd-factorize-a8591eb3347d</a></p>
</blockquote>
<p>这四种编码方式可以分为两类：</p>
<ul>
<li>Encode <strong>labels into categorical variables</strong>: Pandas <code>factorize</code> and scikit-learn <code>LabelEncoder</code>. The result will have <strong>1 dimension</strong>(It is important as it could be used while implementing any model). <span style="color:red">factorize与LabelEncoder都是将字符型变量(categorical varirables)编码为数值型1，2，3…（本来是一维，编码后依然是一维）</span></li>
<li>Encode <strong>categorical variable into dummy/indicator (binary) variables</strong>: Pandas <code>get_dummies</code> and scikit-learn <code>OneHotEncoder</code>. The result will have <strong>n dimensions</strong>, one by distinct value of the encoded categorical variable. <span style="color:red">get_dummies与OneHotEnocder都是将字符型变量编码为0，1哑变量（本来是一维，编码后变为多维）</span></li>
</ul>
<p>The main difference between pandas and scikit-learn encoders is that scikit-learn encoders are made to be used in <strong>scikit-learn pipelines</strong> with <code>fit</code> and <code>transform</code> methods. <span style="color:red">sklearn中的LabelEnocder，OneHotEncoder与pandas中的factorize, get_dummies的区别在于sklearn的两个方法可以使用fit和transform（在测试集上的编码应依赖于训练集）</span></p>
<h5 id="2-5-完整代码"><a href="#2-5-完整代码" class="headerlink" title="2.5 完整代码"></a>2.5 完整代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the libraries</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values</span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding categorical data</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding the Independent Variable</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line">labelencoder_X = LabelEncoder()</span><br><span class="line">X[:, <span class="number">0</span>] = labelencoder_X.fit_transform(X[:, <span class="number">0</span>])</span><br><span class="line">onehotencoder = OneHotEncoder(categorical_features = [<span class="number">0</span>])  <span class="comment"># which column you want to encode</span></span><br><span class="line">X = onehotencoder.fit_transform(X).toarray()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Encoding the Dependent Variable</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">For the dependent variable, we are only going to use LabelEncoder, </span></span><br><span class="line"><span class="string">because since this is the dpendent variable, the machine learning model will know</span></span><br><span class="line"><span class="string">that it's a category, and that there is no oder between the two</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">labelencoder_y = LabelEncoder()</span><br><span class="line">y = labelencoder_y.fit_transform(y)</span><br></pre></td></tr></table></figure>
<h4 id="R-1"><a href="#R-1" class="headerlink" title="R"></a>R</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encoding categorical data</span></span><br><span class="line">dataset$Country = factor(dataset$Country,</span><br><span class="line">                         levels = c(<span class="string">'France'</span>, <span class="string">'Spain'</span>, <span class="string">'Germany'</span>),</span><br><span class="line">                         labels = c(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">dataset$Purchased = factor(dataset$Purchased,</span><br><span class="line">                           levels = c(<span class="string">'No'</span>, <span class="string">'Yes'</span>),</span><br><span class="line">                           labels = c(<span class="number">0</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/21/Data-Preprocessing/result3.JPG" alt="result3"></p>
<p><img src="/2019/09/21/Data-Preprocessing/result4.JPG" alt="result4"></p>
<h3 id="3-train-test-split"><a href="#3-train-test-split" class="headerlink" title="3. train_test_split"></a>3. train_test_split</h3><h4 id="Python-2"><a href="#Python-2" class="headerlink" title="Python"></a>Python</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values <span class="comment"># :-1 -&gt; take all the column except the last one</span></span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="R-2"><a href="#R-2" class="headerlink" title="R"></a>R</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = read.csv(<span class="string">'Data.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="comment"># install.packages('caTools')</span></span><br><span class="line"><span class="keyword">library</span>(caTools)</span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">split = sample.split(dataset$Purchased, SplitRatio = <span class="number">0.8</span>) <span class="comment"># 这里取因变量</span></span><br><span class="line"><span class="comment"># spilt结果为TRUE,FALSE, TRUE -&gt; go to training set, FALSE -&gt; go to test set</span></span><br><span class="line">training_set = subset(dataset, split == <span class="literal">TRUE</span>)</span><br><span class="line">test_set = subset(dataset, split == <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure>
<h3 id="4-Feature-Scaling"><a href="#4-Feature-Scaling" class="headerlink" title="4. Feature Scaling"></a>4. Feature Scaling</h3><p>Lots of machine learning models are based on Euclidean distance. Since the salary has a much wider range of values, the euclidean distance will be dominated by the salary. </p>
<p>Even if the machine learning models are not based on euclidean distance, we will still need to do feature scaling, because the algorithms will converge much faster, that will be the case for decision trees. （？决策树不需要归一化/标准化？）</p>
<p><strong><em>Feature Scaling:</em></strong> Putting our variables in the same range (in the same scale),  so that no variable is dominated by the other.</p>
<p><img src="/2019/09/21/Data-Preprocessing/feature-scaling.JPG" alt="feature scaling"></p>
<p><strong><em>Question 1: Do we need to fit and transform dummy variables?</em></strong></p>
<p><img src="/2019/09/21/Data-Preprocessing/show1.JPG" alt="show1"></p>
<p>It depends on the context. Depends on how much you want to keep interpretation in your models. Because if we scale dummy variables, it will be good because everything will be on the same scale, it will be good for our predicitons, but we will lose interpretation of knowing which observation belongs to which country.</p>
<p><strong><em>Qustion 2: Do we need to apply feature scaling to y?</em></strong></p>
<p>we don’t need to do it if it is a classification problem  with categorical dependent variable. But for regression, where the dependent variable will take a huge range of values, we will need to apply feature scaling to y as well.</p>
<blockquote>
<p>以下内容参考 <a href="https://www.jianshu.com/p/ba2a64a81c81" target="_blank" rel="noopener">https://www.jianshu.com/p/ba2a64a81c81</a></p>
</blockquote>
<h4 id="4-1-Normalization归一化-Min-Max"><a href="#4-1-Normalization归一化-Min-Max" class="headerlink" title="4.1 Normalization归一化 Min-Max"></a>4.1 Normalization归一化 Min-Max</h4><script type="math/tex; mode=display">
x_{new} = \frac{x_{old}-x_{min}}{x_{max}-x_{min}}</script><p>$x_{new}$取值范围：[0,1]</p>
<p>其他归一化方法：</p>
<p><img src="/2019/09/21/Data-Preprocessing/1605753529878.png" alt="1605753529878"></p>
<p><img src="/2019/09/21/Data-Preprocessing/1605753552476.png" alt="1605753552476"></p>
<h4 id="4-2-Standardization标准化-Z-score"><a href="#4-2-Standardization标准化-Z-score" class="headerlink" title="4.2 Standardization标准化 Z-score"></a>4.2 Standardization标准化 Z-score</h4><script type="math/tex; mode=display">
x_{new} = \frac{X_{old}-\mu}{\sigma}</script><p>The resulting values hover around 0, and typically range between -3 and +3, but can be higher or lower.</p>
<h4 id="4-3-归一化和标准化的区别"><a href="#4-3-归一化和标准化的区别" class="headerlink" title="4.3 归一化和标准化的区别"></a>4.3 归一化和标准化的区别</h4><p><strong>（1）转换区间</strong><br>归一化（Normalization）：把数据转换到(0,1)或者(-1,1)区间的数据映射方式<br>标准化（Standardization）：把数据转换到均值为0，标准差为1的数据映射方式</p>
<p><strong>（2）数据分布</strong><br>归一化：对数据的数值范围进行特定缩放，但不改变其数据分布</p>
<p><img src="/2019/09/21/Data-Preprocessing/1605683366191.png" alt="1605683366191"></p>
<p>标准化：对数据的分布进行转换，使其符合某种分布（如正态分布）</p>
<p><img src="/2019/09/21/Data-Preprocessing/1605683445278.png" alt="1605683445278"></p>
<h4 id="4-4-为什么要归一化-标准化"><a href="#4-4-为什么要归一化-标准化" class="headerlink" title="4.4 为什么要归一化/标准化"></a>4.4 为什么要归一化/标准化</h4><p><strong>（1）梯度下降的需要，加速算法收敛速度</strong><br>在使用梯度下降的方法求解最优化问题时，归一化/标准化后可以加快梯度下降的求解速度，即提升模型的收敛速度。</p>
<p><img src="/2019/09/21/Data-Preprocessing/1605752923883.png" alt="1605752923883"></p>
<p>线性回归、逻辑回归、神经网络等使用梯度下降法求解最优参数的算法，输入数据需要做归一化/标准化处理，提升模型收敛速度。</p>
<p><strong>（2）距离计算的需要，保障算法准确度</strong><br>一些算法需要计算样本之间的距离（如欧式距离），例如KNN、kmeans等聚类算法。<strong>如果一个特征值域范围非常大，那么距离计算就主要取决于这个特征</strong>，从而与实际情况相悖。</p>
<p><strong>（3）消除量纲和数量级影响</strong><br>各个指标之间由于计量单位和数量级不尽相同，从而使得各指标间不具有综合性，不能直接进行综合分析，这时就必须采用某种方法对各指标数值进行无量纲化处理，解决各指标数值不可综合性问题。</p>
<blockquote>
<p>去量纲指的是去除数据单位之间的不统一，将数据统一变换为无单位（统一单位）的数据集。</p>
</blockquote>
<h4 id="4-5-什么时候用标准化？什么时候用归一化？"><a href="#4-5-什么时候用标准化？什么时候用归一化？" class="headerlink" title="4.5  什么时候用标准化？什么时候用归一化？"></a>4.5  什么时候用标准化？什么时候用归一化？</h4><p>（1）一般建议优先使用标准化，在机器学习中，标准化是更常用的手段，归一化的应用场景是有限的。<br>（2）如果数据不稳定，存在极端的最大最小值，不要用归一化。<br>（3）在分类、聚类算法中，需要使用距离来度量相似性的时候、或者使用PCA技术进行降维的时候，标准化(Z-score standardization)表现更好。<br>（4）在不涉及距离度量、协方差计算、数据不符合正态分布的时候，可以使用归一化方法。比如图像处理中，将RGB图像转换为灰度图像后将其值限定在[0, 255]的范围。</p>
<h4 id="4-6-不是所有模型都要求输入数据经过标准化-归一化处理"><a href="#4-6-不是所有模型都要求输入数据经过标准化-归一化处理" class="headerlink" title="4.6 不是所有模型都要求输入数据经过标准化/归一化处理"></a>4.6 不是所有模型都要求输入数据经过标准化/归一化处理</h4><p>不是所有的模型都需要做归一的，比如模型算法里面没有关于对距离的衡量，没有关于对变量间标准差的衡量。<br>（1）比如decision tree决策树，算法里面没有涉及到任何和距离等有关的，所以在做决策树模型时，通常是不需要将变量做标准化的<br>（2）概率模型不需要归一化，因为它们不关心变量的值，而是关心变量的分布和变量之间的条件概率。</p>
<h4 id="4-7-Python"><a href="#4-7-Python" class="headerlink" title="4.7 Python"></a>4.7 Python</h4><p>以下代码中scale了dummy variable.</p>
<p>标准化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Importing the dataset</span></span><br><span class="line">dataset = pd.read_csv(<span class="string">'Data.csv'</span>)</span><br><span class="line">X = dataset.iloc[:, :<span class="number">-1</span>].values <span class="comment"># :-1 -&gt; take all the column except the last one</span></span><br><span class="line">y = dataset.iloc[:, <span class="number">3</span>].values</span><br><span class="line"></span><br><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = <span class="number">0.2</span>, random_state = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Scaling</span></span><br><span class="line"><span class="comment"># most of time we don't need to do feature scaling, beacuse feature scaling is a tool</span></span><br><span class="line"><span class="comment"># included most of time in the machine learning libraries</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">sc_X = StandardScaler()</span><br><span class="line">X_train_scaled = sc_X.fit_transform(X_train)</span><br><span class="line">X_test_scaled = sc_X.transform(X_test)</span><br></pre></td></tr></table></figure>
<p>Feature scaling on X_test is the same as the feature scaling on the X_train(scaled on the same bases)</p>
<p><img src="/2019/09/21/Data-Preprocessing/result5.JPG" alt="result5"></p>
<p>The result is between -1 and 1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sc_y = StandardScaler()</span><br><span class="line">y_train_scaled = sc_y.fit_transform(y_train.reshape(<span class="number">-1</span>,<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<p>归一化MinMax：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line">scaler = MinMaxScaler()</span><br><span class="line">X_train_scaled = scaler.fit_transform(X_train)</span><br><span class="line">X_test_scaled = scaler.transform(X_test)</span><br></pre></td></tr></table></figure>
<h4 id="4-8-R"><a href="#4-8-R" class="headerlink" title="4.8 R"></a>4.8 R</h4><figure class="highlight r"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Splitting the dataset into the Training set and Test set</span></span><br><span class="line"><span class="comment"># install.packages('caTools')</span></span><br><span class="line"><span class="keyword">library</span>(caTools)</span><br><span class="line">set.seed(<span class="number">123</span>)</span><br><span class="line">split = sample.split(dataset$Purchased, SplitRatio = <span class="number">0.8</span>)</span><br><span class="line"><span class="comment"># spilt结果为TRUE,FALSE, TRUE -&gt; go to training set, FALSE -&gt; go to test set</span></span><br><span class="line">training_set = subset(dataset, split == <span class="literal">TRUE</span>)</span><br><span class="line">test_set = subset(dataset, split == <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Feature Scaling 标准化</span></span><br><span class="line">training_set = scale(training_set)</span><br><span class="line">test_set = scale(test_set)</span><br></pre></td></tr></table></figure>
<p>语法：<code>scale(x, center = TRUE, scale = TRUE)</code></p>
<p>Arguments:<br><code>x</code>: a numeric matrix(like object).<br><code>center</code>: either a logical value or a numeric vector of length equal to the number of columns of <code>x</code>.<br><code>scale</code>: either a logical value or a numeric vector of length equal to the number of columns of <code>x</code>.</p>
<p>Details:<br>If <code>center</code> is <code>TRUE</code> then centering is done by subtracting the column means (omitting <code>NA</code>s) of <code>x</code> from their corresponding columns, and if <code>center</code> is <code>FALSE</code>, no centering is done.<br>If <code>scale</code> is <code>TRUE</code> then scaling is done by dividing the (centered) columns of <code>x</code> by their standard deviations if <code>center</code> is <code>TRUE</code>, and the root mean square otherwise. If <code>scale</code> is <code>FALSE</code>, no scaling is done.<br>The root-mean-square for a (possibly centered) column is defined as $\sqrt{sum(x^2)/(n-1)}$, where <em>x</em> is a vector of the non-missing values and <em>n</em> is the number of non-missing values. In the case <code>center = TRUE</code>, this is the same as the standard deviation, but in general it is not. (To scale by the standard deviations without centering, use <code>scale(x, center = FALSE, scale = apply(x, 2, sd, na.rm = TRUE))</code>.)</p>
<p>但直接这样运行会出错：</p>
<p><img src="/2019/09/21/Data-Preprocessing/result6.JPG" alt="result6"></p>
<p>原因：因子型变量不是 numeric的。</p>
<p><img src="/2019/09/21/Data-Preprocessing/result7.JPG" alt="result7"></p>
<p>解决方法：We’re going to exclude categories from the feature scaling, we’re not going to apply feature scaling on those columns.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><span class="line">training_set[,<span class="number">2</span>:<span class="number">3</span>] = scale(training_set[,<span class="number">2</span>:<span class="number">3</span>])</span><br><span class="line">test_set[,<span class="number">2</span>:<span class="number">3</span>] = scale(test_set[,<span class="number">2</span>:<span class="number">3</span>])</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>MachineLearningA-Z</tag>
      </tags>
  </entry>
  <entry>
    <title>Python working directory</title>
    <url>/2019/09/17/Python-working-directory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>更改当前路径</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">"E:/machine learning"</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前路径</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据框操作</title>
    <url>/2019/09/02/dataframe-operation/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="1-创建dataframe"><a href="#1-创建dataframe" class="headerlink" title="1. 创建dataframe"></a>1. 创建dataframe</h4><ul>
<li>法一</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = pd.DataFrame(&#123;<span class="string">'id'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], <span class="string">'string'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>,<span class="string">'c'</span>]&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>法二（若已有现成的list）</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = pd.DataFrame([n_clusters_start, score], columns = [<span class="string">"分类数"</span>, <span class="string">"得分"</span>])</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">exclamationCount = <span class="keyword">lambda</span> text: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text <span class="keyword">if</span> x == <span class="string">'!'</span>])</span><br><span class="line">EC = tweet.apply(<span class="keyword">lambda</span> x:exclamationCount(x))</span><br><span class="line">EC = EC.tolist()</span><br><span class="line">questionMarkCount = <span class="keyword">lambda</span> text: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text <span class="keyword">if</span> x == <span class="string">'?'</span>])</span><br><span class="line">QC = tweet.apply(<span class="keyword">lambda</span> x:questionMarkCount(x))</span><br><span class="line">QC = QC.tolist()</span><br><span class="line">dat = pd.DataFrame(&#123;<span class="string">'EC'</span>:EC,<span class="string">'QC'</span>:QC&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eachLetterCount = <span class="keyword">lambda</span> text,letter: sum([<span class="number">1</span> <span class="keyword">for</span> x <span class="keyword">in</span> text.lower() <span class="keyword">if</span> x == letter])</span><br><span class="line"></span><br><span class="line">FList = []</span><br><span class="line">pattern = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">j=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">  F = tweet.apply(<span class="keyword">lambda</span> x:eachLetterCount(x,i))</span><br><span class="line">  F = F.tolist()</span><br><span class="line">  FList.append(F)</span><br><span class="line"></span><br><span class="line">res = pd.DataFrame(FList)</span><br><span class="line">res = res.transpose()</span><br><span class="line"></span><br><span class="line">pattern = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line">name = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pattern:</span><br><span class="line">  name.append(<span class="string">"freqOf "</span> + i)</span><br><span class="line">res.columns = name</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/dataframe-operation/outcome.JPG" alt="结果"></p>
<a id="more"></a>
<h4 id="2-数据框拼接"><a href="#2-数据框拼接" class="headerlink" title="2.  数据框拼接"></a>2.  数据框拼接</h4><p><strong>ignore_index = True, 重新分配索引</strong></p>
<h5 id="2-1-append"><a href="#2-1-append" class="headerlink" title="2.1 append"></a>2.1 append</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = result1.append(result2, ignore_index = <span class="literal">True</span>) <span class="comment"># 粘贴行</span></span><br></pre></td></tr></table></figure>
<h5 id="2-2-concat"><a href="#2-2-concat" class="headerlink" title="2.2 concat"></a>2.2 concat</h5><blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.concat.html" target="_blank" rel="noopener">pandas.concat — pandas 1.3.0 documentation (pydata.org)</a></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = pd.concat([result1, result2], ignore_index = <span class="literal">True</span>) <span class="comment"># 默认axis = 0, 粘贴行 </span></span><br><span class="line">RF_eval = pd.concat([RF_eval, eval_raw], axis = <span class="number">1</span>) <span class="comment"># 粘贴列</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-merge"><a href="#2-3-merge" class="headerlink" title="2.3 merge"></a>2.3 merge</h5><blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.merge.html" target="_blank" rel="noopener">pandas.merge — pandas 1.3.0 documentation (pydata.org)</a></p>
</blockquote>
<p><img src="/2019/09/02/dataframe-operation/image-20210717004007434.png" alt="image-20210717004007434"></p>
<h4 id="3-删掉列"><a href="#3-删掉列" class="headerlink" title="3. 删掉列"></a>3. 删掉列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RF_eval.drop([<span class="string">'raw'</span>], axis = <span class="number">1</span>, inplace = <span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="4-删掉行"><a href="#4-删掉行" class="headerlink" title="4. 删掉行"></a>4. 删掉行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dat = dat.drop(<span class="number">0</span>) <span class="comment"># 删掉第一行</span></span><br></pre></td></tr></table></figure>
<h4 id="5-提取行索引"><a href="#5-提取行索引" class="headerlink" title="5. 提取行索引"></a>5. 提取行索引</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index0 = res.index[res[<span class="string">'label'</span>] == <span class="number">0</span>].tolist()</span><br><span class="line">X0 = X[index0] <span class="comment"># X为矩阵</span></span><br></pre></td></tr></table></figure>
<h4 id="6-提取特定的行"><a href="#6-提取特定的行" class="headerlink" title="6. 提取特定的行"></a>6. 提取特定的行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[df[<span class="string">'id'</span>]=<span class="number">1</span>] <span class="comment"># 提取id为1的行</span></span><br><span class="line">df[(df[<span class="string">'id'</span>]&gt;=<span class="number">1</span>) &amp;&amp; (df[<span class="string">'id'</span>]&lt;=<span class="number">5</span>)] <span class="comment"># 提取id在[1,5]之间的行</span></span><br><span class="line">df.loc[df[<span class="string">'id'</span>]==<span class="number">1</span>, <span class="string">'age'</span>] <span class="comment">#提取id为1的行的人的年龄</span></span><br></pre></td></tr></table></figure>
<h4 id="7-DataFrame-中-axis-的概念"><a href="#7-DataFrame-中-axis-的概念" class="headerlink" title="7. DataFrame 中 axis 的概念"></a>7. DataFrame 中 axis 的概念</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/100064394" target="_blank" rel="noopener">Pandas教程 | 数据处理三板斧——map、apply、applymap详解 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p>在 DataFrame 对象的大多数方法中，都会有 <code>axis</code> 这个参数，它控制了你指定的操作是沿着0轴还是1轴进行。<strong><code>axis=0</code>代表操作对列<code>columns</code>进行，<code>axis=1</code>代表操作对行<code>row</code>进行</strong>，如下图所示。</p>
<p><img src="/2019/09/02/dataframe-operation/image-20210717170137958.png" alt="image-20210717170137958"></p>
<p><strong><span style="color:red">换言之，如果想增加一列（如把两个数据框横向拼接在一起(沿着axis=1的方向)），则选择axis=1，如果想增加一行（如对以上数据，对height求和(结果将显示在最下方，即”增加了一行”(沿着axis=0的方向))），则选择axis=0</span></strong></p>
<p>假设现在需要对上述数据框中的数值列分别进行<strong>取对数</strong>和<strong>求和</strong>的操作，这时可以用<code>apply</code>进行相应的操作，因为是对列进行操作，所以需要指定<code>axis=0</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 沿着0轴求和</span></span><br><span class="line">data[[<span class="string">"height"</span>,<span class="string">"weight"</span>,<span class="string">"age"</span>]].apply(np.sum, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 沿着0轴取对数</span></span><br><span class="line">data[[<span class="string">"height"</span>,<span class="string">"weight"</span>,<span class="string">"age"</span>]].apply(np.log, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/dataframe-operation/image-20210717171536577.png" alt="image-20210717171536577"></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>读取与保存csv和txt文件</title>
    <url>/2019/09/02/%E8%AF%BB%E5%8F%96%E4%B8%8E%E4%BF%9D%E5%AD%98csv%E5%92%8Ctxt%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="一、csv文件"><a href="#一、csv文件" class="headerlink" title="一、csv文件"></a>一、csv文件</h4><h5 id="1-读取"><a href="#1-读取" class="headerlink" title="1. 读取"></a>1. 读取</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train = pd.read_csv(<span class="string">"Google_Stock_Price_Train.csv"</span>)</span><br><span class="line">train.head()</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/读取与保存csv和txt文件/1594120531625.png" alt="1594120531625" style="zoom:80%;"></p>
<p>若文件中无列表头，需设定header = None，否则第一行会被识别为标题（如下图）</p>
<p><img src="/2019/09/02/读取与保存csv和txt文件/1594120744906.png" alt="1594120744906" style="zoom:80%;"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">"dataset.csv"</span>, header=<span class="literal">None</span>)</span><br><span class="line">data.head()</span><br><span class="line"><span class="comment">#data.columns = ['date','open','high','low','close','volume']</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/读取与保存csv和txt文件/1594120675413.png" alt="1594120675413" style="zoom:80%;"></p>
<p>或者用names指定需要的列表头</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">'dataset.csv'</span>, names =  [<span class="string">'date'</span>,<span class="string">'open'</span>,<span class="string">'high'</span>,<span class="string">'low'</span>,<span class="string">'close'</span>,<span class="string">'volume'</span>])</span><br></pre></td></tr></table></figure>
<p><strong>另：关于读取csv文件，报错：</strong></p>
<blockquote>
<p>参考 <a href="https://www.cnblogs.com/huangchenggener/p/10983812.html" target="_blank" rel="noopener">https://www.cnblogs.com/huangchenggener/p/10983812.html</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;utf-8&apos; codec can&apos;t decode byte 0xd4 in position 0: invalid continuation byte</span><br></pre></td></tr></table></figure>
<p>法一：csv文件的保存格式改为 “CSV UTF-8 (逗号分割) (*.csv)”</p>
<p>法二：pd.read_csv()中加上编码方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">"xxx.csv"</span>, encoding=<span class="string">'gbk'</span>)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-保存"><a href="#2-保存" class="headerlink" title="2. 保存"></a>2. 保存</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">df = pd.DataFrame(np_data, columns = [<span class="string">'year'</span>, <span class="string">'month'</span>, <span class="string">'day'</span>])</span><br><span class="line">df.to_csv(<span class="string">'E:\test\modified.csv'</span>, index = <span class="literal">False</span>, header = <span class="literal">False</span>) <span class="comment"># index = False, header = False表示不保存行索引和列标题</span></span><br><span class="line"><span class="comment"># save.to_csv("RF_test.csv", index = False)</span></span><br></pre></td></tr></table></figure>
<p><strong>另：关于使用to_csv保存后，打开csv有中文乱码问题：</strong></p>
<blockquote>
<p>参考 <a href="https://blog.csdn.net/zhuzuwei/article/details/80890007" target="_blank" rel="noopener">pandas 之 to_csv 保存数据出现中文乱码问题及解决办法</a></p>
</blockquote>
<p>若有乱码问题，使用如下语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.to_csv(<span class="string">"xxx.csv"</span>, index=<span class="literal">False</span>, encoding=<span class="string">'utf_8'</span>)</span><br><span class="line">若仍有乱码，可使用：</span><br><span class="line">df.to_csv(<span class="string">"xxx.csv"</span>, index=<span class="literal">False</span>, encoding=<span class="string">'utf_8_sig'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="二、txt文件"><a href="#二、txt文件" class="headerlink" title="二、txt文件"></a>二、txt文件</h4><h5 id="1-读取-1"><a href="#1-读取-1" class="headerlink" title="1. 读取"></a>1. 读取</h5><p>(注：法一和法二都有可能会造成行数缺少或数据分割不正确的现象，建议采用法三)</p>
<p>法一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train = pd.read_table(<span class="string">'train_tweets.txt'</span>, sep = <span class="string">'\t'</span>, header = <span class="literal">None</span>, encoding = <span class="string">"UTF-8"</span>)</span><br></pre></td></tr></table></figure>
<p>法二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">train = pd.read_fwf(<span class="string">'train_tweets.txt'</span>, sep = <span class="string">'\t'</span>, header = <span class="literal">None</span>, encoding = <span class="string">"UTF-8"</span>)</span><br></pre></td></tr></table></figure>
<p>法三</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">####### example 1 #########</span></span><br><span class="line">ids = []</span><br><span class="line">tweets = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'/content/Twitter-Authorship/train_tweets.txt'</span>, encoding=<span class="string">'utf-8'</span>):</span><br><span class="line">    (id,tweet) = line.strip().split(<span class="string">'\t'</span>)</span><br><span class="line">    ids.append(id)</span><br><span class="line">    tweets.append(tweet)</span><br><span class="line">train = pd.DataFrame(&#123;<span class="string">"ID"</span>: ids, <span class="string">"tweet"</span>: tweets&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">####### example 2 #########</span></span><br><span class="line">stream = []</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">'dataset.txt'</span>):</span><br><span class="line">    row = [eval(i) <span class="keyword">for</span> i <span class="keyword">in</span> line.strip().split(<span class="string">' '</span>)]</span><br><span class="line">    stream.append(row)</span><br><span class="line">    </span><br><span class="line">arms = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    temp = stream[i][<span class="number">0</span>]</span><br><span class="line">    arms.append(temp)</span><br><span class="line">    </span><br><span class="line">rewards = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    temp = stream[i][<span class="number">1</span>]</span><br><span class="line">    rewards.append(temp)</span><br><span class="line">    </span><br><span class="line">contexts = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(stream)):</span><br><span class="line">    contexts.append(stream[i][<span class="number">2</span>:])</span><br></pre></td></tr></table></figure>
<h5 id="2-保存-1"><a href="#2-保存-1" class="headerlink" title="2. 保存"></a>2. 保存</h5><p>方法同csv</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">RF_test.to_csv(<span class="string">"RF_test.txt"</span>, sep = <span class="string">'\t'</span>, index = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="三、json文件"><a href="#三、json文件" class="headerlink" title="三、json文件"></a>三、json文件</h4><blockquote>
<p>参考 <a href="https://blog.csdn.net/weixin_38842821/article/details/108359551" target="_blank" rel="noopener">https://blog.csdn.net/weixin_38842821/article/details/108359551</a><br><a href="https://zhuanlan.zhihu.com/p/373661877" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/373661877</a><br><a href="https://vimsky.com/examples/usage/json-dump-in-python.html" target="_blank" rel="noopener">https://vimsky.com/examples/usage/json-dump-in-python.html</a></p>
</blockquote>
<h5 id="1-保存"><a href="#1-保存" class="headerlink" title="1. 保存"></a>1. 保存</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">dicts = &#123;<span class="string">'name'</span>:<span class="string">'Alice'</span>, <span class="string">'age'</span>:<span class="number">100</span>&#125;</span><br><span class="line">json.dump(dicts, open(<span class="string">"./myfile.json"</span>,<span class="string">'w'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或写为：</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./myfile.json"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	json.dump(dicts, f)</span><br></pre></td></tr></table></figure>
<h5 id="2-读取"><a href="#2-读取" class="headerlink" title="2.读取"></a>2.读取</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./myfile.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	dicts = json.load(f)</span><br></pre></td></tr></table></figure>
<h5 id="3-含中文时"><a href="#3-含中文时" class="headerlink" title="3. 含中文时"></a>3. 含中文时</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#如果是在python3环境，可使用：</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">dicts = &#123;<span class="string">'name'</span>:<span class="string">'张三'</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./my_file.json"</span>, <span class="string">'w'</span>, encoding=<span class="string">'gbk'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	json.dump(dicts, f, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line">	</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./my_file.json"</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	res = json.load(f, encoding=<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># &#123;'name':'张三'&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果是在python3环境保存，python2环境中读取：含中文时，先使用json.dumps()将python对象转换成json字符串，再使用pickle保存</span></span><br><span class="line"><span class="comment"># 例：</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"></span><br><span class="line">dicts = &#123;<span class="string">'province'</span>: [<span class="string">'广东省'</span>,<span class="string">'福建省'</span>]&#125;</span><br><span class="line">json_str = json.dumps(dicts, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># ↑具体参数解释见后文</span></span><br><span class="line">pickle.dump(json_str, open(<span class="string">"./myfile.pkl"</span>, <span class="string">"wb"</span>))</span><br><span class="line"><span class="comment"># ↑如果要在python3中保存，python2中读取，此处应加上参数protocol=2:</span></span><br><span class="line"><span class="comment"># pickle.dump(json_str, open("./myfile.pkl", "wb"), protocol=2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./myfile.pkl"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	dicts = pickle.load(f)</span><br><span class="line">print(dicts)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="comment"># &#123;"province": ["广东省","福建省"]&#125;</span></span><br></pre></td></tr></table></figure>
<p>关于 <strong>json.dump(), json.dumps(), json.load(), json.loads()：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>json.dump()</td>
<td>将python对象转化成json存储到文件中</td>
</tr>
<tr>
<td>json.dumps()</td>
<td>将python对象编码成json字符串</td>
</tr>
<tr>
<td>json.load()</td>
<td>将json文件转化成python对象提取出来</td>
</tr>
<tr>
<td>json.loads()</td>
<td>将json字符串解码成python对象</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2019/09/02/读取与保存csv和txt文件/image-20220105152837291.png" alt="image-20220105152837291"></p>
<p>用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, encoding=&quot;utf-8&quot;, default=None, sort_keys=False, **kw)</span><br><span class="line"></span><br><span class="line">obj:转化成json的对象。</span><br><span class="line">skipkeys: 如果key不是标准允许的类型，如int, float, string, None或bool, 则在转储时将产生错误，若将此参数设置为True, 可避免这种情况。</span><br><span class="line">indent:参数根据数据格式缩进显示，读起来更加清晰</span><br><span class="line">sort_keys=True:告诉编码器按照字典排序(a到z)输出。如果是字典类型的python对象，就把关键字按照字典排序。</span><br><span class="line">ensure_ascii=True：默认输出ascii码，如果把设置成False,则将非ASCII字符原样转储到输出文件中，即可以输出中文</span><br></pre></td></tr></table></figure>
<p><img src="/2019/09/02/读取与保存csv和txt文件/image-20220105154116425.png" alt="image-20220105154116425"></p>
<h4 id="四、pickle文件"><a href="#四、pickle文件" class="headerlink" title="四、pickle文件"></a>四、pickle文件</h4><blockquote>
<p>官方文档：<a href="https://docs.python.org/3/library/pickle.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pickle.html</a></p>
</blockquote>
<p>The <a href="https://docs.python.org/3/library/pickle.html#module-pickle" target="_blank" rel="noopener"><code>pickle</code></a> module implements binary protocols for serializing and de-serializing a Python object structure. <em>“Pickling”</em> is the process whereby a Python object hierarchy is converted into a byte stream, and <em>“unpickling”</em> is the inverse operation, whereby a byte stream (from a <a href="https://docs.python.org/3/glossary.html#term-binary-file" target="_blank" rel="noopener">binary file</a> or <a href="https://docs.python.org/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a>) is converted back into an object hierarchy. Pickling (and unpickling) is alternatively known as “serialization”, “marshalling,” [1](<a href="https://docs.python.org/3/library/pickle.html#id7" target="_blank" rel="noopener">https://docs.python.org/3/library/pickle.html#id7</a>) or “flattening”; however, to avoid confusion, the terms used here are “pickling” and “unpickling”.</p>
<p>pickle模块实现了用于序列化和反序列化Python对象结构的二进制协议。pickle是将Python对象层次结构转换为字节流的过程，而unpickle是反向操作，即将字节流(从二进制文件或字节类对象)转换回对象层次结构。</p>
<blockquote>
<p>Warning：</p>
<p> The <code>pickle</code> module <strong>is not secure</strong>. Only unpickle data you trust.</p>
<p>It is possible to construct malicious pickle data which will <strong>execute arbitrary code during unpickling</strong>. Never unpickle data that could have come from an untrusted source, or that could have been tampered with.</p>
<p>Consider signing data with <a href="https://docs.python.org/3/library/hmac.html#module-hmac" target="_blank" rel="noopener"><code>hmac</code></a> if you need to ensure that it has not been tampered with.</p>
<p>Safer serialization formats such as <a href="https://docs.python.org/3/library/json.html#module-json" target="_blank" rel="noopener"><code>json</code></a> may be more appropriate if you are processing untrusted data. See <a href="https://docs.python.org/3/library/pickle.html#comparison-with-json" target="_blank" rel="noopener">Comparison with json</a>.</p>
</blockquote>
<p><strong>pickle与json的区别：</strong></p>
<ul>
<li>JSON is a text serialization format (it outputs unicode text, although most of the time it is then encoded to <code>utf-8</code>), while pickle is a binary serialization format; JSON是一种文本序列化格式(它输出unicode文本，尽管大多数时候它会被编码成utf-8)，而pickle是一种二进制序列化格式</li>
<li>JSON is human-readable, while pickle is not; JSON是人类可读的，而pickle不是</li>
<li>JSON is interoperable and widely used outside of the Python ecosystem, while pickle is Python-specific; JSON是可互操作的，在Python生态系统之外被广泛使用，而pickle是特定于Python的</li>
<li>JSON, by default, can only represent a subset of the Python built-in types, and no custom classes; pickle can represent an extremely large number of Python types (many of them automatically, by clever usage of Python’s introspection facilities; complex cases can be tackled by implementing <a href="https://docs.python.org/3/library/pickle.html#pickle-inst" target="_blank" rel="noopener">specific object APIs</a>); 默认情况下，JSON只能表示Python内置类型的子集，而不能表示自定义类;pickle可以表示非常多的Python类型(其中许多是通过巧妙地使用Python的内省工具自动实现的;复杂的情况可以通过实现特定的对象api来解决)</li>
<li>Unlike pickle, deserializing untrusted JSON does not in itself create an arbitrary code execution vulnerability. 与pickle不同，反序列化不受信任的JSON本身并不会产生任意代码执行漏洞。</li>
</ul>
<p>目前有6种不同的协议可以用于pickling。使用的协议越高，读取生成的pickle所需的Python版本就得越新。</p>
<ul>
<li>Protocol version 0 is the original “human-readable” protocol and is backwards compatible with earlier versions of Python. 协议版本0是原始的人类可读的协议，并向后兼容较早版本的Python</li>
<li>Protocol version 1 is an old binary format which is also compatible with earlier versions of Python. 协议版本1是一种旧的二进制格式，它也与早期版本的Python兼容。</li>
<li>Protocol version 2 was introduced in Python 2.3. It provides much more efficient pickling of <a href="https://docs.python.org/3/glossary.html#term-new-style-class" target="_blank" rel="noopener">new-style class</a>es. Refer to <a href="https://www.python.org/dev/peps/pep-0307" target="_blank" rel="noopener"><strong>PEP 307</strong></a> for information about improvements brought by protocol 2. 协议版本2是在Python 2.3中引入的。它针对 new-style classes 提供了更有效的pickling。</li>
<li>Protocol version 3 was added in Python 3.0. It has explicit support for <a href="https://docs.python.org/3/library/stdtypes.html#bytes" target="_blank" rel="noopener"><code>bytes</code></a> objects and cannot be unpickled by Python 2.x. This was the default protocol in Python 3.0–3.7. 协议版本3是在Python 3.0中添加的。它对bytes对象有显式的支持，并且不能被Python 2.x unpickle。这是Python 3.0-3.7中的默认协议。</li>
<li>Protocol version 4 was added in Python 3.4. It adds support for very large objects, pickling more kinds of objects, and some data format optimizations. It is the default protocol starting with Python 3.8. Refer to <a href="https://www.python.org/dev/peps/pep-3154" target="_blank" rel="noopener"><strong>PEP 3154</strong></a> for information about improvements brought by protocol 4. 协议版本4是在Python 3.4中添加的。它增加了对非常大的对象的支持，pickle更多类型的对象，以及一些数据格式优化。这是从Python 3.8开始的默认协议。</li>
<li>Protocol version 5 was added in Python 3.8. It adds support for out-of-band data and speedup for in-band data. Refer to <a href="https://www.python.org/dev/peps/pep-0574" target="_blank" rel="noopener"><strong>PEP 574</strong></a> for information about improvements brought by protocol 5. 协议版本5是在Python 3.8中添加的。它增加了对带外数据的支持和对带内数据的加速。</li>
</ul>
<p>关于 pickle.dump(), pickle.dumps(), pickle.load(), pickle.loads()：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>pickle.dump(<em>obj</em>, <em>file</em>, <em>protocol=None</em>, <em>*</em>)</td>
<td>将对象obj的pickle表示写入打开的文件对象file</td>
</tr>
<tr>
<td>pickle.dumps(<em>obj</em>, <em>protocol=None</em>, <em>*</em>)</td>
<td>将对象obj的pickle表示作为一个bytes object返回，而不是将其写入文件。</td>
</tr>
<tr>
<td>pickle.load(<em>file</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=’ASCII’<em>, </em>errors=’strict’<em>, </em>buffers=None*)</td>
<td>从打开的文件对象file中读取对象的pickle表示，并返回其中指定的 reconstituted object hierarchy。</td>
</tr>
<tr>
<td>pickle.loads(<em>data</em>, <em>/</em>, <em>**, </em>fix_imports=True<em>, </em>encoding=”ASCII”<em>, </em>errors=”strict”<em>, </em>buffers=None*)</td>
<td>Return the reconstituted object hierarchy of the pickled representation <em>data</em> of an object. <em>data</em> must be a <a href="https://docs.python.org/3/glossary.html#term-bytes-like-object" target="_blank" rel="noopener">bytes-like object</a>.</td>
</tr>
</tbody>
</table>
</div>
<h5 id="1-保存-1"><a href="#1-保存-1" class="headerlink" title="1. 保存"></a>1. 保存</h5><p>例：保存xgb模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle </span><br><span class="line">pickle.dump(xgb, open(<span class="string">"./xgb.pkl"</span>, <span class="string">"wb"</span>))</span><br><span class="line"><span class="comment"># ↑如果要在python3中保存，python2中读取，此处应加上参数protocol=2:</span></span><br><span class="line"><span class="comment"># pickle.dump(xgb, open("./xgb.pkl", "wb"), protocol=2)</span></span><br></pre></td></tr></table></figure>
<h5 id="2-读取-1"><a href="#2-读取-1" class="headerlink" title="2. 读取"></a>2. 读取</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle </span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"./xgb.pkl"</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">	model = pickle.load(f)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法</title>
    <url>/2019/06/27/Markdown%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>(本文参考<a href="https://www.markdowntutorial.com/" target="_blank" rel="noopener">Markdown Tutorial</a>)</p>
<h4 id="1-加粗与斜体"><a href="#1-加粗与斜体" class="headerlink" title="1. 加粗与斜体"></a>1. 加粗与斜体</h4><ul>
<li>斜体：在文本两侧加上一个星号或一个下划线，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">_unknown_或*unkown*</span><br></pre></td></tr></table></figure>
<p>效果如下：_unknown_</p>
<ul>
<li>加粗：在文本两侧加上两个星号或两个下划线, 例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__unknown__或**unknown**</span><br></pre></td></tr></table></figure>
<p>效果如下：<strong>unknown</strong></p>
<ul>
<li>注：斜体和加粗可以一起用，例如：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">**_of course_**</span><br></pre></td></tr></table></figure>
<p>效果如下：<strong>_of course_</strong></p>
<h4 id="2-标题-Headers"><a href="#2-标题-Headers" class="headerlink" title="2.标题(Headers)"></a>2.标题(Headers)</h4><p>在前面加#号, 一共有六级标题。一级标题为在前面加一个#号（# 一级标题），二级标题为在前面加两个#号（## 二级标题）。效果如下：</p>
<blockquote>
<h1 id="Header-one"><a href="#Header-one" class="headerlink" title="Header one"></a>Header one</h1><h2 id="Header-two"><a href="#Header-two" class="headerlink" title="Header two"></a>Header two</h2><h3 id="Header-three"><a href="#Header-three" class="headerlink" title="Header three"></a>Header three</h3><h4 id="Header-four"><a href="#Header-four" class="headerlink" title="Header four"></a>Header four</h4><h5 id="Header-five"><a href="#Header-five" class="headerlink" title="Header five"></a>Header five</h5><h6 id="Header-six"><a href="#Header-six" class="headerlink" title="Header six"></a>Header six</h6><p>plain text</p>
</blockquote>
<p>注：#号与文本之间有一个空格。</p>
<h4 id="3-链接"><a href="#3-链接" class="headerlink" title="3.链接"></a>3.链接</h4><ul>
<li><p>inline link</p>
<p>语法如下：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Visit GitHub!](www.github.com)</span><br></pre></td></tr></table></figure>
<p><a href="www.github.com">Visit GitHub!</a></p>
<p>再比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[Yo<span class="string">u're **really, really** going to see this.](www.dailykitten.com)</span></span><br></pre></td></tr></table></figure>
<p><a href="www.dailykitten.com">You’re <strong>really, really</strong> going to see this.</a></p>
<ul>
<li>reference link</li>
</ul>
<p>语法如下：  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do you want to [see something fun][a fun place]?  </span><br><span class="line"></span><br><span class="line">Well, I have [a website <span class="keyword">for</span> you][another fun place]!</span><br><span class="line"></span><br><span class="line">[a fun place]: www.zombo.com</span><br><span class="line">    </span><br><span class="line">[another fun place]: www.stumbleupon.com</span><br></pre></td></tr></table></figure>
<p>效果如下：<br>Do you want to <a href="www.zombo.com">see something fun</a>?  </p>
<p>Well, I have <a href="www.stumbleupon.com">a website for you</a>!</p>
<p>一般可将链接地址写在Markdown文件的最后。使用refrence的好处是如果有许多链接都是指向一个地方，那么需要更改的时候只需要修改一次就行了。</p>
<h4 id="4-图片"><a href="#4-图片" class="headerlink" title="4.图片"></a>4.图片</h4><ul>
<li>inline link</li>
</ul>
<p>插入图片和插入链接类似，语法如下： </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">![A pretty tiger](https://upload.wikimedia.org/wikipedia/commons/<span class="number">5</span>/<span class="number">56</span>/Tiger<span class="number">.50</span>.jpg)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/5/56/Tiger.50.jpg" alt="A pretty tiger"></p>
<p>注：</p>
<ol>
<li>[ ]中的内容可以空着，当网络不好，图片无法显示时（或某些其它原因）会显示[ ]中的文字</li>
<li>!和[ ]之间不要加空格</li>
</ol>
<ul>
<li>reference link</li>
</ul>
<p>语法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">![Black cat][Black]</span><br><span class="line"></span><br><span class="line">![Orange cat][Orange]</span><br><span class="line"></span><br><span class="line">[Black]: https://upload.wikimedia.org/wikipedia/commons/a/a3/<span class="number">81</span>_INF_DIV_SSI.jpg  </span><br><span class="line">        </span><br><span class="line">[Orange]:http://icons.iconarchive.com/icons/google/noto-emoji-animals-nature/<span class="number">256</span>/<span class="number">22221</span>-cat-icon.png</span><br></pre></td></tr></table></figure>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/a/a3/81_INF_DIV_SSI.jpg" alt="Black cat"></p>
<p><img src="http://icons.iconarchive.com/icons/google/noto-emoji-animals-nature/256/22221-cat-icon.png" alt="Orange cat"></p>
<h4 id="5-Blockquotes"><a href="#5-Blockquotes" class="headerlink" title="5.Blockquotes"></a>5.Blockquotes</h4><p>当想引用一段话并让读者注意到时，可以采用如下方法：在文本前加上”&gt;”</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; <span class="string">"In a few moments he was barefoot, his stockings folded in his pockets and his</span></span><br><span class="line"><span class="string">  canvas shoes dangling by their knotted laces over his shoulders and, picking a</span></span><br><span class="line"><span class="string">  pointed salt-eaten stick out of the jetsam among the rocks, he clambered down</span></span><br><span class="line"><span class="string">  the slope of the breakwater."</span></span><br></pre></td></tr></table></figure>
<p> 效果如下：</p>
<blockquote>
<p>“In a few moments he was barefoot, his stockings folded in his pockets and his<br>  canvas shoes dangling by their knotted laces over his shoulders and, picking a<br>  pointed salt-eaten stick out of the jetsam among the rocks, he clambered down<br>  the slope of the breakwater.”</p>
</blockquote>
<p>当引用多段话时，可以在每一部分前加上”&gt;”，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt; His words seemed to have struck some deep chord <span class="keyword">in</span> his own nature. Had he spoken</span><br><span class="line">of himself, of himself as he was or wished to be? Stephen watched his face for some</span><br><span class="line">moments <span class="keyword">in</span> silence. A cold sadness was there. He had spoken of himself, of his own</span><br><span class="line">loneliness which he feared.  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; —Of whom are you speaking? Stephen asked at length.  </span><br><span class="line">&gt;  </span><br><span class="line">&gt; Cranly did <span class="keyword">not</span> answer.</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<blockquote>
<p>His words seemed to have struck some deep chord in his own nature. Had he spoken<br>of himself, of himself as he was or wished to be? Stephen watched his face for some<br>moments in silence. A cold sadness was there. He had spoken of himself, of his own<br>loneliness which he feared.</p>
<p>—Of whom are you speaking? Stephen asked at length.</p>
<p>Cranly did not answer.</p>
</blockquote>
<p>Note: even blank lines must contain the caret character. This ensures that the entire blockquote is grouped together.</p>
<h4 id="6-列表-Lists"><a href="#6-列表-Lists" class="headerlink" title="6.列表(Lists)"></a>6.列表(Lists)</h4><h5 id="unordered-list"><a href="#unordered-list" class="headerlink" title="* unordered list"></a>* unordered list</h5><p>在前面加星号：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* Milk  </span><br><span class="line">* Eggs  </span><br><span class="line">* Salmon  </span><br><span class="line">* Butter</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>Milk</li>
<li>Eggs</li>
<li>Salmon</li>
<li>Butter</li>
</ul>
<h5 id="odered-list"><a href="#odered-list" class="headerlink" title="* odered list"></a>* odered list</h5><p>在前面加数字</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> Crack three eggs over a bowl</span><br><span class="line"><span class="number">2.</span> Pour a gallon of milk into the bowl</span><br><span class="line"><span class="number">3.</span> Rub the salmon vigorously <span class="keyword">with</span> butter</span><br><span class="line"><span class="number">4.</span> Drop the salmon into the egg-milk bowl</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>Crack three eggs over a bowl</li>
<li>Pour a gallon of milk into the bowl</li>
<li>Rub the salmon vigorously with butter</li>
<li>Drop the salmon into the egg-milk bowl</li>
</ol>
<h5 id="nest-one-list-within-another"><a href="#nest-one-list-within-another" class="headerlink" title="* nest one list within another"></a>* nest one list within another</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">* Tintin</span><br><span class="line"> * A reporter</span><br><span class="line"> * Has poofy orange hair</span><br><span class="line"> * Friends <span class="keyword">with</span> the world<span class="string">'s most awesome dog</span></span><br><span class="line"><span class="string">* Haddock</span></span><br><span class="line"><span class="string"> * A sea captain</span></span><br><span class="line"><span class="string"> * Has a fantastic beard</span></span><br><span class="line"><span class="string"> * Loves whiskey</span></span><br><span class="line"><span class="string">   * Possibly also scotch?</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Tintin<ul>
<li>A reporter</li>
<li>Has poofy orange hair</li>
<li>Friends with the world’s most awesome dog</li>
</ul>
</li>
<li>Haddock<ul>
<li>A sea captain</li>
<li>Has a fantastic beard</li>
<li>Loves whiskey<ul>
<li>Possibly also scotch?</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>建议最多建三层，否则文章结构会变得太混乱</p>
<h4 id="7-段落"><a href="#7-段落" class="headerlink" title="7.段落"></a>7.段落</h4><ul>
<li>hard break</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do I contradict myself?</span><br><span class="line"></span><br><span class="line">Very well then I contradict myself,</span><br><span class="line"></span><br><span class="line">(I am large, I contain multitudes.)</span><br></pre></td></tr></table></figure>
<p>想换行时，空一行。效果如下：</p>
<p>Do I contradict myself?</p>
<p>Very well then I contradict myself,</p>
<p>(I am large, I contain multitudes.)</p>
<ul>
<li>soft break</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Do I contradict myself?··</span><br><span class="line">Very well then I contradict myself,··</span><br><span class="line">(I am large, I contain multitudes.)</span><br></pre></td></tr></table></figure>
<p>想换行时，打两个空格。上面每个点 ( · ) 代表一个空格。效果如下：</p>
<p>Do I contradict myself?<br>Very well then I contradict myself,<br>(I am large, I contain multitudes.)</p>
<h4 id="8-LaTeX-数学表达式"><a href="#8-LaTeX-数学表达式" class="headerlink" title="8. LaTeX 数学表达式"></a>8. LaTeX 数学表达式</h4><p>在Markdown文档中，可以使用<a href="https://www.latex-project.org/" target="_blank" rel="noopener">LaTex</a>符号创建数学表达式。例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">y = \frac&#123;a&#125;&#123;b+c&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
y = \frac{a}{b+c}</script><p>(hexo中公式显示问题：在文章的Front-matter中加上：mathjax: true)</p>
<h5 id="8-1-LaTeX-中-argmin-argmax-下标使用方法"><a href="#8-1-LaTeX-中-argmin-argmax-下标使用方法" class="headerlink" title="8.1 LaTeX 中  argmin, argmax 下标使用方法"></a>8.1 LaTeX 中  argmin, argmax 下标使用方法</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathop&#123;\arg \min&#125;_x f(x)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\mathop{\arg\min}_x f(x)</script><p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathop&#123;\arg \min_x&#125; f(x)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\mathop{\arg \min_x} f(x)</script><h4 id="9-Typora中，字体颜色"><a href="#9-Typora中，字体颜色" class="headerlink" title="9. Typora中，字体颜色"></a>9. Typora中，字体颜色</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;span style=&apos;color:red&apos;&gt;This is red&lt;/span&gt;</span><br><span class="line">&lt;span style=&quot;background:yellow&quot;&gt;高亮黄色&lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p><span style="color:red">This is red</span></p>
<p><span style="background:yellow">高亮黄色</span></p>
<h4 id="10-表格宽度调整"><a href="#10-表格宽度调整" class="headerlink" title="10.表格宽度调整"></a>10.表格宽度调整</h4><blockquote>
<p>参考 <a href="https://blog.csdn.net/maxsky/article/details/54666998" target="_blank" rel="noopener">https://blog.csdn.net/maxsky/article/details/54666998</a></p>
</blockquote>
<p>在原表格前添加 CSS 代码，类似如下（在Typora中启用源代码模式）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">table th:first-of-type &#123;</span><br><span class="line">    width: 220px;</span><br><span class="line">&#125;</span><br><span class="line">table th:nth-of-type(2) &#123;</span><br><span class="line">	width: 70px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 下方是表格的 Markdown 语法 --&gt;</span><br><span class="line">名称|值|备注</span><br><span class="line">---|---|---</span><br></pre></td></tr></table></figure>
<p>这里需要一点 CSS 知识，选择器的问题，首先 <code>&lt;th&gt;</code> 存在于 <code>&lt;table&gt;</code> 中；其次 <code>th:first-of-type</code> 的意思是每个 <code>&lt;th&gt;</code> 为其父级的第一个元素，这里指的就是围绕着【名称】的 <code>&lt;th&gt;</code>。同理第二、三个使用 <code>th:nth-of-type(2)</code>、<code>th:nth-of-type(3)</code> 就可以了，以此类推。上述的 <code>th:first-of-type</code> 等价于 <code>th:nth-of-type(1)</code>。</p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter Notebook中的快捷键</title>
    <url>/2019/06/27/Jupyter-Notebook%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>shift+enter: 运行代码块</p>
</li>
<li><p>shift+tab: show the documentation pop up for the method</p>
</li>
<li><p>Esc+m: markdown语句</p>
</li>
<li><p>jupyter notebook中reload模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> importlib</span><br><span class="line">importlib.reload(feature_transform)</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Jupyter Notebook</category>
      </categories>
      <tags>
        <tag>Jupyter Notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Advanced Python Types</title>
    <url>/2019/06/27/Advanced-Python-Types/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-List"><a href="#1-List" class="headerlink" title="1. List"></a>1. List</h3><h4 id="1-1-常见操作"><a href="#1-1-常见操作" class="headerlink" title="1.1 常见操作"></a>1.1 常见操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;print(x)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line">&gt;&gt;&gt;x[:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">&gt;&gt;&gt;x[<span class="number">3</span>:]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">&gt;&gt;&gt;x[<span class="number">-2</span>:]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># extend</span></span><br><span class="line">&gt;&gt;&gt;x.extend([<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">&gt;&gt;&gt;x</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># append</span></span><br><span class="line">&gt;&gt;x.append(<span class="number">9</span>)</span><br><span class="line">&gt;&gt;&gt;x</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;y=[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]</span><br><span class="line">&gt;&gt;&gt;listOfLists=[x,y]</span><br><span class="line">&gt;&gt;&gt;listiOfLists</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>],[<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]]</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="1-2-append-与-extend-方法的区别"><a href="#1-2-append-与-extend-方法的区别" class="headerlink" title="1.2 append() 与 extend() 方法的区别"></a>1.2 append() 与 extend() 方法的区别</h4><p>1.append() 方法用于在列表末尾添加新的对象。语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list1.append(obj) # 向列表中添加一个对象object</span><br></pre></td></tr></table></figure>
<p>该方法无返回值，直接修改原列表。</p>
<p><strong>使用<code>append()</code> 的时候，是将obj看作一个对象，整体打包添加到list1对象中。</strong></p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list1.append([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">print(list1)</span><br><span class="line"><span class="comment"># [1, 2, 3, [4, 5]]</span></span><br></pre></td></tr></table></figure>
<p>2.extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）。语法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1.extend(seq) <span class="comment"># 把一个序列seq的内容添加到列表中</span></span><br></pre></td></tr></table></figure>
<p>该方法没有返回值，直接修改原列表。</p>
<p><strong><code>extend()</code>方法接受一个序列作为参数，并将该序列的每个元素都添加到原有的列表中。</strong></p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">list1.extend([<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">print(list1)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = (<span class="number">5</span>, <span class="number">15</span>, <span class="number">25</span>, <span class="number">50</span>)</span><br><span class="line">s1 = <span class="string">"Apple"</span> </span><br><span class="line"></span><br><span class="line">l1 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">l1.extend(t1)</span><br><span class="line">print(l1)</span><br><span class="line"><span class="comment"># [[1, 2, 3, 4], 5, 15, 25, 50]</span></span><br><span class="line"></span><br><span class="line">l1 = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line">l1.extend((s1,t1))</span><br><span class="line">print(l1)</span><br><span class="line"><span class="comment"># [[1, 2, 3, 4], 'Apple', (5, 15, 25, 50)]</span></span><br></pre></td></tr></table></figure>
<h4 id="1-3-给List添加元素"><a href="#1-3-给List添加元素" class="headerlink" title="1.3 给List添加元素"></a>1.3 给List添加元素</h4><p>1.往后添加元素append</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr.append(<span class="number">3</span>)</span><br><span class="line">print(arr)</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>2.往前添加元素，或在指定位置添加元素 insert</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = []</span><br><span class="line">num = <span class="number">345</span></span><br><span class="line"><span class="keyword">while</span> num:</span><br><span class="line">    arr.insert(<span class="number">0</span>,num%<span class="number">10</span>)</span><br><span class="line">    num = num//<span class="number">10</span></span><br><span class="line">	</span><br><span class="line">print(arr)</span><br><span class="line"><span class="comment"># [3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="1-4-List的拼接"><a href="#1-4-List的拼接" class="headerlink" title="1.4 List的拼接"></a>1.4 List的拼接</h4><p>方法一：使用 “+”</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr3 = arr1 + arr2</span><br><span class="line">print(arr3)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>方法二：使用extend()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">arr2 = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">arr1.extend(arr2)</span><br><span class="line">print(arr1)</span><br><span class="line"><span class="comment"># [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="1-5-排序"><a href="#1-5-排序" class="headerlink" title="1.5 排序"></a>1.5 排序</h4><p>法一：sort()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">x.sort()</span><br><span class="line">x</span><br><span class="line"><span class="comment"># [1,2,3]</span></span><br><span class="line"></span><br><span class="line">x.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># [3,2,1]</span></span><br></pre></td></tr></table></figure>
<p>sort()会改变原列表</p>
<p>法二：sorted()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">y = sorted(x)</span><br><span class="line"></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line"><span class="comment"># [3, 4, 1]</span></span><br><span class="line"><span class="comment"># [1, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>sorted()不会改变原列表</p>
<p>更多关于sort的内容见 <a href="https://qypx.github.io/2020/10/30/Python中的reverse-reversed-sort-sorted/">Python中的reverse, reversed, sort, sorted</a></p>
<h4 id="1-6-列表-count-方法"><a href="#1-6-列表-count-方法" class="headerlink" title="1.6 列表 count() 方法"></a>1.6 列表 count() 方法</h4><p>count() 方法返回具有指定值的元素数量。语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list.count(value)</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">points = [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">x = points.count(<span class="number">9</span>)</span><br><span class="line">print(x)</span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-all-方法"><a href="#1-7-all-方法" class="headerlink" title="1.7 all() 方法"></a>1.7 all() 方法</h4><p>all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。元素除了是 0、空、None、False 外都算 True。语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">all(iterable)</span><br></pre></td></tr></table></figure>
<p>iterable — 元组或列表。</p>
<p>例：<br>Define a list with elements 11, 25, 43, 68, 76 and 94. Write code that confirms the list of numbers are over 10.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">11</span>, <span class="number">25</span>, <span class="number">43</span>, <span class="number">68</span>, <span class="number">76</span> , <span class="number">94</span>]</span><br><span class="line"><span class="keyword">if</span> all([x&gt;<span class="number">10</span> <span class="keyword">for</span> x <span class="keyword">in</span> numbers]):</span><br><span class="line">    print(<span class="string">"All numbers are over 10"</span>)</span><br><span class="line"><span class="comment"># All numbers are over 10</span></span><br></pre></td></tr></table></figure>
<h4 id="1-8-创建一个0-99的数列"><a href="#1-8-创建一个0-99的数列" class="headerlink" title="1.8 创建一个0-99的数列"></a>1.8 创建一个0-99的数列</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = list(range(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ..., <span class="number">99</span>]</span><br></pre></td></tr></table></figure>
<h4 id="1-9-列表生成式"><a href="#1-9-列表生成式" class="headerlink" title="1.9 列表生成式"></a>1.9 列表生成式</h4><blockquote>
<p>参考 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017317609699776" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017317609699776</a></p>
</blockquote>
<p>关于列表生成式中的 <code>if ... else</code> 的用法：</p>
<p>例：输出偶数<br><span style="color:red">只需要 if 时的正确写法：</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>) <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>但是，不能在最后的 <code>if</code> 加上 <code>else</code>：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1605269674893.png" alt="1605269674893"></p>
<p>这是因为跟在 <code>for</code> 后面的 <code>if</code> 是一个筛选条件，不能带 <code>else</code>，否则如何筛选？</p>
<p>另外，如果把 <code>if</code> 写在 <code>for</code> 前面，必须加 <code>else</code>，否则报错：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1605269903917.png" alt="1605269903917"></p>
<p>这是因为 <code>for</code> 前面的部分是一个表达式，它必须根据 <code>x</code> 计算出一个结果。因此，考察表达式： <code>x if x%2 == 0</code>，它无法根据 <code>x</code> 计算出结果，因为缺少 <code>x</code>，必须加上 <code>else</code>：<br><span style="color:red">需要 if … else 时的正确写法：</span></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[x <span class="keyword">if</span> x%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> -x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">11</span>)]</span><br><span class="line">[<span class="number">-1</span>, <span class="number">2</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">6</span>, <span class="number">-7</span>, <span class="number">8</span>, <span class="number">-9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure>
<p>上述 <code>for</code> 前面的表达式 <code>x if x%2 == 0 else -x</code> 才能根据 <code>x</code> 计算出确定的结果。</p>
<blockquote>
<p><strong>总结：在列表生成式中，<code>for</code> 前面的 <code>if ... else</code> 是表达式，而 <code>for</code> 后面的 <code>if</code> 是过滤条件，不能带 <code>else</code>.</strong></p>
</blockquote>
<h3 id="2-Tuple"><a href="#2-Tuple" class="headerlink" title="2. Tuple"></a>2. Tuple</h3><p>Tuples are a lot like lists, but the main difference is that they are <strong>immutable</strong>. Once you create a tuple, you can’t change them.</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054069373.jpg" alt="1578054069373"></p>
<p>向tuple添加元素：<br>注：由于元组是不可变的，您不能直接向元素例添加元素，但可以将元组连接在一起</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">primes = (<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>)</span><br><span class="line">primes = primes + (<span class="number">29</span>, <span class="number">31</span>)</span><br><span class="line">primes</span><br><span class="line"><span class="comment"># (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31)</span></span><br></pre></td></tr></table></figure>
<p>元组可以使用切片：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">primes[<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">primes[<span class="number">-3</span>]</span><br><span class="line"><span class="comment"># 23</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Dictionary"><a href="#3-Dictionary" class="headerlink" title="3. Dictionary"></a>3. Dictionary</h3><p><span style="color:red">注：3.6版本后Python的dict就是有序的了，顺序就是插入的顺序。</span></p>
<p>In other languages, you might know this as a map, or a hash table. It’s basically a lookup table, where you store values associated with some unique set of key values.</p>
<p>参考 <a href="https://www.runoob.com/python/python-dictionary.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-dictionary.html</a></p>
<p>字典是一种可变容器模型，且可存储任意类型对象。</p>
<p>字典的每个键值 <strong>key=&gt;value</strong> 对用冒号 <strong>:</strong> 分割，每个键值对之间用逗号 <strong>,</strong> 分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;key1 : value1, key2 : value2 &#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的字典实例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">'foo'</span>:<span class="number">1</span>, <span class="string">'bar'</span>:<span class="number">2.3</span>, <span class="string">'s'</span>:<span class="string">'my first dictionary'</span>&#125;</span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># &#123;'s': 'my first dictionary', 'bar': 2.3, 'foo': 1&#125;</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="string">'foo'</span>])</span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>
<p>键一般是唯一的，如果重复，最后的一个键值对会替换前面的，值不需要唯一。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'b'</span>: <span class="string">'3'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">'b'</span>]</span><br><span class="line"><span class="string">'3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="string">'3'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>值可以取任何数据类型（字典值可以没有限制地取任何python对象，既可以是标准的对象，也可以是用户定义的），但键必须是不可变的，如字符串，数字或元组（列表不行）。如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;[<span class="string">'Name'</span>]: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125; </span><br><span class="line"><span class="keyword">print</span> (<span class="string">"dict1['Name']: "</span>, dict1[<span class="string">'Name'</span>])</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">以上实例输出结果：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;test.py&quot;, line 3, in &lt;module&gt;</span><br><span class="line">    dict1 = &#123;[&apos;Name&apos;]: &apos;Zara&apos;, &apos;Age&apos;: 7&#125; </span><br><span class="line">TypeError: list objects are unhashable</span><br></pre></td></tr></table></figure>
<h4 id="3-1-访问字典里的值"><a href="#3-1-访问字典里的值" class="headerlink" title="3.1 访问字典里的值"></a>3.1 访问字典里的值</h4><p>把相应的键放入方括弧</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054637299.jpg" alt="1578054637299"></p>
<p>If you try to retrieve a value for a key that doesn’t exist, you will get an exception. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">captains[<span class="string">'NX-01'</span>]</span><br><span class="line">输出：</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"test.py"</span>, line <span class="number">5</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    captains[<span class="string">'NX-01'</span>]</span><br><span class="line">KeyError: <span class="string">'NX-01'</span></span><br></pre></td></tr></table></figure>
<p>One way to avoid that is to use the <code>get</code> function on the dictionary. <code>get</code>是Python字典内置方法。<a href="https://www.runoob.com/python/att-dictionary-get.html" target="_blank" rel="noopener">dict.get(key, default=None)</a><br>返回指定键的值，如果值不在字典中返回default值</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054512678.jpg" alt="1578054512678"></p>
<p><code>get</code>还可指定不存在时的默认返回值，如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(captains.get(<span class="string">"NX-01"</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<h4 id="3-2-修改字典"><a href="#3-2-修改字典" class="headerlink" title="3.2 修改字典"></a>3.2 修改字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1 = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">'Age'</span>] = <span class="number">8</span> <span class="comment"># 更新</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict1[<span class="string">'School'</span>] = <span class="string">"RUNOOB"</span> <span class="comment"># 添加</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dict1)</span><br><span class="line">&#123;<span class="string">'School'</span>: <span class="string">'RUNOOB'</span>, <span class="string">'Age'</span>: <span class="number">8</span>, <span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-删除字段元素"><a href="#3-3-删除字段元素" class="headerlink" title="3.3 删除字段元素"></a>3.3 删除字段元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'Name'</span>: <span class="string">'Zara'</span>, <span class="string">'Age'</span>: <span class="number">7</span>, <span class="string">'Class'</span>: <span class="string">'First'</span>&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">del</span> dict1[<span class="string">'Name'</span>]  <span class="comment"># 删除键是'Name'的条目</span></span><br><span class="line"><span class="comment"># 此时dict为：&#123;'Age':7, 'Class':'First'&#125;</span></span><br><span class="line"></span><br><span class="line">dict1.pop(<span class="string">'Age'</span>)</span><br><span class="line"><span class="comment"># 此时会输出7，dict现为&#123;'Class':'First'&#125;</span></span><br><span class="line"><span class="comment"># pop(key[,default])</span></span><br><span class="line"><span class="comment"># 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dict1.clear()      <span class="comment"># 清空字典所有条目</span></span><br><span class="line"><span class="comment"># 此时dict为空：&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> dict1          <span class="comment"># 删除字典</span></span><br><span class="line"><span class="comment"># 此时dict变量不存在</span></span><br></pre></td></tr></table></figure>
<h4 id="3-4-遍历字典：-keys-、values-、items"><a href="#3-4-遍历字典：-keys-、values-、items" class="headerlink" title="3.4 遍历字典： keys()  、values() 、items()"></a>3.4 遍历字典： keys()  、values() 、items()</h4><p>Iterate:</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1578054588653.jpg" alt="1578054588653"></p>
<p><a href="https://www.cnblogs.com/FlyingLiao/p/11192330.html" target="_blank" rel="noopener">https://www.cnblogs.com/FlyingLiao/p/11192330.html</a></p>
<ul>
<li>xxx.keys() : 返回字典的所有的key.  返回一个序列，序列中保存有字典的所有的键</li>
</ul>
<p>例：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1584001011558.png" alt="1584001011558"></p>
<ul>
<li>xxx.values() :  返回字典所有的值.</li>
</ul>
<p>例：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1584001175719.png" alt="1584001175719"></p>
<ul>
<li>xxx.items() :  返回字典中所有的key和values.  返回一个序列，序列中包含所有双值子序列</li>
</ul>
<p>例：</p>
<p><img src="/2019/06/27/Advanced-Python-Types/1584001276582.png" alt="1584001276582"></p>
<h4 id="3-5-Python中的defaultdict"><a href="#3-5-Python中的defaultdict" class="headerlink" title="3.5 Python中的defaultdict"></a>3.5 Python中的<code>defaultdict</code></h4><p>dict subclass that calls a factory function to supply missing values.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">dict1 = collections.defaultdict(int)</span><br></pre></td></tr></table></figure>
<p><em>defaultdict(int)</em> 创建一个类似 <em>dictionary</em> 对象，里面任何的 <em>values</em> 都是 <em>int</em> 的实例，而且就算是一个不存在的 <em>key</em>, <em>d[key]</em> 也有一个默认值，这个默认值是 <em>int()</em> 的默认值0.</p>
<h4 id="3-6-按照字典的键或者值排序"><a href="#3-6-按照字典的键或者值排序" class="headerlink" title="3.6 按照字典的键或者值排序"></a>3.6 按照字典的键或者值排序</h4><p><a href="https://blog.csdn.net/leokingszx/article/details/81154681" target="_blank" rel="noopener">https://blog.csdn.net/leokingszx/article/details/81154681</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">y = &#123;<span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">1</span>&#125;</span><br><span class="line">by_key =  sorted(y.items(),key = <span class="keyword">lambda</span> item:item[<span class="number">0</span>])</span><br><span class="line">by_value = sorted(y.items(),key = <span class="keyword">lambda</span> item:item[<span class="number">1</span>])</span><br><span class="line">print(by_key)   <span class="comment">#结果为[(1, 3), (2, 2), (3, 1)]，即按照键名排列</span></span><br><span class="line">print(by_value) <span class="comment">#结果为[(3, 1), (2, 2), (1, 3)]，即按照键值排列</span></span><br></pre></td></tr></table></figure>
<p>当然，在这样处理后，得到的结果将变成元组。这样也可以理解，毕竟对于字典而言，本身是不提供排序的需求的。如果想按照里面的元素进行排列，那么将不得不对其类型进行转化。</p>
<p>另：Python中多条件排序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line">y = &#123;<span class="string">"ab"</span>:<span class="number">1</span>, <span class="string">"b"</span>:<span class="number">2</span>, <span class="string">"a"</span>:<span class="number">1</span>&#125;</span><br><span class="line">by_key =  sorted(y.items(),key = <span class="keyword">lambda</span> item:(len(item[<span class="number">0</span>]),item[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">print(by_key) </span><br><span class="line"><span class="comment"># [('a', 1), ('b', 2), ('ab', 1)]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> by_key:</span><br><span class="line">    print(value[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># a</span></span><br><span class="line"><span class="comment"># b</span></span><br><span class="line"><span class="comment"># ab</span></span><br></pre></td></tr></table></figure>
<h4 id="3-7-其他一些字典内置函数-amp-方法"><a href="#3-7-其他一些字典内置函数-amp-方法" class="headerlink" title="3.7 其他一些字典内置函数&amp;方法"></a>3.7 其他一些字典内置函数&amp;方法</h4><p><a href="https://www.runoob.com/python/att-dictionary-len.html" target="_blank" rel="noopener"><br>len(my_dict)</a><br>计算字典元素个数，即键的总数。</p>
<p><a href="https://www.runoob.com/python/att-dictionary-copy.html" target="_blank" rel="noopener">my_dict.copy()</a><br>返回一个字典的浅拷贝</p>
<p><a href="https://www.runoob.com/python/python-att-dictionary-pop.html" target="_blank" rel="noopener">pop(key[,default])</a><br>删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</p>
<p><a href="https://www.runoob.com/python/python-att-dictionary-popitem.html" target="_blank" rel="noopener">popitem()</a><br>返回并删除字典中的最后一对键和值。</p>
<h4 id="3-8-两个列表合并成一个字典"><a href="#3-8-两个列表合并成一个字典" class="headerlink" title="3.8 两个列表合并成一个字典"></a>3.8 两个列表合并成一个字典</h4><p>两个列表合并成一个字典，一个列表里的值为 <em>key</em>，一个列表里的为 <em>Value</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">b = [<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">c = dict(zip(a,b))</span><br><span class="line">c</span><br><span class="line"><span class="comment"># &#123;1: 6, 2: 7, 3: 8, 4: 9&#125;</span></span><br></pre></td></tr></table></figure>
<p>补充1：关于zip()函数：</p>
<p><a href="https://www.runoob.com/python/python-func-zip.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-zip.html</a></p>
<p><strong>zip()</strong> 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表(python2中返回的是列表，python3中返回的是对象）。</p>
<p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip([iterable, ...])</span><br></pre></td></tr></table></figure>
<p><em>zip 方法在 Python 2 和 Python 3 中的不同：在 Python 2.x zip() 返回的是一个元组列表， Python 3.x 中为了减少内存，zip() 返回的是一个对象。如需展示列表，需手动 list() 转换。。</em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped = zip(a,b)     <span class="comment"># 返回一个对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>zipped</span><br><span class="line">&lt;zip object at <span class="number">0x103abc288</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zipped)  <span class="comment"># list() 转换为列表</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(zip(a,c))              <span class="comment"># 元素个数与最短的列表一致</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a1, a2 = zip(*zip(a,b))        <span class="comment"># 与 zip 相反，zip(*) 可理解为解压，返回二维矩阵式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a1)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(a2)</span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>
<p>补充2：字典还可以这样定义：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>)])</span><br><span class="line">&#123;<span class="number">1</span>: <span class="number">2</span>, <span class="number">3</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-合并两个字典"><a href="#3-9-合并两个字典" class="headerlink" title="3.9 合并两个字典"></a>3.9 合并两个字典</h4><p>Combine below dictionaries in order to add values for common keys:<br><code>dict1 = {&#39;alpha&#39;: 50,&#39;beta&#39;: 200, &#39;gamma&#39;:300} 
dict2 = {&#39;alpha&#39;: 300, &#39;b&#39;: 200, &#39;beta&#39;: 120, &#39;delta&#39;:400}</code><br>Expected output:<br><code>{&#39;alpha&#39;: 350, &#39;beta&#39;: 320, &#39;gamma&#39;: 300, &#39;b&#39;: 200, &#39;delta&#39;: 400}</code>.</p>
<p>法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'alpha'</span>: <span class="number">50</span>,<span class="string">'beta'</span>: <span class="number">200</span>, <span class="string">'gamma'</span>:<span class="number">300</span>&#125; </span><br><span class="line">dict2 = &#123;<span class="string">'alpha'</span>: <span class="number">300</span>, <span class="string">'b'</span>: <span class="number">200</span>, <span class="string">'beta'</span>: <span class="number">120</span>, <span class="string">'delta'</span>:<span class="number">400</span>&#125; </span><br><span class="line"></span><br><span class="line">dict3 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict1.items():</span><br><span class="line">    dict3[k] = v + dict2.get(k,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict2.items():</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> dict1:</span><br><span class="line">        dict3[k] = v</span><br><span class="line">print(dict3)</span><br><span class="line"><span class="comment"># &#123;'beta': 320, 'gamma': 300, 'b': 200, 'delta': 400, 'alpha': 350&#125;</span></span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dict1 = &#123;<span class="string">'alpha'</span>: <span class="number">50</span>,<span class="string">'beta'</span>: <span class="number">200</span>, <span class="string">'gamma'</span>:<span class="number">300</span>&#125;</span><br><span class="line">dict2 = &#123;<span class="string">'alpha'</span>: <span class="number">300</span>, <span class="string">'b'</span>: <span class="number">200</span>, <span class="string">'beta'</span>: <span class="number">120</span>, <span class="string">'delta'</span>:<span class="number">400</span>&#125;</span><br><span class="line">dict3 = dict(dict1) <span class="comment"># don't do `dict3=dict1`, you need to make a copy</span></span><br><span class="line">dict3.update(dict2) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, j <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="keyword">for</span> x, y <span class="keyword">in</span> dict2.items():</span><br><span class="line">        <span class="keyword">if</span> i == x:</span><br><span class="line">            dict3[i]=(j+y)</span><br><span class="line">print(dict3)</span><br><span class="line"><span class="comment"># &#123;'gamma': 300, 'delta': 400, 'alpha': 350, 'beta': 320, 'b': 200&#125;</span></span><br></pre></td></tr></table></figure>
<p>法三：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">d = Counter(dict1) + Counter(dict2)</span><br><span class="line">print(d)</span><br><span class="line"><span class="comment"># Counter(&#123;'delta': 400, 'alpha': 350, 'beta': 320, 'gamma': 300, 'b': 200&#125;)</span></span><br></pre></td></tr></table></figure>
<h3 id="4-String"><a href="#4-String" class="headerlink" title="4. String"></a>4. String</h3><h4 id="4-1-endswith"><a href="#4-1-endswith" class="headerlink" title="4.1 endswith()"></a>4.1 endswith()</h4><p>Define a list called <code>files</code> which contains some file names: <code>files = [&#39;1.txt&#39;, &#39;2.txt&#39;, &#39;2.ab&#39;, &#39;2.c&#39;, &#39;3.txt&#39;, &#39;3.ann&#39;, &#39;3.ss&#39;]</code>. Delete the file name which doesn’t use the extension <code>.txt</code> from the list. Print the list, the expected output is: <code>[&#39;1.txt&#39;, &#39;2.txt&#39;, &#39;3.txt&#39;]</code></p>
<p>法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files = [<span class="string">'1.txt'</span>, <span class="string">'2.txt'</span>, <span class="string">'2.ab'</span>, <span class="string">'2.c'</span>, <span class="string">'3.txt'</span>, <span class="string">'3.ann'</span>, <span class="string">'3.ss'</span>]</span><br><span class="line">files1 = []</span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'.txt'</span> <span class="keyword">in</span> f: <span class="comment"># 不够严谨?</span></span><br><span class="line">        files1.append(f)</span><br><span class="line">print(files1)</span><br><span class="line"><span class="comment"># ['1.txt', '2.txt', '3.txt']</span></span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">files = [<span class="string">'1.txt'</span>, <span class="string">'2.txt'</span>, <span class="string">'2.ab'</span>, <span class="string">'2.c'</span>, <span class="string">'3.txt'</span>, <span class="string">'3.ann'</span>, <span class="string">'3.ss'</span>,]</span><br><span class="line">files = [i <span class="keyword">for</span> i <span class="keyword">in</span> files <span class="keyword">if</span> i.endswith(<span class="string">'.txt'</span>)]</span><br><span class="line">print(files)</span><br><span class="line"><span class="comment"># ['1.txt', '2.txt', '3.txt']</span></span><br></pre></td></tr></table></figure>
<p>类似的函数还有 <a href="https://www.runoob.com/python/att-string-startswith.html" target="_blank" rel="noopener">startswith()</a></p>
<h4 id="4-2-strip"><a href="#4-2-strip" class="headerlink" title="4.2 strip()"></a>4.2 strip()</h4><p>strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p>
<p><strong>注：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cities = [<span class="string">' London'</span>, <span class="string">' Birmingham '</span>, <span class="string">' Manchester'</span>, <span class="string">'  Glasgow'</span>, <span class="string">'  Newcastle'</span>, <span class="string">'Sheffield  '</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除掉字符串首尾的空格</span></span><br><span class="line">cities = [city.strip() <span class="keyword">for</span> city <span class="keyword">in</span> cities]</span><br><span class="line">print(cities)</span><br><span class="line"><span class="comment"># ['London', 'Birmingham', 'Manchester', 'Glasgow', 'Newcastle', 'Sheffield']</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"00000003210Runoob01230000000"</span>; </span><br><span class="line">print(str1.strip(<span class="string">'0'</span>));  <span class="comment"># 去除首尾字符 0</span></span><br><span class="line"><span class="comment"># 3210Runoob0123</span></span><br></pre></td></tr></table></figure>
<p>例：<br>Define a string: <code>idx_str = &#39;use, index,numbers ,to  , specify ,positions&#39;</code>.<br>生成如下字典idx_dict：<code>{0: &#39;use&#39;, 1: &#39;index&#39;, 2: &#39;numbers&#39;, 3: &#39;to&#39;, 4: &#39;specify&#39;, 5: &#39;positions&#39;}</code></p>
<p>法一：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idx_str = <span class="string">'use, index,numbers ,to  , specify ,positions'</span></span><br><span class="line">idx_dict = dict([(i, val.strip()) <span class="keyword">for</span> i, val <span class="keyword">in</span> enumerate(idx_str.split(<span class="string">","</span>))])</span><br><span class="line">print(idx_dict)</span><br><span class="line"><span class="comment"># &#123;0: 'use', 1: 'index', 2: 'numbers', 3: 'to', 4: 'specify', 5: 'positions'&#125;</span></span><br></pre></td></tr></table></figure>
<p>法二：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">idx_str = <span class="string">'use, index,numbers ,to  , specify ,positions'</span></span><br><span class="line">idx_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(idx_str.split(<span class="string">','</span>)):</span><br><span class="line">    idx_dict[idx] = val.strip()</span><br><span class="line">print(idx_dict)</span><br><span class="line"><span class="comment"># &#123;0: 'use', 1: 'index', 2: 'numbers', 3: 'to', 4: 'specify', 5: 'positions'&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-大小写"><a href="#4-3-大小写" class="headerlink" title="4.3 大小写"></a>4.3 大小写</h4><ul>
<li>s.lower()：全部转换为小写</li>
<li>s.upper()：全部转换为大写</li>
<li>s.title()：每个单词的首字母大写，其余小写</li>
<li>s.capitalize()：第一个单词的首字母大写，其余小写</li>
<li>s.islower()：判断是否全为小写</li>
<li>s.isupper()：判断是否全为大写</li>
<li>s.istitle()：判断是否每个单词的首字母均大写，其余均小写</li>
</ul>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">"hello WorlD"</span></span><br><span class="line"></span><br><span class="line">print(s.title())</span><br><span class="line"><span class="comment"># Hello World</span></span><br><span class="line"></span><br><span class="line">print(s.capitalize())</span><br><span class="line"><span class="comment"># Hello world</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-判断是否为数字、字母"><a href="#4-4-判断是否为数字、字母" class="headerlink" title="4.4 判断是否为数字、字母"></a>4.4 判断是否为数字、字母</h4><ul>
<li>s.isdigit()：判断是否全为数字（若s为空，返回False）</li>
<li>s.isalpha()：判断是否全为字母（若s为空，返回False）</li>
<li>s.isalnum()：判断是否全为字母数字（若s为空，返回False）</li>
</ul>
<p>注：Python官方定义中的字母：可默认为英文字母+汉字；Python官方定义中的数字：可默认为阿拉伯数字+带圈的数字（如①）</p>
<h3 id="5-Array"><a href="#5-Array" class="headerlink" title="5. Array"></a>5. Array</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">print(np.array([<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line"><span class="comment"># [1 2]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array_2 = np.array([[[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]],[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>]],[[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]],[[<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>],[<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>]]])</span><br><span class="line">print(array_2.ndim)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">print(array_2.shape)</span><br><span class="line"><span class="comment"># (4, 2, 3)</span></span><br><span class="line">print(array_2.dtype)</span><br><span class="line"><span class="comment"># int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换成 float</span></span><br><span class="line">array_2 = array_2.astype(np.float64)</span><br></pre></td></tr></table></figure>
<p>np.arange()：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array_3 = np.arange(<span class="number">1</span>,<span class="number">20</span>,<span class="number">2</span>)</span><br><span class="line">array_3</span><br><span class="line"><span class="comment"># array([ 1,  3,  5,  7,  9, 11, 13, 15, 17, 19])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of shape (2,2,2,2). The array contains numbers from 0 to 15</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr4d= np.arange(<span class="number">16</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr4d</span><br><span class="line">array([[[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">         [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>,  <span class="number">7</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       [[[ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">         [<span class="number">14</span>, <span class="number">15</span>]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Change values 8,9,10,11 in the array to 12.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr4d[<span class="number">1</span>,<span class="number">0</span>] = <span class="number">12</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr4d</span><br><span class="line">array([[[[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">         [ <span class="number">2</span>,  <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">         [ <span class="number">6</span>,  <span class="number">7</span>]]],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       [[[<span class="number">12</span>, <span class="number">12</span>],</span><br><span class="line">         [<span class="number">12</span>, <span class="number">12</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>, <span class="number">13</span>],</span><br><span class="line">         [<span class="number">14</span>, <span class="number">15</span>]]]])</span><br></pre></td></tr></table></figure>
<p>cumsum:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">21</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a.cumsum())</span><br><span class="line">[  <span class="number">1</span>   <span class="number">4</span>   <span class="number">9</span>  <span class="number">16</span>  <span class="number">25</span>  <span class="number">36</span>  <span class="number">49</span>  <span class="number">64</span>  <span class="number">81</span> <span class="number">100</span> <span class="number">121</span>]</span><br></pre></td></tr></table></figure>
<p>Create an array by using <code>array_4 = np.array([[7,-1],[10,2],[-3,4]])</code>.Print the elements of the array which are larger than 0.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>array_4 = np.array([[<span class="number">7</span>,<span class="number">-1</span>],[<span class="number">10</span>,<span class="number">2</span>],[<span class="number">-3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array_4[array_4&gt;<span class="number">0</span>]</span><br><span class="line">array([ <span class="number">7</span>, <span class="number">10</span>,  <span class="number">2</span>,  <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<p>Replace the odd numbers in <code>array_4</code> with zeros. </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>array_4[array_4%<span class="number">2</span>==<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array_4</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">       [<span class="number">10</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">4</span>]])</span><br></pre></td></tr></table></figure>
<h4 id="5-1-Array的合并"><a href="#5-1-Array的合并" class="headerlink" title="5.1 Array的合并"></a>5.1 Array的合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.concatenate(要拼接的多个数组, axis = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">arr2 = np.array([<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">arr3 = np.concatenate([arr1,arr2], axis = <span class="number">0</span>)</span><br><span class="line">print(arr3)</span><br><span class="line"><span class="comment"># [1 2 3 4 5]</span></span><br></pre></td></tr></table></figure>
<h4 id="5-2-矩阵"><a href="#5-2-矩阵" class="headerlink" title="5.2 矩阵"></a>5.2 矩阵</h4><p>单位矩阵：np.identity(), np.eye()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">法一：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr1 = np.identity(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr1)</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br><span class="line"></span><br><span class="line">法二：</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2 = np.eye(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr2</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">1.</span>]]</span><br></pre></td></tr></table></figure>
<p>区别：np.identity() 返回的是行数和列数相等的 square array，np.eye() 行数和列数可以不同，例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(np.eye(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line">[[<span class="number">1.</span> <span class="number">0.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">1.</span>]</span><br><span class="line"> [<span class="number">0.</span> <span class="number">0.</span>]]</span><br></pre></td></tr></table></figure>
<p>全为1的矩阵：np.ones()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_array = np.ones([<span class="number">5</span>,<span class="number">5</span>]) <span class="comment">#也可以用(5,5)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_array</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将内部改为0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_array[<span class="number">1</span>:<span class="number">4</span>,<span class="number">1</span>:<span class="number">4</span>]=<span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_array</span><br><span class="line">array([[<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure>
<p>全为0的矩阵：np.zeros()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array = np.zeros((<span class="number">12</span>,<span class="number">12</span>))</span><br></pre></td></tr></table></figure>
<p>空矩阵：np.empty(). Return a new array of given shape and type, without initializing entries.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.empty((<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>   arr[i] = i</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>, <span class="number">3.</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr_new = arr.reshape(<span class="number">8</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr_new</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>]])</span><br></pre></td></tr></table></figure>
<p>Write a code that reindexes the array <code>arr_new</code> so that it looks like the below array:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0., 0.],</span><br><span class="line">[1., 1.],</span><br><span class="line">[2., 2.],</span><br><span class="line">[3., 3.],</span><br><span class="line">[3., 3.],</span><br><span class="line">[2., 2.],</span><br><span class="line">[1., 1.],</span><br><span class="line">[0., 0.]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr_new[np.ix_([<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>], [<span class="number">0</span>,<span class="number">1</span>])]</span><br><span class="line">array([[<span class="number">0.</span>, <span class="number">0.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">3.</span>, <span class="number">3.</span>],</span><br><span class="line">       [<span class="number">2.</span>, <span class="number">2.</span>],</span><br><span class="line">       [<span class="number">1.</span>, <span class="number">1.</span>],</span><br><span class="line">       [<span class="number">0.</span>, <span class="number">0.</span>]])</span><br></pre></td></tr></table></figure>
<p>Using <code>ix_</code> one can quickly construct index arrays that will index the cross product. <code>a[np.ix_([1,3],[2,5])]</code> returns the array <code>[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]</code>.</p>
<p>上三角矩阵与下三角矩阵</p>
<p>Use <strong>one</strong> line of <code>numpy</code> code to create and <strong>print</strong> the below array:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[0. 0. 0. 0.]  </span><br><span class="line"> [1. 0. 0. 0.]  </span><br><span class="line"> [1. 1. 0. 0.]  </span><br><span class="line"> [1. 1. 1. 0.]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(np.triu(np.ones((<span class="number">4</span>, <span class="number">4</span>)), <span class="number">1</span>)).T</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">print(np.tril(np.ones((<span class="number">4</span>, <span class="number">4</span>)), <span class="number">-1</span>))</span><br></pre></td></tr></table></figure>
<p>np.triu(): 上三角矩阵（主对角线以下都是零的方阵）<br>np.tril(): 下三角矩阵（主对角线以上都是零的方阵）</p>
<p>随机矩阵</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>X = np.random.randn(<span class="number">6</span>, <span class="number">3</span>) <span class="comment"># Return a sample (or samples) from the "standard normal" distribution.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(X)</span><br><span class="line">[[ <span class="number">0.63926617</span>  <span class="number">0.76423729</span>  <span class="number">1.80890798</span>]</span><br><span class="line"> [ <span class="number">1.41459964</span> <span class="number">-0.62706709</span> <span class="number">-1.26970789</span>]</span><br><span class="line"> [ <span class="number">0.38017848</span> <span class="number">-0.22310835</span>  <span class="number">0.34467019</span>]</span><br><span class="line"> [<span class="number">-1.59067911</span> <span class="number">-1.10059474</span> <span class="number">-0.36641207</span>]</span><br><span class="line"> [ <span class="number">0.02698284</span> <span class="number">-2.00582688</span> <span class="number">-0.70687337</span>]</span><br><span class="line"> [<span class="number">-0.10859002</span> <span class="number">-1.28653612</span>  <span class="number">0.65185543</span>]]</span><br></pre></td></tr></table></figure>
<p>Define an array called <code>data</code> using the following code: <code>data = np.array([[10,2,3],[1,3,3],[2,34,4],[5,4,3]])</code><br>For each row in the array, apply the following formula: $x_1×2+x_2×5+x_3×3$<br>For instance, if you apply the formula to the first row, you will get $39\ (10×2+2×5+3×3). $Print the new array after applying the formula to each row. The expected output is: <code>[ 39  26 186  39]</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = np.array([[<span class="number">10</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">34</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print((data*[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>]).sum(axis=<span class="number">1</span>))</span><br><span class="line">[ <span class="number">39</span>  <span class="number">26</span> <span class="number">186</span>  <span class="number">39</span>]</span><br></pre></td></tr></table></figure>
<p><strong>Print</strong> an array of shape 4X4, with the first value of 1000 and next values being 25% larger than the previous one. It should look like this:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ 1000.          1250.          1562.5         1953.125     ]</span><br><span class="line"> [ 2441.40625     3051.7578125   3814.69726562  4768.37158203]</span><br><span class="line"> [ 5960.46447754  7450.58059692  9313.22574615 11641.53218269]</span><br><span class="line"> [14551.91522837 18189.89403546 22737.36754432 28421.7094304 ]]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">1000</span>*(<span class="number">1.25</span>**np.arange(<span class="number">16</span>)).reshape(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">[[ <span class="number">1000.</span>          <span class="number">1250.</span>          <span class="number">1562.5</span>         <span class="number">1953.125</span>     ]</span><br><span class="line"> [ <span class="number">2441.40625</span>     <span class="number">3051.7578125</span>   <span class="number">3814.69726562</span>  <span class="number">4768.37158203</span>]</span><br><span class="line"> [ <span class="number">5960.46447754</span>  <span class="number">7450.58059692</span>  <span class="number">9313.22574615</span> <span class="number">11641.53218269</span>]</span><br><span class="line"> [<span class="number">14551.91522837</span> <span class="number">18189.89403546</span> <span class="number">22737.36754432</span> <span class="number">28421.7094304</span> ]]</span><br></pre></td></tr></table></figure>
<h4 id="5-3-Array中的nan"><a href="#5-3-Array中的nan" class="headerlink" title="5.3 Array中的nan"></a>5.3 Array中的nan</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.isnan(arr).sum()</span><br></pre></td></tr></table></figure>
<h3 id="6-python的数据类型的有序无序"><a href="#6-python的数据类型的有序无序" class="headerlink" title="6. python的数据类型的有序无序"></a>6. python的数据类型的有序无序</h3><blockquote>
<p>参考 <a href="https://www.cnblogs.com/z-x-y/p/10090749.html" target="_blank" rel="noopener">https://www.cnblogs.com/z-x-y/p/10090749.html</a></p>
</blockquote>
<ul>
<li>列表list有序可变</li>
<li>字典dict在python3.6之前是无序的，到了python3.7变成了有序，可变</li>
<li>元组tuple不可变</li>
<li>集合set无序可变（还有个不可变集合frozenset）</li>
<li>数字number不可变</li>
<li>字符串string不可变</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的简单语法与常见操作</title>
    <url>/2019/06/27/basic-python-type/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em><span style="color:blue">缩进是 Python的灵魂</span></em></strong></p>
<blockquote>
<p>更多Python基础见我的onenote笔记本”Python学习笔记“<br>另：关于 Python 的教程可参考廖雪峰的网站 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400</a></p>
</blockquote>
<h3 id="1-逻辑运算符"><a href="#1-逻辑运算符" class="headerlink" title="1. 逻辑运算符"></a>1. 逻辑运算符</h3><p><img src="/2019/06/27/basic-python-type/logic-operator.jpg" alt="逻辑运算符"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[(df[<span class="string">'id'</span>]&gt;=<span class="number">1</span>) &amp; (df[<span class="string">'id'</span>]&lt;=<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<h3 id="2-比较操作符"><a href="#2-比较操作符" class="headerlink" title="2. 比较操作符"></a>2. 比较操作符</h3><blockquote>
<p>>, &lt;, &gt;=, &lt;=, ==, != </p>
</blockquote>
<a id="more"></a>
<h3 id="3-Python中的双引号"><a href="#3-Python中的双引号" class="headerlink" title="3. Python中的双引号"></a>3. Python中的双引号</h3><p>Python中双引号和单引号作用一样，即字符串可以用单引号也可以用双引号</p>
<h3 id="4-type"><a href="#4-type" class="headerlink" title="4. type()"></a>4. type()</h3><h4 id="4-1-type-函数"><a href="#4-1-type-函数" class="headerlink" title="4.1 type()函数"></a>4.1 type()函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">i = <span class="number">4</span></span><br><span class="line">type(i)</span><br><span class="line"><span class="comment"># int</span></span><br><span class="line"></span><br><span class="line">type(<span class="string">"hello"</span>)</span><br><span class="line"><span class="comment"># str</span></span><br><span class="line"></span><br><span class="line">n = <span class="literal">None</span></span><br><span class="line">type(n)</span><br><span class="line"><span class="comment"># NoneType</span></span><br></pre></td></tr></table></figure>
<h4 id="4-2-dtype"><a href="#4-2-dtype" class="headerlink" title="4.2 dtype"></a>4.2 dtype</h4><p>查看type<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(train[<span class="string">"ID"</span>].dtype)</span><br><span class="line"><span class="comment"># object</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或 train["ID"].dtypes</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-3-转换type"><a href="#4-3-转换type" class="headerlink" title="4.3 转换type"></a>4.3 转换type</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 法一</span></span><br><span class="line">train[<span class="string">"ID"</span>] = train[<span class="string">"ID"</span>].astype(np.int32)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法二</span></span><br><span class="line">train = train.astype(&#123;<span class="string">"user_age"</span>: <span class="string">"float64"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将因缺失值而成为object的变量转换为float</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> X_train1.columns[X_train1.dtypes==<span class="string">"object"</span>]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        X_train1 = X_train1.astype(&#123;col: <span class="string">"float64"</span>&#125;)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="5-Python二维列表初始化"><a href="#5-Python二维列表初始化" class="headerlink" title="5. Python二维列表初始化"></a>5. Python二维列表初始化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[[<span class="number">0</span>]*n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="comment"># m*n的二维列表</span></span><br></pre></td></tr></table></figure>
<h3 id="6-查看列表中最小值所在位置-索引"><a href="#6-查看列表中最小值所在位置-索引" class="headerlink" title="6. 查看列表中最小值所在位置(索引)"></a>6. 查看列表中最小值所在位置(索引)</h3><ul>
<li>第一个位置 <code>listA.index(min(listA))</code> ；</li>
<li>所有位置：<code>[i for i,v in enumerate(listA) if v == min(listA)]</code></li>
</ul>
<h3 id="7-输出"><a href="#7-输出" class="headerlink" title="7. 输出"></a>7. 输出</h3><blockquote>
<p>参考：<br><a href="https://www.runoob.com/w3cnote/python3-print-func-b.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/python3-print-func-b.html</a><br><a href="https://www.cnblogs.com/penphy/p/10028546.html" target="_blank" rel="noopener">https://www.cnblogs.com/penphy/p/10028546.html</a><br><a href="https://www.cnblogs.com/lovejh/p/9201219.html" target="_blank" rel="noopener">https://www.cnblogs.com/lovejh/p/9201219.html</a></p>
</blockquote>
<p>简单的输出：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(<span class="string">'My name is'</span>, <span class="string">'John'</span>)</span><br><span class="line">My name <span class="keyword">is</span> John</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;student = (<span class="number">30</span>,<span class="string">"University of Oxford"</span>,<span class="string">"1 High Street, London, W1 1PP"</span>, <span class="string">"John Cameron"</span>)</span><br><span class="line">&gt;&gt;&gt;print(student[<span class="number">3</span>]+ <span class="string">", "</span>+student[<span class="number">1</span>] + <span class="string">", "</span> + student[<span class="number">2</span>] + <span class="string">","</span> + str(student[<span class="number">0</span>]))</span><br><span class="line">John Cameron, University of Oxford, <span class="number">1</span> High Street, London, W1 <span class="number">1</span>PP,<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p>print不换行：</p>
<p>在 Python 中 print 默认是换行的:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">3</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> (i)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>要想不换行应该写成 <strong>print(i, end = ‘’ )</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">6</span>):</span><br><span class="line"><span class="meta">... </span>    print(i, end=<span class="string">" "</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h4 id="7-1-用法"><a href="#7-1-用法" class="headerlink" title="7.1 %用法"></a>7.1 %用法</h4><p>支持参数格式化，与 C 语言的 printf 类似</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(<span class="string">'Hello, %s. Your age is %d.'</span> % (<span class="string">'Johon'</span>, <span class="number">20</span>))</span><br><span class="line">Hello, Johon. Your age <span class="keyword">is</span> <span class="number">20.</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;str = <span class="string">"the length of (%s) is %d"</span> %(<span class="string">'runoob'</span>,len(<span class="string">'runoob'</span>))</span><br><span class="line">&gt;&gt;&gt;print(str)</span><br><span class="line">the length of (runoob) <span class="keyword">is</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>python字符串格式化符号:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">符   号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">%c</td>
<td style="text-align:left">格式化字符及其ASCII码</td>
</tr>
<tr>
<td style="text-align:left">%s</td>
<td style="text-align:left">格式化字符串</td>
</tr>
<tr>
<td style="text-align:left">%d</td>
<td style="text-align:left">格式化整数</td>
</tr>
<tr>
<td style="text-align:left">%u</td>
<td style="text-align:left">格式化无符号整型</td>
</tr>
<tr>
<td style="text-align:left">%o</td>
<td style="text-align:left">格式化无符号八进制数</td>
</tr>
<tr>
<td style="text-align:left">%x</td>
<td style="text-align:left">格式化无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:left">%X</td>
<td style="text-align:left">格式化无符号十六进制数（大写）</td>
</tr>
<tr>
<td style="text-align:left">%f</td>
<td style="text-align:left">格式化浮点数字，可指定小数点后的精度</td>
</tr>
<tr>
<td style="text-align:left">%e</td>
<td style="text-align:left">用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%E</td>
<td style="text-align:left">作用同%e，用科学计数法格式化浮点数</td>
</tr>
<tr>
<td style="text-align:left">%g</td>
<td style="text-align:left">%f和%e的简写</td>
</tr>
<tr>
<td style="text-align:left">%G</td>
<td style="text-align:left">%f 和 %E 的简写</td>
</tr>
<tr>
<td style="text-align:left">%p</td>
<td style="text-align:left">用十六进制数格式化变量的地址</td>
</tr>
</tbody>
</table>
</div>
<p>格式化操作符辅助指令:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*</td>
<td style="text-align:left">定义宽度或者小数点精度</td>
</tr>
<tr>
<td style="text-align:left">-</td>
<td style="text-align:left">用做左对齐</td>
</tr>
<tr>
<td style="text-align:left">+</td>
<td style="text-align:left">在正数前面显示加号( + )</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;sp&gt;</code></td>
<td style="text-align:left">在正数前面显示空格</td>
</tr>
<tr>
<td style="text-align:left">#</td>
<td style="text-align:left">在八进制数前面显示零(‘0’)，在十六进制前面显示’0x’或者’0X’(取决于用的是’x’还是’X’)</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">显示的数字前面填充’0’而不是默认的空格</td>
</tr>
<tr>
<td style="text-align:left">%</td>
<td style="text-align:left">‘%%’输出一个单一的’%’</td>
</tr>
<tr>
<td style="text-align:left">(var)</td>
<td style="text-align:left">映射变量(字典参数)</td>
</tr>
<tr>
<td style="text-align:left">m.n.</td>
<td style="text-align:left">m 是显示的最小总宽度,n 是小数点后的位数(如果可用的话)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="7-1-1-格式化输出整数"><a href="#7-1-1-格式化输出整数" class="headerlink" title="7.1.1 格式化输出整数"></a>7.1.1 格式化输出整数</h5><p><strong>%x</strong> —- hex 十六进制<br><strong>%d</strong> —- dec 十进制<br><strong>%o</strong> —- oct 八进制</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;nHex = <span class="number">0xFF</span></span><br><span class="line">&gt;&gt;&gt;print(<span class="string">"nHex = %x,nDec = %d,nOct = %o"</span> %(nHex,nHex,nHex))</span><br><span class="line">nHex = ff,nDec = <span class="number">255</span>,nOct = <span class="number">377</span></span><br></pre></td></tr></table></figure>
<h5 id="7-1-2-格式化输出浮点数"><a href="#7-1-2-格式化输出浮点数" class="headerlink" title="7.1.2 格式化输出浮点数"></a>7.1.2 格式化输出浮点数</h5><p><strong>%f</strong>  —- 保留小数点后面六位有效数字<br><strong>%.3f</strong>，保留3位小数位</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;pi = <span class="number">3.141592653</span>  </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">'%10.3f'</span> % pi) <span class="comment">#字段宽10，精度3 (整个数包括小数点后的位数一共为10位) </span></span><br><span class="line">     <span class="number">3.142</span>  </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">"pi = %.*f"</span> % (<span class="number">3</span>,pi)) <span class="comment">#用*从后面的元组中读取字段宽度或精度  </span></span><br><span class="line">pi = <span class="number">3.142</span>  </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">'%010.3f'</span> % pi) <span class="comment">#用0填充空白  </span></span><br><span class="line"><span class="number">000003.142</span>  </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">'%-10.3f'</span> % pi) <span class="comment">#左对齐  </span></span><br><span class="line"><span class="number">3.142</span>       </span><br><span class="line">&gt;&gt;&gt;print(<span class="string">'%+f'</span> % pi) <span class="comment">#在正数前面显示加号( + )</span></span><br><span class="line">+<span class="number">3.141593</span></span><br></pre></td></tr></table></figure>
<h5 id="7-1-3-格式化输出字符串"><a href="#7-1-3-格式化输出字符串" class="headerlink" title="7.1.3 格式化输出字符串"></a>7.1.3 格式化输出字符串</h5><p><strong>%s</strong><br><strong>%10s</strong> —- 右对齐，占位符10位<br><strong>%-10s</strong> —- 左对齐，占位符10位<br><strong>%.2s</strong> —- 截取2位字符串<br><strong>%10.2s</strong> —-10位占位符，截取两位字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 字符串输出</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%20s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 右对齐，取20位，不够则补位</span></span><br><span class="line">         hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%-20s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 左对齐，取20位，不够则补位</span></span><br><span class="line">hello world         </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 取2位</span></span><br><span class="line">he</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%10.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 右对齐，取2位</span></span><br><span class="line">        he</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'%-10.2s'</span> % <span class="string">'hello world'</span>)  <span class="comment"># 左对齐，取2位</span></span><br><span class="line">he</span><br></pre></td></tr></table></figure>
<h4 id="7-2-format用法"><a href="#7-2-format用法" class="headerlink" title="7.2 format用法"></a>7.2 format用法</h4><p>相对基本格式化输出采用‘%’的方法，format()功能更强大，该函数把字符串当成一个模板，通过传入的参数进行格式化，并且使用大括号‘{}’作为特殊字符代替‘%’</p>
<p>位置匹配</p>
<p><strong>（1）不带编号，即“{}”</strong><br><strong>（2）带数字编号，可调换顺序，即“{1}”、“{2}”</strong><br><strong>（3）带关键字，即“{a}”、“{tom}”</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125; &#123;&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 不带字段</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; &#123;1&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 带数字编号</span></span><br><span class="line">hello world</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;0&#125; &#123;1&#125; &#123;0&#125;'</span>.format(<span class="string">'hello'</span>,<span class="string">'world'</span>))  <span class="comment"># 打乱顺序</span></span><br><span class="line">hello world hello</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;a&#125; &#123;tom&#125; &#123;a&#125;'</span>.format(tom=<span class="string">'hello'</span>,a=<span class="string">'world'</span>))  <span class="comment"># 带关键字</span></span><br><span class="line">world hello world</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'&#123;&#125; is &#123;:.2f&#125;'</span>.format(<span class="number">1.123</span>,<span class="number">1.123</span>))  <span class="comment"># 取2位小数</span></span><br><span class="line"><span class="number">1.123</span> <span class="keyword">is</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'&#123;:,&#125;'</span>.format(<span class="number">1234567890</span>)</span><br><span class="line"><span class="string">'1,234,567,890'</span></span><br></pre></td></tr></table></figure>
<p>想输出：The percentage of female students is 68.85%.👇</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str_student = <span class="string">"The percentage of female students is &#123;:.2f&#125;%."</span>.format(<span class="number">68.8543</span>)</span><br><span class="line">print(str_student)</span><br></pre></td></tr></table></figure>
<p>百分数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>points = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>total = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Correct answers: &#123;:.2%&#125;'</span>.format(points/total)</span><br><span class="line"><span class="string">'Correct answers: 50.00%'</span></span><br></pre></td></tr></table></figure>
<h3 id="8-切片操作"><a href="#8-切片操作" class="headerlink" title="8. 切片操作"></a>8. 切片操作</h3><blockquote>
<p>参考 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017269965565856" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1017269965565856</a></p>
</blockquote>
<p><span style="color:blue">Python切片操作可作用于list (包括tuple, string)</span></p>
<p>可以想象为每个位置有两个编号：</p>
<p><img src="/2019/06/27/basic-python-type/1605268940795.png" alt="1605268940795"></p>
<p><strong><code>b = a[i:j]</code></strong> - 表示复制 a[i] 到 a[j-1]，以生成新的list对象。例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">a[<span class="number">1</span>:<span class="number">3</span>] <span class="comment"># [1,2]</span></span><br><span class="line">a[:<span class="number">-2</span>] <span class="comment"># [0,1,2,3,4,5,6,7]</span></span><br><span class="line">a[<span class="number">-2</span>:<span class="number">-1</span>] <span class="comment"># [8]</span></span><br><span class="line">a[:<span class="number">2</span>] <span class="comment"># [0,1]，前2个数</span></span><br><span class="line">a[<span class="number">-2</span>:] <span class="comment">#[8,9]，后2个数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当 i 缺省时，默认为0，即 a[:3] 等价于 a[0:3]</li>
<li>当 j 缺省时，默认为 len(a)，即 a[1:] 等价于 a[1:len(a)]</li>
<li>当 i, j 都缺省时，<strong>a[:] 就相当于完整复制一份 a</strong> (等价于 a.copy() 浅拷贝，<span style="color:red">注：更多关于浅拷贝与深拷贝的内容见我的另一篇<a href="https://qypx.github.io/2020/11/15/Python%E7%9B%B4%E6%8E%A5%E8%B5%8B%E5%80%BC%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%BB%A5%E5%8F%8A%E5%88%87%E7%89%87">博客</a></span>)</li>
</ul>
<p><strong><code>b = a[i:j:s]</code></strong> - 其中 i 与 j 与上面一样，s 表示步进，缺省时默认为1.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">a[::<span class="number">-1</span>] <span class="comment"># [9,8,7,6,5,4,3,2,1,0]</span></span><br><span class="line">a[::<span class="number">-2</span>] <span class="comment"># [9,7,5,3,1]</span></span><br><span class="line">a[:<span class="number">5</span>:<span class="number">2</span>] <span class="comment"># 前5个数，每两个取一个，[0,2,4]</span></span><br><span class="line">a[::<span class="number">5</span>] <span class="comment">#所有数，每5个取一个，[0,5]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>a[i:j:1] 等价于 a[i:j]</li>
<li>当 s&lt;0 时（step小于0），i 缺省时默认为-1，j 缺省时默认为 -len(a) -1</li>
<li><strong>a[::-1]</strong> 等价于 a[-1:-len(a)-1:-1]，即从最后一个元素f复制到第一个元素，即<strong>倒序</strong></li>
</ul>
<hr>
<p>另：dataframe中：</p>
<ul>
<li><p>若想取第2列到第4列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[:, <span class="number">2</span>:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想取第6列、第10列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.iloc[:, [<span class="number">6</span>,<span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>若想取第2列到第4列，与第6列、第10列：</p>
<blockquote>
<p>参考 <a href="https://stackoverflow.com/questions/43206786/how-to-slice-continuous-and-discontinuous-index-in-pandas" target="_blank" rel="noopener">How to slice continuous and discontinuous index in pandas? - Stack Overflow</a></p>
</blockquote>
<p>使用numpy.r：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">df.iloc[:, np.r_[<span class="number">2</span>:<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>]]</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>test blog</title>
    <url>/2019/06/26/test-blog/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇测试文章.</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
</search>
